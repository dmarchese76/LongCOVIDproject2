function t({ id: t, step: e, marginTop: i }) {
  const { index: r, height: n } = e,
    a = `scrollama__debug-step--${t}-${r}`;
  let s = document.querySelector(`.${a}`);
  s ||
    (s = (function (t) {
      const e = document.createElement('div');
      (e.className = `scrollama__debug-step ${t}`),
        (e.style.position = 'fixed'),
        (e.style.left = '0'),
        (e.style.width = '100%'),
        (e.style.zIndex = '9999'),
        (e.style.borderTop = '2px solid black'),
        (e.style.borderBottom = '2px solid black');
      const i = document.createElement('p');
      return (
        (i.style.position = 'absolute'),
        (i.style.left = '0'),
        (i.style.height = '1px'),
        (i.style.width = '100%'),
        (i.style.borderTop = '1px dashed black'),
        e.appendChild(i),
        document.body.appendChild(e),
        e
      );
    })(a)),
    (s.style.top = -1 * i + 'px'),
    (s.style.height = `${n}px`),
    (s.querySelector('p').style.top = n / 2 + 'px');
}
function e(t) {
  console.error(`scrollama error: ${t}`);
}
function i(t) {
  return +t.getAttribute('data-scrollama-index');
}
function r(t) {
  if ('string' == typeof t && t.indexOf('px') > 0) {
    const e = +t.replace('px', '');
    return isNaN(e)
      ? (err("offset value must be in 'px' format. Fallback to 0.5."),
        { format: 'percent', value: 0.5 })
      : { format: 'pixels', value: e };
  }
  return 'number' != typeof t && isNaN(+t)
    ? null
    : (t > 1 && err('offset value is greater than 1. Fallback to 1.'),
      t < 0 && err('offset value is lower than 0. Fallback to 0.'),
      { format: 'percent', value: Math.min(Math.max(0, t), 1) });
}
function n(t) {
  const { top: e } = t.getBoundingClientRect();
  return e + window.pageYOffset - (document.body.clientTop || 0);
}
let a, s, o;
function l(t) {
  const e = t ? t.scrollTop : window.pageYOffset;
  a !== e && ((a = e), a > s ? (o = 'down') : a < s && (o = 'up'), (s = a));
}
var c = { value: () => {} };
function h() {
  for (var t, e = 0, i = arguments.length, r = {}; e < i; ++e) {
    if (!(t = arguments[e] + '') || t in r || /[\s.]/.test(t))
      throw new Error('illegal type: ' + t);
    r[t] = [];
  }
  return new u(r);
}
function u(t) {
  this._ = t;
}
function d(t, e) {
  return t
    .trim()
    .split(/^|\s+/)
    .map(function (t) {
      var i = '',
        r = t.indexOf('.');
      if (
        (r >= 0 && ((i = t.slice(r + 1)), (t = t.slice(0, r))),
        t && !e.hasOwnProperty(t))
      )
        throw new Error('unknown type: ' + t);
      return { type: t, name: i };
    });
}
function p(t, e) {
  for (var i, r = 0, n = t.length; r < n; ++r)
    if ((i = t[r]).name === e) return i.value;
}
function f(t, e, i) {
  for (var r = 0, n = t.length; r < n; ++r)
    if (t[r].name === e) {
      (t[r] = c), (t = t.slice(0, r).concat(t.slice(r + 1)));
      break;
    }
  return null != i && t.push({ name: e, value: i }), t;
}
u.prototype = h.prototype = {
  constructor: u,
  on: function (t, e) {
    var i,
      r = this._,
      n = d(t + '', r),
      a = -1,
      s = n.length;
    if (!(arguments.length < 2)) {
      if (null != e && 'function' != typeof e)
        throw new Error('invalid callback: ' + e);
      for (; ++a < s; )
        if ((i = (t = n[a]).type)) r[i] = f(r[i], t.name, e);
        else if (null == e) for (i in r) r[i] = f(r[i], t.name, null);
      return this;
    }
    for (; ++a < s; )
      if ((i = (t = n[a]).type) && (i = p(r[i], t.name))) return i;
  },
  copy: function () {
    var t = {},
      e = this._;
    for (var i in e) t[i] = e[i].slice();
    return new u(t);
  },
  call: function (t, e) {
    if ((i = arguments.length - 2) > 0)
      for (var i, r, n = new Array(i), a = 0; a < i; ++a)
        n[a] = arguments[a + 2];
    if (!this._.hasOwnProperty(t)) throw new Error('unknown type: ' + t);
    for (a = 0, i = (r = this._[t]).length; a < i; ++a) r[a].value.apply(e, n);
  },
  apply: function (t, e, i) {
    if (!this._.hasOwnProperty(t)) throw new Error('unknown type: ' + t);
    for (var r = this._[t], n = 0, a = r.length; n < a; ++n)
      r[n].value.apply(e, i);
  },
};
var m = 'http://www.w3.org/1999/xhtml',
  g = {
    svg: 'http://www.w3.org/2000/svg',
    xhtml: m,
    xlink: 'http://www.w3.org/1999/xlink',
    xml: 'http://www.w3.org/XML/1998/namespace',
    xmlns: 'http://www.w3.org/2000/xmlns/',
  };
function _(t) {
  var e = (t += ''),
    i = e.indexOf(':');
  return (
    i >= 0 && 'xmlns' !== (e = t.slice(0, i)) && (t = t.slice(i + 1)),
    g.hasOwnProperty(e) ? { space: g[e], local: t } : t
  );
}
function y(t) {
  return function () {
    var e = this.ownerDocument,
      i = this.namespaceURI;
    return i === m && e.documentElement.namespaceURI === m
      ? e.createElement(t)
      : e.createElementNS(i, t);
  };
}
function v(t) {
  return function () {
    return this.ownerDocument.createElementNS(t.space, t.local);
  };
}
function x(t) {
  var e = _(t);
  return (e.local ? v : y)(e);
}
function b() {}
function w(t) {
  return null == t
    ? b
    : function () {
        return this.querySelector(t);
      };
}
function T(t) {
  return null == t ? [] : Array.isArray(t) ? t : Array.from(t);
}
function P() {
  return [];
}
function C(t) {
  return null == t
    ? P
    : function () {
        return this.querySelectorAll(t);
      };
}
function I(t) {
  return function () {
    return this.matches(t);
  };
}
function S(t) {
  return function (e) {
    return e.matches(t);
  };
}
var M = Array.prototype.find;
function D() {
  return this.firstElementChild;
}
var L = Array.prototype.filter;
function A() {
  return Array.from(this.children);
}
function E(t) {
  return new Array(t.length);
}
function R(t, e) {
  (this.ownerDocument = t.ownerDocument),
    (this.namespaceURI = t.namespaceURI),
    (this._next = null),
    (this._parent = t),
    (this.__data__ = e);
}
function z(t) {
  return function () {
    return t;
  };
}
function k(t, e, i, r, n, a) {
  for (var s, o = 0, l = e.length, c = a.length; o < c; ++o)
    (s = e[o]) ? ((s.__data__ = a[o]), (r[o] = s)) : (i[o] = new R(t, a[o]));
  for (; o < l; ++o) (s = e[o]) && (n[o] = s);
}
function O(t, e, i, r, n, a, s) {
  var o,
    l,
    c,
    h = new Map(),
    u = e.length,
    d = a.length,
    p = new Array(u);
  for (o = 0; o < u; ++o)
    (l = e[o]) &&
      ((p[o] = c = s.call(l, l.__data__, o, e) + ''),
      h.has(c) ? (n[o] = l) : h.set(c, l));
  for (o = 0; o < d; ++o)
    (c = s.call(t, a[o], o, a) + ''),
      (l = h.get(c))
        ? ((r[o] = l), (l.__data__ = a[o]), h.delete(c))
        : (i[o] = new R(t, a[o]));
  for (o = 0; o < u; ++o) (l = e[o]) && h.get(p[o]) === l && (n[o] = l);
}
function F(t) {
  return t.__data__;
}
function B(t) {
  return 'object' == typeof t && 'length' in t ? t : Array.from(t);
}
function N(t, e) {
  return t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN;
}
function V(t) {
  return function () {
    this.removeAttribute(t);
  };
}
function j(t) {
  return function () {
    this.removeAttributeNS(t.space, t.local);
  };
}
function U(t, e) {
  return function () {
    this.setAttribute(t, e);
  };
}
function G(t, e) {
  return function () {
    this.setAttributeNS(t.space, t.local, e);
  };
}
function Z(t, e) {
  return function () {
    var i = e.apply(this, arguments);
    null == i ? this.removeAttribute(t) : this.setAttribute(t, i);
  };
}
function $(t, e) {
  return function () {
    var i = e.apply(this, arguments);
    null == i
      ? this.removeAttributeNS(t.space, t.local)
      : this.setAttributeNS(t.space, t.local, i);
  };
}
function q(t) {
  return (
    (t.ownerDocument && t.ownerDocument.defaultView) ||
    (t.document && t) ||
    t.defaultView
  );
}
function H(t) {
  return function () {
    this.style.removeProperty(t);
  };
}
function W(t, e, i) {
  return function () {
    this.style.setProperty(t, e, i);
  };
}
function X(t, e, i) {
  return function () {
    var r = e.apply(this, arguments);
    null == r ? this.style.removeProperty(t) : this.style.setProperty(t, r, i);
  };
}
function Y(t, e) {
  return (
    t.style.getPropertyValue(e) ||
    q(t).getComputedStyle(t, null).getPropertyValue(e)
  );
}
function K(t) {
  return function () {
    delete this[t];
  };
}
function J(t, e) {
  return function () {
    this[t] = e;
  };
}
function Q(t, e) {
  return function () {
    var i = e.apply(this, arguments);
    null == i ? delete this[t] : (this[t] = i);
  };
}
function tt(t) {
  return t.trim().split(/^|\s+/);
}
function et(t) {
  return t.classList || new it(t);
}
function it(t) {
  (this._node = t), (this._names = tt(t.getAttribute('class') || ''));
}
function rt(t, e) {
  for (var i = et(t), r = -1, n = e.length; ++r < n; ) i.add(e[r]);
}
function nt(t, e) {
  for (var i = et(t), r = -1, n = e.length; ++r < n; ) i.remove(e[r]);
}
function at(t) {
  return function () {
    rt(this, t);
  };
}
function st(t) {
  return function () {
    nt(this, t);
  };
}
function ot(t, e) {
  return function () {
    (e.apply(this, arguments) ? rt : nt)(this, t);
  };
}
function lt() {
  this.textContent = '';
}
function ct(t) {
  return function () {
    this.textContent = t;
  };
}
function ht(t) {
  return function () {
    var e = t.apply(this, arguments);
    this.textContent = null == e ? '' : e;
  };
}
function ut() {
  this.innerHTML = '';
}
function dt(t) {
  return function () {
    this.innerHTML = t;
  };
}
function pt(t) {
  return function () {
    var e = t.apply(this, arguments);
    this.innerHTML = null == e ? '' : e;
  };
}
function ft() {
  this.nextSibling && this.parentNode.appendChild(this);
}
function mt() {
  this.previousSibling &&
    this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function gt() {
  return null;
}
function _t() {
  var t = this.parentNode;
  t && t.removeChild(this);
}
function yt() {
  var t = this.cloneNode(!1),
    e = this.parentNode;
  return e ? e.insertBefore(t, this.nextSibling) : t;
}
function vt() {
  var t = this.cloneNode(!0),
    e = this.parentNode;
  return e ? e.insertBefore(t, this.nextSibling) : t;
}
function xt(t) {
  return t
    .trim()
    .split(/^|\s+/)
    .map(function (t) {
      var e = '',
        i = t.indexOf('.');
      return (
        i >= 0 && ((e = t.slice(i + 1)), (t = t.slice(0, i))),
        { type: t, name: e }
      );
    });
}
function bt(t) {
  return function () {
    var e = this.__on;
    if (e) {
      for (var i, r = 0, n = -1, a = e.length; r < a; ++r)
        (i = e[r]),
          (t.type && i.type !== t.type) || i.name !== t.name
            ? (e[++n] = i)
            : this.removeEventListener(i.type, i.listener, i.options);
      ++n ? (e.length = n) : delete this.__on;
    }
  };
}
function wt(t, e, i) {
  return function () {
    var r,
      n = this.__on,
      a = (function (t) {
        return function (e) {
          t.call(this, e, this.__data__);
        };
      })(e);
    if (n)
      for (var s = 0, o = n.length; s < o; ++s)
        if ((r = n[s]).type === t.type && r.name === t.name)
          return (
            this.removeEventListener(r.type, r.listener, r.options),
            this.addEventListener(r.type, (r.listener = a), (r.options = i)),
            void (r.value = e)
          );
    this.addEventListener(t.type, a, i),
      (r = { type: t.type, name: t.name, value: e, listener: a, options: i }),
      n ? n.push(r) : (this.__on = [r]);
  };
}
function Tt(t, e, i) {
  var r = q(t),
    n = r.CustomEvent;
  'function' == typeof n
    ? (n = new n(e, i))
    : ((n = r.document.createEvent('Event')),
      i
        ? (n.initEvent(e, i.bubbles, i.cancelable), (n.detail = i.detail))
        : n.initEvent(e, !1, !1)),
    t.dispatchEvent(n);
}
function Pt(t, e) {
  return function () {
    return Tt(this, t, e);
  };
}
function Ct(t, e) {
  return function () {
    return Tt(this, t, e.apply(this, arguments));
  };
}
(R.prototype = {
  constructor: R,
  appendChild: function (t) {
    return this._parent.insertBefore(t, this._next);
  },
  insertBefore: function (t, e) {
    return this._parent.insertBefore(t, e);
  },
  querySelector: function (t) {
    return this._parent.querySelector(t);
  },
  querySelectorAll: function (t) {
    return this._parent.querySelectorAll(t);
  },
}),
  (it.prototype = {
    add: function (t) {
      this._names.indexOf(t) < 0 &&
        (this._names.push(t),
        this._node.setAttribute('class', this._names.join(' ')));
    },
    remove: function (t) {
      var e = this._names.indexOf(t);
      e >= 0 &&
        (this._names.splice(e, 1),
        this._node.setAttribute('class', this._names.join(' ')));
    },
    contains: function (t) {
      return this._names.indexOf(t) >= 0;
    },
  });
var It = [null];
function St(t, e) {
  (this._groups = t), (this._parents = e);
}
function Mt() {
  return new St([[document.documentElement]], It);
}
function Dt(t, e, i) {
  (t.prototype = e.prototype = i), (i.constructor = t);
}
function Lt(t, e) {
  var i = Object.create(t.prototype);
  for (var r in e) i[r] = e[r];
  return i;
}
function At() {}
St.prototype = Mt.prototype = {
  constructor: St,
  select: function (t) {
    'function' != typeof t && (t = w(t));
    for (
      var e = this._groups, i = e.length, r = new Array(i), n = 0;
      n < i;
      ++n
    )
      for (
        var a, s, o = e[n], l = o.length, c = (r[n] = new Array(l)), h = 0;
        h < l;
        ++h
      )
        (a = o[h]) &&
          (s = t.call(a, a.__data__, h, o)) &&
          ('__data__' in a && (s.__data__ = a.__data__), (c[h] = s));
    return new St(r, this._parents);
  },
  selectAll: function (t) {
    t =
      'function' == typeof t
        ? (function (t) {
            return function () {
              return T(t.apply(this, arguments));
            };
          })(t)
        : C(t);
    for (var e = this._groups, i = e.length, r = [], n = [], a = 0; a < i; ++a)
      for (var s, o = e[a], l = o.length, c = 0; c < l; ++c)
        (s = o[c]) && (r.push(t.call(s, s.__data__, c, o)), n.push(s));
    return new St(r, n);
  },
  selectChild: function (t) {
    return this.select(
      null == t
        ? D
        : (function (t) {
            return function () {
              return M.call(this.children, t);
            };
          })('function' == typeof t ? t : S(t))
    );
  },
  selectChildren: function (t) {
    return this.selectAll(
      null == t
        ? A
        : (function (t) {
            return function () {
              return L.call(this.children, t);
            };
          })('function' == typeof t ? t : S(t))
    );
  },
  filter: function (t) {
    'function' != typeof t && (t = I(t));
    for (
      var e = this._groups, i = e.length, r = new Array(i), n = 0;
      n < i;
      ++n
    )
      for (var a, s = e[n], o = s.length, l = (r[n] = []), c = 0; c < o; ++c)
        (a = s[c]) && t.call(a, a.__data__, c, s) && l.push(a);
    return new St(r, this._parents);
  },
  data: function (t, e) {
    if (!arguments.length) return Array.from(this, F);
    var i = e ? O : k,
      r = this._parents,
      n = this._groups;
    'function' != typeof t && (t = z(t));
    for (
      var a = n.length,
        s = new Array(a),
        o = new Array(a),
        l = new Array(a),
        c = 0;
      c < a;
      ++c
    ) {
      var h = r[c],
        u = n[c],
        d = u.length,
        p = B(t.call(h, h && h.__data__, c, r)),
        f = p.length,
        m = (o[c] = new Array(f)),
        g = (s[c] = new Array(f)),
        _ = (l[c] = new Array(d));
      i(h, u, m, g, _, p, e);
      for (var y, v, x = 0, b = 0; x < f; ++x)
        if ((y = m[x])) {
          for (x >= b && (b = x + 1); !(v = g[b]) && ++b < f; );
          y._next = v || null;
        }
    }
    return ((s = new St(s, r))._enter = o), (s._exit = l), s;
  },
  enter: function () {
    return new St(this._enter || this._groups.map(E), this._parents);
  },
  exit: function () {
    return new St(this._exit || this._groups.map(E), this._parents);
  },
  join: function (t, e, i) {
    var r = this.enter(),
      n = this,
      a = this.exit();
    return (
      'function' == typeof t
        ? (r = t(r)) && (r = r.selection())
        : (r = r.append(t + '')),
      null != e && (n = e(n)) && (n = n.selection()),
      null == i ? a.remove() : i(a),
      r && n ? r.merge(n).order() : n
    );
  },
  merge: function (t) {
    for (
      var e = t.selection ? t.selection() : t,
        i = this._groups,
        r = e._groups,
        n = i.length,
        a = r.length,
        s = Math.min(n, a),
        o = new Array(n),
        l = 0;
      l < s;
      ++l
    )
      for (
        var c,
          h = i[l],
          u = r[l],
          d = h.length,
          p = (o[l] = new Array(d)),
          f = 0;
        f < d;
        ++f
      )
        (c = h[f] || u[f]) && (p[f] = c);
    for (; l < n; ++l) o[l] = i[l];
    return new St(o, this._parents);
  },
  selection: function () {
    return this;
  },
  order: function () {
    for (var t = this._groups, e = -1, i = t.length; ++e < i; )
      for (var r, n = t[e], a = n.length - 1, s = n[a]; --a >= 0; )
        (r = n[a]) &&
          (s &&
            4 ^ r.compareDocumentPosition(s) &&
            s.parentNode.insertBefore(r, s),
          (s = r));
    return this;
  },
  sort: function (t) {
    function e(e, i) {
      return e && i ? t(e.__data__, i.__data__) : !e - !i;
    }
    t || (t = N);
    for (
      var i = this._groups, r = i.length, n = new Array(r), a = 0;
      a < r;
      ++a
    ) {
      for (
        var s, o = i[a], l = o.length, c = (n[a] = new Array(l)), h = 0;
        h < l;
        ++h
      )
        (s = o[h]) && (c[h] = s);
      c.sort(e);
    }
    return new St(n, this._parents).order();
  },
  call: function () {
    var t = arguments[0];
    return (arguments[0] = this), t.apply(null, arguments), this;
  },
  nodes: function () {
    return Array.from(this);
  },
  node: function () {
    for (var t = this._groups, e = 0, i = t.length; e < i; ++e)
      for (var r = t[e], n = 0, a = r.length; n < a; ++n) {
        var s = r[n];
        if (s) return s;
      }
    return null;
  },
  size: function () {
    let t = 0;
    for (const e of this) ++t;
    return t;
  },
  empty: function () {
    return !this.node();
  },
  each: function (t) {
    for (var e = this._groups, i = 0, r = e.length; i < r; ++i)
      for (var n, a = e[i], s = 0, o = a.length; s < o; ++s)
        (n = a[s]) && t.call(n, n.__data__, s, a);
    return this;
  },
  attr: function (t, e) {
    var i = _(t);
    if (arguments.length < 2) {
      var r = this.node();
      return i.local ? r.getAttributeNS(i.space, i.local) : r.getAttribute(i);
    }
    return this.each(
      (null == e
        ? i.local
          ? j
          : V
        : 'function' == typeof e
        ? i.local
          ? $
          : Z
        : i.local
        ? G
        : U)(i, e)
    );
  },
  style: function (t, e, i) {
    return arguments.length > 1
      ? this.each(
          (null == e ? H : 'function' == typeof e ? X : W)(
            t,
            e,
            null == i ? '' : i
          )
        )
      : Y(this.node(), t);
  },
  property: function (t, e) {
    return arguments.length > 1
      ? this.each((null == e ? K : 'function' == typeof e ? Q : J)(t, e))
      : this.node()[t];
  },
  classed: function (t, e) {
    var i = tt(t + '');
    if (arguments.length < 2) {
      for (var r = et(this.node()), n = -1, a = i.length; ++n < a; )
        if (!r.contains(i[n])) return !1;
      return !0;
    }
    return this.each(('function' == typeof e ? ot : e ? at : st)(i, e));
  },
  text: function (t) {
    return arguments.length
      ? this.each(null == t ? lt : ('function' == typeof t ? ht : ct)(t))
      : this.node().textContent;
  },
  html: function (t) {
    return arguments.length
      ? this.each(null == t ? ut : ('function' == typeof t ? pt : dt)(t))
      : this.node().innerHTML;
  },
  raise: function () {
    return this.each(ft);
  },
  lower: function () {
    return this.each(mt);
  },
  append: function (t) {
    var e = 'function' == typeof t ? t : x(t);
    return this.select(function () {
      return this.appendChild(e.apply(this, arguments));
    });
  },
  insert: function (t, e) {
    var i = 'function' == typeof t ? t : x(t),
      r = null == e ? gt : 'function' == typeof e ? e : w(e);
    return this.select(function () {
      return this.insertBefore(
        i.apply(this, arguments),
        r.apply(this, arguments) || null
      );
    });
  },
  remove: function () {
    return this.each(_t);
  },
  clone: function (t) {
    return this.select(t ? vt : yt);
  },
  datum: function (t) {
    return arguments.length
      ? this.property('__data__', t)
      : this.node().__data__;
  },
  on: function (t, e, i) {
    var r,
      n,
      a = xt(t + ''),
      s = a.length;
    if (!(arguments.length < 2)) {
      for (o = e ? wt : bt, r = 0; r < s; ++r) this.each(o(a[r], e, i));
      return this;
    }
    var o = this.node().__on;
    if (o)
      for (var l, c = 0, h = o.length; c < h; ++c)
        for (r = 0, l = o[c]; r < s; ++r)
          if ((n = a[r]).type === l.type && n.name === l.name) return l.value;
  },
  dispatch: function (t, e) {
    return this.each(('function' == typeof e ? Ct : Pt)(t, e));
  },
  [Symbol.iterator]: function* () {
    for (var t = this._groups, e = 0, i = t.length; e < i; ++e)
      for (var r, n = t[e], a = 0, s = n.length; a < s; ++a)
        (r = n[a]) && (yield r);
  },
};
var Et = 0.7,
  Rt = 1 / Et,
  zt = '\\s*([+-]?\\d+)\\s*',
  kt = '\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*',
  Ot = '\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*',
  Ft = /^#([0-9a-f]{3,8})$/,
  Bt = new RegExp(`^rgb\\(${zt},${zt},${zt}\\)$`),
  Nt = new RegExp(`^rgb\\(${Ot},${Ot},${Ot}\\)$`),
  Vt = new RegExp(`^rgba\\(${zt},${zt},${zt},${kt}\\)$`),
  jt = new RegExp(`^rgba\\(${Ot},${Ot},${Ot},${kt}\\)$`),
  Ut = new RegExp(`^hsl\\(${kt},${Ot},${Ot}\\)$`),
  Gt = new RegExp(`^hsla\\(${kt},${Ot},${Ot},${kt}\\)$`),
  Zt = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074,
  };
function $t() {
  return this.rgb().formatHex();
}
function qt() {
  return this.rgb().formatRgb();
}
function Ht(t) {
  var e, i;
  return (
    (t = (t + '').trim().toLowerCase()),
    (e = Ft.exec(t))
      ? ((i = e[1].length),
        (e = parseInt(e[1], 16)),
        6 === i
          ? Wt(e)
          : 3 === i
          ? new Jt(
              ((e >> 8) & 15) | ((e >> 4) & 240),
              ((e >> 4) & 15) | (240 & e),
              ((15 & e) << 4) | (15 & e),
              1
            )
          : 8 === i
          ? Xt(
              (e >> 24) & 255,
              (e >> 16) & 255,
              (e >> 8) & 255,
              (255 & e) / 255
            )
          : 4 === i
          ? Xt(
              ((e >> 12) & 15) | ((e >> 8) & 240),
              ((e >> 8) & 15) | ((e >> 4) & 240),
              ((e >> 4) & 15) | (240 & e),
              (((15 & e) << 4) | (15 & e)) / 255
            )
          : null)
      : (e = Bt.exec(t))
      ? new Jt(e[1], e[2], e[3], 1)
      : (e = Nt.exec(t))
      ? new Jt((255 * e[1]) / 100, (255 * e[2]) / 100, (255 * e[3]) / 100, 1)
      : (e = Vt.exec(t))
      ? Xt(e[1], e[2], e[3], e[4])
      : (e = jt.exec(t))
      ? Xt((255 * e[1]) / 100, (255 * e[2]) / 100, (255 * e[3]) / 100, e[4])
      : (e = Ut.exec(t))
      ? ne(e[1], e[2] / 100, e[3] / 100, 1)
      : (e = Gt.exec(t))
      ? ne(e[1], e[2] / 100, e[3] / 100, e[4])
      : Zt.hasOwnProperty(t)
      ? Wt(Zt[t])
      : 'transparent' === t
      ? new Jt(NaN, NaN, NaN, 0)
      : null
  );
}
function Wt(t) {
  return new Jt((t >> 16) & 255, (t >> 8) & 255, 255 & t, 1);
}
function Xt(t, e, i, r) {
  return r <= 0 && (t = e = i = NaN), new Jt(t, e, i, r);
}
function Yt(t) {
  return (
    t instanceof At || (t = Ht(t)),
    t ? new Jt((t = t.rgb()).r, t.g, t.b, t.opacity) : new Jt()
  );
}
function Kt(t, e, i, r) {
  return 1 === arguments.length ? Yt(t) : new Jt(t, e, i, null == r ? 1 : r);
}
function Jt(t, e, i, r) {
  (this.r = +t), (this.g = +e), (this.b = +i), (this.opacity = +r);
}
function Qt() {
  return `#${re(this.r)}${re(this.g)}${re(this.b)}`;
}
function te() {
  const t = ee(this.opacity);
  return `${1 === t ? 'rgb(' : 'rgba('}${ie(this.r)}, ${ie(this.g)}, ${ie(
    this.b
  )}${1 === t ? ')' : `, ${t})`}`;
}
function ee(t) {
  return isNaN(t) ? 1 : Math.max(0, Math.min(1, t));
}
function ie(t) {
  return Math.max(0, Math.min(255, Math.round(t) || 0));
}
function re(t) {
  return ((t = ie(t)) < 16 ? '0' : '') + t.toString(16);
}
function ne(t, e, i, r) {
  return (
    r <= 0
      ? (t = e = i = NaN)
      : i <= 0 || i >= 1
      ? (t = e = NaN)
      : e <= 0 && (t = NaN),
    new se(t, e, i, r)
  );
}
function ae(t) {
  if (t instanceof se) return new se(t.h, t.s, t.l, t.opacity);
  if ((t instanceof At || (t = Ht(t)), !t)) return new se();
  if (t instanceof se) return t;
  var e = (t = t.rgb()).r / 255,
    i = t.g / 255,
    r = t.b / 255,
    n = Math.min(e, i, r),
    a = Math.max(e, i, r),
    s = NaN,
    o = a - n,
    l = (a + n) / 2;
  return (
    o
      ? ((s =
          e === a
            ? (i - r) / o + 6 * (i < r)
            : i === a
            ? (r - e) / o + 2
            : (e - i) / o + 4),
        (o /= l < 0.5 ? a + n : 2 - a - n),
        (s *= 60))
      : (o = l > 0 && l < 1 ? 0 : s),
    new se(s, o, l, t.opacity)
  );
}
function se(t, e, i, r) {
  (this.h = +t), (this.s = +e), (this.l = +i), (this.opacity = +r);
}
function oe(t) {
  return (t = (t || 0) % 360) < 0 ? t + 360 : t;
}
function le(t) {
  return Math.max(0, Math.min(1, t || 0));
}
function ce(t, e, i) {
  return (
    255 *
    (t < 60
      ? e + ((i - e) * t) / 60
      : t < 180
      ? i
      : t < 240
      ? e + ((i - e) * (240 - t)) / 60
      : e)
  );
}
Dt(At, Ht, {
  copy(t) {
    return Object.assign(new this.constructor(), this, t);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: $t,
  formatHex: $t,
  formatHex8: function () {
    return this.rgb().formatHex8();
  },
  formatHsl: function () {
    return ae(this).formatHsl();
  },
  formatRgb: qt,
  toString: qt,
}),
  Dt(
    Jt,
    Kt,
    Lt(At, {
      brighter(t) {
        return (
          (t = null == t ? Rt : Math.pow(Rt, t)),
          new Jt(this.r * t, this.g * t, this.b * t, this.opacity)
        );
      },
      darker(t) {
        return (
          (t = null == t ? Et : Math.pow(Et, t)),
          new Jt(this.r * t, this.g * t, this.b * t, this.opacity)
        );
      },
      rgb() {
        return this;
      },
      clamp() {
        return new Jt(ie(this.r), ie(this.g), ie(this.b), ee(this.opacity));
      },
      displayable() {
        return (
          -0.5 <= this.r &&
          this.r < 255.5 &&
          -0.5 <= this.g &&
          this.g < 255.5 &&
          -0.5 <= this.b &&
          this.b < 255.5 &&
          0 <= this.opacity &&
          this.opacity <= 1
        );
      },
      hex: Qt,
      formatHex: Qt,
      formatHex8: function () {
        return `#${re(this.r)}${re(this.g)}${re(this.b)}${re(
          255 * (isNaN(this.opacity) ? 1 : this.opacity)
        )}`;
      },
      formatRgb: te,
      toString: te,
    })
  ),
  Dt(
    se,
    function (t, e, i, r) {
      return 1 === arguments.length
        ? ae(t)
        : new se(t, e, i, null == r ? 1 : r);
    },
    Lt(At, {
      brighter(t) {
        return (
          (t = null == t ? Rt : Math.pow(Rt, t)),
          new se(this.h, this.s, this.l * t, this.opacity)
        );
      },
      darker(t) {
        return (
          (t = null == t ? Et : Math.pow(Et, t)),
          new se(this.h, this.s, this.l * t, this.opacity)
        );
      },
      rgb() {
        var t = (this.h % 360) + 360 * (this.h < 0),
          e = isNaN(t) || isNaN(this.s) ? 0 : this.s,
          i = this.l,
          r = i + (i < 0.5 ? i : 1 - i) * e,
          n = 2 * i - r;
        return new Jt(
          ce(t >= 240 ? t - 240 : t + 120, n, r),
          ce(t, n, r),
          ce(t < 120 ? t + 240 : t - 120, n, r),
          this.opacity
        );
      },
      clamp() {
        return new se(oe(this.h), le(this.s), le(this.l), ee(this.opacity));
      },
      displayable() {
        return (
          ((0 <= this.s && this.s <= 1) || isNaN(this.s)) &&
          0 <= this.l &&
          this.l <= 1 &&
          0 <= this.opacity &&
          this.opacity <= 1
        );
      },
      formatHsl() {
        const t = ee(this.opacity);
        return `${1 === t ? 'hsl(' : 'hsla('}${oe(this.h)}, ${
          100 * le(this.s)
        }%, ${100 * le(this.l)}%${1 === t ? ')' : `, ${t})`}`;
      },
    })
  );
var he = (t) => () => t;
function ue(t) {
  return 1 == (t = +t)
    ? de
    : function (e, i) {
        return i - e
          ? (function (t, e, i) {
              return (
                (t = Math.pow(t, i)),
                (e = Math.pow(e, i) - t),
                (i = 1 / i),
                function (r) {
                  return Math.pow(t + r * e, i);
                }
              );
            })(e, i, t)
          : he(isNaN(e) ? i : e);
      };
}
function de(t, e) {
  var i = e - t;
  return i
    ? (function (t, e) {
        return function (i) {
          return t + i * e;
        };
      })(t, i)
    : he(isNaN(t) ? e : t);
}
var pe = (function t(e) {
  var i = ue(e);
  function r(t, e) {
    var r = i((t = Kt(t)).r, (e = Kt(e)).r),
      n = i(t.g, e.g),
      a = i(t.b, e.b),
      s = de(t.opacity, e.opacity);
    return function (e) {
      return (
        (t.r = r(e)), (t.g = n(e)), (t.b = a(e)), (t.opacity = s(e)), t + ''
      );
    };
  }
  return (r.gamma = t), r;
})(1);
function fe(t, e) {
  return (
    (t = +t),
    (e = +e),
    function (i) {
      return t * (1 - i) + e * i;
    }
  );
}
var me = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
  ge = new RegExp(me.source, 'g');
function _e(t, e) {
  var i,
    r,
    n,
    a = (me.lastIndex = ge.lastIndex = 0),
    s = -1,
    o = [],
    l = [];
  for (t += '', e += ''; (i = me.exec(t)) && (r = ge.exec(e)); )
    (n = r.index) > a &&
      ((n = e.slice(a, n)), o[s] ? (o[s] += n) : (o[++s] = n)),
      (i = i[0]) === (r = r[0])
        ? o[s]
          ? (o[s] += r)
          : (o[++s] = r)
        : ((o[++s] = null), l.push({ i: s, x: fe(i, r) })),
      (a = ge.lastIndex);
  return (
    a < e.length && ((n = e.slice(a)), o[s] ? (o[s] += n) : (o[++s] = n)),
    o.length < 2
      ? l[0]
        ? (function (t) {
            return function (e) {
              return t(e) + '';
            };
          })(l[0].x)
        : (function (t) {
            return function () {
              return t;
            };
          })(e)
      : ((e = l.length),
        function (t) {
          for (var i, r = 0; r < e; ++r) o[(i = l[r]).i] = i.x(t);
          return o.join('');
        })
  );
}
var ye,
  ve = 180 / Math.PI,
  xe = {
    translateX: 0,
    translateY: 0,
    rotate: 0,
    skewX: 0,
    scaleX: 1,
    scaleY: 1,
  };
function be(t, e, i, r, n, a) {
  var s, o, l;
  return (
    (s = Math.sqrt(t * t + e * e)) && ((t /= s), (e /= s)),
    (l = t * i + e * r) && ((i -= t * l), (r -= e * l)),
    (o = Math.sqrt(i * i + r * r)) && ((i /= o), (r /= o), (l /= o)),
    t * r < e * i && ((t = -t), (e = -e), (l = -l), (s = -s)),
    {
      translateX: n,
      translateY: a,
      rotate: Math.atan2(e, t) * ve,
      skewX: Math.atan(l) * ve,
      scaleX: s,
      scaleY: o,
    }
  );
}
function we(t, e, i, r) {
  function n(t) {
    return t.length ? t.pop() + ' ' : '';
  }
  return function (a, s) {
    var o = [],
      l = [];
    return (
      (a = t(a)),
      (s = t(s)),
      (function (t, r, n, a, s, o) {
        if (t !== n || r !== a) {
          var l = s.push('translate(', null, e, null, i);
          o.push({ i: l - 4, x: fe(t, n) }, { i: l - 2, x: fe(r, a) });
        } else (n || a) && s.push('translate(' + n + e + a + i);
      })(a.translateX, a.translateY, s.translateX, s.translateY, o, l),
      (function (t, e, i, a) {
        t !== e
          ? (t - e > 180 ? (e += 360) : e - t > 180 && (t += 360),
            a.push({ i: i.push(n(i) + 'rotate(', null, r) - 2, x: fe(t, e) }))
          : e && i.push(n(i) + 'rotate(' + e + r);
      })(a.rotate, s.rotate, o, l),
      (function (t, e, i, a) {
        t !== e
          ? a.push({ i: i.push(n(i) + 'skewX(', null, r) - 2, x: fe(t, e) })
          : e && i.push(n(i) + 'skewX(' + e + r);
      })(a.skewX, s.skewX, o, l),
      (function (t, e, i, r, a, s) {
        if (t !== i || e !== r) {
          var o = a.push(n(a) + 'scale(', null, ',', null, ')');
          s.push({ i: o - 4, x: fe(t, i) }, { i: o - 2, x: fe(e, r) });
        } else
          (1 === i && 1 === r) || a.push(n(a) + 'scale(' + i + ',' + r + ')');
      })(a.scaleX, a.scaleY, s.scaleX, s.scaleY, o, l),
      (a = s = null),
      function (t) {
        for (var e, i = -1, r = l.length; ++i < r; ) o[(e = l[i]).i] = e.x(t);
        return o.join('');
      }
    );
  };
}
var Te,
  Pe,
  Ce = we(
    function (t) {
      const e = new (
        'function' == typeof DOMMatrix ? DOMMatrix : WebKitCSSMatrix
      )(t + '');
      return e.isIdentity ? xe : be(e.a, e.b, e.c, e.d, e.e, e.f);
    },
    'px, ',
    'px)',
    'deg)'
  ),
  Ie = we(
    function (t) {
      return null == t
        ? xe
        : (ye ||
            (ye = document.createElementNS('http://www.w3.org/2000/svg', 'g')),
          ye.setAttribute('transform', t),
          (t = ye.transform.baseVal.consolidate())
            ? be((t = t.matrix).a, t.b, t.c, t.d, t.e, t.f)
            : xe);
    },
    ', ',
    ')',
    ')'
  ),
  Se = 0,
  Me = 0,
  De = 0,
  Le = 0,
  Ae = 0,
  Ee = 0,
  Re = 'object' == typeof performance && performance.now ? performance : Date,
  ze =
    'object' == typeof window && window.requestAnimationFrame
      ? window.requestAnimationFrame.bind(window)
      : function (t) {
          setTimeout(t, 17);
        };
function ke() {
  return Ae || (ze(Oe), (Ae = Re.now() + Ee));
}
function Oe() {
  Ae = 0;
}
function Fe() {
  this._call = this._time = this._next = null;
}
function Be(t, e, i) {
  var r = new Fe();
  return r.restart(t, e, i), r;
}
function Ne() {
  (Ae = (Le = Re.now()) + Ee), (Se = Me = 0);
  try {
    !(function () {
      ke(), ++Se;
      for (var t, e = Te; e; )
        (t = Ae - e._time) >= 0 && e._call.call(void 0, t), (e = e._next);
      --Se;
    })();
  } finally {
    (Se = 0),
      (function () {
        var t,
          e,
          i = Te,
          r = 1 / 0;
        for (; i; )
          i._call
            ? (r > i._time && (r = i._time), (t = i), (i = i._next))
            : ((e = i._next),
              (i._next = null),
              (i = t ? (t._next = e) : (Te = e)));
        (Pe = t), je(r);
      })(),
      (Ae = 0);
  }
}
function Ve() {
  var t = Re.now(),
    e = t - Le;
  e > 1e3 && ((Ee -= e), (Le = t));
}
function je(t) {
  Se ||
    (Me && (Me = clearTimeout(Me)),
    t - Ae > 24
      ? (t < 1 / 0 && (Me = setTimeout(Ne, t - Re.now() - Ee)),
        De && (De = clearInterval(De)))
      : (De || ((Le = Re.now()), (De = setInterval(Ve, 1e3))),
        (Se = 1),
        ze(Ne)));
}
function Ue(t, e, i) {
  var r = new Fe();
  return (
    (e = null == e ? 0 : +e),
    r.restart(
      (i) => {
        r.stop(), t(i + e);
      },
      e,
      i
    ),
    r
  );
}
Fe.prototype = Be.prototype = {
  constructor: Fe,
  restart: function (t, e, i) {
    if ('function' != typeof t)
      throw new TypeError('callback is not a function');
    (i = (null == i ? ke() : +i) + (null == e ? 0 : +e)),
      this._next ||
        Pe === this ||
        (Pe ? (Pe._next = this) : (Te = this), (Pe = this)),
      (this._call = t),
      (this._time = i),
      je();
  },
  stop: function () {
    this._call && ((this._call = null), (this._time = 1 / 0), je());
  },
};
var Ge = h('start', 'end', 'cancel', 'interrupt'),
  Ze = [];
function $e(t, e, i, r, n, a) {
  var s = t.__transition;
  if (s) {
    if (i in s) return;
  } else t.__transition = {};
  !(function (t, e, i) {
    var r,
      n = t.__transition;
    function a(t) {
      (i.state = 1),
        i.timer.restart(s, i.delay, i.time),
        i.delay <= t && s(t - i.delay);
    }
    function s(a) {
      var c, h, u, d;
      if (1 !== i.state) return l();
      for (c in n)
        if ((d = n[c]).name === i.name) {
          if (3 === d.state) return Ue(s);
          4 === d.state
            ? ((d.state = 6),
              d.timer.stop(),
              d.on.call('interrupt', t, t.__data__, d.index, d.group),
              delete n[c])
            : +c < e &&
              ((d.state = 6),
              d.timer.stop(),
              d.on.call('cancel', t, t.__data__, d.index, d.group),
              delete n[c]);
        }
      if (
        (Ue(function () {
          3 === i.state &&
            ((i.state = 4), i.timer.restart(o, i.delay, i.time), o(a));
        }),
        (i.state = 2),
        i.on.call('start', t, t.__data__, i.index, i.group),
        2 === i.state)
      ) {
        for (
          i.state = 3, r = new Array((u = i.tween.length)), c = 0, h = -1;
          c < u;
          ++c
        )
          (d = i.tween[c].value.call(t, t.__data__, i.index, i.group)) &&
            (r[++h] = d);
        r.length = h + 1;
      }
    }
    function o(e) {
      for (
        var n =
            e < i.duration
              ? i.ease.call(null, e / i.duration)
              : (i.timer.restart(l), (i.state = 5), 1),
          a = -1,
          s = r.length;
        ++a < s;

      )
        r[a].call(t, n);
      5 === i.state && (i.on.call('end', t, t.__data__, i.index, i.group), l());
    }
    function l() {
      for (var r in ((i.state = 6), i.timer.stop(), delete n[e], n)) return;
      delete t.__transition;
    }
    (n[e] = i), (i.timer = Be(a, 0, i.time));
  })(t, i, {
    name: e,
    index: r,
    group: n,
    on: Ge,
    tween: Ze,
    time: a.time,
    delay: a.delay,
    duration: a.duration,
    ease: a.ease,
    timer: null,
    state: 0,
  });
}
function qe(t, e) {
  var i = We(t, e);
  if (i.state > 0) throw new Error('too late; already scheduled');
  return i;
}
function He(t, e) {
  var i = We(t, e);
  if (i.state > 3) throw new Error('too late; already running');
  return i;
}
function We(t, e) {
  var i = t.__transition;
  if (!i || !(i = i[e])) throw new Error('transition not found');
  return i;
}
function Xe(t, e) {
  var i, r;
  return function () {
    var n = He(this, t),
      a = n.tween;
    if (a !== i)
      for (var s = 0, o = (r = i = a).length; s < o; ++s)
        if (r[s].name === e) {
          (r = r.slice()).splice(s, 1);
          break;
        }
    n.tween = r;
  };
}
function Ye(t, e, i) {
  var r, n;
  if ('function' != typeof i) throw new Error();
  return function () {
    var a = He(this, t),
      s = a.tween;
    if (s !== r) {
      n = (r = s).slice();
      for (var o = { name: e, value: i }, l = 0, c = n.length; l < c; ++l)
        if (n[l].name === e) {
          n[l] = o;
          break;
        }
      l === c && n.push(o);
    }
    a.tween = n;
  };
}
function Ke(t, e, i) {
  var r = t._id;
  return (
    t.each(function () {
      var t = He(this, r);
      (t.value || (t.value = {}))[e] = i.apply(this, arguments);
    }),
    function (t) {
      return We(t, r).value[e];
    }
  );
}
function Je(t, e) {
  var i;
  return (
    'number' == typeof e
      ? fe
      : e instanceof Ht
      ? pe
      : (i = Ht(e))
      ? ((e = i), pe)
      : _e
  )(t, e);
}
function Qe(t) {
  return function () {
    this.removeAttribute(t);
  };
}
function ti(t) {
  return function () {
    this.removeAttributeNS(t.space, t.local);
  };
}
function ei(t, e, i) {
  var r,
    n,
    a = i + '';
  return function () {
    var s = this.getAttribute(t);
    return s === a ? null : s === r ? n : (n = e((r = s), i));
  };
}
function ii(t, e, i) {
  var r,
    n,
    a = i + '';
  return function () {
    var s = this.getAttributeNS(t.space, t.local);
    return s === a ? null : s === r ? n : (n = e((r = s), i));
  };
}
function ri(t, e, i) {
  var r, n, a;
  return function () {
    var s,
      o,
      l = i(this);
    if (null != l)
      return (s = this.getAttribute(t)) === (o = l + '')
        ? null
        : s === r && o === n
        ? a
        : ((n = o), (a = e((r = s), l)));
    this.removeAttribute(t);
  };
}
function ni(t, e, i) {
  var r, n, a;
  return function () {
    var s,
      o,
      l = i(this);
    if (null != l)
      return (s = this.getAttributeNS(t.space, t.local)) === (o = l + '')
        ? null
        : s === r && o === n
        ? a
        : ((n = o), (a = e((r = s), l)));
    this.removeAttributeNS(t.space, t.local);
  };
}
function ai(t, e) {
  return function (i) {
    this.setAttribute(t, e.call(this, i));
  };
}
function si(t, e) {
  return function (i) {
    this.setAttributeNS(t.space, t.local, e.call(this, i));
  };
}
function oi(t, e) {
  var i, r;
  function n() {
    var n = e.apply(this, arguments);
    return n !== r && (i = (r = n) && si(t, n)), i;
  }
  return (n._value = e), n;
}
function li(t, e) {
  var i, r;
  function n() {
    var n = e.apply(this, arguments);
    return n !== r && (i = (r = n) && ai(t, n)), i;
  }
  return (n._value = e), n;
}
function ci(t, e) {
  return function () {
    qe(this, t).delay = +e.apply(this, arguments);
  };
}
function hi(t, e) {
  return (
    (e = +e),
    function () {
      qe(this, t).delay = e;
    }
  );
}
function ui(t, e) {
  return function () {
    He(this, t).duration = +e.apply(this, arguments);
  };
}
function di(t, e) {
  return (
    (e = +e),
    function () {
      He(this, t).duration = e;
    }
  );
}
function pi(t, e) {
  if ('function' != typeof e) throw new Error();
  return function () {
    He(this, t).ease = e;
  };
}
function fi(t, e, i) {
  var r,
    n,
    a = (function (t) {
      return (t + '')
        .trim()
        .split(/^|\s+/)
        .every(function (t) {
          var e = t.indexOf('.');
          return e >= 0 && (t = t.slice(0, e)), !t || 'start' === t;
        });
    })(e)
      ? qe
      : He;
  return function () {
    var s = a(this, t),
      o = s.on;
    o !== r && (n = (r = o).copy()).on(e, i), (s.on = n);
  };
}
var mi = Mt.prototype.constructor;
function gi(t) {
  return function () {
    this.style.removeProperty(t);
  };
}
function _i(t, e, i) {
  return function (r) {
    this.style.setProperty(t, e.call(this, r), i);
  };
}
function yi(t, e, i) {
  var r, n;
  function a() {
    var a = e.apply(this, arguments);
    return a !== n && (r = (n = a) && _i(t, a, i)), r;
  }
  return (a._value = e), a;
}
function vi(t) {
  return function (e) {
    this.textContent = t.call(this, e);
  };
}
function xi(t) {
  var e, i;
  function r() {
    var r = t.apply(this, arguments);
    return r !== i && (e = (i = r) && vi(r)), e;
  }
  return (r._value = t), r;
}
var bi = 0;
function wi(t, e, i, r) {
  (this._groups = t), (this._parents = e), (this._name = i), (this._id = r);
}
function Ti() {
  return ++bi;
}
var Pi = Mt.prototype;
wi.prototype = {
  constructor: wi,
  select: function (t) {
    var e = this._name,
      i = this._id;
    'function' != typeof t && (t = w(t));
    for (
      var r = this._groups, n = r.length, a = new Array(n), s = 0;
      s < n;
      ++s
    )
      for (
        var o, l, c = r[s], h = c.length, u = (a[s] = new Array(h)), d = 0;
        d < h;
        ++d
      )
        (o = c[d]) &&
          (l = t.call(o, o.__data__, d, c)) &&
          ('__data__' in o && (l.__data__ = o.__data__),
          (u[d] = l),
          $e(u[d], e, i, d, u, We(o, i)));
    return new wi(a, this._parents, e, i);
  },
  selectAll: function (t) {
    var e = this._name,
      i = this._id;
    'function' != typeof t && (t = C(t));
    for (var r = this._groups, n = r.length, a = [], s = [], o = 0; o < n; ++o)
      for (var l, c = r[o], h = c.length, u = 0; u < h; ++u)
        if ((l = c[u])) {
          for (
            var d,
              p = t.call(l, l.__data__, u, c),
              f = We(l, i),
              m = 0,
              g = p.length;
            m < g;
            ++m
          )
            (d = p[m]) && $e(d, e, i, m, p, f);
          a.push(p), s.push(l);
        }
    return new wi(a, s, e, i);
  },
  selectChild: Pi.selectChild,
  selectChildren: Pi.selectChildren,
  filter: function (t) {
    'function' != typeof t && (t = I(t));
    for (
      var e = this._groups, i = e.length, r = new Array(i), n = 0;
      n < i;
      ++n
    )
      for (var a, s = e[n], o = s.length, l = (r[n] = []), c = 0; c < o; ++c)
        (a = s[c]) && t.call(a, a.__data__, c, s) && l.push(a);
    return new wi(r, this._parents, this._name, this._id);
  },
  merge: function (t) {
    if (t._id !== this._id) throw new Error();
    for (
      var e = this._groups,
        i = t._groups,
        r = e.length,
        n = i.length,
        a = Math.min(r, n),
        s = new Array(r),
        o = 0;
      o < a;
      ++o
    )
      for (
        var l,
          c = e[o],
          h = i[o],
          u = c.length,
          d = (s[o] = new Array(u)),
          p = 0;
        p < u;
        ++p
      )
        (l = c[p] || h[p]) && (d[p] = l);
    for (; o < r; ++o) s[o] = e[o];
    return new wi(s, this._parents, this._name, this._id);
  },
  selection: function () {
    return new mi(this._groups, this._parents);
  },
  transition: function () {
    for (
      var t = this._name,
        e = this._id,
        i = Ti(),
        r = this._groups,
        n = r.length,
        a = 0;
      a < n;
      ++a
    )
      for (var s, o = r[a], l = o.length, c = 0; c < l; ++c)
        if ((s = o[c])) {
          var h = We(s, e);
          $e(s, t, i, c, o, {
            time: h.time + h.delay + h.duration,
            delay: 0,
            duration: h.duration,
            ease: h.ease,
          });
        }
    return new wi(r, this._parents, t, i);
  },
  call: Pi.call,
  nodes: Pi.nodes,
  node: Pi.node,
  size: Pi.size,
  empty: Pi.empty,
  each: Pi.each,
  on: function (t, e) {
    var i = this._id;
    return arguments.length < 2
      ? We(this.node(), i).on.on(t)
      : this.each(fi(i, t, e));
  },
  attr: function (t, e) {
    var i = _(t),
      r = 'transform' === i ? Ie : Je;
    return this.attrTween(
      t,
      'function' == typeof e
        ? (i.local ? ni : ri)(i, r, Ke(this, 'attr.' + t, e))
        : null == e
        ? (i.local ? ti : Qe)(i)
        : (i.local ? ii : ei)(i, r, e)
    );
  },
  attrTween: function (t, e) {
    var i = 'attr.' + t;
    if (arguments.length < 2) return (i = this.tween(i)) && i._value;
    if (null == e) return this.tween(i, null);
    if ('function' != typeof e) throw new Error();
    var r = _(t);
    return this.tween(i, (r.local ? oi : li)(r, e));
  },
  style: function (t, e, i) {
    var r = 'transform' == (t += '') ? Ce : Je;
    return null == e
      ? this.styleTween(
          t,
          (function (t, e) {
            var i, r, n;
            return function () {
              var a = Y(this, t),
                s = (this.style.removeProperty(t), Y(this, t));
              return a === s
                ? null
                : a === i && s === r
                ? n
                : (n = e((i = a), (r = s)));
            };
          })(t, r)
        ).on('end.style.' + t, gi(t))
      : 'function' == typeof e
      ? this.styleTween(
          t,
          (function (t, e, i) {
            var r, n, a;
            return function () {
              var s = Y(this, t),
                o = i(this),
                l = o + '';
              return (
                null == o &&
                  (this.style.removeProperty(t), (l = o = Y(this, t))),
                s === l
                  ? null
                  : s === r && l === n
                  ? a
                  : ((n = l), (a = e((r = s), o)))
              );
            };
          })(t, r, Ke(this, 'style.' + t, e))
        ).each(
          (function (t, e) {
            var i,
              r,
              n,
              a,
              s = 'style.' + e,
              o = 'end.' + s;
            return function () {
              var l = He(this, t),
                c = l.on,
                h = null == l.value[s] ? a || (a = gi(e)) : void 0;
              (c === i && n === h) || (r = (i = c).copy()).on(o, (n = h)),
                (l.on = r);
            };
          })(this._id, t)
        )
      : this.styleTween(
          t,
          (function (t, e, i) {
            var r,
              n,
              a = i + '';
            return function () {
              var s = Y(this, t);
              return s === a ? null : s === r ? n : (n = e((r = s), i));
            };
          })(t, r, e),
          i
        ).on('end.style.' + t, null);
  },
  styleTween: function (t, e, i) {
    var r = 'style.' + (t += '');
    if (arguments.length < 2) return (r = this.tween(r)) && r._value;
    if (null == e) return this.tween(r, null);
    if ('function' != typeof e) throw new Error();
    return this.tween(r, yi(t, e, null == i ? '' : i));
  },
  text: function (t) {
    return this.tween(
      'text',
      'function' == typeof t
        ? (function (t) {
            return function () {
              var e = t(this);
              this.textContent = null == e ? '' : e;
            };
          })(Ke(this, 'text', t))
        : (function (t) {
            return function () {
              this.textContent = t;
            };
          })(null == t ? '' : t + '')
    );
  },
  textTween: function (t) {
    var e = 'text';
    if (arguments.length < 1) return (e = this.tween(e)) && e._value;
    if (null == t) return this.tween(e, null);
    if ('function' != typeof t) throw new Error();
    return this.tween(e, xi(t));
  },
  remove: function () {
    return this.on(
      'end.remove',
      (function (t) {
        return function () {
          var e = this.parentNode;
          for (var i in this.__transition) if (+i !== t) return;
          e && e.removeChild(this);
        };
      })(this._id)
    );
  },
  tween: function (t, e) {
    var i = this._id;
    if (((t += ''), arguments.length < 2)) {
      for (var r, n = We(this.node(), i).tween, a = 0, s = n.length; a < s; ++a)
        if ((r = n[a]).name === t) return r.value;
      return null;
    }
    return this.each((null == e ? Xe : Ye)(i, t, e));
  },
  delay: function (t) {
    var e = this._id;
    return arguments.length
      ? this.each(('function' == typeof t ? ci : hi)(e, t))
      : We(this.node(), e).delay;
  },
  duration: function (t) {
    var e = this._id;
    return arguments.length
      ? this.each(('function' == typeof t ? ui : di)(e, t))
      : We(this.node(), e).duration;
  },
  ease: function (t) {
    var e = this._id;
    return arguments.length ? this.each(pi(e, t)) : We(this.node(), e).ease;
  },
  easeVarying: function (t) {
    if ('function' != typeof t) throw new Error();
    return this.each(
      (function (t, e) {
        return function () {
          var i = e.apply(this, arguments);
          if ('function' != typeof i) throw new Error();
          He(this, t).ease = i;
        };
      })(this._id, t)
    );
  },
  end: function () {
    var t,
      e,
      i = this,
      r = i._id,
      n = i.size();
    return new Promise(function (a, s) {
      var o = { value: s },
        l = {
          value: function () {
            0 == --n && a();
          },
        };
      i.each(function () {
        var i = He(this, r),
          n = i.on;
        n !== t &&
          ((e = (t = n).copy())._.cancel.push(o),
          e._.interrupt.push(o),
          e._.end.push(l)),
          (i.on = e);
      }),
        0 === n && a();
    });
  },
  [Symbol.iterator]: Pi[Symbol.iterator],
};
var Ci = {
  time: null,
  delay: 0,
  duration: 250,
  ease: function (t) {
    return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
  },
};
function Ii(t, e) {
  for (var i; !(i = t.__transition) || !(i = i[e]); )
    if (!(t = t.parentNode)) throw new Error(`transition ${e} not found`);
  return i;
}
function Si(t, e, i) {
  (this.k = t), (this.x = e), (this.y = i);
}
(Mt.prototype.interrupt = function (t) {
  return this.each(function () {
    !(function (t, e) {
      var i,
        r,
        n,
        a = t.__transition,
        s = !0;
      if (a) {
        for (n in ((e = null == e ? null : e + ''), a))
          (i = a[n]).name === e
            ? ((r = i.state > 2 && i.state < 5),
              (i.state = 6),
              i.timer.stop(),
              i.on.call(
                r ? 'interrupt' : 'cancel',
                t,
                t.__data__,
                i.index,
                i.group
              ),
              delete a[n])
            : (s = !1);
        s && delete t.__transition;
      }
    })(this, t);
  });
}),
  (Mt.prototype.transition = function (t) {
    var e, i;
    t instanceof wi
      ? ((e = t._id), (t = t._name))
      : ((e = Ti()), ((i = Ci).time = ke()), (t = null == t ? null : t + ''));
    for (var r = this._groups, n = r.length, a = 0; a < n; ++a)
      for (var s, o = r[a], l = o.length, c = 0; c < l; ++c)
        (s = o[c]) && $e(s, t, e, c, o, i || Ii(s, e));
    return new wi(r, this._parents, t, e);
  }),
  (Si.prototype = {
    constructor: Si,
    scale: function (t) {
      return 1 === t ? this : new Si(this.k * t, this.x, this.y);
    },
    translate: function (t, e) {
      return (0 === t) & (0 === e)
        ? this
        : new Si(this.k, this.x + this.k * t, this.y + this.k * e);
    },
    apply: function (t) {
      return [t[0] * this.k + this.x, t[1] * this.k + this.y];
    },
    applyX: function (t) {
      return t * this.k + this.x;
    },
    applyY: function (t) {
      return t * this.k + this.y;
    },
    invert: function (t) {
      return [(t[0] - this.x) / this.k, (t[1] - this.y) / this.k];
    },
    invertX: function (t) {
      return (t - this.x) / this.k;
    },
    invertY: function (t) {
      return (t - this.y) / this.k;
    },
    rescaleX: function (t) {
      return t
        .copy()
        .domain(t.range().map(this.invertX, this).map(t.invert, t));
    },
    rescaleY: function (t) {
      return t
        .copy()
        .domain(t.range().map(this.invertY, this).map(t.invert, t));
    },
    toString: function () {
      return 'translate(' + this.x + ',' + this.y + ') scale(' + this.k + ')';
    },
  }),
  new Si(1, 0, 0),
  Si.prototype;
'undefined' != typeof globalThis
  ? globalThis
  : 'undefined' != typeof window
  ? window
  : 'undefined' != typeof global
  ? global
  : 'undefined' != typeof self && self;
function Mi(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, 'default')
    ? t.default
    : t;
}
var Di = { exports: {} };
/**
 * MapLibre GL JS
 * @license 3-Clause BSD. Full text of license: https://github.com/maplibre/maplibre-gl-js/blob/v5.11.0/LICENSE.txt
 */ Di.exports = (function () {
  var t = {},
    e = {};
  function i(i, r, n) {
    if (((e[i] = n), 'index' === i)) {
      var a =
          'var sharedModule = {}; (' +
          e.shared +
          ')(sharedModule); (' +
          e.worker +
          ')(sharedModule);',
        s = {};
      return (
        e.shared(s),
        e.index(t, s),
        'undefined' != typeof window &&
          t.setWorkerUrl(
            window.URL.createObjectURL(
              new Blob([a], { type: 'text/javascript' })
            )
          ),
        t
      );
    }
  }
  i('shared', ['exports'], function (t) {
    function e(t, e, i, r) {
      return new (i || (i = Promise))(function (n, a) {
        function s(t) {
          try {
            l(r.next(t));
          } catch (t) {
            a(t);
          }
        }
        function o(t) {
          try {
            l(r.throw(t));
          } catch (t) {
            a(t);
          }
        }
        function l(t) {
          var e;
          t.done
            ? n(t.value)
            : ((e = t.value),
              e instanceof i
                ? e
                : new i(function (t) {
                    t(e);
                  })).then(s, o);
        }
        l((r = r.apply(t, e || [])).next());
      });
    }
    function i(t, e) {
      (this.x = t), (this.y = e);
    }
    function r(t) {
      return t &&
        t.__esModule &&
        Object.prototype.hasOwnProperty.call(t, 'default')
        ? t.default
        : t;
    }
    var n, a;
    'function' == typeof SuppressedError && SuppressedError,
      (i.prototype = {
        clone() {
          return new i(this.x, this.y);
        },
        add(t) {
          return this.clone()._add(t);
        },
        sub(t) {
          return this.clone()._sub(t);
        },
        multByPoint(t) {
          return this.clone()._multByPoint(t);
        },
        divByPoint(t) {
          return this.clone()._divByPoint(t);
        },
        mult(t) {
          return this.clone()._mult(t);
        },
        div(t) {
          return this.clone()._div(t);
        },
        rotate(t) {
          return this.clone()._rotate(t);
        },
        rotateAround(t, e) {
          return this.clone()._rotateAround(t, e);
        },
        matMult(t) {
          return this.clone()._matMult(t);
        },
        unit() {
          return this.clone()._unit();
        },
        perp() {
          return this.clone()._perp();
        },
        round() {
          return this.clone()._round();
        },
        mag() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        },
        equals(t) {
          return this.x === t.x && this.y === t.y;
        },
        dist(t) {
          return Math.sqrt(this.distSqr(t));
        },
        distSqr(t) {
          const e = t.x - this.x,
            i = t.y - this.y;
          return e * e + i * i;
        },
        angle() {
          return Math.atan2(this.y, this.x);
        },
        angleTo(t) {
          return Math.atan2(this.y - t.y, this.x - t.x);
        },
        angleWith(t) {
          return this.angleWithSep(t.x, t.y);
        },
        angleWithSep(t, e) {
          return Math.atan2(this.x * e - this.y * t, this.x * t + this.y * e);
        },
        _matMult(t) {
          const e = t[2] * this.x + t[3] * this.y;
          return (this.x = t[0] * this.x + t[1] * this.y), (this.y = e), this;
        },
        _add(t) {
          return (this.x += t.x), (this.y += t.y), this;
        },
        _sub(t) {
          return (this.x -= t.x), (this.y -= t.y), this;
        },
        _mult(t) {
          return (this.x *= t), (this.y *= t), this;
        },
        _div(t) {
          return (this.x /= t), (this.y /= t), this;
        },
        _multByPoint(t) {
          return (this.x *= t.x), (this.y *= t.y), this;
        },
        _divByPoint(t) {
          return (this.x /= t.x), (this.y /= t.y), this;
        },
        _unit() {
          return this._div(this.mag()), this;
        },
        _perp() {
          const t = this.y;
          return (this.y = this.x), (this.x = -t), this;
        },
        _rotate(t) {
          const e = Math.cos(t),
            i = Math.sin(t),
            r = i * this.x + e * this.y;
          return (this.x = e * this.x - i * this.y), (this.y = r), this;
        },
        _rotateAround(t, e) {
          const i = Math.cos(t),
            r = Math.sin(t),
            n = e.y + r * (this.x - e.x) + i * (this.y - e.y);
          return (
            (this.x = e.x + i * (this.x - e.x) - r * (this.y - e.y)),
            (this.y = n),
            this
          );
        },
        _round() {
          return (
            (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this
          );
        },
        constructor: i,
      }),
      (i.convert = function (t) {
        if (t instanceof i) return t;
        if (Array.isArray(t)) return new i(+t[0], +t[1]);
        if (void 0 !== t.x && void 0 !== t.y) return new i(+t.x, +t.y);
        throw new Error('Expected [x, y] or {x, y} point format');
      });
    var s = (function () {
        if (a) return n;
        function t(t, e, i, r) {
          (this.cx = 3 * t),
            (this.bx = 3 * (i - t) - this.cx),
            (this.ax = 1 - this.cx - this.bx),
            (this.cy = 3 * e),
            (this.by = 3 * (r - e) - this.cy),
            (this.ay = 1 - this.cy - this.by),
            (this.p1x = t),
            (this.p1y = e),
            (this.p2x = i),
            (this.p2y = r);
        }
        return (
          (a = 1),
          (n = t),
          (t.prototype = {
            sampleCurveX: function (t) {
              return ((this.ax * t + this.bx) * t + this.cx) * t;
            },
            sampleCurveY: function (t) {
              return ((this.ay * t + this.by) * t + this.cy) * t;
            },
            sampleCurveDerivativeX: function (t) {
              return (3 * this.ax * t + 2 * this.bx) * t + this.cx;
            },
            solveCurveX: function (t, e) {
              if ((void 0 === e && (e = 1e-6), t < 0)) return 0;
              if (t > 1) return 1;
              for (var i = t, r = 0; r < 8; r++) {
                var n = this.sampleCurveX(i) - t;
                if (Math.abs(n) < e) return i;
                var a = this.sampleCurveDerivativeX(i);
                if (Math.abs(a) < 1e-6) break;
                i -= n / a;
              }
              var s = 0,
                o = 1;
              for (
                i = t, r = 0;
                r < 20 && ((n = this.sampleCurveX(i)), !(Math.abs(n - t) < e));
                r++
              )
                t > n ? (s = i) : (o = i), (i = 0.5 * (o - s) + s);
              return i;
            },
            solve: function (t, e) {
              return this.sampleCurveY(this.solveCurveX(t, e));
            },
          }),
          n
        );
      })(),
      o = r(s);
    let l, c;
    function h() {
      return (
        null == l &&
          (l =
            'undefined' != typeof OffscreenCanvas &&
            new OffscreenCanvas(1, 1).getContext('2d') &&
            'function' == typeof createImageBitmap),
        l
      );
    }
    function u() {
      if (null == c && ((c = !1), h())) {
        const t = 5,
          e = new OffscreenCanvas(t, t).getContext('2d', {
            willReadFrequently: !0,
          });
        if (e) {
          for (let r = 0; r < t * t; r++) {
            const i = 4 * r;
            (e.fillStyle = `rgb(${i},${i + 1},${i + 2})`),
              e.fillRect(r % t, Math.floor(r / t), 1, 1);
          }
          const i = e.getImageData(0, 0, t, t).data;
          for (let e = 0; e < t * t * 4; e++)
            if (e % 4 != 3 && i[e] !== e) {
              c = !0;
              break;
            }
        }
      }
      return c || !1;
    }
    var d = 1e-6,
      p = 'undefined' != typeof Float32Array ? Float32Array : Array;
    function f() {
      var t = new p(9);
      return (
        p != Float32Array &&
          ((t[1] = 0),
          (t[2] = 0),
          (t[3] = 0),
          (t[5] = 0),
          (t[6] = 0),
          (t[7] = 0)),
        (t[0] = 1),
        (t[4] = 1),
        (t[8] = 1),
        t
      );
    }
    function m(t) {
      return (
        (t[0] = 1),
        (t[1] = 0),
        (t[2] = 0),
        (t[3] = 0),
        (t[4] = 0),
        (t[5] = 1),
        (t[6] = 0),
        (t[7] = 0),
        (t[8] = 0),
        (t[9] = 0),
        (t[10] = 1),
        (t[11] = 0),
        (t[12] = 0),
        (t[13] = 0),
        (t[14] = 0),
        (t[15] = 1),
        t
      );
    }
    function g() {
      var t = new p(3);
      return p != Float32Array && ((t[0] = 0), (t[1] = 0), (t[2] = 0)), t;
    }
    function _(t) {
      var e = t[0],
        i = t[1],
        r = t[2];
      return Math.sqrt(e * e + i * i + r * r);
    }
    function y(t, e, i) {
      var r = new p(3);
      return (r[0] = t), (r[1] = e), (r[2] = i), r;
    }
    function v(t, e, i) {
      return (
        (t[0] = e[0] + i[0]), (t[1] = e[1] + i[1]), (t[2] = e[2] + i[2]), t
      );
    }
    function x(t, e, i) {
      return (t[0] = e[0] * i), (t[1] = e[1] * i), (t[2] = e[2] * i), t;
    }
    function b(t, e, i) {
      var r = e[0],
        n = e[1],
        a = e[2],
        s = i[0],
        o = i[1],
        l = i[2];
      return (
        (t[0] = n * l - a * o),
        (t[1] = a * s - r * l),
        (t[2] = r * o - n * s),
        t
      );
    }
    var w,
      T = _;
    function P(t, e, i) {
      var r = e[0],
        n = e[1],
        a = e[2],
        s = e[3];
      return (
        (t[0] = i[0] * r + i[4] * n + i[8] * a + i[12] * s),
        (t[1] = i[1] * r + i[5] * n + i[9] * a + i[13] * s),
        (t[2] = i[2] * r + i[6] * n + i[10] * a + i[14] * s),
        (t[3] = i[3] * r + i[7] * n + i[11] * a + i[15] * s),
        t
      );
    }
    function C() {
      var t = new p(4);
      return (
        p != Float32Array && ((t[0] = 0), (t[1] = 0), (t[2] = 0)), (t[3] = 1), t
      );
    }
    function I(t, e, i, r) {
      var n =
          arguments.length > 4 && void 0 !== arguments[4]
            ? arguments[4]
            : 'zyx',
        a = Math.PI / 360;
      (e *= a), (r *= a), (i *= a);
      var s = Math.sin(e),
        o = Math.cos(e),
        l = Math.sin(i),
        c = Math.cos(i),
        h = Math.sin(r),
        u = Math.cos(r);
      switch (n) {
        case 'xyz':
          (t[0] = s * c * u + o * l * h),
            (t[1] = o * l * u - s * c * h),
            (t[2] = o * c * h + s * l * u),
            (t[3] = o * c * u - s * l * h);
          break;
        case 'xzy':
          (t[0] = s * c * u - o * l * h),
            (t[1] = o * l * u - s * c * h),
            (t[2] = o * c * h + s * l * u),
            (t[3] = o * c * u + s * l * h);
          break;
        case 'yxz':
          (t[0] = s * c * u + o * l * h),
            (t[1] = o * l * u - s * c * h),
            (t[2] = o * c * h - s * l * u),
            (t[3] = o * c * u + s * l * h);
          break;
        case 'yzx':
          (t[0] = s * c * u + o * l * h),
            (t[1] = o * l * u + s * c * h),
            (t[2] = o * c * h - s * l * u),
            (t[3] = o * c * u - s * l * h);
          break;
        case 'zxy':
          (t[0] = s * c * u - o * l * h),
            (t[1] = o * l * u + s * c * h),
            (t[2] = o * c * h + s * l * u),
            (t[3] = o * c * u - s * l * h);
          break;
        case 'zyx':
          (t[0] = s * c * u - o * l * h),
            (t[1] = o * l * u + s * c * h),
            (t[2] = o * c * h - s * l * u),
            (t[3] = o * c * u + s * l * h);
          break;
        default:
          throw new Error('Unknown angle order ' + n);
      }
      return t;
    }
    function S() {
      var t = new p(2);
      return p != Float32Array && ((t[0] = 0), (t[1] = 0)), t;
    }
    function M(t, e) {
      var i = new p(2);
      return (i[0] = t), (i[1] = e), i;
    }
    g(),
      (w = new p(4)),
      p != Float32Array && ((w[0] = 0), (w[1] = 0), (w[2] = 0), (w[3] = 0)),
      g(),
      y(1, 0, 0),
      y(0, 1, 0),
      C(),
      C(),
      f(),
      S();
    const D = 8192;
    function L(t, e, i) {
      return e * (D / (t.tileSize * Math.pow(2, i - t.tileID.overscaledZ)));
    }
    function A(t, e) {
      return ((t % e) + e) % e;
    }
    function E(t, e, i) {
      return t * (1 - i) + e * i;
    }
    function R(t) {
      if (t <= 0) return 0;
      if (t >= 1) return 1;
      const e = t * t,
        i = e * t;
      return 4 * (t < 0.5 ? i : 3 * (t - e) + i - 0.75);
    }
    function z(t, e, i, r) {
      const n = new o(t, e, i, r);
      return (t) => n.solve(t);
    }
    const k = z(0.25, 0.1, 0.25, 1);
    function O(t, e, i) {
      return Math.min(i, Math.max(e, t));
    }
    function F(t, e, i) {
      const r = i - e,
        n = ((((t - e) % r) + r) % r) + e;
      return n === e ? i : n;
    }
    function B(t, ...e) {
      for (const i of e) for (const e in i) t[e] = i[e];
      return t;
    }
    let N = 1;
    function V(t, e, i) {
      const r = {};
      for (const n in t) r[n] = e.call(this, t[n], n, t);
      return r;
    }
    function j(t, e, i) {
      const r = {};
      for (const n in t) e.call(this, t[n], n, t) && (r[n] = t[n]);
      return r;
    }
    function U(t) {
      return Array.isArray(t)
        ? t.map(U)
        : 'object' == typeof t && t
        ? V(t, U)
        : t;
    }
    const G = {};
    function Z(t) {
      G[t] || ('undefined' != typeof console && console.warn(t), (G[t] = !0));
    }
    function $(t, e, i) {
      return (i.y - t.y) * (e.x - t.x) > (e.y - t.y) * (i.x - t.x);
    }
    function q(t) {
      return (
        'undefined' != typeof WorkerGlobalScope &&
        void 0 !== t &&
        t instanceof WorkerGlobalScope
      );
    }
    let H = null;
    function W(t) {
      if (null == H) {
        const e = t.navigator ? t.navigator.userAgent : null;
        H =
          !!t.safari ||
          !(
            !e ||
            !(
              /\b(iPad|iPhone|iPod)\b/.test(e) ||
              (e.match('Safari') && !e.match('Chrome'))
            )
          );
      }
      return H;
    }
    function X(t) {
      return 'undefined' != typeof ImageBitmap && t instanceof ImageBitmap;
    }
    const Y =
      'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=';
    function K(t, i, r, n, a) {
      return e(this, void 0, void 0, function* () {
        if ('undefined' == typeof VideoFrame)
          throw new Error('VideoFrame not supported');
        const e = new VideoFrame(t, { timestamp: 0 });
        try {
          const s = null == e ? void 0 : e.format;
          if (!s || (!s.startsWith('BGR') && !s.startsWith('RGB')))
            throw new Error(`Unrecognized format ${s}`);
          const o = s.startsWith('BGR'),
            l = new Uint8ClampedArray(n * a * 4);
          if (
            (yield e.copyTo(
              l,
              (function (t, e, i, r, n) {
                const a = 4 * Math.max(-e, 0),
                  s = (Math.max(0, i) - i) * r * 4 + a,
                  o = 4 * r,
                  l = Math.max(0, e),
                  c = Math.max(0, i);
                return {
                  rect: {
                    x: l,
                    y: c,
                    width: Math.min(t.width, e + r) - l,
                    height: Math.min(t.height, i + n) - c,
                  },
                  layout: [{ offset: s, stride: o }],
                };
              })(t, i, r, n, a)
            ),
            o)
          )
            for (let t = 0; t < l.length; t += 4) {
              const e = l[t];
              (l[t] = l[t + 2]), (l[t + 2] = e);
            }
          return l;
        } finally {
          e.close();
        }
      });
    }
    let J, Q;
    function tt(t, e, i, r) {
      return (
        t.addEventListener(e, i, r),
        {
          unsubscribe: () => {
            t.removeEventListener(e, i, r);
          },
        }
      );
    }
    function et(t) {
      return (t * Math.PI) / 180;
    }
    function it(t) {
      return (t / Math.PI) * 180;
    }
    const rt = {
        touchstart: !0,
        touchmove: !0,
        touchmoveWindow: !0,
        touchend: !0,
        touchcancel: !0,
      },
      nt = {
        dblclick: !0,
        click: !0,
        mouseover: !0,
        mouseout: !0,
        mousedown: !0,
        mousemove: !0,
        mousemoveWindow: !0,
        mouseup: !0,
        mouseupWindow: !0,
        contextmenu: !0,
        wheel: !0,
      },
      at = 'AbortError';
    function st() {
      return new Error(at);
    }
    const ot = {
      MAX_PARALLEL_IMAGE_REQUESTS: 16,
      MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME: 8,
      MAX_TILE_CACHE_ZOOM_LEVELS: 5,
      REGISTERED_PROTOCOLS: {},
      WORKER_URL: '',
    };
    function lt(t) {
      return ot.REGISTERED_PROTOCOLS[t.substring(0, t.indexOf('://'))];
    }
    const ct = 'global-dispatcher';
    class ht extends Error {
      constructor(t, e, i, r) {
        super(`AJAXError: ${e} (${t}): ${i}`),
          (this.status = t),
          (this.statusText = e),
          (this.url = i),
          (this.body = r);
      }
    }
    const ut = () =>
        q(self)
          ? self.worker && self.worker.referrer
          : ('blob:' === window.location.protocol ? window.parent : window)
              .location.href,
      dt = function (t, i) {
        if (/:\/\//.test(t.url) && !/^https?:|^file:/.test(t.url)) {
          const e = lt(t.url);
          if (e) return e(t, i);
          if (q(self) && self.worker && self.worker.actor)
            return self.worker.actor.sendAsync(
              { type: 'GR', data: t, targetMapId: ct },
              i
            );
        }
        if (
          !(
            /^file:/.test((r = t.url)) ||
            (/^file:/.test(ut()) && !/^\w+:/.test(r))
          )
        ) {
          if (
            fetch &&
            Request &&
            AbortController &&
            Object.prototype.hasOwnProperty.call(Request.prototype, 'signal')
          )
            return (function (t, i) {
              return e(this, void 0, void 0, function* () {
                const e = new Request(t.url, {
                  method: t.method || 'GET',
                  body: t.body,
                  credentials: t.credentials,
                  headers: t.headers,
                  cache: t.cache,
                  referrer: ut(),
                  signal: i.signal,
                });
                let r, n;
                'json' !== t.type ||
                  e.headers.has('Accept') ||
                  e.headers.set('Accept', 'application/json');
                try {
                  r = yield fetch(e);
                } catch (e) {
                  throw new ht(0, e.message, t.url, new Blob());
                }
                if (!r.ok) {
                  const e = yield r.blob();
                  throw new ht(r.status, r.statusText, t.url, e);
                }
                n =
                  'arrayBuffer' === t.type || 'image' === t.type
                    ? r.arrayBuffer()
                    : 'json' === t.type
                    ? r.json()
                    : r.text();
                const a = yield n;
                if (i.signal.aborted) throw st();
                return {
                  data: a,
                  cacheControl: r.headers.get('Cache-Control'),
                  expires: r.headers.get('Expires'),
                };
              });
            })(t, i);
          if (q(self) && self.worker && self.worker.actor)
            return self.worker.actor.sendAsync(
              { type: 'GR', data: t, mustQueue: !0, targetMapId: ct },
              i
            );
        }
        var r;
        return (function (t, e) {
          return new Promise((i, r) => {
            var n;
            const a = new XMLHttpRequest();
            a.open(t.method || 'GET', t.url, !0),
              ('arrayBuffer' !== t.type && 'image' !== t.type) ||
                (a.responseType = 'arraybuffer');
            for (const e in t.headers) a.setRequestHeader(e, t.headers[e]);
            'json' === t.type &&
              ((a.responseType = 'text'),
              (null === (n = t.headers) || void 0 === n ? void 0 : n.Accept) ||
                a.setRequestHeader('Accept', 'application/json')),
              (a.withCredentials = 'include' === t.credentials),
              (a.onerror = () => {
                r(new Error(a.statusText));
              }),
              (a.onload = () => {
                if (!e.signal.aborted)
                  if (
                    ((a.status >= 200 && a.status < 300) || 0 === a.status) &&
                    null !== a.response
                  ) {
                    let e = a.response;
                    if ('json' === t.type)
                      try {
                        e = JSON.parse(a.response);
                      } catch (t) {
                        return void r(t);
                      }
                    i({
                      data: e,
                      cacheControl: a.getResponseHeader('Cache-Control'),
                      expires: a.getResponseHeader('Expires'),
                    });
                  } else {
                    const e = new Blob([a.response], {
                      type: a.getResponseHeader('Content-Type'),
                    });
                    r(new ht(a.status, a.statusText, t.url, e));
                  }
              }),
              e.signal.addEventListener('abort', () => {
                a.abort(), r(st());
              }),
              a.send(t.body);
          });
        })(t, i);
      };
    function pt(t) {
      if (
        !t ||
        t.indexOf('://') <= 0 ||
        0 === t.indexOf('data:image/') ||
        0 === t.indexOf('blob:')
      )
        return !0;
      const e = new URL(t),
        i = window.location;
      return e.protocol === i.protocol && e.host === i.host;
    }
    function ft(t, e, i) {
      (i[t] && -1 !== i[t].indexOf(e)) || ((i[t] = i[t] || []), i[t].push(e));
    }
    function mt(t, e, i) {
      if (i && i[t]) {
        const r = i[t].indexOf(e);
        -1 !== r && i[t].splice(r, 1);
      }
    }
    class gt {
      constructor(t, e = {}) {
        B(this, e), (this.type = t);
      }
    }
    class _t extends gt {
      constructor(t, e = {}) {
        super('error', B({ error: t }, e));
      }
    }
    class yt {
      on(t, e) {
        return (
          (this._listeners = this._listeners || {}),
          ft(t, e, this._listeners),
          {
            unsubscribe: () => {
              this.off(t, e);
            },
          }
        );
      }
      off(t, e) {
        return (
          mt(t, e, this._listeners), mt(t, e, this._oneTimeListeners), this
        );
      }
      once(t, e) {
        return e
          ? ((this._oneTimeListeners = this._oneTimeListeners || {}),
            ft(t, e, this._oneTimeListeners),
            this)
          : new Promise((e) => this.once(t, e));
      }
      fire(t, e) {
        'string' == typeof t && (t = new gt(t, e || {}));
        const i = t.type;
        if (this.listens(i)) {
          t.target = this;
          const e =
            this._listeners && this._listeners[i]
              ? this._listeners[i].slice()
              : [];
          for (const i of e) i.call(this, t);
          const r =
            this._oneTimeListeners && this._oneTimeListeners[i]
              ? this._oneTimeListeners[i].slice()
              : [];
          for (const a of r) mt(i, a, this._oneTimeListeners), a.call(this, t);
          const n = this._eventedParent;
          n &&
            (B(
              t,
              'function' == typeof this._eventedParentData
                ? this._eventedParentData()
                : this._eventedParentData
            ),
            n.fire(t));
        } else t instanceof _t && console.error(t.error);
        return this;
      }
      listens(t) {
        return (
          (this._listeners &&
            this._listeners[t] &&
            this._listeners[t].length > 0) ||
          (this._oneTimeListeners &&
            this._oneTimeListeners[t] &&
            this._oneTimeListeners[t].length > 0) ||
          (this._eventedParent && this._eventedParent.listens(t))
        );
      }
      setEventedParent(t, e) {
        return (this._eventedParent = t), (this._eventedParentData = e), this;
      }
    }
    var vt = {
      '$version': 8,
      '$root': {
        'version': { required: !0, type: 'enum', values: [8] },
        'name': { type: 'string' },
        'metadata': { type: '*' },
        'center': { type: 'array', value: 'number' },
        'centerAltitude': { type: 'number' },
        'zoom': { type: 'number' },
        'bearing': {
          type: 'number',
          default: 0,
          period: 360,
          units: 'degrees',
        },
        'pitch': { type: 'number', default: 0, units: 'degrees' },
        'roll': { type: 'number', default: 0, units: 'degrees' },
        'state': { type: 'state', default: {} },
        'light': { type: 'light' },
        'sky': { type: 'sky' },
        'projection': { type: 'projection' },
        'terrain': { type: 'terrain' },
        'sources': { required: !0, type: 'sources' },
        'sprite': { type: 'sprite' },
        'glyphs': { type: 'string' },
        'font-faces': { type: 'array', value: 'fontFaces' },
        'transition': { type: 'transition' },
        'layers': { required: !0, type: 'array', value: 'layer' },
      },
      'sources': { '*': { type: 'source' } },
      'source': [
        'source_vector',
        'source_raster',
        'source_raster_dem',
        'source_geojson',
        'source_video',
        'source_image',
      ],
      'source_vector': {
        'type': { required: !0, type: 'enum', values: { vector: {} } },
        'url': { type: 'string' },
        'tiles': { type: 'array', value: 'string' },
        'bounds': {
          type: 'array',
          value: 'number',
          length: 4,
          default: [-180, -85.051129, 180, 85.051129],
        },
        'scheme': {
          type: 'enum',
          values: { xyz: {}, tms: {} },
          default: 'xyz',
        },
        'minzoom': { type: 'number', default: 0 },
        'maxzoom': { type: 'number', default: 22 },
        'attribution': { type: 'string' },
        'promoteId': { type: 'promoteId' },
        'volatile': { type: 'boolean', default: !1 },
        'encoding': {
          type: 'enum',
          values: { mvt: {}, mlt: {} },
          default: 'mvt',
        },
        '*': { type: '*' },
      },
      'source_raster': {
        'type': { required: !0, type: 'enum', values: { raster: {} } },
        'url': { type: 'string' },
        'tiles': { type: 'array', value: 'string' },
        'bounds': {
          type: 'array',
          value: 'number',
          length: 4,
          default: [-180, -85.051129, 180, 85.051129],
        },
        'minzoom': { type: 'number', default: 0 },
        'maxzoom': { type: 'number', default: 22 },
        'tileSize': { type: 'number', default: 512, units: 'pixels' },
        'scheme': {
          type: 'enum',
          values: { xyz: {}, tms: {} },
          default: 'xyz',
        },
        'attribution': { type: 'string' },
        'volatile': { type: 'boolean', default: !1 },
        '*': { type: '*' },
      },
      'source_raster_dem': {
        'type': { required: !0, type: 'enum', values: { 'raster-dem': {} } },
        'url': { type: 'string' },
        'tiles': { type: 'array', value: 'string' },
        'bounds': {
          type: 'array',
          value: 'number',
          length: 4,
          default: [-180, -85.051129, 180, 85.051129],
        },
        'minzoom': { type: 'number', default: 0 },
        'maxzoom': { type: 'number', default: 22 },
        'tileSize': { type: 'number', default: 512, units: 'pixels' },
        'attribution': { type: 'string' },
        'encoding': {
          type: 'enum',
          values: { terrarium: {}, mapbox: {}, custom: {} },
          default: 'mapbox',
        },
        'redFactor': { type: 'number', default: 1 },
        'blueFactor': { type: 'number', default: 1 },
        'greenFactor': { type: 'number', default: 1 },
        'baseShift': { type: 'number', default: 0 },
        'volatile': { type: 'boolean', default: !1 },
        '*': { type: '*' },
      },
      'source_geojson': {
        type: { required: !0, type: 'enum', values: { geojson: {} } },
        data: { required: !0, type: '*' },
        maxzoom: { type: 'number', default: 18 },
        attribution: { type: 'string' },
        buffer: { type: 'number', default: 128, maximum: 512, minimum: 0 },
        filter: { type: '*' },
        tolerance: { type: 'number', default: 0.375 },
        cluster: { type: 'boolean', default: !1 },
        clusterRadius: { type: 'number', default: 50, minimum: 0 },
        clusterMaxZoom: { type: 'number' },
        clusterMinPoints: { type: 'number' },
        clusterProperties: { type: '*' },
        lineMetrics: { type: 'boolean', default: !1 },
        generateId: { type: 'boolean', default: !1 },
        promoteId: { type: 'promoteId' },
      },
      'source_video': {
        type: { required: !0, type: 'enum', values: { video: {} } },
        urls: { required: !0, type: 'array', value: 'string' },
        coordinates: {
          required: !0,
          type: 'array',
          length: 4,
          value: { type: 'array', length: 2, value: 'number' },
        },
      },
      'source_image': {
        type: { required: !0, type: 'enum', values: { image: {} } },
        url: { required: !0, type: 'string' },
        coordinates: {
          required: !0,
          type: 'array',
          length: 4,
          value: { type: 'array', length: 2, value: 'number' },
        },
      },
      'layer': {
        'id': { type: 'string', required: !0 },
        'type': {
          type: 'enum',
          values: {
            'fill': {},
            'line': {},
            'symbol': {},
            'circle': {},
            'heatmap': {},
            'fill-extrusion': {},
            'raster': {},
            'hillshade': {},
            'color-relief': {},
            'background': {},
          },
          required: !0,
        },
        'metadata': { type: '*' },
        'source': { type: 'string' },
        'source-layer': { type: 'string' },
        'minzoom': { type: 'number', minimum: 0, maximum: 24 },
        'maxzoom': { type: 'number', minimum: 0, maximum: 24 },
        'filter': { type: 'filter' },
        'layout': { type: 'layout' },
        'paint': { type: 'paint' },
      },
      'layout': [
        'layout_fill',
        'layout_line',
        'layout_circle',
        'layout_heatmap',
        'layout_fill-extrusion',
        'layout_symbol',
        'layout_raster',
        'layout_hillshade',
        'layout_color-relief',
        'layout_background',
      ],
      'layout_background': {
        visibility: {
          'type': 'enum',
          'values': { visible: {}, none: {} },
          'default': 'visible',
          'property-type': 'constant',
        },
      },
      'layout_fill': {
        'fill-sort-key': {
          'type': 'number',
          'expression': { interpolated: !1, parameters: ['zoom', 'feature'] },
          'property-type': 'data-driven',
        },
        'visibility': {
          'type': 'enum',
          'values': { visible: {}, none: {} },
          'default': 'visible',
          'property-type': 'constant',
        },
      },
      'layout_circle': {
        'circle-sort-key': {
          'type': 'number',
          'expression': { interpolated: !1, parameters: ['zoom', 'feature'] },
          'property-type': 'data-driven',
        },
        'visibility': {
          'type': 'enum',
          'values': { visible: {}, none: {} },
          'default': 'visible',
          'property-type': 'constant',
        },
      },
      'layout_heatmap': {
        visibility: {
          'type': 'enum',
          'values': { visible: {}, none: {} },
          'default': 'visible',
          'property-type': 'constant',
        },
      },
      'layout_fill-extrusion': {
        visibility: {
          'type': 'enum',
          'values': { visible: {}, none: {} },
          'default': 'visible',
          'property-type': 'constant',
        },
      },
      'layout_line': {
        'line-cap': {
          'type': 'enum',
          'values': { butt: {}, round: {}, square: {} },
          'default': 'butt',
          'expression': { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'line-join': {
          'type': 'enum',
          'values': { bevel: {}, round: {}, miter: {} },
          'default': 'miter',
          'expression': { interpolated: !1, parameters: ['zoom', 'feature'] },
          'property-type': 'data-driven',
        },
        'line-miter-limit': {
          'type': 'number',
          'default': 2,
          'requires': [{ 'line-join': 'miter' }],
          'expression': { interpolated: !0, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'line-round-limit': {
          'type': 'number',
          'default': 1.05,
          'requires': [{ 'line-join': 'round' }],
          'expression': { interpolated: !0, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'line-sort-key': {
          'type': 'number',
          'expression': { interpolated: !1, parameters: ['zoom', 'feature'] },
          'property-type': 'data-driven',
        },
        'visibility': {
          'type': 'enum',
          'values': { visible: {}, none: {} },
          'default': 'visible',
          'property-type': 'constant',
        },
      },
      'layout_symbol': {
        'symbol-placement': {
          'type': 'enum',
          'values': { 'point': {}, 'line': {}, 'line-center': {} },
          'default': 'point',
          'expression': { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'symbol-spacing': {
          'type': 'number',
          'default': 250,
          'minimum': 1,
          'units': 'pixels',
          'requires': [{ 'symbol-placement': 'line' }],
          'expression': { interpolated: !0, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'symbol-avoid-edges': {
          'type': 'boolean',
          'default': !1,
          'expression': { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'symbol-sort-key': {
          'type': 'number',
          'expression': { interpolated: !1, parameters: ['zoom', 'feature'] },
          'property-type': 'data-driven',
        },
        'symbol-z-order': {
          'type': 'enum',
          'values': { 'auto': {}, 'viewport-y': {}, 'source': {} },
          'default': 'auto',
          'expression': { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'icon-allow-overlap': {
          'type': 'boolean',
          'default': !1,
          'requires': ['icon-image', { '!': 'icon-overlap' }],
          'expression': { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'icon-overlap': {
          'type': 'enum',
          'values': { never: {}, always: {}, cooperative: {} },
          'requires': ['icon-image'],
          'expression': { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'icon-ignore-placement': {
          'type': 'boolean',
          'default': !1,
          'requires': ['icon-image'],
          'expression': { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'icon-optional': {
          'type': 'boolean',
          'default': !1,
          'requires': ['icon-image', 'text-field'],
          'expression': { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'icon-rotation-alignment': {
          'type': 'enum',
          'values': { map: {}, viewport: {}, auto: {} },
          'default': 'auto',
          'requires': ['icon-image'],
          'expression': { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'icon-size': {
          'type': 'number',
          'default': 1,
          'minimum': 0,
          'units': 'factor of the original icon size',
          'requires': ['icon-image'],
          'expression': { interpolated: !0, parameters: ['zoom', 'feature'] },
          'property-type': 'data-driven',
        },
        'icon-text-fit': {
          'type': 'enum',
          'values': { none: {}, width: {}, height: {}, both: {} },
          'default': 'none',
          'requires': ['icon-image', 'text-field'],
          'expression': { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'icon-text-fit-padding': {
          'type': 'array',
          'value': 'number',
          'length': 4,
          'default': [0, 0, 0, 0],
          'units': 'pixels',
          'requires': [
            'icon-image',
            'text-field',
            { 'icon-text-fit': ['both', 'width', 'height'] },
          ],
          'expression': { interpolated: !0, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'icon-image': {
          'type': 'resolvedImage',
          'tokens': !0,
          'expression': { interpolated: !1, parameters: ['zoom', 'feature'] },
          'property-type': 'data-driven',
        },
        'icon-rotate': {
          'type': 'number',
          'default': 0,
          'period': 360,
          'units': 'degrees',
          'requires': ['icon-image'],
          'expression': { interpolated: !0, parameters: ['zoom', 'feature'] },
          'property-type': 'data-driven',
        },
        'icon-padding': {
          'type': 'padding',
          'default': [2],
          'units': 'pixels',
          'requires': ['icon-image'],
          'expression': { interpolated: !0, parameters: ['zoom', 'feature'] },
          'property-type': 'data-driven',
        },
        'icon-keep-upright': {
          'type': 'boolean',
          'default': !1,
          'requires': [
            'icon-image',
            { 'icon-rotation-alignment': 'map' },
            { 'symbol-placement': ['line', 'line-center'] },
          ],
          'expression': { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'icon-offset': {
          'type': 'array',
          'value': 'number',
          'length': 2,
          'default': [0, 0],
          'requires': ['icon-image'],
          'expression': { interpolated: !0, parameters: ['zoom', 'feature'] },
          'property-type': 'data-driven',
        },
        'icon-anchor': {
          'type': 'enum',
          'values': {
            'center': {},
            'left': {},
            'right': {},
            'top': {},
            'bottom': {},
            'top-left': {},
            'top-right': {},
            'bottom-left': {},
            'bottom-right': {},
          },
          'default': 'center',
          'requires': ['icon-image'],
          'expression': { interpolated: !1, parameters: ['zoom', 'feature'] },
          'property-type': 'data-driven',
        },
        'icon-pitch-alignment': {
          'type': 'enum',
          'values': { map: {}, viewport: {}, auto: {} },
          'default': 'auto',
          'requires': ['icon-image'],
          'expression': { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'text-pitch-alignment': {
          'type': 'enum',
          'values': { map: {}, viewport: {}, auto: {} },
          'default': 'auto',
          'requires': ['text-field'],
          'expression': { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'text-rotation-alignment': {
          'type': 'enum',
          'values': {
            'map': {},
            'viewport': {},
            'viewport-glyph': {},
            'auto': {},
          },
          'default': 'auto',
          'requires': ['text-field'],
          'expression': { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'text-field': {
          'type': 'formatted',
          'default': '',
          'tokens': !0,
          'expression': { interpolated: !1, parameters: ['zoom', 'feature'] },
          'property-type': 'data-driven',
        },
        'text-font': {
          'type': 'array',
          'value': 'string',
          'default': ['Open Sans Regular', 'Arial Unicode MS Regular'],
          'requires': ['text-field'],
          'expression': { interpolated: !1, parameters: ['zoom', 'feature'] },
          'property-type': 'data-driven',
        },
        'text-size': {
          'type': 'number',
          'default': 16,
          'minimum': 0,
          'units': 'pixels',
          'requires': ['text-field'],
          'expression': { interpolated: !0, parameters: ['zoom', 'feature'] },
          'property-type': 'data-driven',
        },
        'text-max-width': {
          'type': 'number',
          'default': 10,
          'minimum': 0,
          'units': 'ems',
          'requires': ['text-field'],
          'expression': { interpolated: !0, parameters: ['zoom', 'feature'] },
          'property-type': 'data-driven',
        },
        'text-line-height': {
          'type': 'number',
          'default': 1.2,
          'units': 'ems',
          'requires': ['text-field'],
          'expression': { interpolated: !0, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'text-letter-spacing': {
          'type': 'number',
          'default': 0,
          'units': 'ems',
          'requires': ['text-field'],
          'expression': { interpolated: !0, parameters: ['zoom', 'feature'] },
          'property-type': 'data-driven',
        },
        'text-justify': {
          'type': 'enum',
          'values': { auto: {}, left: {}, center: {}, right: {} },
          'default': 'center',
          'requires': ['text-field'],
          'expression': { interpolated: !1, parameters: ['zoom', 'feature'] },
          'property-type': 'data-driven',
        },
        'text-radial-offset': {
          'type': 'number',
          'units': 'ems',
          'default': 0,
          'requires': ['text-field'],
          'property-type': 'data-driven',
          'expression': { interpolated: !0, parameters: ['zoom', 'feature'] },
        },
        'text-variable-anchor': {
          'type': 'array',
          'value': 'enum',
          'values': {
            'center': {},
            'left': {},
            'right': {},
            'top': {},
            'bottom': {},
            'top-left': {},
            'top-right': {},
            'bottom-left': {},
            'bottom-right': {},
          },
          'requires': ['text-field', { 'symbol-placement': ['point'] }],
          'expression': { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'text-variable-anchor-offset': {
          'type': 'variableAnchorOffsetCollection',
          'requires': ['text-field', { 'symbol-placement': ['point'] }],
          'expression': { interpolated: !0, parameters: ['zoom', 'feature'] },
          'property-type': 'data-driven',
        },
        'text-anchor': {
          'type': 'enum',
          'values': {
            'center': {},
            'left': {},
            'right': {},
            'top': {},
            'bottom': {},
            'top-left': {},
            'top-right': {},
            'bottom-left': {},
            'bottom-right': {},
          },
          'default': 'center',
          'requires': ['text-field', { '!': 'text-variable-anchor' }],
          'expression': { interpolated: !1, parameters: ['zoom', 'feature'] },
          'property-type': 'data-driven',
        },
        'text-max-angle': {
          'type': 'number',
          'default': 45,
          'units': 'degrees',
          'requires': [
            'text-field',
            { 'symbol-placement': ['line', 'line-center'] },
          ],
          'expression': { interpolated: !0, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'text-writing-mode': {
          'type': 'array',
          'value': 'enum',
          'values': { horizontal: {}, vertical: {} },
          'requires': ['text-field', { 'symbol-placement': ['point'] }],
          'expression': { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'text-rotate': {
          'type': 'number',
          'default': 0,
          'period': 360,
          'units': 'degrees',
          'requires': ['text-field'],
          'expression': { interpolated: !0, parameters: ['zoom', 'feature'] },
          'property-type': 'data-driven',
        },
        'text-padding': {
          'type': 'number',
          'default': 2,
          'minimum': 0,
          'units': 'pixels',
          'requires': ['text-field'],
          'expression': { interpolated: !0, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'text-keep-upright': {
          'type': 'boolean',
          'default': !0,
          'requires': [
            'text-field',
            { 'text-rotation-alignment': 'map' },
            { 'symbol-placement': ['line', 'line-center'] },
          ],
          'expression': { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'text-transform': {
          'type': 'enum',
          'values': { none: {}, uppercase: {}, lowercase: {} },
          'default': 'none',
          'requires': ['text-field'],
          'expression': { interpolated: !1, parameters: ['zoom', 'feature'] },
          'property-type': 'data-driven',
        },
        'text-offset': {
          'type': 'array',
          'value': 'number',
          'units': 'ems',
          'length': 2,
          'default': [0, 0],
          'requires': ['text-field', { '!': 'text-radial-offset' }],
          'expression': { interpolated: !0, parameters: ['zoom', 'feature'] },
          'property-type': 'data-driven',
        },
        'text-allow-overlap': {
          'type': 'boolean',
          'default': !1,
          'requires': ['text-field', { '!': 'text-overlap' }],
          'expression': { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'text-overlap': {
          'type': 'enum',
          'values': { never: {}, always: {}, cooperative: {} },
          'requires': ['text-field'],
          'expression': { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'text-ignore-placement': {
          'type': 'boolean',
          'default': !1,
          'requires': ['text-field'],
          'expression': { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'text-optional': {
          'type': 'boolean',
          'default': !1,
          'requires': ['text-field', 'icon-image'],
          'expression': { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'visibility': {
          'type': 'enum',
          'values': { visible: {}, none: {} },
          'default': 'visible',
          'property-type': 'constant',
        },
      },
      'layout_raster': {
        visibility: {
          'type': 'enum',
          'values': { visible: {}, none: {} },
          'default': 'visible',
          'property-type': 'constant',
        },
      },
      'layout_hillshade': {
        visibility: {
          'type': 'enum',
          'values': { visible: {}, none: {} },
          'default': 'visible',
          'property-type': 'constant',
        },
      },
      'layout_color-relief': {
        visibility: {
          'type': 'enum',
          'values': { visible: {}, none: {} },
          'default': 'visible',
          'property-type': 'constant',
        },
      },
      'filter': { type: 'array', value: '*' },
      'filter_operator': {
        type: 'enum',
        values: {
          '==': {},
          '!=': {},
          '>': {},
          '>=': {},
          '<': {},
          '<=': {},
          'in': {},
          '!in': {},
          'all': {},
          'any': {},
          'none': {},
          'has': {},
          '!has': {},
        },
      },
      'geometry_type': {
        type: 'enum',
        values: { Point: {}, LineString: {}, Polygon: {} },
      },
      'function': {
        expression: { type: 'expression' },
        stops: { type: 'array', value: 'function_stop' },
        base: { type: 'number', default: 1, minimum: 0 },
        property: { type: 'string', default: '$zoom' },
        type: {
          type: 'enum',
          values: {
            identity: {},
            exponential: {},
            interval: {},
            categorical: {},
          },
          default: 'exponential',
        },
        colorSpace: {
          type: 'enum',
          values: { rgb: {}, lab: {}, hcl: {} },
          default: 'rgb',
        },
        default: { type: '*', required: !1 },
      },
      'function_stop': {
        type: 'array',
        minimum: 0,
        maximum: 24,
        value: ['number', 'color'],
        length: 2,
      },
      'expression': { type: 'array', value: '*', minimum: 1 },
      'light': {
        anchor: {
          'type': 'enum',
          'default': 'viewport',
          'values': { map: {}, viewport: {} },
          'property-type': 'data-constant',
          'transition': !1,
          'expression': { interpolated: !1, parameters: ['zoom'] },
        },
        position: {
          'type': 'array',
          'default': [1.15, 210, 30],
          'length': 3,
          'value': 'number',
          'property-type': 'data-constant',
          'transition': !0,
          'expression': { interpolated: !0, parameters: ['zoom'] },
        },
        color: {
          'type': 'color',
          'property-type': 'data-constant',
          'default': '#ffffff',
          'expression': { interpolated: !0, parameters: ['zoom'] },
          'transition': !0,
        },
        intensity: {
          'type': 'number',
          'property-type': 'data-constant',
          'default': 0.5,
          'minimum': 0,
          'maximum': 1,
          'expression': { interpolated: !0, parameters: ['zoom'] },
          'transition': !0,
        },
      },
      'sky': {
        'sky-color': {
          'type': 'color',
          'property-type': 'data-constant',
          'default': '#88C6FC',
          'expression': { interpolated: !0, parameters: ['zoom'] },
          'transition': !0,
        },
        'horizon-color': {
          'type': 'color',
          'property-type': 'data-constant',
          'default': '#ffffff',
          'expression': { interpolated: !0, parameters: ['zoom'] },
          'transition': !0,
        },
        'fog-color': {
          'type': 'color',
          'property-type': 'data-constant',
          'default': '#ffffff',
          'expression': { interpolated: !0, parameters: ['zoom'] },
          'transition': !0,
        },
        'fog-ground-blend': {
          'type': 'number',
          'property-type': 'data-constant',
          'default': 0.5,
          'minimum': 0,
          'maximum': 1,
          'expression': { interpolated: !0, parameters: ['zoom'] },
          'transition': !0,
        },
        'horizon-fog-blend': {
          'type': 'number',
          'property-type': 'data-constant',
          'default': 0.8,
          'minimum': 0,
          'maximum': 1,
          'expression': { interpolated: !0, parameters: ['zoom'] },
          'transition': !0,
        },
        'sky-horizon-blend': {
          'type': 'number',
          'property-type': 'data-constant',
          'default': 0.8,
          'minimum': 0,
          'maximum': 1,
          'expression': { interpolated: !0, parameters: ['zoom'] },
          'transition': !0,
        },
        'atmosphere-blend': {
          'type': 'number',
          'property-type': 'data-constant',
          'default': 0.8,
          'minimum': 0,
          'maximum': 1,
          'expression': { interpolated: !0, parameters: ['zoom'] },
          'transition': !0,
        },
      },
      'terrain': {
        source: { type: 'string', required: !0 },
        exaggeration: { type: 'number', minimum: 0, default: 1 },
      },
      'projection': {
        type: {
          'type': 'projectionDefinition',
          'default': 'mercator',
          'property-type': 'data-constant',
          'transition': !1,
          'expression': { interpolated: !0, parameters: ['zoom'] },
        },
      },
      'paint': [
        'paint_fill',
        'paint_line',
        'paint_circle',
        'paint_heatmap',
        'paint_fill-extrusion',
        'paint_symbol',
        'paint_raster',
        'paint_hillshade',
        'paint_color-relief',
        'paint_background',
      ],
      'paint_fill': {
        'fill-antialias': {
          'type': 'boolean',
          'default': !0,
          'expression': { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'fill-opacity': {
          'type': 'number',
          'default': 1,
          'minimum': 0,
          'maximum': 1,
          'transition': !0,
          'expression': {
            interpolated: !0,
            parameters: ['zoom', 'feature', 'feature-state'],
          },
          'property-type': 'data-driven',
        },
        'fill-color': {
          'type': 'color',
          'default': '#000000',
          'transition': !0,
          'requires': [{ '!': 'fill-pattern' }],
          'expression': {
            interpolated: !0,
            parameters: ['zoom', 'feature', 'feature-state'],
          },
          'property-type': 'data-driven',
        },
        'fill-outline-color': {
          'type': 'color',
          'transition': !0,
          'requires': [{ '!': 'fill-pattern' }, { 'fill-antialias': !0 }],
          'expression': {
            interpolated: !0,
            parameters: ['zoom', 'feature', 'feature-state'],
          },
          'property-type': 'data-driven',
        },
        'fill-translate': {
          'type': 'array',
          'value': 'number',
          'length': 2,
          'default': [0, 0],
          'transition': !0,
          'units': 'pixels',
          'expression': { interpolated: !0, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'fill-translate-anchor': {
          'type': 'enum',
          'values': { map: {}, viewport: {} },
          'default': 'map',
          'requires': ['fill-translate'],
          'expression': { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'fill-pattern': {
          'type': 'resolvedImage',
          'transition': !0,
          'expression': { interpolated: !1, parameters: ['zoom', 'feature'] },
          'property-type': 'cross-faded-data-driven',
        },
      },
      'paint_fill-extrusion': {
        'fill-extrusion-opacity': {
          'type': 'number',
          'default': 1,
          'minimum': 0,
          'maximum': 1,
          'transition': !0,
          'expression': { interpolated: !0, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'fill-extrusion-color': {
          'type': 'color',
          'default': '#000000',
          'transition': !0,
          'requires': [{ '!': 'fill-extrusion-pattern' }],
          'expression': {
            interpolated: !0,
            parameters: ['zoom', 'feature', 'feature-state'],
          },
          'property-type': 'data-driven',
        },
        'fill-extrusion-translate': {
          'type': 'array',
          'value': 'number',
          'length': 2,
          'default': [0, 0],
          'transition': !0,
          'units': 'pixels',
          'expression': { interpolated: !0, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'fill-extrusion-translate-anchor': {
          'type': 'enum',
          'values': { map: {}, viewport: {} },
          'default': 'map',
          'requires': ['fill-extrusion-translate'],
          'expression': { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'fill-extrusion-pattern': {
          'type': 'resolvedImage',
          'transition': !0,
          'expression': { interpolated: !1, parameters: ['zoom', 'feature'] },
          'property-type': 'cross-faded-data-driven',
        },
        'fill-extrusion-height': {
          'type': 'number',
          'default': 0,
          'minimum': 0,
          'units': 'meters',
          'transition': !0,
          'expression': {
            interpolated: !0,
            parameters: ['zoom', 'feature', 'feature-state'],
          },
          'property-type': 'data-driven',
        },
        'fill-extrusion-base': {
          'type': 'number',
          'default': 0,
          'minimum': 0,
          'units': 'meters',
          'transition': !0,
          'requires': ['fill-extrusion-height'],
          'expression': {
            interpolated: !0,
            parameters: ['zoom', 'feature', 'feature-state'],
          },
          'property-type': 'data-driven',
        },
        'fill-extrusion-vertical-gradient': {
          'type': 'boolean',
          'default': !0,
          'transition': !1,
          'expression': { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
      },
      'paint_line': {
        'line-opacity': {
          'type': 'number',
          'default': 1,
          'minimum': 0,
          'maximum': 1,
          'transition': !0,
          'expression': {
            interpolated: !0,
            parameters: ['zoom', 'feature', 'feature-state'],
          },
          'property-type': 'data-driven',
        },
        'line-color': {
          'type': 'color',
          'default': '#000000',
          'transition': !0,
          'requires': [{ '!': 'line-pattern' }],
          'expression': {
            interpolated: !0,
            parameters: ['zoom', 'feature', 'feature-state'],
          },
          'property-type': 'data-driven',
        },
        'line-translate': {
          'type': 'array',
          'value': 'number',
          'length': 2,
          'default': [0, 0],
          'transition': !0,
          'units': 'pixels',
          'expression': { interpolated: !0, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'line-translate-anchor': {
          'type': 'enum',
          'values': { map: {}, viewport: {} },
          'default': 'map',
          'requires': ['line-translate'],
          'expression': { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'line-width': {
          'type': 'number',
          'default': 1,
          'minimum': 0,
          'transition': !0,
          'units': 'pixels',
          'expression': {
            interpolated: !0,
            parameters: ['zoom', 'feature', 'feature-state'],
          },
          'property-type': 'data-driven',
        },
        'line-gap-width': {
          'type': 'number',
          'default': 0,
          'minimum': 0,
          'transition': !0,
          'units': 'pixels',
          'expression': {
            interpolated: !0,
            parameters: ['zoom', 'feature', 'feature-state'],
          },
          'property-type': 'data-driven',
        },
        'line-offset': {
          'type': 'number',
          'default': 0,
          'transition': !0,
          'units': 'pixels',
          'expression': {
            interpolated: !0,
            parameters: ['zoom', 'feature', 'feature-state'],
          },
          'property-type': 'data-driven',
        },
        'line-blur': {
          'type': 'number',
          'default': 0,
          'minimum': 0,
          'transition': !0,
          'units': 'pixels',
          'expression': {
            interpolated: !0,
            parameters: ['zoom', 'feature', 'feature-state'],
          },
          'property-type': 'data-driven',
        },
        'line-dasharray': {
          'type': 'array',
          'value': 'number',
          'minimum': 0,
          'transition': !0,
          'units': 'line widths',
          'requires': [{ '!': 'line-pattern' }],
          'expression': { interpolated: !1, parameters: ['zoom', 'feature'] },
          'property-type': 'cross-faded-data-driven',
        },
        'line-pattern': {
          'type': 'resolvedImage',
          'transition': !0,
          'expression': { interpolated: !1, parameters: ['zoom', 'feature'] },
          'property-type': 'cross-faded-data-driven',
        },
        'line-gradient': {
          'type': 'color',
          'transition': !1,
          'requires': [
            { '!': 'line-dasharray' },
            { '!': 'line-pattern' },
            { source: 'geojson', has: { lineMetrics: !0 } },
          ],
          'expression': { interpolated: !0, parameters: ['line-progress'] },
          'property-type': 'color-ramp',
        },
      },
      'paint_circle': {
        'circle-radius': {
          'type': 'number',
          'default': 5,
          'minimum': 0,
          'transition': !0,
          'units': 'pixels',
          'expression': {
            interpolated: !0,
            parameters: ['zoom', 'feature', 'feature-state'],
          },
          'property-type': 'data-driven',
        },
        'circle-color': {
          'type': 'color',
          'default': '#000000',
          'transition': !0,
          'expression': {
            interpolated: !0,
            parameters: ['zoom', 'feature', 'feature-state'],
          },
          'property-type': 'data-driven',
        },
        'circle-blur': {
          'type': 'number',
          'default': 0,
          'transition': !0,
          'expression': {
            interpolated: !0,
            parameters: ['zoom', 'feature', 'feature-state'],
          },
          'property-type': 'data-driven',
        },
        'circle-opacity': {
          'type': 'number',
          'default': 1,
          'minimum': 0,
          'maximum': 1,
          'transition': !0,
          'expression': {
            interpolated: !0,
            parameters: ['zoom', 'feature', 'feature-state'],
          },
          'property-type': 'data-driven',
        },
        'circle-translate': {
          'type': 'array',
          'value': 'number',
          'length': 2,
          'default': [0, 0],
          'transition': !0,
          'units': 'pixels',
          'expression': { interpolated: !0, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'circle-translate-anchor': {
          'type': 'enum',
          'values': { map: {}, viewport: {} },
          'default': 'map',
          'requires': ['circle-translate'],
          'expression': { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'circle-pitch-scale': {
          'type': 'enum',
          'values': { map: {}, viewport: {} },
          'default': 'map',
          'expression': { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'circle-pitch-alignment': {
          'type': 'enum',
          'values': { map: {}, viewport: {} },
          'default': 'viewport',
          'expression': { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'circle-stroke-width': {
          'type': 'number',
          'default': 0,
          'minimum': 0,
          'transition': !0,
          'units': 'pixels',
          'expression': {
            interpolated: !0,
            parameters: ['zoom', 'feature', 'feature-state'],
          },
          'property-type': 'data-driven',
        },
        'circle-stroke-color': {
          'type': 'color',
          'default': '#000000',
          'transition': !0,
          'expression': {
            interpolated: !0,
            parameters: ['zoom', 'feature', 'feature-state'],
          },
          'property-type': 'data-driven',
        },
        'circle-stroke-opacity': {
          'type': 'number',
          'default': 1,
          'minimum': 0,
          'maximum': 1,
          'transition': !0,
          'expression': {
            interpolated: !0,
            parameters: ['zoom', 'feature', 'feature-state'],
          },
          'property-type': 'data-driven',
        },
      },
      'paint_heatmap': {
        'heatmap-radius': {
          'type': 'number',
          'default': 30,
          'minimum': 1,
          'transition': !0,
          'units': 'pixels',
          'expression': {
            interpolated: !0,
            parameters: ['zoom', 'feature', 'feature-state'],
          },
          'property-type': 'data-driven',
        },
        'heatmap-weight': {
          'type': 'number',
          'default': 1,
          'minimum': 0,
          'transition': !1,
          'expression': {
            interpolated: !0,
            parameters: ['zoom', 'feature', 'feature-state'],
          },
          'property-type': 'data-driven',
        },
        'heatmap-intensity': {
          'type': 'number',
          'default': 1,
          'minimum': 0,
          'transition': !0,
          'expression': { interpolated: !0, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'heatmap-color': {
          'type': 'color',
          'default': [
            'interpolate',
            ['linear'],
            ['heatmap-density'],
            0,
            'rgba(0, 0, 255, 0)',
            0.1,
            'royalblue',
            0.3,
            'cyan',
            0.5,
            'lime',
            0.7,
            'yellow',
            1,
            'red',
          ],
          'transition': !1,
          'expression': { interpolated: !0, parameters: ['heatmap-density'] },
          'property-type': 'color-ramp',
        },
        'heatmap-opacity': {
          'type': 'number',
          'default': 1,
          'minimum': 0,
          'maximum': 1,
          'transition': !0,
          'expression': { interpolated: !0, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
      },
      'paint_symbol': {
        'icon-opacity': {
          'type': 'number',
          'default': 1,
          'minimum': 0,
          'maximum': 1,
          'transition': !0,
          'requires': ['icon-image'],
          'expression': {
            interpolated: !0,
            parameters: ['zoom', 'feature', 'feature-state'],
          },
          'property-type': 'data-driven',
        },
        'icon-color': {
          'type': 'color',
          'default': '#000000',
          'transition': !0,
          'requires': ['icon-image'],
          'expression': {
            interpolated: !0,
            parameters: ['zoom', 'feature', 'feature-state'],
          },
          'property-type': 'data-driven',
        },
        'icon-halo-color': {
          'type': 'color',
          'default': 'rgba(0, 0, 0, 0)',
          'transition': !0,
          'requires': ['icon-image'],
          'expression': {
            interpolated: !0,
            parameters: ['zoom', 'feature', 'feature-state'],
          },
          'property-type': 'data-driven',
        },
        'icon-halo-width': {
          'type': 'number',
          'default': 0,
          'minimum': 0,
          'transition': !0,
          'units': 'pixels',
          'requires': ['icon-image'],
          'expression': {
            interpolated: !0,
            parameters: ['zoom', 'feature', 'feature-state'],
          },
          'property-type': 'data-driven',
        },
        'icon-halo-blur': {
          'type': 'number',
          'default': 0,
          'minimum': 0,
          'transition': !0,
          'units': 'pixels',
          'requires': ['icon-image'],
          'expression': {
            interpolated: !0,
            parameters: ['zoom', 'feature', 'feature-state'],
          },
          'property-type': 'data-driven',
        },
        'icon-translate': {
          'type': 'array',
          'value': 'number',
          'length': 2,
          'default': [0, 0],
          'transition': !0,
          'units': 'pixels',
          'requires': ['icon-image'],
          'expression': { interpolated: !0, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'icon-translate-anchor': {
          'type': 'enum',
          'values': { map: {}, viewport: {} },
          'default': 'map',
          'requires': ['icon-image', 'icon-translate'],
          'expression': { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'text-opacity': {
          'type': 'number',
          'default': 1,
          'minimum': 0,
          'maximum': 1,
          'transition': !0,
          'requires': ['text-field'],
          'expression': {
            interpolated: !0,
            parameters: ['zoom', 'feature', 'feature-state'],
          },
          'property-type': 'data-driven',
        },
        'text-color': {
          'type': 'color',
          'default': '#000000',
          'transition': !0,
          'overridable': !0,
          'requires': ['text-field'],
          'expression': {
            interpolated: !0,
            parameters: ['zoom', 'feature', 'feature-state'],
          },
          'property-type': 'data-driven',
        },
        'text-halo-color': {
          'type': 'color',
          'default': 'rgba(0, 0, 0, 0)',
          'transition': !0,
          'requires': ['text-field'],
          'expression': {
            interpolated: !0,
            parameters: ['zoom', 'feature', 'feature-state'],
          },
          'property-type': 'data-driven',
        },
        'text-halo-width': {
          'type': 'number',
          'default': 0,
          'minimum': 0,
          'transition': !0,
          'units': 'pixels',
          'requires': ['text-field'],
          'expression': {
            interpolated: !0,
            parameters: ['zoom', 'feature', 'feature-state'],
          },
          'property-type': 'data-driven',
        },
        'text-halo-blur': {
          'type': 'number',
          'default': 0,
          'minimum': 0,
          'transition': !0,
          'units': 'pixels',
          'requires': ['text-field'],
          'expression': {
            interpolated: !0,
            parameters: ['zoom', 'feature', 'feature-state'],
          },
          'property-type': 'data-driven',
        },
        'text-translate': {
          'type': 'array',
          'value': 'number',
          'length': 2,
          'default': [0, 0],
          'transition': !0,
          'units': 'pixels',
          'requires': ['text-field'],
          'expression': { interpolated: !0, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'text-translate-anchor': {
          'type': 'enum',
          'values': { map: {}, viewport: {} },
          'default': 'map',
          'requires': ['text-field', 'text-translate'],
          'expression': { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
      },
      'paint_raster': {
        'raster-opacity': {
          'type': 'number',
          'default': 1,
          'minimum': 0,
          'maximum': 1,
          'transition': !0,
          'expression': { interpolated: !0, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'raster-hue-rotate': {
          'type': 'number',
          'default': 0,
          'period': 360,
          'transition': !0,
          'units': 'degrees',
          'expression': { interpolated: !0, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'raster-brightness-min': {
          'type': 'number',
          'default': 0,
          'minimum': 0,
          'maximum': 1,
          'transition': !0,
          'expression': { interpolated: !0, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'raster-brightness-max': {
          'type': 'number',
          'default': 1,
          'minimum': 0,
          'maximum': 1,
          'transition': !0,
          'expression': { interpolated: !0, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'raster-saturation': {
          'type': 'number',
          'default': 0,
          'minimum': -1,
          'maximum': 1,
          'transition': !0,
          'expression': { interpolated: !0, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'raster-contrast': {
          'type': 'number',
          'default': 0,
          'minimum': -1,
          'maximum': 1,
          'transition': !0,
          'expression': { interpolated: !0, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'raster-resampling': {
          'type': 'enum',
          'values': { linear: {}, nearest: {} },
          'default': 'linear',
          'expression': { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'raster-fade-duration': {
          'type': 'number',
          'default': 300,
          'minimum': 0,
          'transition': !1,
          'units': 'milliseconds',
          'expression': { interpolated: !0, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
      },
      'paint_hillshade': {
        'hillshade-illumination-direction': {
          'type': 'numberArray',
          'default': 335,
          'minimum': 0,
          'maximum': 359,
          'transition': !1,
          'expression': { interpolated: !0, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'hillshade-illumination-altitude': {
          'type': 'numberArray',
          'default': 45,
          'minimum': 0,
          'maximum': 90,
          'transition': !1,
          'expression': { interpolated: !0, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'hillshade-illumination-anchor': {
          'type': 'enum',
          'values': { map: {}, viewport: {} },
          'default': 'viewport',
          'expression': { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'hillshade-exaggeration': {
          'type': 'number',
          'default': 0.5,
          'minimum': 0,
          'maximum': 1,
          'transition': !0,
          'expression': { interpolated: !0, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'hillshade-shadow-color': {
          'type': 'colorArray',
          'default': '#000000',
          'transition': !0,
          'expression': { interpolated: !0, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'hillshade-highlight-color': {
          'type': 'colorArray',
          'default': '#FFFFFF',
          'transition': !0,
          'expression': { interpolated: !0, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'hillshade-accent-color': {
          'type': 'color',
          'default': '#000000',
          'transition': !0,
          'expression': { interpolated: !0, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'hillshade-method': {
          'type': 'enum',
          'values': {
            standard: {},
            basic: {},
            combined: {},
            igor: {},
            multidirectional: {},
          },
          'default': 'standard',
          'expression': { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
      },
      'paint_color-relief': {
        'color-relief-opacity': {
          'type': 'number',
          'default': 1,
          'minimum': 0,
          'maximum': 1,
          'transition': !0,
          'expression': { interpolated: !0, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'color-relief-color': {
          'type': 'color',
          'transition': !1,
          'expression': { interpolated: !0, parameters: ['elevation'] },
          'property-type': 'color-ramp',
        },
      },
      'paint_background': {
        'background-color': {
          'type': 'color',
          'default': '#000000',
          'transition': !0,
          'requires': [{ '!': 'background-pattern' }],
          'expression': { interpolated: !0, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'background-pattern': {
          'type': 'resolvedImage',
          'transition': !0,
          'expression': { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'cross-faded',
        },
        'background-opacity': {
          'type': 'number',
          'default': 1,
          'minimum': 0,
          'maximum': 1,
          'transition': !0,
          'expression': { interpolated: !0, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
      },
      'transition': {
        duration: {
          type: 'number',
          default: 300,
          minimum: 0,
          units: 'milliseconds',
        },
        delay: {
          type: 'number',
          default: 0,
          minimum: 0,
          units: 'milliseconds',
        },
      },
      'property-type': {
        'data-driven': { type: 'property-type' },
        'cross-faded': { type: 'property-type' },
        'cross-faded-data-driven': { type: 'property-type' },
        'color-ramp': { type: 'property-type' },
        'data-constant': { type: 'property-type' },
        'constant': { type: 'property-type' },
      },
      'promoteId': { '*': { type: 'string' } },
    };
    const xt = [
      'type',
      'source',
      'source-layer',
      'minzoom',
      'maxzoom',
      'filter',
      'layout',
    ];
    function bt(t, e) {
      const i = {};
      for (const r in t) 'ref' !== r && (i[r] = t[r]);
      return (
        xt.forEach((t) => {
          t in e && (i[t] = e[t]);
        }),
        i
      );
    }
    function wt(t, e) {
      if (Array.isArray(t)) {
        if (!Array.isArray(e) || t.length !== e.length) return !1;
        for (let i = 0; i < t.length; i++) if (!wt(t[i], e[i])) return !1;
        return !0;
      }
      if ('object' == typeof t && null !== t && null !== e) {
        if ('object' != typeof e) return !1;
        if (Object.keys(t).length !== Object.keys(e).length) return !1;
        for (const i in t) if (!wt(t[i], e[i])) return !1;
        return !0;
      }
      return t === e;
    }
    function Tt(t, e) {
      t.push(e);
    }
    function Pt(t, e, i) {
      Tt(i, { command: 'addSource', args: [t, e[t]] });
    }
    function Ct(t, e, i) {
      Tt(e, { command: 'removeSource', args: [t] }), (i[t] = !0);
    }
    function It(t, e, i, r) {
      Ct(t, i, r), Pt(t, e, i);
    }
    function St(t, e, i) {
      let r;
      for (r in t[i])
        if (
          Object.prototype.hasOwnProperty.call(t[i], r) &&
          'data' !== r &&
          !wt(t[i][r], e[i][r])
        )
          return !1;
      for (r in e[i])
        if (
          Object.prototype.hasOwnProperty.call(e[i], r) &&
          'data' !== r &&
          !wt(t[i][r], e[i][r])
        )
          return !1;
      return !0;
    }
    function Mt(t, e, i, r, n, a) {
      (t = t || {}), (e = e || {});
      for (const s in t)
        Object.prototype.hasOwnProperty.call(t, s) &&
          (wt(t[s], e[s]) || i.push({ command: a, args: [r, s, e[s], n] }));
      for (const s in e)
        Object.prototype.hasOwnProperty.call(e, s) &&
          !Object.prototype.hasOwnProperty.call(t, s) &&
          (wt(t[s], e[s]) || i.push({ command: a, args: [r, s, e[s], n] }));
    }
    function Dt(t) {
      return t.id;
    }
    function Lt(t, e) {
      return (t[e.id] = e), t;
    }
    class At {
      constructor(t, e, i, r) {
        (this.message = (t ? `${t}: ` : '') + i),
          r && (this.identifier = r),
          null != e && e.__line__ && (this.line = e.__line__);
      }
    }
    function Et(t, ...e) {
      for (const i of e) for (const e in i) t[e] = i[e];
      return t;
    }
    class Rt extends Error {
      constructor(t, e) {
        super(e), (this.message = e), (this.key = t);
      }
    }
    class zt {
      constructor(t, e = []) {
        (this.parent = t), (this.bindings = {});
        for (const [i, r] of e) this.bindings[i] = r;
      }
      concat(t) {
        return new zt(this, t);
      }
      get(t) {
        if (this.bindings[t]) return this.bindings[t];
        if (this.parent) return this.parent.get(t);
        throw new Error(`${t} not found in scope.`);
      }
      has(t) {
        return !!this.bindings[t] || (!!this.parent && this.parent.has(t));
      }
    }
    const kt = { kind: 'null' },
      Ot = { kind: 'number' },
      Ft = { kind: 'string' },
      Bt = { kind: 'boolean' },
      Nt = { kind: 'color' },
      Vt = { kind: 'projectionDefinition' },
      jt = { kind: 'object' },
      Ut = { kind: 'value' },
      Gt = { kind: 'collator' },
      Zt = { kind: 'formatted' },
      $t = { kind: 'padding' },
      qt = { kind: 'colorArray' },
      Ht = { kind: 'numberArray' },
      Wt = { kind: 'resolvedImage' },
      Xt = { kind: 'variableAnchorOffsetCollection' };
    function Yt(t, e) {
      return { kind: 'array', itemType: t, N: e };
    }
    function Kt(t) {
      if ('array' === t.kind) {
        const e = Kt(t.itemType);
        return 'number' == typeof t.N
          ? `array<${e}, ${t.N}>`
          : 'value' === t.itemType.kind
          ? 'array'
          : `array<${e}>`;
      }
      return t.kind;
    }
    const Jt = [kt, Ot, Ft, Bt, Nt, Vt, Zt, jt, Yt(Ut), $t, Ht, qt, Wt, Xt];
    function Qt(t, e) {
      if ('error' === e.kind) return null;
      if ('array' === t.kind) {
        if (
          'array' === e.kind &&
          ((0 === e.N && 'value' === e.itemType.kind) ||
            !Qt(t.itemType, e.itemType)) &&
          ('number' != typeof t.N || t.N === e.N)
        )
          return null;
      } else {
        if (t.kind === e.kind) return null;
        if ('value' === t.kind) for (const t of Jt) if (!Qt(t, e)) return null;
      }
      return `Expected ${Kt(t)} but found ${Kt(e)} instead.`;
    }
    function te(t, e) {
      return e.some((e) => e.kind === t.kind);
    }
    function ee(t, e) {
      return e.some((e) =>
        'null' === e
          ? null === t
          : 'array' === e
          ? Array.isArray(t)
          : 'object' === e
          ? t && !Array.isArray(t) && 'object' == typeof t
          : e === typeof t
      );
    }
    function ie(t, e) {
      return 'array' === t.kind && 'array' === e.kind
        ? t.itemType.kind === e.itemType.kind && 'number' == typeof t.N
        : t.kind === e.kind;
    }
    const re = 0.96422,
      ne = 0.82521,
      ae = 4 / 29,
      se = 6 / 29,
      oe = 3 * se * se,
      le = se * se * se,
      ce = Math.PI / 180,
      he = 180 / Math.PI;
    function ue(t) {
      return (t %= 360) < 0 && (t += 360), t;
    }
    function de([t, e, i, r]) {
      let n, a;
      const s = fe(
        (0.2225045 * (t = pe(t)) +
          0.7168786 * (e = pe(e)) +
          0.0606169 * (i = pe(i))) /
          1
      );
      t === e && e === i
        ? (n = a = s)
        : ((n = fe((0.4360747 * t + 0.3850649 * e + 0.1430804 * i) / re)),
          (a = fe((0.0139322 * t + 0.0971045 * e + 0.7141733 * i) / ne)));
      const o = 116 * s - 16;
      return [o < 0 ? 0 : o, 500 * (n - s), 200 * (s - a), r];
    }
    function pe(t) {
      return t <= 0.04045 ? t / 12.92 : Math.pow((t + 0.055) / 1.055, 2.4);
    }
    function fe(t) {
      return t > le ? Math.pow(t, 1 / 3) : t / oe + ae;
    }
    function me([t, e, i, r]) {
      let n = (t + 16) / 116,
        a = isNaN(e) ? n : n + e / 500,
        s = isNaN(i) ? n : n - i / 200;
      return (
        (n = 1 * _e(n)),
        (a = re * _e(a)),
        (s = ne * _e(s)),
        [
          ge(3.1338561 * a - 1.6168667 * n - 0.4906146 * s),
          ge(-0.9787684 * a + 1.9161415 * n + 0.033454 * s),
          ge(0.0719453 * a - 0.2289914 * n + 1.4052427 * s),
          r,
        ]
      );
    }
    function ge(t) {
      return (t =
        t <= 0.00304 ? 12.92 * t : 1.055 * Math.pow(t, 1 / 2.4) - 0.055) < 0
        ? 0
        : t > 1
        ? 1
        : t;
    }
    function _e(t) {
      return t > se ? t * t * t : oe * (t - ae);
    }
    const ye =
      Object.hasOwn ||
      function (t, e) {
        return Object.prototype.hasOwnProperty.call(t, e);
      };
    function ve(t, e) {
      return ye(t, e) ? t[e] : void 0;
    }
    function xe(t) {
      return parseInt(t.padEnd(2, t), 16) / 255;
    }
    function be(t, e) {
      return we(e ? t / 100 : t, 0, 1);
    }
    function we(t, e, i) {
      return Math.min(Math.max(e, t), i);
    }
    function Te(t) {
      return !t.some(Number.isNaN);
    }
    const Pe = {
      aliceblue: [240, 248, 255],
      antiquewhite: [250, 235, 215],
      aqua: [0, 255, 255],
      aquamarine: [127, 255, 212],
      azure: [240, 255, 255],
      beige: [245, 245, 220],
      bisque: [255, 228, 196],
      black: [0, 0, 0],
      blanchedalmond: [255, 235, 205],
      blue: [0, 0, 255],
      blueviolet: [138, 43, 226],
      brown: [165, 42, 42],
      burlywood: [222, 184, 135],
      cadetblue: [95, 158, 160],
      chartreuse: [127, 255, 0],
      chocolate: [210, 105, 30],
      coral: [255, 127, 80],
      cornflowerblue: [100, 149, 237],
      cornsilk: [255, 248, 220],
      crimson: [220, 20, 60],
      cyan: [0, 255, 255],
      darkblue: [0, 0, 139],
      darkcyan: [0, 139, 139],
      darkgoldenrod: [184, 134, 11],
      darkgray: [169, 169, 169],
      darkgreen: [0, 100, 0],
      darkgrey: [169, 169, 169],
      darkkhaki: [189, 183, 107],
      darkmagenta: [139, 0, 139],
      darkolivegreen: [85, 107, 47],
      darkorange: [255, 140, 0],
      darkorchid: [153, 50, 204],
      darkred: [139, 0, 0],
      darksalmon: [233, 150, 122],
      darkseagreen: [143, 188, 143],
      darkslateblue: [72, 61, 139],
      darkslategray: [47, 79, 79],
      darkslategrey: [47, 79, 79],
      darkturquoise: [0, 206, 209],
      darkviolet: [148, 0, 211],
      deeppink: [255, 20, 147],
      deepskyblue: [0, 191, 255],
      dimgray: [105, 105, 105],
      dimgrey: [105, 105, 105],
      dodgerblue: [30, 144, 255],
      firebrick: [178, 34, 34],
      floralwhite: [255, 250, 240],
      forestgreen: [34, 139, 34],
      fuchsia: [255, 0, 255],
      gainsboro: [220, 220, 220],
      ghostwhite: [248, 248, 255],
      gold: [255, 215, 0],
      goldenrod: [218, 165, 32],
      gray: [128, 128, 128],
      green: [0, 128, 0],
      greenyellow: [173, 255, 47],
      grey: [128, 128, 128],
      honeydew: [240, 255, 240],
      hotpink: [255, 105, 180],
      indianred: [205, 92, 92],
      indigo: [75, 0, 130],
      ivory: [255, 255, 240],
      khaki: [240, 230, 140],
      lavender: [230, 230, 250],
      lavenderblush: [255, 240, 245],
      lawngreen: [124, 252, 0],
      lemonchiffon: [255, 250, 205],
      lightblue: [173, 216, 230],
      lightcoral: [240, 128, 128],
      lightcyan: [224, 255, 255],
      lightgoldenrodyellow: [250, 250, 210],
      lightgray: [211, 211, 211],
      lightgreen: [144, 238, 144],
      lightgrey: [211, 211, 211],
      lightpink: [255, 182, 193],
      lightsalmon: [255, 160, 122],
      lightseagreen: [32, 178, 170],
      lightskyblue: [135, 206, 250],
      lightslategray: [119, 136, 153],
      lightslategrey: [119, 136, 153],
      lightsteelblue: [176, 196, 222],
      lightyellow: [255, 255, 224],
      lime: [0, 255, 0],
      limegreen: [50, 205, 50],
      linen: [250, 240, 230],
      magenta: [255, 0, 255],
      maroon: [128, 0, 0],
      mediumaquamarine: [102, 205, 170],
      mediumblue: [0, 0, 205],
      mediumorchid: [186, 85, 211],
      mediumpurple: [147, 112, 219],
      mediumseagreen: [60, 179, 113],
      mediumslateblue: [123, 104, 238],
      mediumspringgreen: [0, 250, 154],
      mediumturquoise: [72, 209, 204],
      mediumvioletred: [199, 21, 133],
      midnightblue: [25, 25, 112],
      mintcream: [245, 255, 250],
      mistyrose: [255, 228, 225],
      moccasin: [255, 228, 181],
      navajowhite: [255, 222, 173],
      navy: [0, 0, 128],
      oldlace: [253, 245, 230],
      olive: [128, 128, 0],
      olivedrab: [107, 142, 35],
      orange: [255, 165, 0],
      orangered: [255, 69, 0],
      orchid: [218, 112, 214],
      palegoldenrod: [238, 232, 170],
      palegreen: [152, 251, 152],
      paleturquoise: [175, 238, 238],
      palevioletred: [219, 112, 147],
      papayawhip: [255, 239, 213],
      peachpuff: [255, 218, 185],
      peru: [205, 133, 63],
      pink: [255, 192, 203],
      plum: [221, 160, 221],
      powderblue: [176, 224, 230],
      purple: [128, 0, 128],
      rebeccapurple: [102, 51, 153],
      red: [255, 0, 0],
      rosybrown: [188, 143, 143],
      royalblue: [65, 105, 225],
      saddlebrown: [139, 69, 19],
      salmon: [250, 128, 114],
      sandybrown: [244, 164, 96],
      seagreen: [46, 139, 87],
      seashell: [255, 245, 238],
      sienna: [160, 82, 45],
      silver: [192, 192, 192],
      skyblue: [135, 206, 235],
      slateblue: [106, 90, 205],
      slategray: [112, 128, 144],
      slategrey: [112, 128, 144],
      snow: [255, 250, 250],
      springgreen: [0, 255, 127],
      steelblue: [70, 130, 180],
      tan: [210, 180, 140],
      teal: [0, 128, 128],
      thistle: [216, 191, 216],
      tomato: [255, 99, 71],
      turquoise: [64, 224, 208],
      violet: [238, 130, 238],
      wheat: [245, 222, 179],
      white: [255, 255, 255],
      whitesmoke: [245, 245, 245],
      yellow: [255, 255, 0],
      yellowgreen: [154, 205, 50],
    };
    function Ce(t, e, i) {
      return t + i * (e - t);
    }
    function Ie(t, e, i) {
      return t.map((t, r) => Ce(t, e[r], i));
    }
    class Se {
      constructor(t, e, i, r = 1, n = !0) {
        (this.r = t),
          (this.g = e),
          (this.b = i),
          (this.a = r),
          n ||
            ((this.r *= r),
            (this.g *= r),
            (this.b *= r),
            r || this.overwriteGetter('rgb', [t, e, i, r]));
      }
      static parse(t) {
        if (t instanceof Se) return t;
        if ('string' != typeof t) return;
        const e = (function (t) {
          if ('transparent' === (t = t.toLowerCase().trim()))
            return [0, 0, 0, 0];
          const e = ve(Pe, t);
          if (e) {
            const [t, i, r] = e;
            return [t / 255, i / 255, r / 255, 1];
          }
          if (
            t.startsWith('#') &&
            /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(t)
          ) {
            const e = t.length < 6 ? 1 : 2;
            let i = 1;
            return [
              xe(t.slice(i, (i += e))),
              xe(t.slice(i, (i += e))),
              xe(t.slice(i, (i += e))),
              xe(t.slice(i, i + e) || 'ff'),
            ];
          }
          if (t.startsWith('rgb')) {
            const e = t.match(
              /^rgba?\(\s*([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/
            );
            if (e) {
              const [t, i, r, n, a, s, o, l, c, h, u, d] = e,
                p = [n || ' ', o || ' ', h].join('');
              if ('  ' === p || '  /' === p || ',,' === p || ',,,' === p) {
                const t = [r, s, c].join(''),
                  e = '%%%' === t ? 100 : '' === t ? 255 : 0;
                if (e) {
                  const t = [
                    we(+i / e, 0, 1),
                    we(+a / e, 0, 1),
                    we(+l / e, 0, 1),
                    u ? be(+u, d) : 1,
                  ];
                  if (Te(t)) return t;
                }
              }
              return;
            }
          }
          const i = t.match(
            /^hsla?\(\s*([\de.+-]+)(?:deg)?(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/
          );
          if (i) {
            const [t, e, r, n, a, s, o, l, c] = i,
              h = [r || ' ', a || ' ', o].join('');
            if ('  ' === h || '  /' === h || ',,' === h || ',,,' === h) {
              const t = [+e, we(+n, 0, 100), we(+s, 0, 100), l ? be(+l, c) : 1];
              if (Te(t))
                return (function ([t, e, i, r]) {
                  function n(r) {
                    const n = (r + t / 30) % 12,
                      a = e * Math.min(i, 1 - i);
                    return i - a * Math.max(-1, Math.min(n - 3, 9 - n, 1));
                  }
                  return (
                    (t = ue(t)), (e /= 100), (i /= 100), [n(0), n(8), n(4), r]
                  );
                })(t);
            }
          }
        })(t);
        return e ? new Se(...e, !1) : void 0;
      }
      get rgb() {
        const { r: t, g: e, b: i, a: r } = this,
          n = r || 1 / 0;
        return this.overwriteGetter('rgb', [t / n, e / n, i / n, r]);
      }
      get hcl() {
        return this.overwriteGetter(
          'hcl',
          (function (t) {
            const [e, i, r, n] = de(t),
              a = Math.sqrt(i * i + r * r);
            return [
              Math.round(1e4 * a) ? ue(Math.atan2(r, i) * he) : NaN,
              a,
              e,
              n,
            ];
          })(this.rgb)
        );
      }
      get lab() {
        return this.overwriteGetter('lab', de(this.rgb));
      }
      overwriteGetter(t, e) {
        return Object.defineProperty(this, t, { value: e }), e;
      }
      toString() {
        const [t, e, i, r] = this.rgb;
        return `rgba(${[t, e, i]
          .map((t) => Math.round(255 * t))
          .join(',')},${r})`;
      }
      static interpolate(t, e, i, r = 'rgb') {
        switch (r) {
          case 'rgb': {
            const [r, n, a, s] = Ie(t.rgb, e.rgb, i);
            return new Se(r, n, a, s, !1);
          }
          case 'hcl': {
            const [r, n, a, s] = t.hcl,
              [o, l, c, h] = e.hcl;
            let u, d;
            if (isNaN(r) || isNaN(o))
              isNaN(r)
                ? isNaN(o)
                  ? (u = NaN)
                  : ((u = o), (1 !== a && 0 !== a) || (d = l))
                : ((u = r), (1 !== c && 0 !== c) || (d = n));
            else {
              let t = o - r;
              o > r && t > 180
                ? (t -= 360)
                : o < r && r - o > 180 && (t += 360),
                (u = r + i * t);
            }
            const [p, f, m, g] = (function ([t, e, i, r]) {
              return (
                (t = isNaN(t) ? 0 : t * ce),
                me([i, Math.cos(t) * e, Math.sin(t) * e, r])
              );
            })([u, null != d ? d : Ce(n, l, i), Ce(a, c, i), Ce(s, h, i)]);
            return new Se(p, f, m, g, !1);
          }
          case 'lab': {
            const [r, n, a, s] = me(Ie(t.lab, e.lab, i));
            return new Se(r, n, a, s, !1);
          }
        }
      }
    }
    (Se.black = new Se(0, 0, 0, 1)),
      (Se.white = new Se(1, 1, 1, 1)),
      (Se.transparent = new Se(0, 0, 0, 0)),
      (Se.red = new Se(1, 0, 0, 1));
    class Me {
      constructor(t, e, i) {
        (this.sensitivity = t
          ? e
            ? 'variant'
            : 'case'
          : e
          ? 'accent'
          : 'base'),
          (this.locale = i),
          (this.collator = new Intl.Collator(this.locale ? this.locale : [], {
            sensitivity: this.sensitivity,
            usage: 'search',
          }));
      }
      compare(t, e) {
        return this.collator.compare(t, e);
      }
      resolvedLocale() {
        return new Intl.Collator(
          this.locale ? this.locale : []
        ).resolvedOptions().locale;
      }
    }
    const De = ['bottom', 'center', 'top'];
    class Le {
      constructor(t, e, i, r, n, a) {
        (this.text = t),
          (this.image = e),
          (this.scale = i),
          (this.fontStack = r),
          (this.textColor = n),
          (this.verticalAlign = a);
      }
    }
    class Ae {
      constructor(t) {
        this.sections = t;
      }
      static fromString(t) {
        return new Ae([new Le(t, null, null, null, null, null)]);
      }
      isEmpty() {
        return (
          0 === this.sections.length ||
          !this.sections.some(
            (t) => 0 !== t.text.length || (t.image && 0 !== t.image.name.length)
          )
        );
      }
      static factory(t) {
        return t instanceof Ae ? t : Ae.fromString(t);
      }
      toString() {
        return 0 === this.sections.length
          ? ''
          : this.sections.map((t) => t.text).join('');
      }
    }
    class Ee {
      constructor(t) {
        this.values = t.slice();
      }
      static parse(t) {
        if (t instanceof Ee) return t;
        if ('number' == typeof t) return new Ee([t, t, t, t]);
        if (Array.isArray(t) && !(t.length < 1 || t.length > 4)) {
          for (const e of t) if ('number' != typeof e) return;
          switch (t.length) {
            case 1:
              t = [t[0], t[0], t[0], t[0]];
              break;
            case 2:
              t = [t[0], t[1], t[0], t[1]];
              break;
            case 3:
              t = [t[0], t[1], t[2], t[1]];
          }
          return new Ee(t);
        }
      }
      toString() {
        return JSON.stringify(this.values);
      }
      static interpolate(t, e, i) {
        return new Ee(Ie(t.values, e.values, i));
      }
    }
    class Re {
      constructor(t) {
        this.values = t.slice();
      }
      static parse(t) {
        if (t instanceof Re) return t;
        if ('number' == typeof t) return new Re([t]);
        if (Array.isArray(t)) {
          for (const e of t) if ('number' != typeof e) return;
          return new Re(t);
        }
      }
      toString() {
        return JSON.stringify(this.values);
      }
      static interpolate(t, e, i) {
        return new Re(Ie(t.values, e.values, i));
      }
    }
    class ze {
      constructor(t) {
        this.values = t.slice();
      }
      static parse(t) {
        if (t instanceof ze) return t;
        if ('string' == typeof t) {
          const e = Se.parse(t);
          if (!e) return;
          return new ze([e]);
        }
        if (!Array.isArray(t)) return;
        const e = [];
        for (const i of t) {
          if ('string' != typeof i) return;
          const t = Se.parse(i);
          if (!t) return;
          e.push(t);
        }
        return new ze(e);
      }
      toString() {
        return JSON.stringify(this.values);
      }
      static interpolate(t, e, i, r = 'rgb') {
        const n = [];
        if (t.values.length != e.values.length)
          throw new Error(
            `colorArray: Arrays have mismatched length (${t.values.length} vs. ${e.values.length}), cannot interpolate.`
          );
        for (let a = 0; a < t.values.length; a++)
          n.push(Se.interpolate(t.values[a], e.values[a], i, r));
        return new ze(n);
      }
    }
    class ke extends Error {
      constructor(t) {
        super(t), (this.name = 'RuntimeError');
      }
      toJSON() {
        return this.message;
      }
    }
    const Oe = new Set([
      'center',
      'left',
      'right',
      'top',
      'bottom',
      'top-left',
      'top-right',
      'bottom-left',
      'bottom-right',
    ]);
    class Fe {
      constructor(t) {
        this.values = t.slice();
      }
      static parse(t) {
        if (t instanceof Fe) return t;
        if (Array.isArray(t) && !(t.length < 1) && t.length % 2 == 0) {
          for (let e = 0; e < t.length; e += 2) {
            const i = t[e],
              r = t[e + 1];
            if ('string' != typeof i || !Oe.has(i)) return;
            if (
              !Array.isArray(r) ||
              2 !== r.length ||
              'number' != typeof r[0] ||
              'number' != typeof r[1]
            )
              return;
          }
          return new Fe(t);
        }
      }
      toString() {
        return JSON.stringify(this.values);
      }
      static interpolate(t, e, i) {
        const r = t.values,
          n = e.values;
        if (r.length !== n.length)
          throw new ke(
            `Cannot interpolate values of different length. from: ${t.toString()}, to: ${e.toString()}`
          );
        const a = [];
        for (let s = 0; s < r.length; s += 2) {
          if (r[s] !== n[s])
            throw new ke(
              `Cannot interpolate values containing mismatched anchors. from[${s}]: ${r[s]}, to[${s}]: ${n[s]}`
            );
          a.push(r[s]);
          const [t, e] = r[s + 1],
            [o, l] = n[s + 1];
          a.push([Ce(t, o, i), Ce(e, l, i)]);
        }
        return new Fe(a);
      }
    }
    class Be {
      constructor(t) {
        (this.name = t.name), (this.available = t.available);
      }
      toString() {
        return this.name;
      }
      static fromString(t) {
        return t ? new Be({ name: t, available: !1 }) : null;
      }
    }
    class Ne {
      constructor(t, e, i) {
        (this.from = t), (this.to = e), (this.transition = i);
      }
      static interpolate(t, e, i) {
        return new Ne(t, e, i);
      }
      static parse(t) {
        return t instanceof Ne
          ? t
          : Array.isArray(t) &&
            3 === t.length &&
            'string' == typeof t[0] &&
            'string' == typeof t[1] &&
            'number' == typeof t[2]
          ? new Ne(t[0], t[1], t[2])
          : 'object' == typeof t &&
            'string' == typeof t.from &&
            'string' == typeof t.to &&
            'number' == typeof t.transition
          ? new Ne(t.from, t.to, t.transition)
          : 'string' == typeof t
          ? new Ne(t, t, 1)
          : void 0;
      }
    }
    function Ve(t, e, i, r) {
      return 'number' == typeof t &&
        t >= 0 &&
        t <= 255 &&
        'number' == typeof e &&
        e >= 0 &&
        e <= 255 &&
        'number' == typeof i &&
        i >= 0 &&
        i <= 255
        ? void 0 === r || ('number' == typeof r && r >= 0 && r <= 1)
          ? null
          : `Invalid rgba value [${[t, e, i, r].join(
              ', '
            )}]: 'a' must be between 0 and 1.`
        : `Invalid rgba value [${('number' == typeof r
            ? [t, e, i, r]
            : [t, e, i]
          ).join(', ')}]: 'r', 'g', and 'b' must be between 0 and 255.`;
    }
    function je(t) {
      if (
        null === t ||
        'string' == typeof t ||
        'boolean' == typeof t ||
        'number' == typeof t ||
        t instanceof Ne ||
        t instanceof Se ||
        t instanceof Me ||
        t instanceof Ae ||
        t instanceof Ee ||
        t instanceof Re ||
        t instanceof ze ||
        t instanceof Fe ||
        t instanceof Be
      )
        return !0;
      if (Array.isArray(t)) {
        for (const e of t) if (!je(e)) return !1;
        return !0;
      }
      if ('object' == typeof t) {
        for (const e in t) if (!je(t[e])) return !1;
        return !0;
      }
      return !1;
    }
    function Ue(t) {
      if (null === t) return kt;
      if ('string' == typeof t) return Ft;
      if ('boolean' == typeof t) return Bt;
      if ('number' == typeof t) return Ot;
      if (t instanceof Se) return Nt;
      if (t instanceof Ne) return Vt;
      if (t instanceof Me) return Gt;
      if (t instanceof Ae) return Zt;
      if (t instanceof Ee) return $t;
      if (t instanceof Re) return Ht;
      if (t instanceof ze) return qt;
      if (t instanceof Fe) return Xt;
      if (t instanceof Be) return Wt;
      if (Array.isArray(t)) {
        const e = t.length;
        let i;
        for (const r of t) {
          const t = Ue(r);
          if (i) {
            if (i === t) continue;
            i = Ut;
            break;
          }
          i = t;
        }
        return Yt(i || Ut, e);
      }
      return jt;
    }
    function Ge(t) {
      const e = typeof t;
      return null === t
        ? ''
        : 'string' === e || 'number' === e || 'boolean' === e
        ? String(t)
        : t instanceof Se ||
          t instanceof Ne ||
          t instanceof Ae ||
          t instanceof Ee ||
          t instanceof Re ||
          t instanceof ze ||
          t instanceof Fe ||
          t instanceof Be
        ? t.toString()
        : JSON.stringify(t);
    }
    class Ze {
      constructor(t, e) {
        (this.type = t), (this.value = e);
      }
      static parse(t, e) {
        if (2 !== t.length)
          return e.error(
            `'literal' expression requires exactly one argument, but found ${
              t.length - 1
            } instead.`
          );
        if (!je(t[1])) return e.error('invalid value');
        const i = t[1];
        let r = Ue(i);
        const n = e.expectedType;
        return (
          'array' !== r.kind ||
            0 !== r.N ||
            !n ||
            'array' !== n.kind ||
            ('number' == typeof n.N && 0 !== n.N) ||
            (r = n),
          new Ze(r, i)
        );
      }
      evaluate() {
        return this.value;
      }
      eachChild() {}
      outputDefined() {
        return !0;
      }
    }
    const $e = { string: Ft, number: Ot, boolean: Bt, object: jt };
    class qe {
      constructor(t, e) {
        (this.type = t), (this.args = e);
      }
      static parse(t, e) {
        if (t.length < 2) return e.error('Expected at least one argument.');
        let i,
          r = 1;
        const n = t[0];
        if ('array' === n) {
          let n, a;
          if (t.length > 2) {
            const i = t[1];
            if ('string' != typeof i || !(i in $e) || 'object' === i)
              return e.error(
                'The item type argument of "array" must be one of string, number, boolean',
                1
              );
            (n = $e[i]), r++;
          } else n = Ut;
          if (t.length > 3) {
            if (
              null !== t[2] &&
              ('number' != typeof t[2] || t[2] < 0 || t[2] !== Math.floor(t[2]))
            )
              return e.error(
                'The length argument to "array" must be a positive integer literal',
                2
              );
            (a = t[2]), r++;
          }
          i = Yt(n, a);
        } else {
          if (!$e[n]) throw new Error(`Types doesn't contain name = ${n}`);
          i = $e[n];
        }
        const a = [];
        for (; r < t.length; r++) {
          const i = e.parse(t[r], r, Ut);
          if (!i) return null;
          a.push(i);
        }
        return new qe(i, a);
      }
      evaluate(t) {
        for (let e = 0; e < this.args.length; e++) {
          const i = this.args[e].evaluate(t);
          if (!Qt(this.type, Ue(i))) return i;
          if (e === this.args.length - 1)
            throw new ke(
              `Expected value to be of type ${Kt(this.type)}, but found ${Kt(
                Ue(i)
              )} instead.`
            );
        }
        throw new Error();
      }
      eachChild(t) {
        this.args.forEach(t);
      }
      outputDefined() {
        return this.args.every((t) => t.outputDefined());
      }
    }
    const He = {
      'to-boolean': Bt,
      'to-color': Nt,
      'to-number': Ot,
      'to-string': Ft,
    };
    class We {
      constructor(t, e) {
        (this.type = t), (this.args = e);
      }
      static parse(t, e) {
        if (t.length < 2) return e.error('Expected at least one argument.');
        const i = t[0];
        if (!He[i])
          throw new Error(
            `Can't parse ${i} as it is not part of the known types`
          );
        if (('to-boolean' === i || 'to-string' === i) && 2 !== t.length)
          return e.error('Expected one argument.');
        const r = He[i],
          n = [];
        for (let a = 1; a < t.length; a++) {
          const i = e.parse(t[a], a, Ut);
          if (!i) return null;
          n.push(i);
        }
        return new We(r, n);
      }
      evaluate(t) {
        switch (this.type.kind) {
          case 'boolean':
            return Boolean(this.args[0].evaluate(t));
          case 'color': {
            let e, i;
            for (const r of this.args) {
              if (((e = r.evaluate(t)), (i = null), e instanceof Se)) return e;
              if ('string' == typeof e) {
                const i = t.parseColor(e);
                if (i) return i;
              } else if (
                Array.isArray(e) &&
                ((i =
                  e.length < 3 || e.length > 4
                    ? `Invalid rgba value ${JSON.stringify(
                        e
                      )}: expected an array containing either three or four numeric values.`
                    : Ve(e[0], e[1], e[2], e[3])),
                !i)
              )
                return new Se(e[0] / 255, e[1] / 255, e[2] / 255, e[3]);
            }
            throw new ke(
              i ||
                `Could not parse color from value '${
                  'string' == typeof e ? e : JSON.stringify(e)
                }'`
            );
          }
          case 'padding': {
            let e;
            for (const i of this.args) {
              e = i.evaluate(t);
              const r = Ee.parse(e);
              if (r) return r;
            }
            throw new ke(
              `Could not parse padding from value '${
                'string' == typeof e ? e : JSON.stringify(e)
              }'`
            );
          }
          case 'numberArray': {
            let e;
            for (const i of this.args) {
              e = i.evaluate(t);
              const r = Re.parse(e);
              if (r) return r;
            }
            throw new ke(
              `Could not parse numberArray from value '${
                'string' == typeof e ? e : JSON.stringify(e)
              }'`
            );
          }
          case 'colorArray': {
            let e;
            for (const i of this.args) {
              e = i.evaluate(t);
              const r = ze.parse(e);
              if (r) return r;
            }
            throw new ke(
              `Could not parse colorArray from value '${
                'string' == typeof e ? e : JSON.stringify(e)
              }'`
            );
          }
          case 'variableAnchorOffsetCollection': {
            let e;
            for (const i of this.args) {
              e = i.evaluate(t);
              const r = Fe.parse(e);
              if (r) return r;
            }
            throw new ke(
              `Could not parse variableAnchorOffsetCollection from value '${
                'string' == typeof e ? e : JSON.stringify(e)
              }'`
            );
          }
          case 'number': {
            let e = null;
            for (const i of this.args) {
              if (((e = i.evaluate(t)), null === e)) return 0;
              const r = Number(e);
              if (!isNaN(r)) return r;
            }
            throw new ke(`Could not convert ${JSON.stringify(e)} to number.`);
          }
          case 'formatted':
            return Ae.fromString(Ge(this.args[0].evaluate(t)));
          case 'resolvedImage':
            return Be.fromString(Ge(this.args[0].evaluate(t)));
          case 'projectionDefinition':
            return this.args[0].evaluate(t);
          default:
            return Ge(this.args[0].evaluate(t));
        }
      }
      eachChild(t) {
        this.args.forEach(t);
      }
      outputDefined() {
        return this.args.every((t) => t.outputDefined());
      }
    }
    const Xe = ['Unknown', 'Point', 'LineString', 'Polygon'];
    class Ye {
      constructor() {
        (this.globals = null),
          (this.feature = null),
          (this.featureState = null),
          (this.formattedSection = null),
          (this._parseColorCache = new Map()),
          (this.availableImages = null),
          (this.canonical = null);
      }
      id() {
        return this.feature && 'id' in this.feature ? this.feature.id : null;
      }
      geometryType() {
        return this.feature
          ? 'number' == typeof this.feature.type
            ? Xe[this.feature.type]
            : this.feature.type
          : null;
      }
      geometry() {
        return this.feature && 'geometry' in this.feature
          ? this.feature.geometry
          : null;
      }
      canonicalID() {
        return this.canonical;
      }
      properties() {
        return (this.feature && this.feature.properties) || {};
      }
      parseColor(t) {
        let e = this._parseColorCache.get(t);
        return e || ((e = Se.parse(t)), this._parseColorCache.set(t, e)), e;
      }
    }
    class Ke {
      constructor(t, e, i = [], r, n = new zt(), a = []) {
        (this.registry = t),
          (this.path = i),
          (this.key = i.map((t) => `[${t}]`).join('')),
          (this.scope = n),
          (this.errors = a),
          (this.expectedType = r),
          (this._isConstant = e);
      }
      parse(t, e, i, r, n = {}) {
        return e ? this.concat(e, i, r)._parse(t, n) : this._parse(t, n);
      }
      _parse(t, e) {
        function i(t, e, i) {
          return 'assert' === i
            ? new qe(e, [t])
            : 'coerce' === i
            ? new We(e, [t])
            : t;
        }
        if (
          ((null !== t &&
            'string' != typeof t &&
            'boolean' != typeof t &&
            'number' != typeof t) ||
            (t = ['literal', t]),
          Array.isArray(t))
        ) {
          if (0 === t.length)
            return this.error(
              'Expected an array with at least one element. If you wanted a literal array, use ["literal", []].'
            );
          const r = t[0];
          if ('string' != typeof r)
            return (
              this.error(
                `Expression name must be a string, but found ${typeof r} instead. If you wanted a literal array, use ["literal", [...]].`,
                0
              ),
              null
            );
          const n = this.registry[r];
          if (n) {
            let r = n.parse(t, this);
            if (!r) return null;
            if (this.expectedType) {
              const t = this.expectedType,
                n = r.type;
              if (
                ('string' !== t.kind &&
                  'number' !== t.kind &&
                  'boolean' !== t.kind &&
                  'object' !== t.kind &&
                  'array' !== t.kind) ||
                'value' !== n.kind
              ) {
                if (
                  ('projectionDefinition' === t.kind &&
                    ['string', 'array'].includes(n.kind)) ||
                  (['color', 'formatted', 'resolvedImage'].includes(t.kind) &&
                    ['value', 'string'].includes(n.kind)) ||
                  (['padding', 'numberArray'].includes(t.kind) &&
                    ['value', 'number', 'array'].includes(n.kind)) ||
                  ('colorArray' === t.kind &&
                    ['value', 'string', 'array'].includes(n.kind)) ||
                  ('variableAnchorOffsetCollection' === t.kind &&
                    ['value', 'array'].includes(n.kind))
                )
                  r = i(r, t, e.typeAnnotation || 'coerce');
                else if (this.checkSubtype(t, n)) return null;
              } else r = i(r, t, e.typeAnnotation || 'assert');
            }
            if (
              !(r instanceof Ze) &&
              'resolvedImage' !== r.type.kind &&
              this._isConstant(r)
            ) {
              const e = new Ye();
              try {
                r = new Ze(r.type, r.evaluate(e));
              } catch (t) {
                return this.error(t.message), null;
              }
            }
            return r;
          }
          return this.error(
            `Unknown expression "${r}". If you wanted a literal array, use ["literal", [...]].`,
            0
          );
        }
        return this.error(
          void 0 === t
            ? "'undefined' value invalid. Use null instead."
            : 'object' == typeof t
            ? 'Bare objects invalid. Use ["literal", {...}] instead.'
            : `Expected an array, but found ${typeof t} instead.`
        );
      }
      concat(t, e, i) {
        const r = 'number' == typeof t ? this.path.concat(t) : this.path,
          n = i ? this.scope.concat(i) : this.scope;
        return new Ke(
          this.registry,
          this._isConstant,
          r,
          e || null,
          n,
          this.errors
        );
      }
      error(t, ...e) {
        const i = `${this.key}${e.map((t) => `[${t}]`).join('')}`;
        this.errors.push(new Rt(i, t));
      }
      checkSubtype(t, e) {
        const i = Qt(t, e);
        return i && this.error(i), i;
      }
    }
    class Je {
      constructor(t, e) {
        (this.type = e.type), (this.bindings = [].concat(t)), (this.result = e);
      }
      evaluate(t) {
        return this.result.evaluate(t);
      }
      eachChild(t) {
        for (const e of this.bindings) t(e[1]);
        t(this.result);
      }
      static parse(t, e) {
        if (t.length < 4)
          return e.error(
            `Expected at least 3 arguments, but found ${t.length - 1} instead.`
          );
        const i = [];
        for (let n = 1; n < t.length - 1; n += 2) {
          const r = t[n];
          if ('string' != typeof r)
            return e.error(
              `Expected string, but found ${typeof r} instead.`,
              n
            );
          if (/[^a-zA-Z0-9_]/.test(r))
            return e.error(
              "Variable names must contain only alphanumeric characters or '_'.",
              n
            );
          const a = e.parse(t[n + 1], n + 1);
          if (!a) return null;
          i.push([r, a]);
        }
        const r = e.parse(t[t.length - 1], t.length - 1, e.expectedType, i);
        return r ? new Je(i, r) : null;
      }
      outputDefined() {
        return this.result.outputDefined();
      }
    }
    class Qe {
      constructor(t, e) {
        (this.type = e.type), (this.name = t), (this.boundExpression = e);
      }
      static parse(t, e) {
        if (2 !== t.length || 'string' != typeof t[1])
          return e.error(
            "'var' expression requires exactly one string literal argument."
          );
        const i = t[1];
        return e.scope.has(i)
          ? new Qe(i, e.scope.get(i))
          : e.error(
              `Unknown variable "${i}". Make sure "${i}" has been bound in an enclosing "let" expression before using it.`,
              1
            );
      }
      evaluate(t) {
        return this.boundExpression.evaluate(t);
      }
      eachChild() {}
      outputDefined() {
        return !1;
      }
    }
    class ti {
      constructor(t, e, i) {
        (this.type = t), (this.index = e), (this.input = i);
      }
      static parse(t, e) {
        if (3 !== t.length)
          return e.error(
            `Expected 2 arguments, but found ${t.length - 1} instead.`
          );
        const i = e.parse(t[1], 1, Ot),
          r = e.parse(t[2], 2, Yt(e.expectedType || Ut));
        return i && r ? new ti(r.type.itemType, i, r) : null;
      }
      evaluate(t) {
        const e = this.index.evaluate(t),
          i = this.input.evaluate(t);
        if (e < 0) throw new ke(`Array index out of bounds: ${e} < 0.`);
        if (e >= i.length)
          throw new ke(`Array index out of bounds: ${e} > ${i.length - 1}.`);
        if (e !== Math.floor(e))
          throw new ke(
            `Array index must be an integer, but found ${e} instead.`
          );
        return i[e];
      }
      eachChild(t) {
        t(this.index), t(this.input);
      }
      outputDefined() {
        return !1;
      }
    }
    class ei {
      constructor(t, e) {
        (this.type = Bt), (this.needle = t), (this.haystack = e);
      }
      static parse(t, e) {
        if (3 !== t.length)
          return e.error(
            `Expected 2 arguments, but found ${t.length - 1} instead.`
          );
        const i = e.parse(t[1], 1, Ut),
          r = e.parse(t[2], 2, Ut);
        return i && r
          ? te(i.type, [Bt, Ft, Ot, kt, Ut])
            ? new ei(i, r)
            : e.error(
                `Expected first argument to be of type boolean, string, number or null, but found ${Kt(
                  i.type
                )} instead`
              )
          : null;
      }
      evaluate(t) {
        const e = this.needle.evaluate(t),
          i = this.haystack.evaluate(t);
        if (!i) return !1;
        if (!ee(e, ['boolean', 'string', 'number', 'null']))
          throw new ke(
            `Expected first argument to be of type boolean, string, number or null, but found ${Kt(
              Ue(e)
            )} instead.`
          );
        if (!ee(i, ['string', 'array']))
          throw new ke(
            `Expected second argument to be of type array or string, but found ${Kt(
              Ue(i)
            )} instead.`
          );
        return i.indexOf(e) >= 0;
      }
      eachChild(t) {
        t(this.needle), t(this.haystack);
      }
      outputDefined() {
        return !0;
      }
    }
    class ii {
      constructor(t, e, i) {
        (this.type = Ot),
          (this.needle = t),
          (this.haystack = e),
          (this.fromIndex = i);
      }
      static parse(t, e) {
        if (t.length <= 2 || t.length >= 5)
          return e.error(
            `Expected 2 or 3 arguments, but found ${t.length - 1} instead.`
          );
        const i = e.parse(t[1], 1, Ut),
          r = e.parse(t[2], 2, Ut);
        if (!i || !r) return null;
        if (!te(i.type, [Bt, Ft, Ot, kt, Ut]))
          return e.error(
            `Expected first argument to be of type boolean, string, number or null, but found ${Kt(
              i.type
            )} instead`
          );
        if (4 === t.length) {
          const n = e.parse(t[3], 3, Ot);
          return n ? new ii(i, r, n) : null;
        }
        return new ii(i, r);
      }
      evaluate(t) {
        const e = this.needle.evaluate(t),
          i = this.haystack.evaluate(t);
        if (!ee(e, ['boolean', 'string', 'number', 'null']))
          throw new ke(
            `Expected first argument to be of type boolean, string, number or null, but found ${Kt(
              Ue(e)
            )} instead.`
          );
        let r;
        if (
          (this.fromIndex && (r = this.fromIndex.evaluate(t)),
          ee(i, ['string']))
        ) {
          const t = i.indexOf(e, r);
          return -1 === t ? -1 : [...i.slice(0, t)].length;
        }
        if (ee(i, ['array'])) return i.indexOf(e, r);
        throw new ke(
          `Expected second argument to be of type array or string, but found ${Kt(
            Ue(i)
          )} instead.`
        );
      }
      eachChild(t) {
        t(this.needle), t(this.haystack), this.fromIndex && t(this.fromIndex);
      }
      outputDefined() {
        return !1;
      }
    }
    class ri {
      constructor(t, e, i, r, n, a) {
        (this.inputType = t),
          (this.type = e),
          (this.input = i),
          (this.cases = r),
          (this.outputs = n),
          (this.otherwise = a);
      }
      static parse(t, e) {
        if (t.length < 5)
          return e.error(
            `Expected at least 4 arguments, but found only ${t.length - 1}.`
          );
        if (t.length % 2 != 1)
          return e.error('Expected an even number of arguments.');
        let i, r;
        e.expectedType &&
          'value' !== e.expectedType.kind &&
          (r = e.expectedType);
        const n = {},
          a = [];
        for (let l = 2; l < t.length - 1; l += 2) {
          let s = t[l];
          const o = t[l + 1];
          Array.isArray(s) || (s = [s]);
          const c = e.concat(l);
          if (0 === s.length)
            return c.error('Expected at least one branch label.');
          for (const t of s) {
            if ('number' != typeof t && 'string' != typeof t)
              return c.error('Branch labels must be numbers or strings.');
            if ('number' == typeof t && Math.abs(t) > Number.MAX_SAFE_INTEGER)
              return c.error(
                `Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`
              );
            if ('number' == typeof t && Math.floor(t) !== t)
              return c.error('Numeric branch labels must be integer values.');
            if (i) {
              if (c.checkSubtype(i, Ue(t))) return null;
            } else i = Ue(t);
            if (void 0 !== n[String(t)])
              return c.error('Branch labels must be unique.');
            n[String(t)] = a.length;
          }
          const h = e.parse(o, l, r);
          if (!h) return null;
          (r = r || h.type), a.push(h);
        }
        const s = e.parse(t[1], 1, Ut);
        if (!s) return null;
        const o = e.parse(t[t.length - 1], t.length - 1, r);
        return o
          ? 'value' !== s.type.kind && e.concat(1).checkSubtype(i, s.type)
            ? null
            : new ri(i, r, s, n, a, o)
          : null;
      }
      evaluate(t) {
        const e = this.input.evaluate(t);
        return (
          (Ue(e) === this.inputType && this.outputs[this.cases[e]]) ||
          this.otherwise
        ).evaluate(t);
      }
      eachChild(t) {
        t(this.input), this.outputs.forEach(t), t(this.otherwise);
      }
      outputDefined() {
        return (
          this.outputs.every((t) => t.outputDefined()) &&
          this.otherwise.outputDefined()
        );
      }
    }
    class ni {
      constructor(t, e, i) {
        (this.type = t), (this.branches = e), (this.otherwise = i);
      }
      static parse(t, e) {
        if (t.length < 4)
          return e.error(
            `Expected at least 3 arguments, but found only ${t.length - 1}.`
          );
        if (t.length % 2 != 0)
          return e.error('Expected an odd number of arguments.');
        let i;
        e.expectedType &&
          'value' !== e.expectedType.kind &&
          (i = e.expectedType);
        const r = [];
        for (let a = 1; a < t.length - 1; a += 2) {
          const n = e.parse(t[a], a, Bt);
          if (!n) return null;
          const s = e.parse(t[a + 1], a + 1, i);
          if (!s) return null;
          r.push([n, s]), (i = i || s.type);
        }
        const n = e.parse(t[t.length - 1], t.length - 1, i);
        if (!n) return null;
        if (!i) throw new Error("Can't infer output type");
        return new ni(i, r, n);
      }
      evaluate(t) {
        for (const [e, i] of this.branches)
          if (e.evaluate(t)) return i.evaluate(t);
        return this.otherwise.evaluate(t);
      }
      eachChild(t) {
        for (const [e, i] of this.branches) t(e), t(i);
        t(this.otherwise);
      }
      outputDefined() {
        return (
          this.branches.every(([t, e]) => e.outputDefined()) &&
          this.otherwise.outputDefined()
        );
      }
    }
    class ai {
      constructor(t, e, i, r) {
        (this.type = t),
          (this.input = e),
          (this.beginIndex = i),
          (this.endIndex = r);
      }
      static parse(t, e) {
        if (t.length <= 2 || t.length >= 5)
          return e.error(
            `Expected 2 or 3 arguments, but found ${t.length - 1} instead.`
          );
        const i = e.parse(t[1], 1, Ut),
          r = e.parse(t[2], 2, Ot);
        if (!i || !r) return null;
        if (!te(i.type, [Yt(Ut), Ft, Ut]))
          return e.error(
            `Expected first argument to be of type array or string, but found ${Kt(
              i.type
            )} instead`
          );
        if (4 === t.length) {
          const n = e.parse(t[3], 3, Ot);
          return n ? new ai(i.type, i, r, n) : null;
        }
        return new ai(i.type, i, r);
      }
      evaluate(t) {
        const e = this.input.evaluate(t),
          i = this.beginIndex.evaluate(t);
        let r;
        if (
          (this.endIndex && (r = this.endIndex.evaluate(t)), ee(e, ['string']))
        )
          return [...e].slice(i, r).join('');
        if (ee(e, ['array'])) return e.slice(i, r);
        throw new ke(
          `Expected first argument to be of type array or string, but found ${Kt(
            Ue(e)
          )} instead.`
        );
      }
      eachChild(t) {
        t(this.input), t(this.beginIndex), this.endIndex && t(this.endIndex);
      }
      outputDefined() {
        return !1;
      }
    }
    function si(t, e) {
      const i = t.length - 1;
      let r,
        n,
        a = 0,
        s = i,
        o = 0;
      for (; a <= s; )
        if (
          ((o = Math.floor((a + s) / 2)), (r = t[o]), (n = t[o + 1]), r <= e)
        ) {
          if (o === i || e < n) return o;
          a = o + 1;
        } else {
          if (!(r > e)) throw new ke('Input is not a number.');
          s = o - 1;
        }
      return 0;
    }
    class oi {
      constructor(t, e, i) {
        (this.type = t),
          (this.input = e),
          (this.labels = []),
          (this.outputs = []);
        for (const [r, n] of i) this.labels.push(r), this.outputs.push(n);
      }
      static parse(t, e) {
        if (t.length - 1 < 4)
          return e.error(
            `Expected at least 4 arguments, but found only ${t.length - 1}.`
          );
        if ((t.length - 1) % 2 != 0)
          return e.error('Expected an even number of arguments.');
        const i = e.parse(t[1], 1, Ot);
        if (!i) return null;
        const r = [];
        let n = null;
        e.expectedType &&
          'value' !== e.expectedType.kind &&
          (n = e.expectedType);
        for (let a = 1; a < t.length; a += 2) {
          const i = 1 === a ? -1 / 0 : t[a],
            s = t[a + 1],
            o = a,
            l = a + 1;
          if ('number' != typeof i)
            return e.error(
              'Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.',
              o
            );
          if (r.length && r[r.length - 1][0] >= i)
            return e.error(
              'Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.',
              o
            );
          const c = e.parse(s, l, n);
          if (!c) return null;
          (n = n || c.type), r.push([i, c]);
        }
        return new oi(n, i, r);
      }
      evaluate(t) {
        const e = this.labels,
          i = this.outputs;
        if (1 === e.length) return i[0].evaluate(t);
        const r = this.input.evaluate(t);
        if (r <= e[0]) return i[0].evaluate(t);
        const n = e.length;
        return r >= e[n - 1] ? i[n - 1].evaluate(t) : i[si(e, r)].evaluate(t);
      }
      eachChild(t) {
        t(this.input);
        for (const e of this.outputs) t(e);
      }
      outputDefined() {
        return this.outputs.every((t) => t.outputDefined());
      }
    }
    function li(t) {
      return t &&
        t.__esModule &&
        Object.prototype.hasOwnProperty.call(t, 'default')
        ? t.default
        : t;
    }
    var ci,
      hi,
      ui = (function () {
        if (hi) return ci;
        function t(t, e, i, r) {
          (this.cx = 3 * t),
            (this.bx = 3 * (i - t) - this.cx),
            (this.ax = 1 - this.cx - this.bx),
            (this.cy = 3 * e),
            (this.by = 3 * (r - e) - this.cy),
            (this.ay = 1 - this.cy - this.by),
            (this.p1x = t),
            (this.p1y = e),
            (this.p2x = i),
            (this.p2y = r);
        }
        return (
          (hi = 1),
          (ci = t),
          (t.prototype = {
            sampleCurveX: function (t) {
              return ((this.ax * t + this.bx) * t + this.cx) * t;
            },
            sampleCurveY: function (t) {
              return ((this.ay * t + this.by) * t + this.cy) * t;
            },
            sampleCurveDerivativeX: function (t) {
              return (3 * this.ax * t + 2 * this.bx) * t + this.cx;
            },
            solveCurveX: function (t, e) {
              if ((void 0 === e && (e = 1e-6), t < 0)) return 0;
              if (t > 1) return 1;
              for (var i = t, r = 0; r < 8; r++) {
                var n = this.sampleCurveX(i) - t;
                if (Math.abs(n) < e) return i;
                var a = this.sampleCurveDerivativeX(i);
                if (Math.abs(a) < 1e-6) break;
                i -= n / a;
              }
              var s = 0,
                o = 1;
              for (
                i = t, r = 0;
                r < 20 && ((n = this.sampleCurveX(i)), !(Math.abs(n - t) < e));
                r++
              )
                t > n ? (s = i) : (o = i), (i = 0.5 * (o - s) + s);
              return i;
            },
            solve: function (t, e) {
              return this.sampleCurveY(this.solveCurveX(t, e));
            },
          }),
          ci
        );
      })(),
      di = li(ui);
    class pi {
      constructor(t, e, i, r, n) {
        (this.type = t),
          (this.operator = e),
          (this.interpolation = i),
          (this.input = r),
          (this.labels = []),
          (this.outputs = []);
        for (const [a, s] of n) this.labels.push(a), this.outputs.push(s);
      }
      static interpolationFactor(t, e, i, r) {
        let n = 0;
        if ('exponential' === t.name) n = fi(e, t.base, i, r);
        else if ('linear' === t.name) n = fi(e, 1, i, r);
        else if ('cubic-bezier' === t.name) {
          const a = t.controlPoints;
          n = new di(a[0], a[1], a[2], a[3]).solve(fi(e, 1, i, r));
        }
        return n;
      }
      static parse(t, e) {
        let [i, r, n, ...a] = t;
        if (!Array.isArray(r) || 0 === r.length)
          return e.error('Expected an interpolation type expression.', 1);
        if ('linear' === r[0]) r = { name: 'linear' };
        else if ('exponential' === r[0]) {
          const t = r[1];
          if ('number' != typeof t)
            return e.error(
              'Exponential interpolation requires a numeric base.',
              1,
              1
            );
          r = { name: 'exponential', base: t };
        } else {
          if ('cubic-bezier' !== r[0])
            return e.error(`Unknown interpolation type ${String(r[0])}`, 1, 0);
          {
            const t = r.slice(1);
            if (
              4 !== t.length ||
              t.some((t) => 'number' != typeof t || t < 0 || t > 1)
            )
              return e.error(
                'Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.',
                1
              );
            r = { name: 'cubic-bezier', controlPoints: t };
          }
        }
        if (t.length - 1 < 4)
          return e.error(
            `Expected at least 4 arguments, but found only ${t.length - 1}.`
          );
        if ((t.length - 1) % 2 != 0)
          return e.error('Expected an even number of arguments.');
        if (((n = e.parse(n, 2, Ot)), !n)) return null;
        const s = [];
        let o = null;
        ('interpolate-hcl' !== i && 'interpolate-lab' !== i) ||
        e.expectedType == qt
          ? e.expectedType &&
            'value' !== e.expectedType.kind &&
            (o = e.expectedType)
          : (o = Nt);
        for (let l = 0; l < a.length; l += 2) {
          const t = a[l],
            i = a[l + 1],
            r = l + 3,
            n = l + 4;
          if ('number' != typeof t)
            return e.error(
              'Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.',
              r
            );
          if (s.length && s[s.length - 1][0] >= t)
            return e.error(
              'Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.',
              r
            );
          const c = e.parse(i, n, o);
          if (!c) return null;
          (o = o || c.type), s.push([t, c]);
        }
        return ie(o, Ot) ||
          ie(o, Vt) ||
          ie(o, Nt) ||
          ie(o, $t) ||
          ie(o, Ht) ||
          ie(o, qt) ||
          ie(o, Xt) ||
          ie(o, Yt(Ot))
          ? new pi(o, i, r, n, s)
          : e.error(`Type ${Kt(o)} is not interpolatable.`);
      }
      evaluate(t) {
        const e = this.labels,
          i = this.outputs;
        if (1 === e.length) return i[0].evaluate(t);
        const r = this.input.evaluate(t);
        if (r <= e[0]) return i[0].evaluate(t);
        const n = e.length;
        if (r >= e[n - 1]) return i[n - 1].evaluate(t);
        const a = si(e, r),
          s = pi.interpolationFactor(this.interpolation, r, e[a], e[a + 1]),
          o = i[a].evaluate(t),
          l = i[a + 1].evaluate(t);
        switch (this.operator) {
          case 'interpolate':
            switch (this.type.kind) {
              case 'number':
                return Ce(o, l, s);
              case 'color':
                return Se.interpolate(o, l, s);
              case 'padding':
                return Ee.interpolate(o, l, s);
              case 'colorArray':
                return ze.interpolate(o, l, s);
              case 'numberArray':
                return Re.interpolate(o, l, s);
              case 'variableAnchorOffsetCollection':
                return Fe.interpolate(o, l, s);
              case 'array':
                return Ie(o, l, s);
              case 'projectionDefinition':
                return Ne.interpolate(o, l, s);
            }
          case 'interpolate-hcl':
            switch (this.type.kind) {
              case 'color':
                return Se.interpolate(o, l, s, 'hcl');
              case 'colorArray':
                return ze.interpolate(o, l, s, 'hcl');
            }
          case 'interpolate-lab':
            switch (this.type.kind) {
              case 'color':
                return Se.interpolate(o, l, s, 'lab');
              case 'colorArray':
                return ze.interpolate(o, l, s, 'lab');
            }
        }
      }
      eachChild(t) {
        t(this.input);
        for (const e of this.outputs) t(e);
      }
      outputDefined() {
        return this.outputs.every((t) => t.outputDefined());
      }
    }
    function fi(t, e, i, r) {
      const n = r - i,
        a = t - i;
      return 0 === n
        ? 0
        : 1 === e
        ? a / n
        : (Math.pow(e, a) - 1) / (Math.pow(e, n) - 1);
    }
    const mi = {
      color: Se.interpolate,
      number: Ce,
      padding: Ee.interpolate,
      numberArray: Re.interpolate,
      colorArray: ze.interpolate,
      variableAnchorOffsetCollection: Fe.interpolate,
      array: Ie,
    };
    class gi {
      constructor(t, e) {
        (this.type = t), (this.args = e);
      }
      static parse(t, e) {
        if (t.length < 2) return e.error('Expected at least one argument.');
        let i = null;
        const r = e.expectedType;
        r && 'value' !== r.kind && (i = r);
        const n = [];
        for (const s of t.slice(1)) {
          const t = e.parse(s, 1 + n.length, i, void 0, {
            typeAnnotation: 'omit',
          });
          if (!t) return null;
          (i = i || t.type), n.push(t);
        }
        if (!i) throw new Error('No output type');
        const a = r && n.some((t) => Qt(r, t.type));
        return new gi(a ? Ut : i, n);
      }
      evaluate(t) {
        let e,
          i = null,
          r = 0;
        for (const n of this.args)
          if (
            (r++,
            (i = n.evaluate(t)),
            i &&
              i instanceof Be &&
              !i.available &&
              (e || (e = i.name),
              (i = null),
              r === this.args.length && (i = e)),
            null !== i)
          )
            break;
        return i;
      }
      eachChild(t) {
        this.args.forEach(t);
      }
      outputDefined() {
        return this.args.every((t) => t.outputDefined());
      }
    }
    function _i(t, e) {
      return '==' === t || '!=' === t
        ? 'boolean' === e.kind ||
            'string' === e.kind ||
            'number' === e.kind ||
            'null' === e.kind ||
            'value' === e.kind
        : 'string' === e.kind || 'number' === e.kind || 'value' === e.kind;
    }
    function yi(t, e, i, r) {
      return 0 === r.compare(e, i);
    }
    function vi(t, e, i) {
      const r = '==' !== t && '!=' !== t;
      return class n {
        constructor(t, e, i) {
          (this.type = Bt),
            (this.lhs = t),
            (this.rhs = e),
            (this.collator = i),
            (this.hasUntypedArgument =
              'value' === t.type.kind || 'value' === e.type.kind);
        }
        static parse(t, e) {
          if (3 !== t.length && 4 !== t.length)
            return e.error('Expected two or three arguments.');
          const i = t[0];
          let a = e.parse(t[1], 1, Ut);
          if (!a) return null;
          if (!_i(i, a.type))
            return e
              .concat(1)
              .error(
                `"${i}" comparisons are not supported for type '${Kt(a.type)}'.`
              );
          let s = e.parse(t[2], 2, Ut);
          if (!s) return null;
          if (!_i(i, s.type))
            return e
              .concat(2)
              .error(
                `"${i}" comparisons are not supported for type '${Kt(s.type)}'.`
              );
          if (
            a.type.kind !== s.type.kind &&
            'value' !== a.type.kind &&
            'value' !== s.type.kind
          )
            return e.error(
              `Cannot compare types '${Kt(a.type)}' and '${Kt(s.type)}'.`
            );
          r &&
            ('value' === a.type.kind && 'value' !== s.type.kind
              ? (a = new qe(s.type, [a]))
              : 'value' !== a.type.kind &&
                'value' === s.type.kind &&
                (s = new qe(a.type, [s])));
          let o = null;
          if (4 === t.length) {
            if (
              'string' !== a.type.kind &&
              'string' !== s.type.kind &&
              'value' !== a.type.kind &&
              'value' !== s.type.kind
            )
              return e.error(
                'Cannot use collator to compare non-string types.'
              );
            if (((o = e.parse(t[3], 3, Gt)), !o)) return null;
          }
          return new n(a, s, o);
        }
        evaluate(n) {
          const a = this.lhs.evaluate(n),
            s = this.rhs.evaluate(n);
          if (r && this.hasUntypedArgument) {
            const e = Ue(a),
              i = Ue(s);
            if (
              e.kind !== i.kind ||
              ('string' !== e.kind && 'number' !== e.kind)
            )
              throw new ke(
                `Expected arguments for "${t}" to be (string, string) or (number, number), but found (${e.kind}, ${i.kind}) instead.`
              );
          }
          if (this.collator && !r && this.hasUntypedArgument) {
            const t = Ue(a),
              i = Ue(s);
            if ('string' !== t.kind || 'string' !== i.kind) return e(n, a, s);
          }
          return this.collator
            ? i(n, a, s, this.collator.evaluate(n))
            : e(n, a, s);
        }
        eachChild(t) {
          t(this.lhs), t(this.rhs), this.collator && t(this.collator);
        }
        outputDefined() {
          return !0;
        }
      };
    }
    const xi = vi(
        '==',
        function (t, e, i) {
          return e === i;
        },
        yi
      ),
      bi = vi(
        '!=',
        function (t, e, i) {
          return e !== i;
        },
        function (t, e, i, r) {
          return !yi(0, e, i, r);
        }
      ),
      wi = vi(
        '<',
        function (t, e, i) {
          return e < i;
        },
        function (t, e, i, r) {
          return r.compare(e, i) < 0;
        }
      ),
      Ti = vi(
        '>',
        function (t, e, i) {
          return e > i;
        },
        function (t, e, i, r) {
          return r.compare(e, i) > 0;
        }
      ),
      Pi = vi(
        '<=',
        function (t, e, i) {
          return e <= i;
        },
        function (t, e, i, r) {
          return r.compare(e, i) <= 0;
        }
      ),
      Ci = vi(
        '>=',
        function (t, e, i) {
          return e >= i;
        },
        function (t, e, i, r) {
          return r.compare(e, i) >= 0;
        }
      );
    class Ii {
      constructor(t, e, i) {
        (this.type = Gt),
          (this.locale = i),
          (this.caseSensitive = t),
          (this.diacriticSensitive = e);
      }
      static parse(t, e) {
        if (2 !== t.length) return e.error('Expected one argument.');
        const i = t[1];
        if ('object' != typeof i || Array.isArray(i))
          return e.error('Collator options argument must be an object.');
        const r = e.parse(
          void 0 !== i['case-sensitive'] && i['case-sensitive'],
          1,
          Bt
        );
        if (!r) return null;
        const n = e.parse(
          void 0 !== i['diacritic-sensitive'] && i['diacritic-sensitive'],
          1,
          Bt
        );
        if (!n) return null;
        let a = null;
        return i.locale && ((a = e.parse(i.locale, 1, Ft)), !a)
          ? null
          : new Ii(r, n, a);
      }
      evaluate(t) {
        return new Me(
          this.caseSensitive.evaluate(t),
          this.diacriticSensitive.evaluate(t),
          this.locale ? this.locale.evaluate(t) : null
        );
      }
      eachChild(t) {
        t(this.caseSensitive),
          t(this.diacriticSensitive),
          this.locale && t(this.locale);
      }
      outputDefined() {
        return !1;
      }
    }
    class Si {
      constructor(t, e, i, r, n) {
        (this.type = Ft),
          (this.number = t),
          (this.locale = e),
          (this.currency = i),
          (this.minFractionDigits = r),
          (this.maxFractionDigits = n);
      }
      static parse(t, e) {
        if (3 !== t.length) return e.error('Expected two arguments.');
        const i = e.parse(t[1], 1, Ot);
        if (!i) return null;
        const r = t[2];
        if ('object' != typeof r || Array.isArray(r))
          return e.error('NumberFormat options argument must be an object.');
        let n = null;
        if (r.locale && ((n = e.parse(r.locale, 1, Ft)), !n)) return null;
        let a = null;
        if (r.currency && ((a = e.parse(r.currency, 1, Ft)), !a)) return null;
        let s = null;
        if (
          r['min-fraction-digits'] &&
          ((s = e.parse(r['min-fraction-digits'], 1, Ot)), !s)
        )
          return null;
        let o = null;
        return r['max-fraction-digits'] &&
          ((o = e.parse(r['max-fraction-digits'], 1, Ot)), !o)
          ? null
          : new Si(i, n, a, s, o);
      }
      evaluate(t) {
        return new Intl.NumberFormat(
          this.locale ? this.locale.evaluate(t) : [],
          {
            style: this.currency ? 'currency' : 'decimal',
            currency: this.currency ? this.currency.evaluate(t) : void 0,
            minimumFractionDigits: this.minFractionDigits
              ? this.minFractionDigits.evaluate(t)
              : void 0,
            maximumFractionDigits: this.maxFractionDigits
              ? this.maxFractionDigits.evaluate(t)
              : void 0,
          }
        ).format(this.number.evaluate(t));
      }
      eachChild(t) {
        t(this.number),
          this.locale && t(this.locale),
          this.currency && t(this.currency),
          this.minFractionDigits && t(this.minFractionDigits),
          this.maxFractionDigits && t(this.maxFractionDigits);
      }
      outputDefined() {
        return !1;
      }
    }
    class Mi {
      constructor(t) {
        (this.type = Zt), (this.sections = t);
      }
      static parse(t, e) {
        if (t.length < 2) return e.error('Expected at least one argument.');
        const i = t[1];
        if (!Array.isArray(i) && 'object' == typeof i)
          return e.error('First argument must be an image or text section.');
        const r = [];
        let n = !1;
        for (let a = 1; a <= t.length - 1; ++a) {
          const i = t[a];
          if (n && 'object' == typeof i && !Array.isArray(i)) {
            n = !1;
            let t = null;
            if (i['font-scale'] && ((t = e.parse(i['font-scale'], 1, Ot)), !t))
              return null;
            let a = null;
            if (
              i['text-font'] &&
              ((a = e.parse(i['text-font'], 1, Yt(Ft))), !a)
            )
              return null;
            let s = null;
            if (i['text-color'] && ((s = e.parse(i['text-color'], 1, Nt)), !s))
              return null;
            let o = null;
            if (i['vertical-align']) {
              if (
                'string' == typeof i['vertical-align'] &&
                !De.includes(i['vertical-align'])
              )
                return e.error(
                  `'vertical-align' must be one of: 'bottom', 'center', 'top' but found '${i['vertical-align']}' instead.`
                );
              if (((o = e.parse(i['vertical-align'], 1, Ft)), !o)) return null;
            }
            const l = r[r.length - 1];
            (l.scale = t),
              (l.font = a),
              (l.textColor = s),
              (l.verticalAlign = o);
          } else {
            const i = e.parse(t[a], 1, Ut);
            if (!i) return null;
            const s = i.type.kind;
            if (
              'string' !== s &&
              'value' !== s &&
              'null' !== s &&
              'resolvedImage' !== s
            )
              return e.error(
                "Formatted text type must be 'string', 'value', 'image' or 'null'."
              );
            (n = !0),
              r.push({
                content: i,
                scale: null,
                font: null,
                textColor: null,
                verticalAlign: null,
              });
          }
        }
        return new Mi(r);
      }
      evaluate(t) {
        return new Ae(
          this.sections.map((e) => {
            const i = e.content.evaluate(t);
            return Ue(i) === Wt
              ? new Le(
                  '',
                  i,
                  null,
                  null,
                  null,
                  e.verticalAlign ? e.verticalAlign.evaluate(t) : null
                )
              : new Le(
                  Ge(i),
                  null,
                  e.scale ? e.scale.evaluate(t) : null,
                  e.font ? e.font.evaluate(t).join(',') : null,
                  e.textColor ? e.textColor.evaluate(t) : null,
                  e.verticalAlign ? e.verticalAlign.evaluate(t) : null
                );
          })
        );
      }
      eachChild(t) {
        for (const e of this.sections)
          t(e.content),
            e.scale && t(e.scale),
            e.font && t(e.font),
            e.textColor && t(e.textColor),
            e.verticalAlign && t(e.verticalAlign);
      }
      outputDefined() {
        return !1;
      }
    }
    class Di {
      constructor(t) {
        (this.type = Wt), (this.input = t);
      }
      static parse(t, e) {
        if (2 !== t.length) return e.error('Expected two arguments.');
        const i = e.parse(t[1], 1, Ft);
        return i ? new Di(i) : e.error('No image name provided.');
      }
      evaluate(t) {
        const e = this.input.evaluate(t),
          i = Be.fromString(e);
        return (
          i &&
            t.availableImages &&
            (i.available = t.availableImages.indexOf(e) > -1),
          i
        );
      }
      eachChild(t) {
        t(this.input);
      }
      outputDefined() {
        return !1;
      }
    }
    class Li {
      constructor(t) {
        (this.type = Ot), (this.input = t);
      }
      static parse(t, e) {
        if (2 !== t.length)
          return e.error(
            `Expected 1 argument, but found ${t.length - 1} instead.`
          );
        const i = e.parse(t[1], 1);
        return i
          ? 'array' !== i.type.kind &&
            'string' !== i.type.kind &&
            'value' !== i.type.kind
            ? e.error(
                `Expected argument of type string or array, but found ${Kt(
                  i.type
                )} instead.`
              )
            : new Li(i)
          : null;
      }
      evaluate(t) {
        const e = this.input.evaluate(t);
        if ('string' == typeof e) return [...e].length;
        if (Array.isArray(e)) return e.length;
        throw new ke(
          `Expected value to be of type string or array, but found ${Kt(
            Ue(e)
          )} instead.`
        );
      }
      eachChild(t) {
        t(this.input);
      }
      outputDefined() {
        return !1;
      }
    }
    const Ai = 8192;
    function Ei(t, e) {
      const i = (180 + t[0]) / 360,
        r =
          (180 -
            (180 / Math.PI) *
              Math.log(Math.tan(Math.PI / 4 + (t[1] * Math.PI) / 360))) /
          360,
        n = Math.pow(2, e.z);
      return [Math.round(i * n * Ai), Math.round(r * n * Ai)];
    }
    function Ri(t, e) {
      const i = Math.pow(2, e.z);
      return [
        ((n = (t[0] / Ai + e.x) / i), 360 * n - 180),
        ((r = (t[1] / Ai + e.y) / i),
        (360 / Math.PI) *
          Math.atan(Math.exp(((180 - 360 * r) * Math.PI) / 180)) -
          90),
      ];
      var r, n;
    }
    function zi(t, e) {
      (t[0] = Math.min(t[0], e[0])),
        (t[1] = Math.min(t[1], e[1])),
        (t[2] = Math.max(t[2], e[0])),
        (t[3] = Math.max(t[3], e[1]));
    }
    function ki(t, e) {
      return !(t[0] <= e[0] || t[2] >= e[2] || t[1] <= e[1] || t[3] >= e[3]);
    }
    function Oi(t, e, i) {
      const r = t[0] - e[0],
        n = t[1] - e[1],
        a = t[0] - i[0],
        s = t[1] - i[1];
      return r * s - a * n == 0 && r * a <= 0 && n * s <= 0;
    }
    function Fi(t, e, i, r) {
      return (
        0 !=
          (n = [r[0] - i[0], r[1] - i[1]])[0] *
            (a = [e[0] - t[0], e[1] - t[1]])[1] -
            n[1] * a[0] && !(!Gi(t, e, i, r) || !Gi(i, r, t, e))
      );
      var n, a;
    }
    function Bi(t, e, i) {
      for (const r of i)
        for (let i = 0; i < r.length - 1; ++i)
          if (Fi(t, e, r[i], r[i + 1])) return !0;
      return !1;
    }
    function Ni(t, e, i = !1) {
      let r = !1;
      for (const o of e)
        for (let e = 0; e < o.length - 1; e++) {
          if (Oi(t, o[e], o[e + 1])) return i;
          (a = o[e])[1] > (n = t)[1] != (s = o[e + 1])[1] > n[1] &&
            n[0] < ((s[0] - a[0]) * (n[1] - a[1])) / (s[1] - a[1]) + a[0] &&
            (r = !r);
        }
      var n, a, s;
      return r;
    }
    function Vi(t, e) {
      for (const i of e) if (Ni(t, i)) return !0;
      return !1;
    }
    function ji(t, e) {
      for (const i of t) if (!Ni(i, e)) return !1;
      for (let i = 0; i < t.length - 1; ++i)
        if (Bi(t[i], t[i + 1], e)) return !1;
      return !0;
    }
    function Ui(t, e) {
      for (const i of e) if (ji(t, i)) return !0;
      return !1;
    }
    function Gi(t, e, i, r) {
      const n = r[0] - i[0],
        a = r[1] - i[1],
        s = (t[0] - i[0]) * a - n * (t[1] - i[1]),
        o = (e[0] - i[0]) * a - n * (e[1] - i[1]);
      return (s > 0 && o < 0) || (s < 0 && o > 0);
    }
    function Zi(t, e, i) {
      const r = [];
      for (let n = 0; n < t.length; n++) {
        const a = [];
        for (let r = 0; r < t[n].length; r++) {
          const s = Ei(t[n][r], i);
          zi(e, s), a.push(s);
        }
        r.push(a);
      }
      return r;
    }
    function $i(t, e, i) {
      const r = [];
      for (let n = 0; n < t.length; n++) {
        const a = Zi(t[n], e, i);
        r.push(a);
      }
      return r;
    }
    function qi(t, e, i, r) {
      if (t[0] < i[0] || t[0] > i[2]) {
        const e = 0.5 * r;
        let n = t[0] - i[0] > e ? -r : i[0] - t[0] > e ? r : 0;
        0 === n && (n = t[0] - i[2] > e ? -r : i[2] - t[0] > e ? r : 0),
          (t[0] += n);
      }
      zi(e, t);
    }
    function Hi(t, e, i, r) {
      const n = Math.pow(2, r.z) * Ai,
        a = [r.x * Ai, r.y * Ai],
        s = [];
      for (const o of t)
        for (const t of o) {
          const r = [t.x + a[0], t.y + a[1]];
          qi(r, e, i, n), s.push(r);
        }
      return s;
    }
    function Wi(t, e, i, r) {
      const n = Math.pow(2, r.z) * Ai,
        a = [r.x * Ai, r.y * Ai],
        s = [];
      for (const l of t) {
        const t = [];
        for (const i of l) {
          const r = [i.x + a[0], i.y + a[1]];
          zi(e, r), t.push(r);
        }
        s.push(t);
      }
      if (e[2] - e[0] <= n / 2) {
        ((o = e)[0] = o[1] = 1 / 0), (o[2] = o[3] = -1 / 0);
        for (const t of s) for (const r of t) qi(r, e, i, n);
      }
      var o;
      return s;
    }
    class Xi {
      constructor(t, e) {
        (this.type = Bt), (this.geojson = t), (this.geometries = e);
      }
      static parse(t, e) {
        if (2 !== t.length)
          return e.error(
            `'within' expression requires exactly one argument, but found ${
              t.length - 1
            } instead.`
          );
        if (je(t[1])) {
          const e = t[1];
          if ('FeatureCollection' === e.type) {
            const t = [];
            for (const i of e.features) {
              const { type: e, coordinates: r } = i.geometry;
              'Polygon' === e && t.push(r),
                'MultiPolygon' === e && t.push(...r);
            }
            if (t.length)
              return new Xi(e, { type: 'MultiPolygon', coordinates: t });
          } else if ('Feature' === e.type) {
            const t = e.geometry.type;
            if ('Polygon' === t || 'MultiPolygon' === t)
              return new Xi(e, e.geometry);
          } else if ('Polygon' === e.type || 'MultiPolygon' === e.type)
            return new Xi(e, e);
        }
        return e.error(
          "'within' expression requires valid geojson object that contains polygon geometry type."
        );
      }
      evaluate(t) {
        if (null != t.geometry() && null != t.canonicalID()) {
          if ('Point' === t.geometryType())
            return (function (t, e) {
              const i = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                r = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                n = t.canonicalID();
              if ('Polygon' === e.type) {
                const a = Zi(e.coordinates, r, n),
                  s = Hi(t.geometry(), i, r, n);
                if (!ki(i, r)) return !1;
                for (const t of s) if (!Ni(t, a)) return !1;
              }
              if ('MultiPolygon' === e.type) {
                const a = $i(e.coordinates, r, n),
                  s = Hi(t.geometry(), i, r, n);
                if (!ki(i, r)) return !1;
                for (const t of s) if (!Vi(t, a)) return !1;
              }
              return !0;
            })(t, this.geometries);
          if ('LineString' === t.geometryType())
            return (function (t, e) {
              const i = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                r = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                n = t.canonicalID();
              if ('Polygon' === e.type) {
                const a = Zi(e.coordinates, r, n),
                  s = Wi(t.geometry(), i, r, n);
                if (!ki(i, r)) return !1;
                for (const t of s) if (!ji(t, a)) return !1;
              }
              if ('MultiPolygon' === e.type) {
                const a = $i(e.coordinates, r, n),
                  s = Wi(t.geometry(), i, r, n);
                if (!ki(i, r)) return !1;
                for (const t of s) if (!Ui(t, a)) return !1;
              }
              return !0;
            })(t, this.geometries);
        }
        return !1;
      }
      eachChild() {}
      outputDefined() {
        return !0;
      }
    }
    let Yi = class {
      constructor(t = [], e = (t, e) => (t < e ? -1 : t > e ? 1 : 0)) {
        if (
          ((this.data = t),
          (this.length = this.data.length),
          (this.compare = e),
          this.length > 0)
        )
          for (let i = (this.length >> 1) - 1; i >= 0; i--) this._down(i);
      }
      push(t) {
        this.data.push(t), this._up(this.length++);
      }
      pop() {
        if (0 === this.length) return;
        const t = this.data[0],
          e = this.data.pop();
        return --this.length > 0 && ((this.data[0] = e), this._down(0)), t;
      }
      peek() {
        return this.data[0];
      }
      _up(t) {
        const { data: e, compare: i } = this,
          r = e[t];
        for (; t > 0; ) {
          const n = (t - 1) >> 1,
            a = e[n];
          if (i(r, a) >= 0) break;
          (e[t] = a), (t = n);
        }
        e[t] = r;
      }
      _down(t) {
        const { data: e, compare: i } = this,
          r = this.length >> 1,
          n = e[t];
        for (; t < r; ) {
          let r = 1 + (t << 1);
          const a = r + 1;
          if (
            (a < this.length && i(e[a], e[r]) < 0 && (r = a), i(e[r], n) >= 0)
          )
            break;
          (e[t] = e[r]), (t = r);
        }
        e[t] = n;
      }
    };
    function Ki(t, e, i = 0, r = t.length - 1, n = Qi) {
      for (; r > i; ) {
        if (r - i > 600) {
          const a = r - i + 1,
            s = e - i + 1,
            o = Math.log(a),
            l = 0.5 * Math.exp((2 * o) / 3),
            c =
              0.5 * Math.sqrt((o * l * (a - l)) / a) * (s - a / 2 < 0 ? -1 : 1);
          Ki(
            t,
            e,
            Math.max(i, Math.floor(e - (s * l) / a + c)),
            Math.min(r, Math.floor(e + ((a - s) * l) / a + c)),
            n
          );
        }
        const a = t[e];
        let s = i,
          o = r;
        for (Ji(t, i, e), n(t[r], a) > 0 && Ji(t, i, r); s < o; ) {
          for (Ji(t, s, o), s++, o--; n(t[s], a) < 0; ) s++;
          for (; n(t[o], a) > 0; ) o--;
        }
        0 === n(t[i], a) ? Ji(t, i, o) : (o++, Ji(t, o, r)),
          o <= e && (i = o + 1),
          e <= o && (r = o - 1);
      }
    }
    function Ji(t, e, i) {
      const r = t[e];
      (t[e] = t[i]), (t[i] = r);
    }
    function Qi(t, e) {
      return t < e ? -1 : t > e ? 1 : 0;
    }
    function tr(t, e) {
      if (t.length <= 1) return [t];
      const i = [];
      let r, n;
      for (const a of t) {
        const t = ir(a);
        0 !== t &&
          ((a.area = Math.abs(t)),
          void 0 === n && (n = t < 0),
          n === t < 0 ? (r && i.push(r), (r = [a])) : r.push(a));
      }
      if ((r && i.push(r), e > 1))
        for (let a = 0; a < i.length; a++)
          i[a].length <= e ||
            (Ki(i[a], e, 1, i[a].length - 1, er), (i[a] = i[a].slice(0, e)));
      return i;
    }
    function er(t, e) {
      return e.area - t.area;
    }
    function ir(t) {
      let e = 0;
      for (let i, r, n = 0, a = t.length, s = a - 1; n < a; s = n++)
        (i = t[n]), (r = t[s]), (e += (r.x - i.x) * (i.y + r.y));
      return e;
    }
    const rr = 1 / 298.257223563,
      nr = rr * (2 - rr),
      ar = Math.PI / 180;
    class sr {
      constructor(t) {
        const e = 6378.137 * ar * 1e3,
          i = Math.cos(t * ar),
          r = 1 / (1 - nr * (1 - i * i)),
          n = Math.sqrt(r);
        (this.kx = e * n * i), (this.ky = e * n * r * (1 - nr));
      }
      distance(t, e) {
        const i = this.wrap(t[0] - e[0]) * this.kx,
          r = (t[1] - e[1]) * this.ky;
        return Math.sqrt(i * i + r * r);
      }
      pointOnLine(t, e) {
        let i,
          r,
          n,
          a,
          s = 1 / 0;
        for (let o = 0; o < t.length - 1; o++) {
          let l = t[o][0],
            c = t[o][1],
            h = this.wrap(t[o + 1][0] - l) * this.kx,
            u = (t[o + 1][1] - c) * this.ky,
            d = 0;
          (0 === h && 0 === u) ||
            ((d =
              (this.wrap(e[0] - l) * this.kx * h + (e[1] - c) * this.ky * u) /
              (h * h + u * u)),
            d > 1
              ? ((l = t[o + 1][0]), (c = t[o + 1][1]))
              : d > 0 && ((l += (h / this.kx) * d), (c += (u / this.ky) * d))),
            (h = this.wrap(e[0] - l) * this.kx),
            (u = (e[1] - c) * this.ky);
          const p = h * h + u * u;
          p < s && ((s = p), (i = l), (r = c), (n = o), (a = d));
        }
        return { point: [i, r], index: n, t: Math.max(0, Math.min(1, a)) };
      }
      wrap(t) {
        for (; t < -180; ) t += 360;
        for (; t > 180; ) t -= 360;
        return t;
      }
    }
    function or(t, e) {
      return e[0] - t[0];
    }
    function lr(t) {
      return t[1] - t[0] + 1;
    }
    function cr(t, e) {
      return t[1] >= t[0] && t[1] < e;
    }
    function hr(t, e) {
      if (t[0] > t[1]) return [null, null];
      const i = lr(t);
      if (e) {
        if (2 === i) return [t, null];
        const e = Math.floor(i / 2);
        return [
          [t[0], t[0] + e],
          [t[0] + e, t[1]],
        ];
      }
      if (1 === i) return [t, null];
      const r = Math.floor(i / 2) - 1;
      return [
        [t[0], t[0] + r],
        [t[0] + r + 1, t[1]],
      ];
    }
    function ur(t, e) {
      if (!cr(e, t.length)) return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
      const i = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
      for (let r = e[0]; r <= e[1]; ++r) zi(i, t[r]);
      return i;
    }
    function dr(t) {
      const e = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
      for (const i of t) for (const t of i) zi(e, t);
      return e;
    }
    function pr(t) {
      return (
        t[0] !== -1 / 0 && t[1] !== -1 / 0 && t[2] !== 1 / 0 && t[3] !== 1 / 0
      );
    }
    function fr(t, e, i) {
      if (!pr(t) || !pr(e)) return NaN;
      let r = 0,
        n = 0;
      return (
        t[2] < e[0] && (r = e[0] - t[2]),
        t[0] > e[2] && (r = t[0] - e[2]),
        t[1] > e[3] && (n = t[1] - e[3]),
        t[3] < e[1] && (n = e[1] - t[3]),
        i.distance([0, 0], [r, n])
      );
    }
    function mr(t, e, i) {
      const r = i.pointOnLine(e, t);
      return i.distance(t, r.point);
    }
    function gr(t, e, i, r, n) {
      const a = Math.min(mr(t, [i, r], n), mr(e, [i, r], n)),
        s = Math.min(mr(i, [t, e], n), mr(r, [t, e], n));
      return Math.min(a, s);
    }
    function _r(t, e, i, r, n) {
      if (!cr(e, t.length) || !cr(r, i.length)) return 1 / 0;
      let a = 1 / 0;
      for (let s = e[0]; s < e[1]; ++s) {
        const e = t[s],
          o = t[s + 1];
        for (let t = r[0]; t < r[1]; ++t) {
          const r = i[t],
            s = i[t + 1];
          if (Fi(e, o, r, s)) return 0;
          a = Math.min(a, gr(e, o, r, s, n));
        }
      }
      return a;
    }
    function yr(t, e, i, r, n) {
      if (!cr(e, t.length) || !cr(r, i.length)) return NaN;
      let a = 1 / 0;
      for (let s = e[0]; s <= e[1]; ++s)
        for (let e = r[0]; e <= r[1]; ++e)
          if (((a = Math.min(a, n.distance(t[s], i[e]))), 0 === a)) return a;
      return a;
    }
    function vr(t, e, i) {
      if (Ni(t, e, !0)) return 0;
      let r = 1 / 0;
      for (const n of e) {
        const e = n[0],
          a = n[n.length - 1];
        if (e !== a && ((r = Math.min(r, mr(t, [a, e], i))), 0 === r)) return r;
        const s = i.pointOnLine(n, t);
        if (((r = Math.min(r, i.distance(t, s.point))), 0 === r)) return r;
      }
      return r;
    }
    function xr(t, e, i, r) {
      if (!cr(e, t.length)) return NaN;
      for (let a = e[0]; a <= e[1]; ++a) if (Ni(t[a], i, !0)) return 0;
      let n = 1 / 0;
      for (let a = e[0]; a < e[1]; ++a) {
        const e = t[a],
          s = t[a + 1];
        for (const t of i)
          for (let i = 0, a = t.length, o = a - 1; i < a; o = i++) {
            const a = t[o],
              l = t[i];
            if (Fi(e, s, a, l)) return 0;
            n = Math.min(n, gr(e, s, a, l, r));
          }
      }
      return n;
    }
    function br(t, e) {
      for (const i of t) for (const t of i) if (Ni(t, e, !0)) return !0;
      return !1;
    }
    function wr(t, e, i, r = 1 / 0) {
      const n = dr(t),
        a = dr(e);
      if (r !== 1 / 0 && fr(n, a, i) >= r) return r;
      if (ki(n, a)) {
        if (br(t, e)) return 0;
      } else if (br(e, t)) return 0;
      let s = 1 / 0;
      for (const o of t)
        for (let t = 0, r = o.length, n = r - 1; t < r; n = t++) {
          const r = o[n],
            a = o[t];
          for (const t of e)
            for (let e = 0, n = t.length, o = n - 1; e < n; o = e++) {
              const n = t[o],
                l = t[e];
              if (Fi(r, a, n, l)) return 0;
              s = Math.min(s, gr(r, a, n, l, i));
            }
        }
      return s;
    }
    function Tr(t, e, i, r, n, a) {
      if (!a) return;
      const s = fr(ur(r, a), n, i);
      s < e && t.push([s, a, [0, 0]]);
    }
    function Pr(t, e, i, r, n, a, s) {
      if (!a || !s) return;
      const o = fr(ur(r, a), ur(n, s), i);
      o < e && t.push([o, a, s]);
    }
    function Cr(t, e, i, r, n = 1 / 0) {
      let a = Math.min(r.distance(t[0], i[0][0]), n);
      if (0 === a) return a;
      const s = new Yi([[0, [0, t.length - 1], [0, 0]]], or),
        o = dr(i);
      for (; s.length > 0; ) {
        const n = s.pop();
        if (n[0] >= a) continue;
        const l = n[1],
          c = e ? 50 : 100;
        if (lr(l) <= c) {
          if (!cr(l, t.length)) return NaN;
          if (e) {
            const e = xr(t, l, i, r);
            if (isNaN(e) || 0 === e) return e;
            a = Math.min(a, e);
          } else
            for (let e = l[0]; e <= l[1]; ++e) {
              const n = vr(t[e], i, r);
              if (((a = Math.min(a, n)), 0 === a)) return 0;
            }
        } else {
          const i = hr(l, e);
          Tr(s, a, r, t, o, i[0]), Tr(s, a, r, t, o, i[1]);
        }
      }
      return a;
    }
    function Ir(t, e, i, r, n, a = 1 / 0) {
      let s = Math.min(a, n.distance(t[0], i[0]));
      if (0 === s) return s;
      const o = new Yi([[0, [0, t.length - 1], [0, i.length - 1]]], or);
      for (; o.length > 0; ) {
        const a = o.pop();
        if (a[0] >= s) continue;
        const l = a[1],
          c = a[2],
          h = e ? 50 : 100,
          u = r ? 50 : 100;
        if (lr(l) <= h && lr(c) <= u) {
          if (!cr(l, t.length) && cr(c, i.length)) return NaN;
          let a;
          if (e && r) (a = _r(t, l, i, c, n)), (s = Math.min(s, a));
          else if (e && !r) {
            const e = t.slice(l[0], l[1] + 1);
            for (let t = c[0]; t <= c[1]; ++t)
              if (((a = mr(i[t], e, n)), (s = Math.min(s, a)), 0 === s))
                return s;
          } else if (!e && r) {
            const e = i.slice(c[0], c[1] + 1);
            for (let i = l[0]; i <= l[1]; ++i)
              if (((a = mr(t[i], e, n)), (s = Math.min(s, a)), 0 === s))
                return s;
          } else (a = yr(t, l, i, c, n)), (s = Math.min(s, a));
        } else {
          const a = hr(l, e),
            h = hr(c, r);
          Pr(o, s, n, t, i, a[0], h[0]),
            Pr(o, s, n, t, i, a[0], h[1]),
            Pr(o, s, n, t, i, a[1], h[0]),
            Pr(o, s, n, t, i, a[1], h[1]);
        }
      }
      return s;
    }
    function Sr(t) {
      return 'MultiPolygon' === t.type
        ? t.coordinates.map((t) => ({ type: 'Polygon', coordinates: t }))
        : 'MultiLineString' === t.type
        ? t.coordinates.map((t) => ({ type: 'LineString', coordinates: t }))
        : 'MultiPoint' === t.type
        ? t.coordinates.map((t) => ({ type: 'Point', coordinates: t }))
        : [t];
    }
    class Mr {
      constructor(t, e) {
        (this.type = Ot), (this.geojson = t), (this.geometries = e);
      }
      static parse(t, e) {
        if (2 !== t.length)
          return e.error(
            `'distance' expression requires exactly one argument, but found ${
              t.length - 1
            } instead.`
          );
        if (je(t[1])) {
          const e = t[1];
          if ('FeatureCollection' === e.type)
            return new Mr(e, e.features.map((t) => Sr(t.geometry)).flat());
          if ('Feature' === e.type) return new Mr(e, Sr(e.geometry));
          if ('type' in e && 'coordinates' in e) return new Mr(e, Sr(e));
        }
        return e.error(
          "'distance' expression requires valid geojson object that contains polygon geometry type."
        );
      }
      evaluate(t) {
        if (null != t.geometry() && null != t.canonicalID()) {
          if ('Point' === t.geometryType())
            return (function (t, e) {
              const i = t.geometry(),
                r = i.flat().map((e) => Ri([e.x, e.y], t.canonical));
              if (0 === i.length) return NaN;
              const n = new sr(r[0][1]);
              let a = 1 / 0;
              for (const s of e) {
                switch (s.type) {
                  case 'Point':
                    a = Math.min(a, Ir(r, !1, [s.coordinates], !1, n, a));
                    break;
                  case 'LineString':
                    a = Math.min(a, Ir(r, !1, s.coordinates, !0, n, a));
                    break;
                  case 'Polygon':
                    a = Math.min(a, Cr(r, !1, s.coordinates, n, a));
                }
                if (0 === a) return a;
              }
              return a;
            })(t, this.geometries);
          if ('LineString' === t.geometryType())
            return (function (t, e) {
              const i = t.geometry(),
                r = i.flat().map((e) => Ri([e.x, e.y], t.canonical));
              if (0 === i.length) return NaN;
              const n = new sr(r[0][1]);
              let a = 1 / 0;
              for (const s of e) {
                switch (s.type) {
                  case 'Point':
                    a = Math.min(a, Ir(r, !0, [s.coordinates], !1, n, a));
                    break;
                  case 'LineString':
                    a = Math.min(a, Ir(r, !0, s.coordinates, !0, n, a));
                    break;
                  case 'Polygon':
                    a = Math.min(a, Cr(r, !0, s.coordinates, n, a));
                }
                if (0 === a) return a;
              }
              return a;
            })(t, this.geometries);
          if ('Polygon' === t.geometryType())
            return (function (t, e) {
              const i = t.geometry();
              if (0 === i.length || 0 === i[0].length) return NaN;
              const r = tr(i, 0).map((e) =>
                  e.map((e) => e.map((e) => Ri([e.x, e.y], t.canonical)))
                ),
                n = new sr(r[0][0][0][1]);
              let a = 1 / 0;
              for (const s of e)
                for (const t of r) {
                  switch (s.type) {
                    case 'Point':
                      a = Math.min(a, Cr([s.coordinates], !1, t, n, a));
                      break;
                    case 'LineString':
                      a = Math.min(a, Cr(s.coordinates, !0, t, n, a));
                      break;
                    case 'Polygon':
                      a = Math.min(a, wr(t, s.coordinates, n, a));
                  }
                  if (0 === a) return a;
                }
              return a;
            })(t, this.geometries);
        }
        return NaN;
      }
      eachChild() {}
      outputDefined() {
        return !0;
      }
    }
    class Dr {
      constructor(t) {
        (this.type = Ut), (this.key = t);
      }
      static parse(t, e) {
        if (2 !== t.length)
          return e.error(
            `Expected 1 argument, but found ${t.length - 1} instead.`
          );
        const i = t[1];
        return null == i
          ? e.error('Global state property must be defined.')
          : 'string' != typeof i
          ? e.error(
              `Global state property must be string, but found ${typeof t[1]} instead.`
            )
          : new Dr(i);
      }
      evaluate(t) {
        var e;
        const i =
          null === (e = t.globals) || void 0 === e ? void 0 : e.globalState;
        return i && 0 !== Object.keys(i).length ? ve(i, this.key) : null;
      }
      eachChild() {}
      outputDefined() {
        return !1;
      }
    }
    const Lr = {
      '==': xi,
      '!=': bi,
      '>': Ti,
      '<': wi,
      '>=': Ci,
      '<=': Pi,
      'array': qe,
      'at': ti,
      'boolean': qe,
      'case': ni,
      'coalesce': gi,
      'collator': Ii,
      'format': Mi,
      'image': Di,
      'in': ei,
      'index-of': ii,
      'interpolate': pi,
      'interpolate-hcl': pi,
      'interpolate-lab': pi,
      'length': Li,
      'let': Je,
      'literal': Ze,
      'match': ri,
      'number': qe,
      'number-format': Si,
      'object': qe,
      'slice': ai,
      'step': oi,
      'string': qe,
      'to-boolean': We,
      'to-color': We,
      'to-number': We,
      'to-string': We,
      'var': Qe,
      'within': Xi,
      'distance': Mr,
      'global-state': Dr,
    };
    class Ar {
      constructor(t, e, i, r) {
        (this.name = t), (this.type = e), (this._evaluate = i), (this.args = r);
      }
      evaluate(t) {
        return this._evaluate(t, this.args);
      }
      eachChild(t) {
        this.args.forEach(t);
      }
      outputDefined() {
        return !1;
      }
      static parse(t, e) {
        const i = t[0],
          r = Ar.definitions[i];
        if (!r)
          return e.error(
            `Unknown expression "${i}". If you wanted a literal array, use ["literal", [...]].`,
            0
          );
        const n = Array.isArray(r) ? r[0] : r.type,
          a = Array.isArray(r) ? [[r[1], r[2]]] : r.overloads,
          s = a.filter(([e]) => !Array.isArray(e) || e.length === t.length - 1);
        let o = null;
        for (const [l, c] of s) {
          o = new Ke(e.registry, Or, e.path, null, e.scope);
          const r = [];
          let a = !1;
          for (let e = 1; e < t.length; e++) {
            const i = t[e],
              n = Array.isArray(l) ? l[e - 1] : l.type,
              s = o.parse(i, 1 + r.length, n);
            if (!s) {
              a = !0;
              break;
            }
            r.push(s);
          }
          if (!a)
            if (Array.isArray(l) && l.length !== r.length)
              o.error(
                `Expected ${l.length} arguments, but found ${r.length} instead.`
              );
            else {
              for (let t = 0; t < r.length; t++) {
                const e = Array.isArray(l) ? l[t] : l.type,
                  i = r[t];
                o.concat(t + 1).checkSubtype(e, i.type);
              }
              if (0 === o.errors.length) return new Ar(i, n, c, r);
            }
        }
        if (1 === s.length) e.errors.push(...o.errors);
        else {
          const i = (s.length ? s : a)
              .map(([t]) => {
                return (
                  (e = t),
                  Array.isArray(e)
                    ? `(${e.map(Kt).join(', ')})`
                    : `(${Kt(e.type)}...)`
                );
                var e;
              })
              .join(' | '),
            r = [];
          for (let n = 1; n < t.length; n++) {
            const i = e.parse(t[n], 1 + r.length);
            if (!i) return null;
            r.push(Kt(i.type));
          }
          e.error(
            `Expected arguments of type ${i}, but found (${r.join(
              ', '
            )}) instead.`
          );
        }
        return null;
      }
      static register(t, e) {
        Ar.definitions = e;
        for (const i in e) t[i] = Ar;
      }
    }
    function Er(t, [e, i, r, n]) {
      (e = e.evaluate(t)), (i = i.evaluate(t)), (r = r.evaluate(t));
      const a = n ? n.evaluate(t) : 1,
        s = Ve(e, i, r, a);
      if (s) throw new ke(s);
      return new Se(e / 255, i / 255, r / 255, a, !1);
    }
    function Rr(t, e) {
      return t in e;
    }
    function zr(t, e) {
      const i = e[t];
      return void 0 === i ? null : i;
    }
    function kr(t) {
      return { type: t };
    }
    function Or(t) {
      if (t instanceof Qe) return Or(t.boundExpression);
      if (t instanceof Ar && 'error' === t.name) return !1;
      if (t instanceof Ii) return !1;
      if (t instanceof Xi) return !1;
      if (t instanceof Mr) return !1;
      if (t instanceof Dr) return !1;
      const e = t instanceof We || t instanceof qe;
      let i = !0;
      return (
        t.eachChild((t) => {
          i = e ? i && Or(t) : i && t instanceof Ze;
        }),
        !!i &&
          Fr(t) &&
          Nr(t, [
            'zoom',
            'heatmap-density',
            'elevation',
            'line-progress',
            'accumulated',
            'is-supported-script',
          ])
      );
    }
    function Fr(t) {
      if (t instanceof Ar) {
        if ('get' === t.name && 1 === t.args.length) return !1;
        if ('feature-state' === t.name) return !1;
        if ('has' === t.name && 1 === t.args.length) return !1;
        if (
          'properties' === t.name ||
          'geometry-type' === t.name ||
          'id' === t.name
        )
          return !1;
        if (/^filter-/.test(t.name)) return !1;
      }
      if (t instanceof Xi) return !1;
      if (t instanceof Mr) return !1;
      let e = !0;
      return (
        t.eachChild((t) => {
          e && !Fr(t) && (e = !1);
        }),
        e
      );
    }
    function Br(t) {
      if (t instanceof Ar && 'feature-state' === t.name) return !1;
      let e = !0;
      return (
        t.eachChild((t) => {
          e && !Br(t) && (e = !1);
        }),
        e
      );
    }
    function Nr(t, e) {
      if (t instanceof Ar && e.indexOf(t.name) >= 0) return !1;
      let i = !0;
      return (
        t.eachChild((t) => {
          i && !Nr(t, e) && (i = !1);
        }),
        i
      );
    }
    function Vr(t) {
      return { result: 'success', value: t };
    }
    function jr(t) {
      return { result: 'error', value: t };
    }
    function Ur(t) {
      return (
        'data-driven' === t['property-type'] ||
        'cross-faded-data-driven' === t['property-type']
      );
    }
    function Gr(t) {
      return !!t.expression && t.expression.parameters.indexOf('zoom') > -1;
    }
    function Zr(t) {
      return !!t.expression && t.expression.interpolated;
    }
    function $r(t) {
      return t instanceof Number
        ? 'number'
        : t instanceof String
        ? 'string'
        : t instanceof Boolean
        ? 'boolean'
        : Array.isArray(t)
        ? 'array'
        : null === t
        ? 'null'
        : typeof t;
    }
    function qr(t) {
      return (
        'object' == typeof t && null !== t && !Array.isArray(t) && Ue(t) === jt
      );
    }
    function Hr(t) {
      return t;
    }
    function Wr(t, e) {
      const i = t.stops && 'object' == typeof t.stops[0][0],
        r = i || !(i || void 0 !== t.property),
        n = t.type || (Zr(e) ? 'exponential' : 'interval'),
        a = (function (t) {
          switch (t.type) {
            case 'color':
              return Se.parse;
            case 'padding':
              return Ee.parse;
            case 'numberArray':
              return Re.parse;
            case 'colorArray':
              return ze.parse;
            default:
              return null;
          }
        })(e);
      if (
        (a &&
          ((t = Et({}, t)).stops &&
            (t.stops = t.stops.map((t) => [t[0], a(t[1])])),
          (t.default = a(t.default ? t.default : e.default))),
        t.colorSpace &&
          'rgb' !== (s = t.colorSpace) &&
          'hcl' !== s &&
          'lab' !== s)
      )
        throw new Error(`Unknown color space: "${t.colorSpace}"`);
      var s;
      const o = (function (t) {
        switch (t) {
          case 'exponential':
            return Jr;
          case 'interval':
            return Kr;
          case 'categorical':
            return Yr;
          case 'identity':
            return Qr;
          default:
            throw new Error(`Unknown function type "${t}"`);
        }
      })(n);
      let l, c;
      if ('categorical' === n) {
        l = Object.create(null);
        for (const e of t.stops) l[e[0]] = e[1];
        c = typeof t.stops[0][0];
      }
      if (i) {
        const i = {},
          r = [];
        for (let e = 0; e < t.stops.length; e++) {
          const n = t.stops[e],
            a = n[0].zoom;
          void 0 === i[a] &&
            ((i[a] = {
              zoom: a,
              type: t.type,
              property: t.property,
              default: t.default,
              stops: [],
            }),
            r.push(a)),
            i[a].stops.push([n[0].value, n[1]]);
        }
        const n = [];
        for (const t of r) n.push([i[t].zoom, Wr(i[t], e)]);
        const a = { name: 'linear' };
        return {
          kind: 'composite',
          interpolationType: a,
          interpolationFactor: pi.interpolationFactor.bind(void 0, a),
          zoomStops: n.map((t) => t[0]),
          evaluate: ({ zoom: i }, r) =>
            Jr({ stops: n, base: t.base }, e, i).evaluate(i, r),
        };
      }
      if (r) {
        const i =
          'exponential' === n
            ? { name: 'exponential', base: void 0 !== t.base ? t.base : 1 }
            : null;
        return {
          kind: 'camera',
          interpolationType: i,
          interpolationFactor: pi.interpolationFactor.bind(void 0, i),
          zoomStops: t.stops.map((t) => t[0]),
          evaluate: ({ zoom: i }) => o(t, e, i, l, c),
        };
      }
      return {
        kind: 'source',
        evaluate(i, r) {
          const n = r && r.properties ? r.properties[t.property] : void 0;
          return void 0 === n ? Xr(t.default, e.default) : o(t, e, n, l, c);
        },
      };
    }
    function Xr(t, e, i) {
      return void 0 !== t ? t : void 0 !== e ? e : void 0 !== i ? i : void 0;
    }
    function Yr(t, e, i, r, n) {
      return Xr(typeof i === n ? r[i] : void 0, t.default, e.default);
    }
    function Kr(t, e, i) {
      if ('number' !== $r(i)) return Xr(t.default, e.default);
      const r = t.stops.length;
      if (1 === r) return t.stops[0][1];
      if (i <= t.stops[0][0]) return t.stops[0][1];
      if (i >= t.stops[r - 1][0]) return t.stops[r - 1][1];
      const n = si(
        t.stops.map((t) => t[0]),
        i
      );
      return t.stops[n][1];
    }
    function Jr(t, e, i) {
      const r = void 0 !== t.base ? t.base : 1;
      if ('number' !== $r(i)) return Xr(t.default, e.default);
      const n = t.stops.length;
      if (1 === n) return t.stops[0][1];
      if (i <= t.stops[0][0]) return t.stops[0][1];
      if (i >= t.stops[n - 1][0]) return t.stops[n - 1][1];
      const a = si(
          t.stops.map((t) => t[0]),
          i
        ),
        s = (function (t, e, i, r) {
          const n = r - i,
            a = t - i;
          return 0 === n
            ? 0
            : 1 === e
            ? a / n
            : (Math.pow(e, a) - 1) / (Math.pow(e, n) - 1);
        })(i, r, t.stops[a][0], t.stops[a + 1][0]),
        o = t.stops[a][1],
        l = t.stops[a + 1][1],
        c = mi[e.type] || Hr;
      return 'function' == typeof o.evaluate
        ? {
            evaluate(...e) {
              const i = o.evaluate.apply(void 0, e),
                r = l.evaluate.apply(void 0, e);
              if (void 0 !== i && void 0 !== r) return c(i, r, s, t.colorSpace);
            },
          }
        : c(o, l, s, t.colorSpace);
    }
    function Qr(t, e, i) {
      switch (e.type) {
        case 'color':
          i = Se.parse(i);
          break;
        case 'formatted':
          i = Ae.fromString(i.toString());
          break;
        case 'resolvedImage':
          i = Be.fromString(i.toString());
          break;
        case 'padding':
          i = Ee.parse(i);
          break;
        case 'colorArray':
          i = ze.parse(i);
          break;
        case 'numberArray':
          i = Re.parse(i);
          break;
        default:
          $r(i) === e.type ||
            ('enum' === e.type && e.values[i]) ||
            (i = void 0);
      }
      return Xr(i, t.default, e.default);
    }
    Ar.register(Lr, {
      'error': [
        { kind: 'error' },
        [Ft],
        (t, [e]) => {
          throw new ke(e.evaluate(t));
        },
      ],
      'typeof': [Ft, [Ut], (t, [e]) => Kt(Ue(e.evaluate(t)))],
      'to-rgba': [
        Yt(Ot, 4),
        [Nt],
        (t, [e]) => {
          const [i, r, n, a] = e.evaluate(t).rgb;
          return [255 * i, 255 * r, 255 * n, a];
        },
      ],
      'rgb': [Nt, [Ot, Ot, Ot], Er],
      'rgba': [Nt, [Ot, Ot, Ot, Ot], Er],
      'has': {
        type: Bt,
        overloads: [
          [[Ft], (t, [e]) => Rr(e.evaluate(t), t.properties())],
          [[Ft, jt], (t, [e, i]) => Rr(e.evaluate(t), i.evaluate(t))],
        ],
      },
      'get': {
        type: Ut,
        overloads: [
          [[Ft], (t, [e]) => zr(e.evaluate(t), t.properties())],
          [[Ft, jt], (t, [e, i]) => zr(e.evaluate(t), i.evaluate(t))],
        ],
      },
      'feature-state': [
        Ut,
        [Ft],
        (t, [e]) => zr(e.evaluate(t), t.featureState || {}),
      ],
      'properties': [jt, [], (t) => t.properties()],
      'geometry-type': [Ft, [], (t) => t.geometryType()],
      'id': [Ut, [], (t) => t.id()],
      'zoom': [Ot, [], (t) => t.globals.zoom],
      'heatmap-density': [Ot, [], (t) => t.globals.heatmapDensity || 0],
      'elevation': [Ot, [], (t) => t.globals.elevation || 0],
      'line-progress': [Ot, [], (t) => t.globals.lineProgress || 0],
      'accumulated': [
        Ut,
        [],
        (t) =>
          void 0 === t.globals.accumulated ? null : t.globals.accumulated,
      ],
      '+': [
        Ot,
        kr(Ot),
        (t, e) => {
          let i = 0;
          for (const r of e) i += r.evaluate(t);
          return i;
        },
      ],
      '*': [
        Ot,
        kr(Ot),
        (t, e) => {
          let i = 1;
          for (const r of e) i *= r.evaluate(t);
          return i;
        },
      ],
      '-': {
        type: Ot,
        overloads: [
          [[Ot, Ot], (t, [e, i]) => e.evaluate(t) - i.evaluate(t)],
          [[Ot], (t, [e]) => -e.evaluate(t)],
        ],
      },
      '/': [Ot, [Ot, Ot], (t, [e, i]) => e.evaluate(t) / i.evaluate(t)],
      '%': [Ot, [Ot, Ot], (t, [e, i]) => e.evaluate(t) % i.evaluate(t)],
      'ln2': [Ot, [], () => Math.LN2],
      'pi': [Ot, [], () => Math.PI],
      'e': [Ot, [], () => Math.E],
      '^': [
        Ot,
        [Ot, Ot],
        (t, [e, i]) => Math.pow(e.evaluate(t), i.evaluate(t)),
      ],
      'sqrt': [Ot, [Ot], (t, [e]) => Math.sqrt(e.evaluate(t))],
      'log10': [Ot, [Ot], (t, [e]) => Math.log(e.evaluate(t)) / Math.LN10],
      'ln': [Ot, [Ot], (t, [e]) => Math.log(e.evaluate(t))],
      'log2': [Ot, [Ot], (t, [e]) => Math.log(e.evaluate(t)) / Math.LN2],
      'sin': [Ot, [Ot], (t, [e]) => Math.sin(e.evaluate(t))],
      'cos': [Ot, [Ot], (t, [e]) => Math.cos(e.evaluate(t))],
      'tan': [Ot, [Ot], (t, [e]) => Math.tan(e.evaluate(t))],
      'asin': [Ot, [Ot], (t, [e]) => Math.asin(e.evaluate(t))],
      'acos': [Ot, [Ot], (t, [e]) => Math.acos(e.evaluate(t))],
      'atan': [Ot, [Ot], (t, [e]) => Math.atan(e.evaluate(t))],
      'min': [Ot, kr(Ot), (t, e) => Math.min(...e.map((e) => e.evaluate(t)))],
      'max': [Ot, kr(Ot), (t, e) => Math.max(...e.map((e) => e.evaluate(t)))],
      'abs': [Ot, [Ot], (t, [e]) => Math.abs(e.evaluate(t))],
      'round': [
        Ot,
        [Ot],
        (t, [e]) => {
          const i = e.evaluate(t);
          return i < 0 ? -Math.round(-i) : Math.round(i);
        },
      ],
      'floor': [Ot, [Ot], (t, [e]) => Math.floor(e.evaluate(t))],
      'ceil': [Ot, [Ot], (t, [e]) => Math.ceil(e.evaluate(t))],
      'filter-==': [
        Bt,
        [Ft, Ut],
        (t, [e, i]) => t.properties()[e.value] === i.value,
      ],
      'filter-id-==': [Bt, [Ut], (t, [e]) => t.id() === e.value],
      'filter-type-==': [Bt, [Ft], (t, [e]) => t.geometryType() === e.value],
      'filter-<': [
        Bt,
        [Ft, Ut],
        (t, [e, i]) => {
          const r = t.properties()[e.value],
            n = i.value;
          return typeof r == typeof n && r < n;
        },
      ],
      'filter-id-<': [
        Bt,
        [Ut],
        (t, [e]) => {
          const i = t.id(),
            r = e.value;
          return typeof i == typeof r && i < r;
        },
      ],
      'filter->': [
        Bt,
        [Ft, Ut],
        (t, [e, i]) => {
          const r = t.properties()[e.value],
            n = i.value;
          return typeof r == typeof n && r > n;
        },
      ],
      'filter-id->': [
        Bt,
        [Ut],
        (t, [e]) => {
          const i = t.id(),
            r = e.value;
          return typeof i == typeof r && i > r;
        },
      ],
      'filter-<=': [
        Bt,
        [Ft, Ut],
        (t, [e, i]) => {
          const r = t.properties()[e.value],
            n = i.value;
          return typeof r == typeof n && r <= n;
        },
      ],
      'filter-id-<=': [
        Bt,
        [Ut],
        (t, [e]) => {
          const i = t.id(),
            r = e.value;
          return typeof i == typeof r && i <= r;
        },
      ],
      'filter->=': [
        Bt,
        [Ft, Ut],
        (t, [e, i]) => {
          const r = t.properties()[e.value],
            n = i.value;
          return typeof r == typeof n && r >= n;
        },
      ],
      'filter-id->=': [
        Bt,
        [Ut],
        (t, [e]) => {
          const i = t.id(),
            r = e.value;
          return typeof i == typeof r && i >= r;
        },
      ],
      'filter-has': [Bt, [Ut], (t, [e]) => e.value in t.properties()],
      'filter-has-id': [Bt, [], (t) => null !== t.id() && void 0 !== t.id()],
      'filter-type-in': [
        Bt,
        [Yt(Ft)],
        (t, [e]) => e.value.indexOf(t.geometryType()) >= 0,
      ],
      'filter-id-in': [Bt, [Yt(Ut)], (t, [e]) => e.value.indexOf(t.id()) >= 0],
      'filter-in-small': [
        Bt,
        [Ft, Yt(Ut)],
        (t, [e, i]) => i.value.indexOf(t.properties()[e.value]) >= 0,
      ],
      'filter-in-large': [
        Bt,
        [Ft, Yt(Ut)],
        (t, [e, i]) =>
          (function (t, e, i, r) {
            for (; i <= r; ) {
              const n = (i + r) >> 1;
              if (e[n] === t) return !0;
              e[n] > t ? (r = n - 1) : (i = n + 1);
            }
            return !1;
          })(t.properties()[e.value], i.value, 0, i.value.length - 1),
      ],
      'all': {
        type: Bt,
        overloads: [
          [[Bt, Bt], (t, [e, i]) => e.evaluate(t) && i.evaluate(t)],
          [
            kr(Bt),
            (t, e) => {
              for (const i of e) if (!i.evaluate(t)) return !1;
              return !0;
            },
          ],
        ],
      },
      'any': {
        type: Bt,
        overloads: [
          [[Bt, Bt], (t, [e, i]) => e.evaluate(t) || i.evaluate(t)],
          [
            kr(Bt),
            (t, e) => {
              for (const i of e) if (i.evaluate(t)) return !0;
              return !1;
            },
          ],
        ],
      },
      '!': [Bt, [Bt], (t, [e]) => !e.evaluate(t)],
      'is-supported-script': [
        Bt,
        [Ft],
        (t, [e]) => {
          const i = t.globals && t.globals.isSupportedScript;
          return !i || i(e.evaluate(t));
        },
      ],
      'upcase': [Ft, [Ft], (t, [e]) => e.evaluate(t).toUpperCase()],
      'downcase': [Ft, [Ft], (t, [e]) => e.evaluate(t).toLowerCase()],
      'concat': [
        Ft,
        kr(Ut),
        (t, e) => e.map((e) => Ge(e.evaluate(t))).join(''),
      ],
      'resolved-locale': [Ft, [Gt], (t, [e]) => e.evaluate(t).resolvedLocale()],
    });
    class tn {
      constructor(t, e, i) {
        (this.expression = t),
          (this._warningHistory = {}),
          (this._evaluator = new Ye()),
          (this._defaultValue = e
            ? (function (t) {
                if ('color' === t.type && qr(t.default))
                  return new Se(0, 0, 0, 0);
                switch (t.type) {
                  case 'color':
                    return Se.parse(t.default) || null;
                  case 'padding':
                    return Ee.parse(t.default) || null;
                  case 'numberArray':
                    return Re.parse(t.default) || null;
                  case 'colorArray':
                    return ze.parse(t.default) || null;
                  case 'variableAnchorOffsetCollection':
                    return Fe.parse(t.default) || null;
                  case 'projectionDefinition':
                    return Ne.parse(t.default) || null;
                  default:
                    return void 0 === t.default ? null : t.default;
                }
              })(e)
            : null),
          (this._enumValues = e && 'enum' === e.type ? e.values : null),
          (this._globalState = i);
      }
      evaluateWithoutErrorHandling(t, e, i, r, n, a) {
        return (
          this._globalState && (t = hn(t, this._globalState)),
          (this._evaluator.globals = t),
          (this._evaluator.feature = e),
          (this._evaluator.featureState = i),
          (this._evaluator.canonical = r),
          (this._evaluator.availableImages = n || null),
          (this._evaluator.formattedSection = a),
          this.expression.evaluate(this._evaluator)
        );
      }
      evaluate(t, e, i, r, n, a) {
        this._globalState && (t = hn(t, this._globalState)),
          (this._evaluator.globals = t),
          (this._evaluator.feature = e || null),
          (this._evaluator.featureState = i || null),
          (this._evaluator.canonical = r),
          (this._evaluator.availableImages = n || null),
          (this._evaluator.formattedSection = a || null);
        try {
          const t = this.expression.evaluate(this._evaluator);
          if (null == t || ('number' == typeof t && t != t))
            return this._defaultValue;
          if (this._enumValues && !(t in this._enumValues))
            throw new ke(
              `Expected value to be one of ${Object.keys(this._enumValues)
                .map((t) => JSON.stringify(t))
                .join(', ')}, but found ${JSON.stringify(t)} instead.`
            );
          return t;
        } catch (t) {
          return (
            this._warningHistory[t.message] ||
              ((this._warningHistory[t.message] = !0),
              'undefined' != typeof console && console.warn(t.message)),
            this._defaultValue
          );
        }
      }
    }
    function en(t) {
      return (
        Array.isArray(t) &&
        t.length > 0 &&
        'string' == typeof t[0] &&
        t[0] in Lr
      );
    }
    function rn(t, e, i) {
      const r = new Ke(
          Lr,
          Or,
          [],
          e
            ? (function (t) {
                const e = {
                  color: Nt,
                  string: Ft,
                  number: Ot,
                  enum: Ft,
                  boolean: Bt,
                  formatted: Zt,
                  padding: $t,
                  numberArray: Ht,
                  colorArray: qt,
                  projectionDefinition: Vt,
                  resolvedImage: Wt,
                  variableAnchorOffsetCollection: Xt,
                };
                return 'array' === t.type
                  ? Yt(e[t.value] || Ut, t.length)
                  : e[t.type];
              })(e)
            : void 0
        ),
        n = r.parse(
          t,
          void 0,
          void 0,
          void 0,
          e && 'string' === e.type ? { typeAnnotation: 'coerce' } : void 0
        );
      return n ? Vr(new tn(n, e, i)) : jr(r.errors);
    }
    class nn {
      constructor(t, e, i) {
        (this.kind = t),
          (this._styleExpression = e),
          (this.isStateDependent = 'constant' !== t && !Br(e.expression)),
          (this.globalStateRefs = cn(e.expression)),
          (this._globalState = i);
      }
      evaluateWithoutErrorHandling(t, e, i, r, n, a) {
        return (
          this._globalState && (t = hn(t, this._globalState)),
          this._styleExpression.evaluateWithoutErrorHandling(t, e, i, r, n, a)
        );
      }
      evaluate(t, e, i, r, n, a) {
        return (
          this._globalState && (t = hn(t, this._globalState)),
          this._styleExpression.evaluate(t, e, i, r, n, a)
        );
      }
    }
    class an {
      constructor(t, e, i, r, n) {
        (this.kind = t),
          (this.zoomStops = i),
          (this._styleExpression = e),
          (this.isStateDependent = 'camera' !== t && !Br(e.expression)),
          (this.globalStateRefs = cn(e.expression)),
          (this.interpolationType = r),
          (this._globalState = n);
      }
      evaluateWithoutErrorHandling(t, e, i, r, n, a) {
        return (
          this._globalState && (t = hn(t, this._globalState)),
          this._styleExpression.evaluateWithoutErrorHandling(t, e, i, r, n, a)
        );
      }
      evaluate(t, e, i, r, n, a) {
        return (
          this._globalState && (t = hn(t, this._globalState)),
          this._styleExpression.evaluate(t, e, i, r, n, a)
        );
      }
      interpolationFactor(t, e, i) {
        return this.interpolationType
          ? pi.interpolationFactor(this.interpolationType, t, e, i)
          : 0;
      }
    }
    function sn(t, e, i) {
      const r = rn(t, e, i);
      if ('error' === r.result) return r;
      const n = r.value.expression,
        a = Fr(n);
      if (!a && !Ur(e))
        return jr([new Rt('', 'data expressions not supported')]);
      const s = Nr(n, ['zoom']);
      if (!s && !Gr(e))
        return jr([new Rt('', 'zoom expressions not supported')]);
      const o = ln(n);
      return o || s
        ? o instanceof Rt
          ? jr([o])
          : o instanceof pi && !Zr(e)
          ? jr([
              new Rt(
                '',
                '"interpolate" expressions cannot be used with this property'
              ),
            ])
          : Vr(
              o
                ? new an(
                    a ? 'camera' : 'composite',
                    r.value,
                    o.labels,
                    o instanceof pi ? o.interpolation : void 0,
                    i
                  )
                : new nn(a ? 'constant' : 'source', r.value, i)
            )
        : jr([
            new Rt(
              '',
              '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.'
            ),
          ]);
    }
    class on {
      constructor(t, e) {
        (this._parameters = t),
          (this._specification = e),
          Et(this, Wr(this._parameters, this._specification));
      }
      static deserialize(t) {
        return new on(t._parameters, t._specification);
      }
      static serialize(t) {
        return { _parameters: t._parameters, _specification: t._specification };
      }
    }
    function ln(t) {
      let e = null;
      if (t instanceof Je) e = ln(t.result);
      else if (t instanceof gi) {
        for (const i of t.args) if (((e = ln(i)), e)) break;
      } else
        (t instanceof oi || t instanceof pi) &&
          t.input instanceof Ar &&
          'zoom' === t.input.name &&
          (e = t);
      return (
        e instanceof Rt ||
          t.eachChild((t) => {
            const i = ln(t);
            i instanceof Rt
              ? (e = i)
              : !e && i
              ? (e = new Rt(
                  '',
                  '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.'
                ))
              : e &&
                i &&
                e !== i &&
                (e = new Rt(
                  '',
                  'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'
                ));
          }),
        e
      );
    }
    function cn(t, e = new Set()) {
      return (
        t instanceof Dr && e.add(t.key),
        t.eachChild((t) => {
          cn(t, e);
        }),
        e
      );
    }
    function hn(t, e) {
      const {
        zoom: i,
        heatmapDensity: r,
        elevation: n,
        lineProgress: a,
        isSupportedScript: s,
        accumulated: o,
      } = null != t ? t : {};
      return {
        zoom: i,
        heatmapDensity: r,
        elevation: n,
        lineProgress: a,
        isSupportedScript: s,
        accumulated: o,
        globalState: e,
      };
    }
    function un(t) {
      if (!0 === t || !1 === t) return !0;
      if (!Array.isArray(t) || 0 === t.length) return !1;
      switch (t[0]) {
        case 'has':
          return t.length >= 2 && '$id' !== t[1] && '$type' !== t[1];
        case 'in':
          return (
            t.length >= 3 && ('string' != typeof t[1] || Array.isArray(t[2]))
          );
        case '!in':
        case '!has':
        case 'none':
          return !1;
        case '==':
        case '!=':
        case '>':
        case '>=':
        case '<':
        case '<=':
          return 3 !== t.length || Array.isArray(t[1]) || Array.isArray(t[2]);
        case 'any':
        case 'all':
          for (const e of t.slice(1))
            if (!un(e) && 'boolean' != typeof e) return !1;
          return !0;
        default:
          return !0;
      }
    }
    const dn = {
      'type': 'boolean',
      'default': !1,
      'transition': !1,
      'property-type': 'data-driven',
      'expression': { interpolated: !1, parameters: ['zoom', 'feature'] },
    };
    function pn(t, e) {
      if (null == t)
        return {
          filter: () => !0,
          needGeometry: !1,
          getGlobalStateRefs: () => new Set(),
        };
      un(t) || (t = gn(t));
      const i = rn(t, dn, e);
      if ('error' === i.result)
        throw new Error(
          i.value.map((t) => `${t.key}: ${t.message}`).join(', ')
        );
      return {
        filter: (t, e, r) => i.value.evaluate(t, e, {}, r),
        needGeometry: mn(t),
        getGlobalStateRefs: () => cn(i.value.expression),
      };
    }
    function fn(t, e) {
      return t < e ? -1 : t > e ? 1 : 0;
    }
    function mn(t) {
      if (!Array.isArray(t)) return !1;
      if ('within' === t[0] || 'distance' === t[0]) return !0;
      for (let e = 1; e < t.length; e++) if (mn(t[e])) return !0;
      return !1;
    }
    function gn(t) {
      if (!t) return !0;
      const e = t[0];
      return t.length <= 1
        ? 'any' !== e
        : '==' === e
        ? _n(t[1], t[2], '==')
        : '!=' === e
        ? xn(_n(t[1], t[2], '=='))
        : '<' === e || '>' === e || '<=' === e || '>=' === e
        ? _n(t[1], t[2], e)
        : 'any' === e
        ? ((i = t.slice(1)), ['any'].concat(i.map(gn)))
        : 'all' === e
        ? ['all'].concat(t.slice(1).map(gn))
        : 'none' === e
        ? ['all'].concat(t.slice(1).map(gn).map(xn))
        : 'in' === e
        ? yn(t[1], t.slice(2))
        : '!in' === e
        ? xn(yn(t[1], t.slice(2)))
        : 'has' === e
        ? vn(t[1])
        : '!has' !== e || xn(vn(t[1]));
      var i;
    }
    function _n(t, e, i) {
      switch (t) {
        case '$type':
          return [`filter-type-${i}`, e];
        case '$id':
          return [`filter-id-${i}`, e];
        default:
          return [`filter-${i}`, t, e];
      }
    }
    function yn(t, e) {
      if (0 === e.length) return !1;
      switch (t) {
        case '$type':
          return ['filter-type-in', ['literal', e]];
        case '$id':
          return ['filter-id-in', ['literal', e]];
        default:
          return e.length > 200 && !e.some((t) => typeof t != typeof e[0])
            ? ['filter-in-large', t, ['literal', e.sort(fn)]]
            : ['filter-in-small', t, ['literal', e]];
      }
    }
    function vn(t) {
      switch (t) {
        case '$type':
          return !0;
        case '$id':
          return ['filter-has-id'];
        default:
          return ['filter-has', t];
      }
    }
    function xn(t) {
      return ['!', t];
    }
    function bn(t) {
      const e = typeof t;
      if ('number' === e || 'boolean' === e || 'string' === e || null == t)
        return JSON.stringify(t);
      if (Array.isArray(t)) {
        let e = '[';
        for (const i of t) e += `${bn(i)},`;
        return `${e}]`;
      }
      const i = Object.keys(t).sort();
      let r = '{';
      for (let n = 0; n < i.length; n++)
        r += `${JSON.stringify(i[n])}:${bn(t[i[n]])},`;
      return `${r}}`;
    }
    function wn(t) {
      let e = '';
      for (const i of xt) e += `/${bn(t[i])}`;
      return e;
    }
    function Tn(t) {
      const e = t.value;
      return e
        ? [new At(t.key, e, 'constants have been deprecated as of v8')]
        : [];
    }
    function Pn(t) {
      return t instanceof Number || t instanceof String || t instanceof Boolean
        ? t.valueOf()
        : t;
    }
    function Cn(t) {
      if (Array.isArray(t)) return t.map(Cn);
      if (
        t instanceof Object &&
        !(t instanceof Number || t instanceof String || t instanceof Boolean)
      ) {
        const e = {};
        for (const i in t) e[i] = Cn(t[i]);
        return e;
      }
      return Pn(t);
    }
    function In(t) {
      const e = t.key,
        i = t.value,
        r = t.valueSpec || {},
        n = t.objectElementValidators || {},
        a = t.style,
        s = t.styleSpec,
        o = t.validateSpec;
      let l = [];
      const c = $r(i);
      if ('object' !== c) return [new At(e, i, `object expected, ${c} found`)];
      for (const h in i) {
        const t = h.split('.')[0],
          c = ve(r, t) || r['*'];
        let u;
        if (ve(n, t)) u = n[t];
        else if (ve(r, t)) u = o;
        else if (n['*']) u = n['*'];
        else {
          if (!r['*']) {
            l.push(new At(e, i[h], `unknown property "${h}"`));
            continue;
          }
          u = o;
        }
        l = l.concat(
          u(
            {
              key: (e ? `${e}.` : e) + h,
              value: i[h],
              valueSpec: c,
              style: a,
              styleSpec: s,
              object: i,
              objectKey: h,
              validateSpec: o,
            },
            i
          )
        );
      }
      for (const h in r)
        n[h] ||
          (r[h].required &&
            void 0 === r[h].default &&
            void 0 === i[h] &&
            l.push(new At(e, i, `missing required property "${h}"`)));
      return l;
    }
    function Sn(t) {
      const e = t.value,
        i = t.valueSpec,
        r = t.style,
        n = t.styleSpec,
        a = t.key,
        s = t.arrayElementValidator || t.validateSpec;
      if ('array' !== $r(e))
        return [new At(a, e, `array expected, ${$r(e)} found`)];
      if (i.length && e.length !== i.length)
        return [
          new At(
            a,
            e,
            `array length ${i.length} expected, length ${e.length} found`
          ),
        ];
      if (i['min-length'] && e.length < i['min-length'])
        return [
          new At(
            a,
            e,
            `array length at least ${i['min-length']} expected, length ${e.length} found`
          ),
        ];
      let o = { type: i.value, values: i.values };
      n.$version < 7 && (o.function = i.function),
        'object' === $r(i.value) && (o = i.value);
      let l = [];
      for (let c = 0; c < e.length; c++)
        l = l.concat(
          s({
            array: e,
            arrayIndex: c,
            value: e[c],
            valueSpec: o,
            validateSpec: t.validateSpec,
            style: r,
            styleSpec: n,
            key: `${a}[${c}]`,
          })
        );
      return l;
    }
    function Mn(t) {
      const e = t.key,
        i = t.value,
        r = t.valueSpec;
      let n = $r(i);
      return (
        'number' === n && i != i && (n = 'NaN'),
        'number' !== n
          ? [new At(e, i, `number expected, ${n} found`)]
          : 'minimum' in r && i < r.minimum
          ? [new At(e, i, `${i} is less than the minimum value ${r.minimum}`)]
          : 'maximum' in r && i > r.maximum
          ? [
              new At(
                e,
                i,
                `${i} is greater than the maximum value ${r.maximum}`
              ),
            ]
          : []
      );
    }
    function Dn(t) {
      const e = t.valueSpec,
        i = Pn(t.value.type);
      let r,
        n,
        a,
        s = {};
      const o = 'categorical' !== i && void 0 === t.value.property,
        l = !o,
        c =
          'array' === $r(t.value.stops) &&
          'array' === $r(t.value.stops[0]) &&
          'object' === $r(t.value.stops[0][0]),
        h = In({
          key: t.key,
          value: t.value,
          valueSpec: t.styleSpec.function,
          validateSpec: t.validateSpec,
          style: t.style,
          styleSpec: t.styleSpec,
          objectElementValidators: {
            stops: function (t) {
              if ('identity' === i)
                return [
                  new At(
                    t.key,
                    t.value,
                    'identity function may not have a "stops" property'
                  ),
                ];
              let e = [];
              const r = t.value;
              return (
                (e = e.concat(
                  Sn({
                    key: t.key,
                    value: r,
                    valueSpec: t.valueSpec,
                    validateSpec: t.validateSpec,
                    style: t.style,
                    styleSpec: t.styleSpec,
                    arrayElementValidator: u,
                  })
                )),
                'array' === $r(r) &&
                  0 === r.length &&
                  e.push(new At(t.key, r, 'array must have at least one stop')),
                e
              );
            },
            default: function (t) {
              return t.validateSpec({
                key: t.key,
                value: t.value,
                valueSpec: e,
                validateSpec: t.validateSpec,
                style: t.style,
                styleSpec: t.styleSpec,
              });
            },
          },
        });
      return (
        'identity' === i &&
          o &&
          h.push(
            new At(t.key, t.value, 'missing required property "property"')
          ),
        'identity' === i ||
          t.value.stops ||
          h.push(new At(t.key, t.value, 'missing required property "stops"')),
        'exponential' === i &&
          t.valueSpec.expression &&
          !Zr(t.valueSpec) &&
          h.push(new At(t.key, t.value, 'exponential functions not supported')),
        t.styleSpec.$version >= 8 &&
          (l && !Ur(t.valueSpec)
            ? h.push(new At(t.key, t.value, 'property functions not supported'))
            : o &&
              !Gr(t.valueSpec) &&
              h.push(new At(t.key, t.value, 'zoom functions not supported'))),
        ('categorical' !== i && !c) ||
          void 0 !== t.value.property ||
          h.push(new At(t.key, t.value, '"property" property is required')),
        h
      );
      function u(t) {
        let i = [];
        const r = t.value,
          o = t.key;
        if ('array' !== $r(r))
          return [new At(o, r, `array expected, ${$r(r)} found`)];
        if (2 !== r.length)
          return [
            new At(o, r, `array length 2 expected, length ${r.length} found`),
          ];
        if (c) {
          if ('object' !== $r(r[0]))
            return [new At(o, r, `object expected, ${$r(r[0])} found`)];
          if (void 0 === r[0].zoom)
            return [new At(o, r, 'object stop key must have zoom')];
          if (void 0 === r[0].value)
            return [new At(o, r, 'object stop key must have value')];
          if (a && a > Pn(r[0].zoom))
            return [
              new At(
                o,
                r[0].zoom,
                'stop zoom values must appear in ascending order'
              ),
            ];
          Pn(r[0].zoom) !== a && ((a = Pn(r[0].zoom)), (n = void 0), (s = {})),
            (i = i.concat(
              In({
                key: `${o}[0]`,
                value: r[0],
                valueSpec: { zoom: {} },
                validateSpec: t.validateSpec,
                style: t.style,
                styleSpec: t.styleSpec,
                objectElementValidators: { zoom: Mn, value: d },
              })
            ));
        } else i = i.concat(d({ key: `${o}[0]`, value: r[0], validateSpec: t.validateSpec, style: t.style, styleSpec: t.styleSpec }, r));
        return en(Cn(r[1]))
          ? i.concat([
              new At(
                `${o}[1]`,
                r[1],
                'expressions are not allowed in function stops.'
              ),
            ])
          : i.concat(
              t.validateSpec({
                key: `${o}[1]`,
                value: r[1],
                valueSpec: e,
                validateSpec: t.validateSpec,
                style: t.style,
                styleSpec: t.styleSpec,
              })
            );
      }
      function d(t, a) {
        const o = $r(t.value),
          l = Pn(t.value),
          c = null !== t.value ? t.value : a;
        if (r) {
          if (o !== r)
            return [
              new At(
                t.key,
                c,
                `${o} stop domain type must match previous stop domain type ${r}`
              ),
            ];
        } else r = o;
        if ('number' !== o && 'string' !== o && 'boolean' !== o)
          return [
            new At(
              t.key,
              c,
              'stop domain value must be a number, string, or boolean'
            ),
          ];
        if ('number' !== o && 'categorical' !== i) {
          let r = `number expected, ${o} found`;
          return (
            Ur(e) &&
              void 0 === i &&
              (r +=
                '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'),
            [new At(t.key, c, r)]
          );
        }
        return 'categorical' !== i ||
          'number' !== o ||
          (isFinite(l) && Math.floor(l) === l)
          ? 'categorical' !== i && 'number' === o && void 0 !== n && l < n
            ? [
                new At(
                  t.key,
                  c,
                  'stop domain values must appear in ascending order'
                ),
              ]
            : ((n = l),
              'categorical' === i && l in s
                ? [new At(t.key, c, 'stop domain values must be unique')]
                : ((s[l] = !0), []))
          : [new At(t.key, c, `integer expected, found ${l}`)];
      }
    }
    function Ln(t) {
      const e = ('property' === t.expressionContext ? sn : rn)(
        Cn(t.value),
        t.valueSpec
      );
      if ('error' === e.result)
        return e.value.map(
          (e) => new At(`${t.key}${e.key}`, t.value, e.message)
        );
      const i = e.value.expression || e.value._styleExpression.expression;
      if (
        'property' === t.expressionContext &&
        'text-font' === t.propertyKey &&
        !i.outputDefined()
      )
        return [
          new At(
            t.key,
            t.value,
            `Invalid data expression for "${t.propertyKey}". Output values must be contained as literals within the expression.`
          ),
        ];
      if (
        'property' === t.expressionContext &&
        'layout' === t.propertyType &&
        !Br(i)
      )
        return [
          new At(
            t.key,
            t.value,
            '"feature-state" data expressions are not supported with layout properties.'
          ),
        ];
      if ('filter' === t.expressionContext && !Br(i))
        return [
          new At(
            t.key,
            t.value,
            '"feature-state" data expressions are not supported with filters.'
          ),
        ];
      if (t.expressionContext && 0 === t.expressionContext.indexOf('cluster')) {
        if (!Nr(i, ['zoom', 'feature-state']))
          return [
            new At(
              t.key,
              t.value,
              '"zoom" and "feature-state" expressions are not supported with cluster properties.'
            ),
          ];
        if ('cluster-initial' === t.expressionContext && !Fr(i))
          return [
            new At(
              t.key,
              t.value,
              'Feature data expressions are not supported with initial expression part of cluster properties.'
            ),
          ];
      }
      return [];
    }
    function An(t) {
      const e = t.key,
        i = t.value,
        r = $r(i);
      return 'string' !== r
        ? [new At(e, i, `color expected, ${r} found`)]
        : Se.parse(String(i))
        ? []
        : [new At(e, i, `color expected, "${i}" found`)];
    }
    function En(t) {
      const e = t.key,
        i = t.value,
        r = t.valueSpec,
        n = [];
      return (
        Array.isArray(r.values)
          ? -1 === r.values.indexOf(Pn(i)) &&
            n.push(
              new At(
                e,
                i,
                `expected one of [${r.values.join(', ')}], ${JSON.stringify(
                  i
                )} found`
              )
            )
          : -1 === Object.keys(r.values).indexOf(Pn(i)) &&
            n.push(
              new At(
                e,
                i,
                `expected one of [${Object.keys(r.values).join(
                  ', '
                )}], ${JSON.stringify(i)} found`
              )
            ),
        n
      );
    }
    function Rn(t) {
      return un(Cn(t.value))
        ? Ln(
            Et({}, t, {
              expressionContext: 'filter',
              valueSpec: { value: 'boolean' },
            })
          )
        : zn(t);
    }
    function zn(t) {
      const e = t.value,
        i = t.key;
      if ('array' !== $r(e))
        return [new At(i, e, `array expected, ${$r(e)} found`)];
      const r = t.styleSpec;
      let n,
        a = [];
      if (e.length < 1)
        return [new At(i, e, 'filter array must have at least 1 element')];
      switch (
        ((a = a.concat(
          En({
            key: `${i}[0]`,
            value: e[0],
            valueSpec: r.filter_operator,
            style: t.style,
            styleSpec: t.styleSpec,
          })
        )),
        Pn(e[0]))
      ) {
        case '<':
        case '<=':
        case '>':
        case '>=':
          e.length >= 2 &&
            '$type' === Pn(e[1]) &&
            a.push(
              new At(i, e, `"$type" cannot be use with operator "${e[0]}"`)
            );
        case '==':
        case '!=':
          3 !== e.length &&
            a.push(
              new At(
                i,
                e,
                `filter array for operator "${e[0]}" must have 3 elements`
              )
            );
        case 'in':
        case '!in':
          e.length >= 2 &&
            ((n = $r(e[1])),
            'string' !== n &&
              a.push(new At(`${i}[1]`, e[1], `string expected, ${n} found`)));
          for (let s = 2; s < e.length; s++)
            (n = $r(e[s])),
              '$type' === Pn(e[1])
                ? (a = a.concat(
                    En({
                      key: `${i}[${s}]`,
                      value: e[s],
                      valueSpec: r.geometry_type,
                      style: t.style,
                      styleSpec: t.styleSpec,
                    })
                  ))
                : 'string' !== n &&
                  'number' !== n &&
                  'boolean' !== n &&
                  a.push(
                    new At(
                      `${i}[${s}]`,
                      e[s],
                      `string, number, or boolean expected, ${n} found`
                    )
                  );
          break;
        case 'any':
        case 'all':
        case 'none':
          for (let r = 1; r < e.length; r++)
            a = a.concat(
              zn({
                key: `${i}[${r}]`,
                value: e[r],
                style: t.style,
                styleSpec: t.styleSpec,
              })
            );
          break;
        case 'has':
        case '!has':
          (n = $r(e[1])),
            2 !== e.length
              ? a.push(
                  new At(
                    i,
                    e,
                    `filter array for "${e[0]}" operator must have 2 elements`
                  )
                )
              : 'string' !== n &&
                a.push(new At(`${i}[1]`, e[1], `string expected, ${n} found`));
      }
      return a;
    }
    function kn(t, e) {
      const i = t.key,
        r = t.validateSpec,
        n = t.style,
        a = t.styleSpec,
        s = t.value,
        o = t.objectKey,
        l = a[`${e}_${t.layerType}`];
      if (!l) return [];
      const c = o.match(/^(.*)-transition$/);
      if ('paint' === e && c && l[c[1]] && l[c[1]].transition)
        return r({
          key: i,
          value: s,
          valueSpec: a.transition,
          style: n,
          styleSpec: a,
        });
      const h = t.valueSpec || l[o];
      if (!h) return [new At(i, s, `unknown property "${o}"`)];
      let u;
      if (
        'string' === $r(s) &&
        Ur(h) &&
        !h.tokens &&
        (u = /^{([^}]+)}$/.exec(s))
      )
        return [
          new At(
            i,
            s,
            `"${o}" does not support interpolation syntax\nUse an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(
              u[1]
            )} }\`.`
          ),
        ];
      const d = [];
      return (
        'symbol' === t.layerType &&
          'text-font' === o &&
          qr(Cn(s)) &&
          'identity' === Pn(s.type) &&
          d.push(
            new At(i, s, '"text-font" does not support identity functions')
          ),
        d.concat(
          r({
            key: t.key,
            value: s,
            valueSpec: h,
            style: n,
            styleSpec: a,
            expressionContext: 'property',
            propertyType: e,
            propertyKey: o,
          })
        )
      );
    }
    function On(t) {
      return kn(t, 'paint');
    }
    function Fn(t) {
      return kn(t, 'layout');
    }
    function Bn(t) {
      let e = [];
      const i = t.value,
        r = t.key,
        n = t.style,
        a = t.styleSpec;
      if ('object' !== $r(i))
        return [new At(r, i, `object expected, ${$r(i)} found`)];
      i.type ||
        i.ref ||
        e.push(new At(r, i, 'either "type" or "ref" is required'));
      let s = Pn(i.type);
      const o = Pn(i.ref);
      if (i.id) {
        const a = Pn(i.id);
        for (let s = 0; s < t.arrayIndex; s++) {
          const t = n.layers[s];
          Pn(t.id) === a &&
            e.push(
              new At(
                r,
                i.id,
                `duplicate layer id "${i.id}", previously used at line ${t.id.__line__}`
              )
            );
        }
      }
      if ('ref' in i) {
        let t;
        ['type', 'source', 'source-layer', 'filter', 'layout'].forEach((t) => {
          t in i &&
            e.push(new At(r, i[t], `"${t}" is prohibited for ref layers`));
        }),
          n.layers.forEach((e) => {
            Pn(e.id) === o && (t = e);
          }),
          t
            ? t.ref
              ? e.push(
                  new At(r, i.ref, 'ref cannot reference another ref layer')
                )
              : (s = Pn(t.type))
            : e.push(new At(r, i.ref, `ref layer "${o}" not found`));
      } else if ('background' !== s)
        if (i.source) {
          const t = n.sources && n.sources[i.source],
            a = t && Pn(t.type);
          t
            ? 'vector' === a && 'raster' === s
              ? e.push(
                  new At(
                    r,
                    i.source,
                    `layer "${i.id}" requires a raster source`
                  )
                )
              : ('raster-dem' !== a && 'hillshade' === s) ||
                ('raster-dem' !== a && 'color-relief' === s)
              ? e.push(
                  new At(
                    r,
                    i.source,
                    `layer "${i.id}" requires a raster-dem source`
                  )
                )
              : 'raster' === a && 'raster' !== s
              ? e.push(
                  new At(
                    r,
                    i.source,
                    `layer "${i.id}" requires a vector source`
                  )
                )
              : 'vector' !== a || i['source-layer']
              ? 'raster-dem' === a && 'hillshade' !== s && 'color-relief' !== s
                ? e.push(
                    new At(
                      r,
                      i.source,
                      "raster-dem source can only be used with layer type 'hillshade' or 'color-relief'."
                    )
                  )
                : 'line' !== s ||
                  !i.paint ||
                  !i.paint['line-gradient'] ||
                  ('geojson' === a && t.lineMetrics) ||
                  e.push(
                    new At(
                      r,
                      i,
                      `layer "${i.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`
                    )
                  )
              : e.push(
                  new At(r, i, `layer "${i.id}" must specify a "source-layer"`)
                )
            : e.push(new At(r, i.source, `source "${i.source}" not found`));
        } else e.push(new At(r, i, 'missing required property "source"'));
      return (
        (e = e.concat(
          In({
            key: r,
            value: i,
            valueSpec: a.layer,
            style: t.style,
            styleSpec: t.styleSpec,
            validateSpec: t.validateSpec,
            objectElementValidators: {
              '*': () => [],
              'type': () =>
                t.validateSpec({
                  key: `${r}.type`,
                  value: i.type,
                  valueSpec: a.layer.type,
                  style: t.style,
                  styleSpec: t.styleSpec,
                  validateSpec: t.validateSpec,
                  object: i,
                  objectKey: 'type',
                }),
              'filter': Rn,
              'layout': (t) =>
                In({
                  layer: i,
                  key: t.key,
                  value: t.value,
                  style: t.style,
                  styleSpec: t.styleSpec,
                  validateSpec: t.validateSpec,
                  objectElementValidators: {
                    '*': (t) => Fn(Et({ layerType: s }, t)),
                  },
                }),
              'paint': (t) =>
                In({
                  layer: i,
                  key: t.key,
                  value: t.value,
                  style: t.style,
                  styleSpec: t.styleSpec,
                  validateSpec: t.validateSpec,
                  objectElementValidators: {
                    '*': (t) => On(Et({ layerType: s }, t)),
                  },
                }),
            },
          })
        )),
        e
      );
    }
    function Nn(t) {
      const e = t.value,
        i = t.key,
        r = $r(e);
      return 'string' !== r
        ? [new At(i, e, `string expected, ${r} found`)]
        : [];
    }
    const Vn = {
      promoteId: function ({ key: t, value: e }) {
        if ('string' === $r(e)) return Nn({ key: t, value: e });
        {
          const i = [];
          for (const r in e) i.push(...Nn({ key: `${t}.${r}`, value: e[r] }));
          return i;
        }
      },
    };
    function jn(t) {
      const e = t.value,
        i = t.key,
        r = t.styleSpec,
        n = t.style,
        a = t.validateSpec;
      if (!e.type) return [new At(i, e, '"type" is required')];
      const s = Pn(e.type);
      let o;
      switch (s) {
        case 'vector':
        case 'raster':
          return (
            (o = In({
              key: i,
              value: e,
              valueSpec: r[`source_${s.replace('-', '_')}`],
              style: t.style,
              styleSpec: r,
              objectElementValidators: Vn,
              validateSpec: a,
            })),
            o
          );
        case 'raster-dem':
          return (
            (o = (function (t) {
              var e;
              const i = null !== (e = t.sourceName) && void 0 !== e ? e : '',
                r = t.value,
                n = t.styleSpec,
                a = n.source_raster_dem,
                s = t.style;
              let o = [];
              const l = $r(r);
              if (void 0 === r) return o;
              if ('object' !== l)
                return (
                  o.push(
                    new At(
                      'source_raster_dem',
                      r,
                      `object expected, ${l} found`
                    )
                  ),
                  o
                );
              const c = 'custom' === Pn(r.encoding),
                h = ['redFactor', 'greenFactor', 'blueFactor', 'baseShift'],
                u = t.value.encoding ? `"${t.value.encoding}"` : 'Default';
              for (const d in r)
                !c && h.includes(d)
                  ? o.push(
                      new At(
                        d,
                        r[d],
                        `In "${i}": "${d}" is only valid when "encoding" is set to "custom". ${u} encoding found`
                      )
                    )
                  : a[d]
                  ? (o = o.concat(
                      t.validateSpec({
                        key: d,
                        value: r[d],
                        valueSpec: a[d],
                        validateSpec: t.validateSpec,
                        style: s,
                        styleSpec: n,
                      })
                    ))
                  : o.push(new At(d, r[d], `unknown property "${d}"`));
              return o;
            })({
              sourceName: i,
              value: e,
              style: t.style,
              styleSpec: r,
              validateSpec: a,
            })),
            o
          );
        case 'geojson':
          if (
            ((o = In({
              key: i,
              value: e,
              valueSpec: r.source_geojson,
              style: n,
              styleSpec: r,
              validateSpec: a,
              objectElementValidators: Vn,
            })),
            e.cluster)
          )
            for (const t in e.clusterProperties) {
              const [r, n] = e.clusterProperties[t],
                a = 'string' == typeof r ? [r, ['accumulated'], ['get', t]] : r;
              o.push(
                ...Ln({
                  key: `${i}.${t}.map`,
                  value: n,
                  expressionContext: 'cluster-map',
                })
              ),
                o.push(
                  ...Ln({
                    key: `${i}.${t}.reduce`,
                    value: a,
                    expressionContext: 'cluster-reduce',
                  })
                );
            }
          return o;
        case 'video':
          return In({
            key: i,
            value: e,
            valueSpec: r.source_video,
            style: n,
            validateSpec: a,
            styleSpec: r,
          });
        case 'image':
          return In({
            key: i,
            value: e,
            valueSpec: r.source_image,
            style: n,
            validateSpec: a,
            styleSpec: r,
          });
        case 'canvas':
          return [
            new At(
              i,
              null,
              'Please use runtime APIs to add canvas sources, rather than including them in stylesheets.',
              'source.canvas'
            ),
          ];
        default:
          return En({
            key: `${i}.type`,
            value: e.type,
            valueSpec: {
              values: [
                'vector',
                'raster',
                'raster-dem',
                'geojson',
                'video',
                'image',
              ],
            },
          });
      }
    }
    function Un(t) {
      const e = t.value,
        i = t.styleSpec,
        r = i.light,
        n = t.style;
      let a = [];
      const s = $r(e);
      if (void 0 === e) return a;
      if ('object' !== s)
        return (
          (a = a.concat([new At('light', e, `object expected, ${s} found`)])), a
        );
      for (const o in e) {
        const s = o.match(/^(.*)-transition$/);
        a = a.concat(
          s && r[s[1]] && r[s[1]].transition
            ? t.validateSpec({
                key: o,
                value: e[o],
                valueSpec: i.transition,
                validateSpec: t.validateSpec,
                style: n,
                styleSpec: i,
              })
            : r[o]
            ? t.validateSpec({
                key: o,
                value: e[o],
                valueSpec: r[o],
                validateSpec: t.validateSpec,
                style: n,
                styleSpec: i,
              })
            : [new At(o, e[o], `unknown property "${o}"`)]
        );
      }
      return a;
    }
    function Gn(t) {
      const e = t.value,
        i = t.styleSpec,
        r = i.sky,
        n = t.style,
        a = $r(e);
      if (void 0 === e) return [];
      if ('object' !== a)
        return [new At('sky', e, `object expected, ${a} found`)];
      let s = [];
      for (const o in e)
        s = s.concat(
          r[o]
            ? t.validateSpec({
                key: o,
                value: e[o],
                valueSpec: r[o],
                style: n,
                styleSpec: i,
              })
            : [new At(o, e[o], `unknown property "${o}"`)]
        );
      return s;
    }
    function Zn(t) {
      const e = t.value,
        i = t.styleSpec,
        r = i.terrain,
        n = t.style;
      let a = [];
      const s = $r(e);
      if (void 0 === e) return a;
      if ('object' !== s)
        return (
          (a = a.concat([new At('terrain', e, `object expected, ${s} found`)])),
          a
        );
      for (const o in e)
        a = a.concat(
          r[o]
            ? t.validateSpec({
                key: o,
                value: e[o],
                valueSpec: r[o],
                validateSpec: t.validateSpec,
                style: n,
                styleSpec: i,
              })
            : [new At(o, e[o], `unknown property "${o}"`)]
        );
      return a;
    }
    function $n(t) {
      let e = [];
      const i = t.value,
        r = t.key;
      if (Array.isArray(i)) {
        const n = [],
          a = [];
        for (const s in i)
          i[s].id &&
            n.includes(i[s].id) &&
            e.push(
              new At(
                r,
                i,
                `all the sprites' ids must be unique, but ${i[s].id} is duplicated`
              )
            ),
            n.push(i[s].id),
            i[s].url &&
              a.includes(i[s].url) &&
              e.push(
                new At(
                  r,
                  i,
                  `all the sprites' URLs must be unique, but ${i[s].url} is duplicated`
                )
              ),
            a.push(i[s].url),
            (e = e.concat(
              In({
                key: `${r}[${s}]`,
                value: i[s],
                valueSpec: {
                  id: { type: 'string', required: !0 },
                  url: { type: 'string', required: !0 },
                },
                validateSpec: t.validateSpec,
              })
            ));
        return e;
      }
      return Nn({ key: r, value: i });
    }
    function qn(t) {
      return (
        (e = t.value),
        Boolean(e) && e.constructor === Object
          ? []
          : [new At(t.key, t.value, `object expected, ${$r(t.value)} found`)]
      );
      var e;
    }
    const Hn = {
      '*': () => [],
      'array': Sn,
      'boolean': function (t) {
        const e = t.value,
          i = t.key,
          r = $r(e);
        return 'boolean' !== r
          ? [new At(i, e, `boolean expected, ${r} found`)]
          : [];
      },
      'number': Mn,
      'color': An,
      'constants': Tn,
      'enum': En,
      'filter': Rn,
      'function': Dn,
      'layer': Bn,
      'object': In,
      'source': jn,
      'light': Un,
      'sky': Gn,
      'terrain': Zn,
      'projection': function (t) {
        const e = t.value,
          i = t.styleSpec,
          r = i.projection,
          n = t.style,
          a = $r(e);
        if (void 0 === e) return [];
        if ('object' !== a)
          return [new At('projection', e, `object expected, ${a} found`)];
        let s = [];
        for (const o in e)
          s = s.concat(
            r[o]
              ? t.validateSpec({
                  key: o,
                  value: e[o],
                  valueSpec: r[o],
                  style: n,
                  styleSpec: i,
                })
              : [new At(o, e[o], `unknown property "${o}"`)]
          );
        return s;
      },
      'projectionDefinition': function (t) {
        const e = t.key;
        let i = t.value;
        i = i instanceof String ? i.valueOf() : i;
        const r = $r(i);
        return 'array' !== r ||
          (function (t) {
            return (
              Array.isArray(t) &&
              3 === t.length &&
              'string' == typeof t[0] &&
              'string' == typeof t[1] &&
              'number' == typeof t[2]
            );
          })(i) ||
          (function (t) {
            return !!['interpolate', 'step', 'literal'].includes(t[0]);
          })(i)
          ? ['array', 'string'].includes(r)
            ? []
            : [new At(e, i, `projection expected, invalid type "${r}" found`)]
          : [
              new At(
                e,
                i,
                `projection expected, invalid array ${JSON.stringify(i)} found`
              ),
            ];
      },
      'string': Nn,
      'formatted': function (t) {
        return 0 === Nn(t).length ? [] : Ln(t);
      },
      'resolvedImage': function (t) {
        return 0 === Nn(t).length ? [] : Ln(t);
      },
      'padding': function (t) {
        const e = t.key,
          i = t.value;
        if ('array' === $r(i)) {
          if (i.length < 1 || i.length > 4)
            return [
              new At(
                e,
                i,
                `padding requires 1 to 4 values; ${i.length} values found`
              ),
            ];
          const r = { type: 'number' };
          let n = [];
          for (let a = 0; a < i.length; a++)
            n = n.concat(
              t.validateSpec({
                key: `${e}[${a}]`,
                value: i[a],
                validateSpec: t.validateSpec,
                valueSpec: r,
              })
            );
          return n;
        }
        return Mn({ key: e, value: i, valueSpec: {} });
      },
      'numberArray': function (t) {
        const e = t.key,
          i = t.value;
        if ('array' === $r(i)) {
          const r = { type: 'number' };
          if (i.length < 1)
            return [
              new At(e, i, 'array length at least 1 expected, length 0 found'),
            ];
          let n = [];
          for (let a = 0; a < i.length; a++)
            n = n.concat(
              t.validateSpec({
                key: `${e}[${a}]`,
                value: i[a],
                validateSpec: t.validateSpec,
                valueSpec: r,
              })
            );
          return n;
        }
        return Mn({ key: e, value: i, valueSpec: {} });
      },
      'colorArray': function (t) {
        const e = t.key,
          i = t.value;
        if ('array' === $r(i)) {
          if (i.length < 1)
            return [
              new At(e, i, 'array length at least 1 expected, length 0 found'),
            ];
          let t = [];
          for (let r = 0; r < i.length; r++)
            t = t.concat(An({ key: `${e}[${r}]`, value: i[r] }));
          return t;
        }
        return An({ key: e, value: i });
      },
      'variableAnchorOffsetCollection': function (t) {
        const e = t.key,
          i = t.value,
          r = $r(i),
          n = t.styleSpec;
        if ('array' !== r || i.length < 1 || i.length % 2 != 0)
          return [
            new At(
              e,
              i,
              'variableAnchorOffsetCollection requires a non-empty array of even length'
            ),
          ];
        let a = [];
        for (let s = 0; s < i.length; s += 2)
          (a = a.concat(
            En({
              key: `${e}[${s}]`,
              value: i[s],
              valueSpec: n.layout_symbol['text-anchor'],
            })
          )),
            (a = a.concat(
              Sn({
                key: `${e}[${s + 1}]`,
                value: i[s + 1],
                valueSpec: { length: 2, value: 'number' },
                validateSpec: t.validateSpec,
                style: t.style,
                styleSpec: n,
              })
            ));
        return a;
      },
      'sprite': $n,
      'state': qn,
    };
    function Wn(t) {
      const e = t.value,
        i = t.valueSpec,
        r = t.styleSpec;
      return (
        (t.validateSpec = Wn),
        i.expression && qr(Pn(e))
          ? Dn(t)
          : i.expression && en(Cn(e))
          ? Ln(t)
          : i.type && Hn[i.type]
          ? Hn[i.type](t)
          : In(Et({}, t, { valueSpec: i.type ? r[i.type] : i }))
      );
    }
    function Xn(t) {
      const e = t.value,
        i = t.key,
        r = Nn(t);
      return (
        r.length ||
          (-1 === e.indexOf('{fontstack}') &&
            r.push(
              new At(i, e, '"glyphs" url must include a "{fontstack}" token')
            ),
          -1 === e.indexOf('{range}') &&
            r.push(
              new At(i, e, '"glyphs" url must include a "{range}" token')
            )),
        r
      );
    }
    function Yn(t, e = vt) {
      let i = [];
      return (
        (i = i.concat(
          Wn({
            key: '',
            value: t,
            valueSpec: e.$root,
            styleSpec: e,
            style: t,
            validateSpec: Wn,
            objectElementValidators: { 'glyphs': Xn, '*': () => [] },
          })
        )),
        t.constants &&
          (i = i.concat(Tn({ key: 'constants', value: t.constants }))),
        Jn(i)
      );
    }
    function Kn(t) {
      return function (e) {
        return t(Object.assign({}, e, { validateSpec: Wn }));
      };
    }
    function Jn(t) {
      return [].concat(t).sort((t, e) => t.line - e.line);
    }
    function Qn(t) {
      return function (...e) {
        return Jn(t.apply(this, e));
      };
    }
    (Yn.source = Qn(Kn(jn))),
      (Yn.sprite = Qn(Kn($n))),
      (Yn.glyphs = Qn(Kn(Xn))),
      (Yn.light = Qn(Kn(Un))),
      (Yn.sky = Qn(Kn(Gn))),
      (Yn.terrain = Qn(Kn(Zn))),
      (Yn.state = Qn(Kn(qn))),
      (Yn.layer = Qn(Kn(Bn))),
      (Yn.filter = Qn(Kn(Rn))),
      (Yn.paintProperty = Qn(Kn(On))),
      (Yn.layoutProperty = Qn(Kn(Fn)));
    const ta = vt,
      ea = Yn,
      ia = ea.light,
      ra = ea.sky,
      na = ea.paintProperty,
      aa = ea.layoutProperty;
    function sa(t, e) {
      let i = !1;
      if (e && e.length)
        for (const r of e) t.fire(new _t(new Error(r.message))), (i = !0);
      return i;
    }
    class oa {
      constructor(t, e, i) {
        const r = (this.cells = []);
        if (t instanceof ArrayBuffer) {
          this.arrayBuffer = t;
          const n = new Int32Array(this.arrayBuffer);
          (t = n[0]), (this.d = (e = n[1]) + 2 * (i = n[2]));
          for (let t = 0; t < this.d * this.d; t++) {
            const e = n[3 + t],
              i = n[3 + t + 1];
            r.push(e === i ? null : n.subarray(e, i));
          }
          const a = n[3 + r.length + 1];
          (this.keys = n.subarray(n[3 + r.length], a)),
            (this.bboxes = n.subarray(a)),
            (this.insert = this._insertReadonly);
        } else {
          this.d = e + 2 * i;
          for (let t = 0; t < this.d * this.d; t++) r.push([]);
          (this.keys = []), (this.bboxes = []);
        }
        (this.n = e),
          (this.extent = t),
          (this.padding = i),
          (this.scale = e / t),
          (this.uid = 0);
        const n = (i / e) * t;
        (this.min = -n), (this.max = t + n);
      }
      insert(t, e, i, r, n) {
        this._forEachCell(
          e,
          i,
          r,
          n,
          this._insertCell,
          this.uid++,
          void 0,
          void 0
        ),
          this.keys.push(t),
          this.bboxes.push(e),
          this.bboxes.push(i),
          this.bboxes.push(r),
          this.bboxes.push(n);
      }
      _insertReadonly() {
        throw new Error(
          'Cannot insert into a GridIndex created from an ArrayBuffer.'
        );
      }
      _insertCell(t, e, i, r, n, a) {
        this.cells[n].push(a);
      }
      query(t, e, i, r, n) {
        const a = this.min,
          s = this.max;
        if (t <= a && e <= a && s <= i && s <= r && !n)
          return Array.prototype.slice.call(this.keys);
        {
          const a = [];
          return this._forEachCell(t, e, i, r, this._queryCell, a, {}, n), a;
        }
      }
      _queryCell(t, e, i, r, n, a, s, o) {
        const l = this.cells[n];
        if (null !== l) {
          const n = this.keys,
            c = this.bboxes;
          for (let h = 0; h < l.length; h++) {
            const u = l[h];
            if (void 0 === s[u]) {
              const l = 4 * u;
              (
                o
                  ? o(c[l + 0], c[l + 1], c[l + 2], c[l + 3])
                  : t <= c[l + 2] &&
                    e <= c[l + 3] &&
                    i >= c[l + 0] &&
                    r >= c[l + 1]
              )
                ? ((s[u] = !0), a.push(n[u]))
                : (s[u] = !1);
            }
          }
        }
      }
      _forEachCell(t, e, i, r, n, a, s, o) {
        const l = this._convertToCellCoord(t),
          c = this._convertToCellCoord(e),
          h = this._convertToCellCoord(i),
          u = this._convertToCellCoord(r);
        for (let d = l; d <= h; d++)
          for (let l = c; l <= u; l++) {
            const c = this.d * l + d;
            if (
              (!o ||
                o(
                  this._convertFromCellCoord(d),
                  this._convertFromCellCoord(l),
                  this._convertFromCellCoord(d + 1),
                  this._convertFromCellCoord(l + 1)
                )) &&
              n.call(this, t, e, i, r, c, a, s, o)
            )
              return;
          }
      }
      _convertFromCellCoord(t) {
        return (t - this.padding) / this.scale;
      }
      _convertToCellCoord(t) {
        return Math.max(
          0,
          Math.min(this.d - 1, Math.floor(t * this.scale) + this.padding)
        );
      }
      toArrayBuffer() {
        if (this.arrayBuffer) return this.arrayBuffer;
        const t = this.cells,
          e = 3 + this.cells.length + 1 + 1;
        let i = 0;
        for (let a = 0; a < this.cells.length; a++) i += this.cells[a].length;
        const r = new Int32Array(e + i + this.keys.length + this.bboxes.length);
        (r[0] = this.extent), (r[1] = this.n), (r[2] = this.padding);
        let n = e;
        for (let a = 0; a < t.length; a++) {
          const e = t[a];
          (r[3 + a] = n), r.set(e, n), (n += e.length);
        }
        return (
          (r[3 + t.length] = n),
          r.set(this.keys, n),
          (n += this.keys.length),
          (r[3 + t.length + 1] = n),
          r.set(this.bboxes, n),
          (n += this.bboxes.length),
          r.buffer
        );
      }
      static serialize(t, e) {
        const i = t.toArrayBuffer();
        return e && e.push(i), { buffer: i };
      }
      static deserialize(t) {
        return new oa(t.buffer);
      }
    }
    const la = {};
    function ca(t, e, i = {}) {
      if (la[t]) throw new Error(`${t} is already registered.`);
      Object.defineProperty(e, '_classRegistryKey', {
        value: t,
        writeable: !1,
      }),
        (la[t] = { klass: e, omit: i.omit || [], shallow: i.shallow || [] });
    }
    ca('Object', Object),
      ca('Set', Set),
      ca('TransferableGridIndex', oa),
      ca('Color', Se),
      ca('Error', Error),
      ca('AJAXError', ht),
      ca('ResolvedImage', Be),
      ca('StylePropertyFunction', on),
      ca('StyleExpression', tn, { omit: ['_evaluator'] }),
      ca('ZoomDependentExpression', an),
      ca('ZoomConstantExpression', nn),
      ca('CompoundExpression', Ar, { omit: ['_evaluate'] });
    for (const zd in Lr)
      Lr[zd]._classRegistryKey || ca(`Expression_${zd}`, Lr[zd]);
    function ha(t) {
      return (
        t &&
        'undefined' != typeof ArrayBuffer &&
        (t instanceof ArrayBuffer ||
          (t.constructor && 'ArrayBuffer' === t.constructor.name))
      );
    }
    function ua(t) {
      return t.$name || t.constructor._classRegistryKey;
    }
    function da(t) {
      return (
        !(function (t) {
          if (null === t || 'object' != typeof t) return !1;
          const e = ua(t);
          return !(!e || 'Object' === e);
        })(t) &&
        (null == t ||
          'boolean' == typeof t ||
          'number' == typeof t ||
          'string' == typeof t ||
          t instanceof Boolean ||
          t instanceof Number ||
          t instanceof String ||
          t instanceof Date ||
          t instanceof RegExp ||
          t instanceof Blob ||
          t instanceof Error ||
          ha(t) ||
          X(t) ||
          ArrayBuffer.isView(t) ||
          t instanceof ImageData)
      );
    }
    function pa(t, e) {
      if (da(t))
        return (
          (ha(t) || X(t)) && e && e.push(t),
          ArrayBuffer.isView(t) && e && e.push(t.buffer),
          t instanceof ImageData && e && e.push(t.data.buffer),
          t
        );
      if (Array.isArray(t)) {
        const i = [];
        for (const r of t) i.push(pa(r, e));
        return i;
      }
      if ('object' != typeof t)
        throw new Error("can't serialize object of type " + typeof t);
      const i = ua(t);
      if (!i)
        throw new Error(
          `can't serialize object of unregistered class ${t.constructor.name}`
        );
      if (!la[i]) throw new Error(`${i} is not registered.`);
      const { klass: r } = la[i],
        n = r.serialize ? r.serialize(t, e) : {};
      if (r.serialize) {
        if (e && n === e[e.length - 1])
          throw new Error(
            "statically serialized object won't survive transfer of $name property"
          );
      } else {
        for (const r in t) {
          if (!t.hasOwnProperty(r)) continue;
          if (la[i].omit.indexOf(r) >= 0) continue;
          const a = t[r];
          n[r] = la[i].shallow.indexOf(r) >= 0 ? a : pa(a, e);
        }
        t instanceof Error && (n.message = t.message);
      }
      if (n.$name)
        throw new Error(
          '$name property is reserved for worker serialization logic.'
        );
      return 'Object' !== i && (n.$name = i), n;
    }
    function fa(t) {
      if (da(t)) return t;
      if (Array.isArray(t)) return t.map(fa);
      if ('object' != typeof t)
        throw new Error("can't deserialize object of type " + typeof t);
      const e = ua(t) || 'Object';
      if (!la[e]) throw new Error(`can't deserialize unregistered class ${e}`);
      const { klass: i } = la[e];
      if (!i) throw new Error(`can't deserialize unregistered class ${e}`);
      if (i.deserialize) return i.deserialize(t);
      const r = Object.create(i.prototype);
      for (const n of Object.keys(t)) {
        if ('$name' === n) continue;
        const i = t[n];
        r[n] = la[e].shallow.indexOf(n) >= 0 ? i : fa(i);
      }
      return r;
    }
    class ma {
      constructor() {
        this.first = !0;
      }
      update(t, e) {
        const i = Math.floor(t);
        return this.first
          ? ((this.first = !1),
            (this.lastIntegerZoom = i),
            (this.lastIntegerZoomTime = 0),
            (this.lastZoom = t),
            (this.lastFloorZoom = i),
            !0)
          : (this.lastFloorZoom > i
              ? ((this.lastIntegerZoom = i + 1), (this.lastIntegerZoomTime = e))
              : this.lastFloorZoom < i &&
                ((this.lastIntegerZoom = i), (this.lastIntegerZoomTime = e)),
            t !== this.lastZoom &&
              ((this.lastZoom = t), (this.lastFloorZoom = i), !0));
      }
    }
    const ga = {
      'Latin-1 Supplement': (t) => t >= 128 && t <= 255,
      'Hangul Jamo': (t) => t >= 4352 && t <= 4607,
      'Khmer': (t) => t >= 6016 && t <= 6143,
      'General Punctuation': (t) => t >= 8192 && t <= 8303,
      'Letterlike Symbols': (t) => t >= 8448 && t <= 8527,
      'Number Forms': (t) => t >= 8528 && t <= 8591,
      'Miscellaneous Technical': (t) => t >= 8960 && t <= 9215,
      'Control Pictures': (t) => t >= 9216 && t <= 9279,
      'Optical Character Recognition': (t) => t >= 9280 && t <= 9311,
      'Enclosed Alphanumerics': (t) => t >= 9312 && t <= 9471,
      'Geometric Shapes': (t) => t >= 9632 && t <= 9727,
      'Miscellaneous Symbols': (t) => t >= 9728 && t <= 9983,
      'Miscellaneous Symbols and Arrows': (t) => t >= 11008 && t <= 11263,
      'Ideographic Description Characters': (t) => t >= 12272 && t <= 12287,
      'CJK Symbols and Punctuation': (t) => t >= 12288 && t <= 12351,
      'Hiragana': (t) => t >= 12352 && t <= 12447,
      'Katakana': (t) => t >= 12448 && t <= 12543,
      'Kanbun': (t) => t >= 12688 && t <= 12703,
      'CJK Strokes': (t) => t >= 12736 && t <= 12783,
      'Enclosed CJK Letters and Months': (t) => t >= 12800 && t <= 13055,
      'CJK Compatibility': (t) => t >= 13056 && t <= 13311,
      'Yijing Hexagram Symbols': (t) => t >= 19904 && t <= 19967,
      'CJK Unified Ideographs': (t) => t >= 19968 && t <= 40959,
      'Hangul Syllables': (t) => t >= 44032 && t <= 55215,
      'Private Use Area': (t) => t >= 57344 && t <= 63743,
      'Vertical Forms': (t) => t >= 65040 && t <= 65055,
      'CJK Compatibility Forms': (t) => t >= 65072 && t <= 65103,
      'Small Form Variants': (t) => t >= 65104 && t <= 65135,
      'Halfwidth and Fullwidth Forms': (t) => t >= 65280 && t <= 65519,
    };
    function _a(t) {
      for (const e of t) if (Ta(e.charCodeAt(0))) return !0;
      return !1;
    }
    function ya(t) {
      for (const e of t) if (!ba(e.charCodeAt(0))) return !1;
      return !0;
    }
    function va(t) {
      const e = t
        .map((t) => {
          try {
            return new RegExp(`\\p{sc=${t}}`, 'u').source;
          } catch (t) {
            return null;
          }
        })
        .filter((t) => t);
      return new RegExp(e.join('|'), 'u');
    }
    const xa = va(['Arab', 'Dupl', 'Mong', 'Ougr', 'Syrc']);
    function ba(t) {
      return !xa.test(String.fromCodePoint(t));
    }
    const wa = va([
      'Bopo',
      'Hani',
      'Hira',
      'Kana',
      'Kits',
      'Nshu',
      'Tang',
      'Yiii',
    ]);
    function Ta(t) {
      return !(
        746 !== t &&
        747 !== t &&
        (t < 4352 ||
          !(
            (ga['CJK Compatibility Forms'](t) && !(t >= 65097 && t <= 65103)) ||
            ga['CJK Compatibility'](t) ||
            ga['CJK Strokes'](t) ||
            !(
              !ga['CJK Symbols and Punctuation'](t) ||
              (t >= 12296 && t <= 12305) ||
              (t >= 12308 && t <= 12319) ||
              12336 === t
            ) ||
            ga['Enclosed CJK Letters and Months'](t) ||
            ga['Ideographic Description Characters'](t) ||
            ga.Kanbun(t) ||
            (ga.Katakana(t) && 12540 !== t) ||
            !(
              !ga['Halfwidth and Fullwidth Forms'](t) ||
              65288 === t ||
              65289 === t ||
              65293 === t ||
              (t >= 65306 && t <= 65310) ||
              65339 === t ||
              65341 === t ||
              65343 === t ||
              (t >= 65371 && t <= 65503) ||
              65507 === t ||
              (t >= 65512 && t <= 65519)
            ) ||
            !(
              !ga['Small Form Variants'](t) ||
              (t >= 65112 && t <= 65118) ||
              (t >= 65123 && t <= 65126)
            ) ||
            ga['Vertical Forms'](t) ||
            ga['Yijing Hexagram Symbols'](t) ||
            /\p{sc=Cans}/u.test(String.fromCodePoint(t)) ||
            /\p{sc=Hang}/u.test(String.fromCodePoint(t)) ||
            wa.test(String.fromCodePoint(t))
          ))
      );
    }
    function Pa(t) {
      return !(
        Ta(t) ||
        (function (t) {
          return !!(
            (ga['Latin-1 Supplement'](t) &&
              (167 === t ||
                169 === t ||
                174 === t ||
                177 === t ||
                188 === t ||
                189 === t ||
                190 === t ||
                215 === t ||
                247 === t)) ||
            (ga['General Punctuation'](t) &&
              (8214 === t ||
                8224 === t ||
                8225 === t ||
                8240 === t ||
                8241 === t ||
                8251 === t ||
                8252 === t ||
                8258 === t ||
                8263 === t ||
                8264 === t ||
                8265 === t ||
                8273 === t)) ||
            ga['Letterlike Symbols'](t) ||
            ga['Number Forms'](t) ||
            (ga['Miscellaneous Technical'](t) &&
              ((t >= 8960 && t <= 8967) ||
                (t >= 8972 && t <= 8991) ||
                (t >= 8996 && t <= 9e3) ||
                9003 === t ||
                (t >= 9085 && t <= 9114) ||
                (t >= 9150 && t <= 9165) ||
                9167 === t ||
                (t >= 9169 && t <= 9179) ||
                (t >= 9186 && t <= 9215))) ||
            (ga['Control Pictures'](t) && 9251 !== t) ||
            ga['Optical Character Recognition'](t) ||
            ga['Enclosed Alphanumerics'](t) ||
            ga['Geometric Shapes'](t) ||
            (ga['Miscellaneous Symbols'](t) && !(t >= 9754 && t <= 9759)) ||
            (ga['Miscellaneous Symbols and Arrows'](t) &&
              ((t >= 11026 && t <= 11055) ||
                (t >= 11088 && t <= 11097) ||
                (t >= 11192 && t <= 11243))) ||
            ga['CJK Symbols and Punctuation'](t) ||
            ga.Katakana(t) ||
            ga['Private Use Area'](t) ||
            ga['CJK Compatibility Forms'](t) ||
            ga['Small Form Variants'](t) ||
            ga['Halfwidth and Fullwidth Forms'](t) ||
            8734 === t ||
            8756 === t ||
            8757 === t ||
            (t >= 9984 && t <= 10087) ||
            (t >= 10102 && t <= 10131) ||
            65532 === t ||
            65533 === t
          );
        })(t)
      );
    }
    const Ca = va([
      'Adlm',
      'Arab',
      'Armi',
      'Avst',
      'Chrs',
      'Cprt',
      'Egyp',
      'Elym',
      'Gara',
      'Hatr',
      'Hebr',
      'Hung',
      'Khar',
      'Lydi',
      'Mand',
      'Mani',
      'Mend',
      'Merc',
      'Mero',
      'Narb',
      'Nbat',
      'Nkoo',
      'Orkh',
      'Palm',
      'Phli',
      'Phlp',
      'Phnx',
      'Prti',
      'Rohg',
      'Samr',
      'Sarb',
      'Sogo',
      'Syrc',
      'Thaa',
      'Todr',
      'Yezi',
    ]);
    function Ia(t) {
      return Ca.test(String.fromCodePoint(t));
    }
    function Sa(t, e) {
      return !(
        (!e && Ia(t)) ||
        (t >= 2304 && t <= 3583) ||
        (t >= 3840 && t <= 4255) ||
        ga.Khmer(t)
      );
    }
    function Ma(t) {
      for (const e of t) if (Ia(e.charCodeAt(0))) return !0;
      return !1;
    }
    const Da = new (class {
      constructor() {
        (this.TIMEOUT = 5e3),
          (this.applyArabicShaping = null),
          (this.processBidirectionalText = null),
          (this.processStyledBidirectionalText = null),
          (this.pluginStatus = 'unavailable'),
          (this.pluginURL = null),
          (this.loadScriptResolve = () => {});
      }
      setState(t) {
        (this.pluginStatus = t.pluginStatus), (this.pluginURL = t.pluginURL);
      }
      getState() {
        return { pluginStatus: this.pluginStatus, pluginURL: this.pluginURL };
      }
      setMethods(t) {
        if (Da.isParsed())
          throw new Error('RTL text plugin already registered.');
        (this.applyArabicShaping = t.applyArabicShaping),
          (this.processBidirectionalText = t.processBidirectionalText),
          (this.processStyledBidirectionalText =
            t.processStyledBidirectionalText),
          this.loadScriptResolve();
      }
      isParsed() {
        return (
          null != this.applyArabicShaping &&
          null != this.processBidirectionalText &&
          null != this.processStyledBidirectionalText
        );
      }
      getRTLTextPluginStatus() {
        return this.pluginStatus;
      }
      syncState(t, i) {
        return e(this, void 0, void 0, function* () {
          if (this.isParsed()) return this.getState();
          if ('loading' !== t.pluginStatus) return this.setState(t), t;
          const e = t.pluginURL,
            r = new Promise((t) => {
              this.loadScriptResolve = t;
            });
          i(e);
          const n = new Promise((t) => setTimeout(() => t(), this.TIMEOUT));
          if ((yield Promise.race([r, n]), this.isParsed())) {
            const t = { pluginStatus: 'loaded', pluginURL: e };
            return this.setState(t), t;
          }
          throw (
            (this.setState({ pluginStatus: 'error', pluginURL: '' }),
            new Error(`RTL Text Plugin failed to import scripts from ${e}`))
          );
        });
      }
    })();
    class La {
      constructor(t, e) {
        (this.isSupportedScript = Aa),
          (this.zoom = t),
          e
            ? ((this.now = e.now || 0),
              (this.fadeDuration = e.fadeDuration || 0),
              (this.zoomHistory = e.zoomHistory || new ma()),
              (this.transition = e.transition || {}))
            : ((this.now = 0),
              (this.fadeDuration = 0),
              (this.zoomHistory = new ma()),
              (this.transition = {}));
      }
      crossFadingFactor() {
        return 0 === this.fadeDuration
          ? 1
          : Math.min(
              (this.now - this.zoomHistory.lastIntegerZoomTime) /
                this.fadeDuration,
              1
            );
      }
      getCrossfadeParameters() {
        const t = this.zoom,
          e = t - Math.floor(t),
          i = this.crossFadingFactor();
        return t > this.zoomHistory.lastIntegerZoom
          ? { fromScale: 2, toScale: 1, t: e + (1 - e) * i }
          : { fromScale: 0.5, toScale: 1, t: 1 - (1 - i) * e };
      }
    }
    function Aa(t) {
      return (function (t, e) {
        for (const i of t) if (!Sa(i.charCodeAt(0), e)) return !1;
        return !0;
      })(t, 'loaded' === Da.getRTLTextPluginStatus());
    }
    class Ea {
      constructor(t, e, i) {
        (this.property = t),
          (this.value = e),
          (this.expression = (function (t, e, i) {
            if (qr(t)) return new on(t, e);
            if (en(t)) {
              const r = sn(t, e, i);
              if ('error' === r.result)
                throw new Error(
                  r.value.map((t) => `${t.key}: ${t.message}`).join(', ')
                );
              return r.value;
            }
            {
              let i = t;
              return (
                'color' === e.type && 'string' == typeof t
                  ? (i = Se.parse(t))
                  : 'padding' !== e.type ||
                    ('number' != typeof t && !Array.isArray(t))
                  ? 'numberArray' !== e.type ||
                    ('number' != typeof t && !Array.isArray(t))
                    ? 'colorArray' !== e.type ||
                      ('string' != typeof t && !Array.isArray(t))
                      ? 'variableAnchorOffsetCollection' === e.type &&
                        Array.isArray(t)
                        ? (i = Fe.parse(t))
                        : 'projectionDefinition' === e.type &&
                          'string' == typeof t &&
                          (i = Ne.parse(t))
                      : (i = ze.parse(t))
                    : (i = Re.parse(t))
                  : (i = Ee.parse(t)),
                {
                  globalStateRefs: new Set(),
                  _globalState: null,
                  kind: 'constant',
                  evaluate: () => i,
                }
              );
            }
          })(void 0 === e ? t.specification.default : e, t.specification, i));
      }
      isDataDriven() {
        return (
          'source' === this.expression.kind ||
          'composite' === this.expression.kind
        );
      }
      getGlobalStateRefs() {
        return this.expression.globalStateRefs || new Set();
      }
      possiblyEvaluate(t, e, i) {
        return this.property.possiblyEvaluate(this, t, e, i);
      }
    }
    class Ra {
      constructor(t, e) {
        (this.property = t), (this.value = new Ea(t, void 0, e));
      }
      transitioned(t, e) {
        return new ka(
          this.property,
          this.value,
          e,
          B({}, t.transition, this.transition),
          t.now
        );
      }
      untransitioned() {
        return new ka(this.property, this.value, null, {}, 0);
      }
    }
    class za {
      constructor(t, e) {
        (this._properties = t),
          (this._values = Object.create(t.defaultTransitionablePropertyValues)),
          (this._globalState = e);
      }
      getValue(t) {
        return U(this._values[t].value.value);
      }
      setValue(t, e) {
        Object.prototype.hasOwnProperty.call(this._values, t) ||
          (this._values[t] = new Ra(
            this._values[t].property,
            this._globalState
          )),
          (this._values[t].value = new Ea(
            this._values[t].property,
            null === e ? void 0 : U(e),
            this._globalState
          ));
      }
      getTransition(t) {
        return U(this._values[t].transition);
      }
      setTransition(t, e) {
        Object.prototype.hasOwnProperty.call(this._values, t) ||
          (this._values[t] = new Ra(
            this._values[t].property,
            this._globalState
          )),
          (this._values[t].transition = U(e) || void 0);
      }
      serialize() {
        const t = {};
        for (const e of Object.keys(this._values)) {
          const i = this.getValue(e);
          void 0 !== i && (t[e] = i);
          const r = this.getTransition(e);
          void 0 !== r && (t[`${e}-transition`] = r);
        }
        return t;
      }
      transitioned(t, e) {
        const i = new Oa(this._properties);
        for (const r of Object.keys(this._values))
          i._values[r] = this._values[r].transitioned(t, e._values[r]);
        return i;
      }
      untransitioned() {
        const t = new Oa(this._properties);
        for (const e of Object.keys(this._values))
          t._values[e] = this._values[e].untransitioned();
        return t;
      }
    }
    class ka {
      constructor(t, e, i, r, n) {
        (this.property = t),
          (this.value = e),
          (this.begin = n + r.delay || 0),
          (this.end = this.begin + r.duration || 0),
          t.specification.transition &&
            (r.delay || r.duration) &&
            (this.prior = i);
      }
      possiblyEvaluate(t, e, i) {
        const r = t.now || 0,
          n = this.value.possiblyEvaluate(t, e, i),
          a = this.prior;
        if (a) {
          if (r > this.end) return (this.prior = null), n;
          if (this.value.isDataDriven()) return (this.prior = null), n;
          if (r < this.begin) return a.possiblyEvaluate(t, e, i);
          {
            const s = (r - this.begin) / (this.end - this.begin);
            return this.property.interpolate(
              a.possiblyEvaluate(t, e, i),
              n,
              R(s)
            );
          }
        }
        return n;
      }
    }
    class Oa {
      constructor(t) {
        (this._properties = t),
          (this._values = Object.create(t.defaultTransitioningPropertyValues));
      }
      possiblyEvaluate(t, e, i) {
        const r = new Na(this._properties);
        for (const n of Object.keys(this._values))
          r._values[n] = this._values[n].possiblyEvaluate(t, e, i);
        return r;
      }
      hasTransition() {
        for (const t of Object.keys(this._values))
          if (this._values[t].prior) return !0;
        return !1;
      }
    }
    class Fa {
      constructor(t, e) {
        (this._properties = t),
          (this._values = Object.create(t.defaultPropertyValues)),
          (this._globalState = e);
      }
      hasValue(t) {
        return void 0 !== this._values[t].value;
      }
      getValue(t) {
        return U(this._values[t].value);
      }
      setValue(t, e) {
        this._values[t] = new Ea(
          this._values[t].property,
          null === e ? void 0 : U(e),
          this._globalState
        );
      }
      serialize() {
        const t = {};
        for (const e of Object.keys(this._values)) {
          const i = this.getValue(e);
          void 0 !== i && (t[e] = i);
        }
        return t;
      }
      possiblyEvaluate(t, e, i) {
        const r = new Na(this._properties);
        for (const n of Object.keys(this._values))
          r._values[n] = this._values[n].possiblyEvaluate(t, e, i);
        return r;
      }
    }
    class Ba {
      constructor(t, e, i) {
        (this.property = t), (this.value = e), (this.parameters = i);
      }
      isConstant() {
        return 'constant' === this.value.kind;
      }
      constantOr(t) {
        return 'constant' === this.value.kind ? this.value.value : t;
      }
      evaluate(t, e, i, r) {
        return this.property.evaluate(this.value, this.parameters, t, e, i, r);
      }
    }
    class Na {
      constructor(t) {
        (this._properties = t),
          (this._values = Object.create(t.defaultPossiblyEvaluatedValues));
      }
      get(t) {
        return this._values[t];
      }
    }
    class Va {
      constructor(t) {
        this.specification = t;
      }
      possiblyEvaluate(t, e) {
        if (t.isDataDriven())
          throw new Error('Value should not be data driven');
        return t.expression.evaluate(e);
      }
      interpolate(t, e, i) {
        const r = mi[this.specification.type];
        return r ? r(t, e, i) : t;
      }
    }
    class ja {
      constructor(t, e) {
        (this.specification = t), (this.overrides = e);
      }
      possiblyEvaluate(t, e, i, r) {
        return new Ba(
          this,
          'constant' === t.expression.kind || 'camera' === t.expression.kind
            ? {
                kind: 'constant',
                value: t.expression.evaluate(e, null, {}, i, r),
              }
            : t.expression,
          e
        );
      }
      interpolate(t, e, i) {
        if ('constant' !== t.value.kind || 'constant' !== e.value.kind)
          return t;
        if (void 0 === t.value.value || void 0 === e.value.value)
          return new Ba(
            this,
            { kind: 'constant', value: void 0 },
            t.parameters
          );
        const r = mi[this.specification.type];
        if (r) {
          const n = r(t.value.value, e.value.value, i);
          return new Ba(this, { kind: 'constant', value: n }, t.parameters);
        }
        return t;
      }
      evaluate(t, e, i, r, n, a) {
        return 'constant' === t.kind ? t.value : t.evaluate(e, i, r, n, a);
      }
    }
    class Ua extends ja {
      possiblyEvaluate(t, e, i, r) {
        if (void 0 === t.value)
          return new Ba(this, { kind: 'constant', value: void 0 }, e);
        if ('constant' === t.expression.kind) {
          const n = t.expression.evaluate(e, null, {}, i, r),
            a =
              'resolvedImage' === t.property.specification.type &&
              'string' != typeof n
                ? n.name
                : n,
            s = this._calculate(a, a, a, e);
          return new Ba(this, { kind: 'constant', value: s }, e);
        }
        if ('camera' === t.expression.kind) {
          const i = this._calculate(
            t.expression.evaluate({ zoom: e.zoom - 1 }),
            t.expression.evaluate({ zoom: e.zoom }),
            t.expression.evaluate({ zoom: e.zoom + 1 }),
            e
          );
          return new Ba(this, { kind: 'constant', value: i }, e);
        }
        return new Ba(this, t.expression, e);
      }
      evaluate(t, e, i, r, n, a) {
        if ('source' === t.kind) {
          const s = t.evaluate(e, i, r, n, a);
          return this._calculate(s, s, s, e);
        }
        return 'composite' === t.kind
          ? this._calculate(
              t.evaluate({ zoom: Math.floor(e.zoom) - 1 }, i, r),
              t.evaluate({ zoom: Math.floor(e.zoom) }, i, r),
              t.evaluate({ zoom: Math.floor(e.zoom) + 1 }, i, r),
              e
            )
          : t.value;
      }
      _calculate(t, e, i, r) {
        return r.zoom > r.zoomHistory.lastIntegerZoom
          ? { from: t, to: e }
          : { from: i, to: e };
      }
      interpolate(t) {
        return t;
      }
    }
    class Ga {
      constructor(t) {
        this.specification = t;
      }
      possiblyEvaluate(t, e, i, r) {
        if (void 0 !== t.value) {
          if ('constant' === t.expression.kind) {
            const n = t.expression.evaluate(e, null, {}, i, r);
            return this._calculate(n, n, n, e);
          }
          return this._calculate(
            t.expression.evaluate(new La(Math.floor(e.zoom - 1), e)),
            t.expression.evaluate(new La(Math.floor(e.zoom), e)),
            t.expression.evaluate(new La(Math.floor(e.zoom + 1), e)),
            e
          );
        }
      }
      _calculate(t, e, i, r) {
        return r.zoom > r.zoomHistory.lastIntegerZoom
          ? { from: t, to: e }
          : { from: i, to: e };
      }
      interpolate(t) {
        return t;
      }
    }
    class Za {
      constructor(t) {
        this.specification = t;
      }
      possiblyEvaluate(t, e, i, r) {
        return !!t.expression.evaluate(e, null, {}, i, r);
      }
      interpolate() {
        return !1;
      }
    }
    class $a {
      constructor(t) {
        (this.properties = t),
          (this.defaultPropertyValues = {}),
          (this.defaultTransitionablePropertyValues = {}),
          (this.defaultTransitioningPropertyValues = {}),
          (this.defaultPossiblyEvaluatedValues = {}),
          (this.overridableProperties = []);
        for (const e in t) {
          const i = t[e];
          i.specification.overridable && this.overridableProperties.push(e);
          const r = (this.defaultPropertyValues[e] = new Ea(i, void 0, void 0)),
            n = (this.defaultTransitionablePropertyValues[e] = new Ra(
              i,
              void 0
            ));
          (this.defaultTransitioningPropertyValues[e] = n.untransitioned()),
            (this.defaultPossiblyEvaluatedValues[e] = r.possiblyEvaluate({}));
        }
      }
    }
    ca('DataDrivenProperty', ja),
      ca('DataConstantProperty', Va),
      ca('CrossFadedDataDrivenProperty', Ua),
      ca('CrossFadedProperty', Ga),
      ca('ColorRampProperty', Za);
    const qa = '-transition';
    class Ha extends yt {
      constructor(t, e, i) {
        if (
          (super(),
          (this.id = t.id),
          (this.type = t.type),
          (this._globalState = i),
          (this._featureFilter = {
            filter: () => !0,
            needGeometry: !1,
            getGlobalStateRefs: () => new Set(),
          }),
          'custom' !== t.type &&
            ((this.metadata = t.metadata),
            (this.minzoom = t.minzoom),
            (this.maxzoom = t.maxzoom),
            'background' !== t.type &&
              ((this.source = t.source),
              (this.sourceLayer = t['source-layer']),
              (this.filter = t.filter),
              (this._featureFilter = pn(t.filter, i))),
            e.layout && (this._unevaluatedLayout = new Fa(e.layout, i)),
            e.paint))
        ) {
          this._transitionablePaint = new za(e.paint, i);
          for (const e in t.paint)
            this.setPaintProperty(e, t.paint[e], { validate: !1 });
          for (const e in t.layout)
            this.setLayoutProperty(e, t.layout[e], { validate: !1 });
          (this._transitioningPaint =
            this._transitionablePaint.untransitioned()),
            (this.paint = new Na(e.paint));
        }
      }
      setFilter(t) {
        (this.filter = t), (this._featureFilter = pn(t, this._globalState));
      }
      getCrossfadeParameters() {
        return this._crossfadeParameters;
      }
      getLayoutProperty(t) {
        return 'visibility' === t
          ? this.visibility
          : this._unevaluatedLayout.getValue(t);
      }
      getLayoutAffectingGlobalStateRefs() {
        const t = new Set();
        if (this._unevaluatedLayout)
          for (const e in this._unevaluatedLayout._values) {
            const i = this._unevaluatedLayout._values[e];
            for (const e of i.getGlobalStateRefs()) t.add(e);
          }
        for (const e of this._featureFilter.getGlobalStateRefs()) t.add(e);
        return t;
      }
      getPaintAffectingGlobalStateRefs() {
        var t;
        const e = new globalThis.Map();
        if (this._transitionablePaint)
          for (const i in this._transitionablePaint._values) {
            const r = this._transitionablePaint._values[i].value;
            for (const n of r.getGlobalStateRefs()) {
              const a = null !== (t = e.get(n)) && void 0 !== t ? t : [];
              a.push({ name: i, value: r.value }), e.set(n, a);
            }
          }
        return e;
      }
      setLayoutProperty(t, e, i = {}) {
        (null != e &&
          this._validate(aa, `layers.${this.id}.layout.${t}`, t, e, i)) ||
          ('visibility' !== t
            ? this._unevaluatedLayout.setValue(t, e)
            : (this.visibility = e));
      }
      getPaintProperty(t) {
        return t.endsWith(qa)
          ? this._transitionablePaint.getTransition(t.slice(0, -11))
          : this._transitionablePaint.getValue(t);
      }
      setPaintProperty(t, e, i = {}) {
        if (
          null != e &&
          this._validate(na, `layers.${this.id}.paint.${t}`, t, e, i)
        )
          return !1;
        if (t.endsWith(qa))
          return (
            this._transitionablePaint.setTransition(
              t.slice(0, -11),
              e || void 0
            ),
            !1
          );
        {
          const i = this._transitionablePaint._values[t],
            r =
              'cross-faded-data-driven' ===
              i.property.specification['property-type'],
            n = i.value.isDataDriven(),
            a = i.value;
          this._transitionablePaint.setValue(t, e),
            this._handleSpecialPaintPropertyUpdate(t);
          const s = this._transitionablePaint._values[t].value;
          return (
            s.isDataDriven() ||
            n ||
            r ||
            this._handleOverridablePaintPropertyUpdate(t, a, s)
          );
        }
      }
      _handleSpecialPaintPropertyUpdate(t) {}
      _handleOverridablePaintPropertyUpdate(t, e, i) {
        return !1;
      }
      isHidden(t, e = !1) {
        return (
          !!(
            this.minzoom && t < (e ? Math.floor(this.minzoom) : this.minzoom)
          ) ||
          !!(this.maxzoom && t >= this.maxzoom) ||
          'none' === this.visibility
        );
      }
      updateTransitions(t) {
        this._transitioningPaint = this._transitionablePaint.transitioned(
          t,
          this._transitioningPaint
        );
      }
      hasTransition() {
        return this._transitioningPaint.hasTransition();
      }
      recalculate(t, e) {
        t.getCrossfadeParameters &&
          (this._crossfadeParameters = t.getCrossfadeParameters()),
          this._unevaluatedLayout &&
            (this.layout = this._unevaluatedLayout.possiblyEvaluate(
              t,
              void 0,
              e
            )),
          (this.paint = this._transitioningPaint.possiblyEvaluate(
            t,
            void 0,
            e
          ));
      }
      serialize() {
        const t = {
          'id': this.id,
          'type': this.type,
          'source': this.source,
          'source-layer': this.sourceLayer,
          'metadata': this.metadata,
          'minzoom': this.minzoom,
          'maxzoom': this.maxzoom,
          'filter': this.filter,
          'layout':
            this._unevaluatedLayout && this._unevaluatedLayout.serialize(),
          'paint':
            this._transitionablePaint && this._transitionablePaint.serialize(),
        };
        return (
          this.visibility &&
            ((t.layout = t.layout || {}),
            (t.layout.visibility = this.visibility)),
          j(
            t,
            (t, e) =>
              !(
                void 0 === t ||
                ('layout' === e && !Object.keys(t).length) ||
                ('paint' === e && !Object.keys(t).length)
              )
          )
        );
      }
      _validate(t, e, i, r, n = {}) {
        return (
          (!n || !1 !== n.validate) &&
          sa(
            this,
            t.call(ea, {
              key: e,
              layerType: this.type,
              objectKey: i,
              value: r,
              styleSpec: vt,
              style: { glyphs: !0, sprite: !0 },
            })
          )
        );
      }
      is3D() {
        return !1;
      }
      isTileClipped() {
        return !1;
      }
      hasOffscreenPass() {
        return !1;
      }
      resize() {}
      isStateDependent() {
        for (const t in this.paint._values) {
          const e = this.paint.get(t);
          if (
            e instanceof Ba &&
            Ur(e.property.specification) &&
            ('source' === e.value.kind || 'composite' === e.value.kind) &&
            e.value.isStateDependent
          )
            return !0;
        }
        return !1;
      }
    }
    let Wa;
    var Xa = {
      get paint() {
        return (Wa =
          Wa ||
          new $a({
            'raster-opacity': new Va(vt.paint_raster['raster-opacity']),
            'raster-hue-rotate': new Va(vt.paint_raster['raster-hue-rotate']),
            'raster-brightness-min': new Va(
              vt.paint_raster['raster-brightness-min']
            ),
            'raster-brightness-max': new Va(
              vt.paint_raster['raster-brightness-max']
            ),
            'raster-saturation': new Va(vt.paint_raster['raster-saturation']),
            'raster-contrast': new Va(vt.paint_raster['raster-contrast']),
            'raster-resampling': new Va(vt.paint_raster['raster-resampling']),
            'raster-fade-duration': new Va(
              vt.paint_raster['raster-fade-duration']
            ),
          }));
      },
    };
    class Ya extends Ha {
      constructor(t, e) {
        super(t, Xa, e);
      }
    }
    const Ka = {
      Int8: Int8Array,
      Uint8: Uint8Array,
      Int16: Int16Array,
      Uint16: Uint16Array,
      Int32: Int32Array,
      Uint32: Uint32Array,
      Float32: Float32Array,
    };
    class Ja {
      constructor(t, e) {
        (this._structArray = t),
          (this._pos1 = e * this.size),
          (this._pos2 = this._pos1 / 2),
          (this._pos4 = this._pos1 / 4),
          (this._pos8 = this._pos1 / 8);
      }
    }
    class Qa {
      constructor() {
        (this.isTransferred = !1), (this.capacity = -1), this.resize(0);
      }
      static serialize(t, e) {
        return (
          t._trim(),
          e && ((t.isTransferred = !0), e.push(t.arrayBuffer)),
          { length: t.length, arrayBuffer: t.arrayBuffer }
        );
      }
      static deserialize(t) {
        const e = Object.create(this.prototype);
        return (
          (e.arrayBuffer = t.arrayBuffer),
          (e.length = t.length),
          (e.capacity = t.arrayBuffer.byteLength / e.bytesPerElement),
          e._refreshViews(),
          e
        );
      }
      _trim() {
        this.length !== this.capacity &&
          ((this.capacity = this.length),
          (this.arrayBuffer = this.arrayBuffer.slice(
            0,
            this.length * this.bytesPerElement
          )),
          this._refreshViews());
      }
      clear() {
        this.length = 0;
      }
      resize(t) {
        this.reserve(t), (this.length = t);
      }
      reserve(t) {
        if (t > this.capacity) {
          (this.capacity = Math.max(t, Math.floor(5 * this.capacity), 128)),
            (this.arrayBuffer = new ArrayBuffer(
              this.capacity * this.bytesPerElement
            ));
          const e = this.uint8;
          this._refreshViews(), e && this.uint8.set(e);
        }
      }
      _refreshViews() {
        throw new Error(
          '_refreshViews() must be implemented by each concrete StructArray layout'
        );
      }
    }
    function ts(t, e = 1) {
      let i = 0,
        r = 0;
      return {
        members: t.map((t) => {
          const n = Ka[t.type].BYTES_PER_ELEMENT,
            a = (i = es(i, Math.max(e, n))),
            s = t.components || 1;
          return (
            (r = Math.max(r, n)),
            (i += n * s),
            { name: t.name, type: t.type, components: s, offset: a }
          );
        }),
        size: es(i, Math.max(r, e)),
        alignment: e,
      };
    }
    function es(t, e) {
      return Math.ceil(t / e) * e;
    }
    class is extends Qa {
      _refreshViews() {
        (this.uint8 = new Uint8Array(this.arrayBuffer)),
          (this.int16 = new Int16Array(this.arrayBuffer));
      }
      emplaceBack(t, e) {
        const i = this.length;
        return this.resize(i + 1), this.emplace(i, t, e);
      }
      emplace(t, e, i) {
        const r = 2 * t;
        return (this.int16[r + 0] = e), (this.int16[r + 1] = i), t;
      }
    }
    (is.prototype.bytesPerElement = 4), ca('StructArrayLayout2i4', is);
    class rs extends Qa {
      _refreshViews() {
        (this.uint8 = new Uint8Array(this.arrayBuffer)),
          (this.int16 = new Int16Array(this.arrayBuffer));
      }
      emplaceBack(t, e, i) {
        const r = this.length;
        return this.resize(r + 1), this.emplace(r, t, e, i);
      }
      emplace(t, e, i, r) {
        const n = 3 * t;
        return (
          (this.int16[n + 0] = e),
          (this.int16[n + 1] = i),
          (this.int16[n + 2] = r),
          t
        );
      }
    }
    (rs.prototype.bytesPerElement = 6), ca('StructArrayLayout3i6', rs);
    class ns extends Qa {
      _refreshViews() {
        (this.uint8 = new Uint8Array(this.arrayBuffer)),
          (this.int16 = new Int16Array(this.arrayBuffer));
      }
      emplaceBack(t, e, i, r) {
        const n = this.length;
        return this.resize(n + 1), this.emplace(n, t, e, i, r);
      }
      emplace(t, e, i, r, n) {
        const a = 4 * t;
        return (
          (this.int16[a + 0] = e),
          (this.int16[a + 1] = i),
          (this.int16[a + 2] = r),
          (this.int16[a + 3] = n),
          t
        );
      }
    }
    (ns.prototype.bytesPerElement = 8), ca('StructArrayLayout4i8', ns);
    class as extends Qa {
      _refreshViews() {
        (this.uint8 = new Uint8Array(this.arrayBuffer)),
          (this.int16 = new Int16Array(this.arrayBuffer));
      }
      emplaceBack(t, e, i, r, n, a) {
        const s = this.length;
        return this.resize(s + 1), this.emplace(s, t, e, i, r, n, a);
      }
      emplace(t, e, i, r, n, a, s) {
        const o = 6 * t;
        return (
          (this.int16[o + 0] = e),
          (this.int16[o + 1] = i),
          (this.int16[o + 2] = r),
          (this.int16[o + 3] = n),
          (this.int16[o + 4] = a),
          (this.int16[o + 5] = s),
          t
        );
      }
    }
    (as.prototype.bytesPerElement = 12), ca('StructArrayLayout2i4i12', as);
    class ss extends Qa {
      _refreshViews() {
        (this.uint8 = new Uint8Array(this.arrayBuffer)),
          (this.int16 = new Int16Array(this.arrayBuffer));
      }
      emplaceBack(t, e, i, r, n, a) {
        const s = this.length;
        return this.resize(s + 1), this.emplace(s, t, e, i, r, n, a);
      }
      emplace(t, e, i, r, n, a, s) {
        const o = 4 * t,
          l = 8 * t;
        return (
          (this.int16[o + 0] = e),
          (this.int16[o + 1] = i),
          (this.uint8[l + 4] = r),
          (this.uint8[l + 5] = n),
          (this.uint8[l + 6] = a),
          (this.uint8[l + 7] = s),
          t
        );
      }
    }
    (ss.prototype.bytesPerElement = 8), ca('StructArrayLayout2i4ub8', ss);
    class os extends Qa {
      _refreshViews() {
        (this.uint8 = new Uint8Array(this.arrayBuffer)),
          (this.float32 = new Float32Array(this.arrayBuffer));
      }
      emplaceBack(t, e) {
        const i = this.length;
        return this.resize(i + 1), this.emplace(i, t, e);
      }
      emplace(t, e, i) {
        const r = 2 * t;
        return (this.float32[r + 0] = e), (this.float32[r + 1] = i), t;
      }
    }
    (os.prototype.bytesPerElement = 8), ca('StructArrayLayout2f8', os);
    class ls extends Qa {
      _refreshViews() {
        (this.uint8 = new Uint8Array(this.arrayBuffer)),
          (this.uint16 = new Uint16Array(this.arrayBuffer));
      }
      emplaceBack(t, e, i, r, n, a, s, o, l, c) {
        const h = this.length;
        return (
          this.resize(h + 1), this.emplace(h, t, e, i, r, n, a, s, o, l, c)
        );
      }
      emplace(t, e, i, r, n, a, s, o, l, c, h) {
        const u = 10 * t;
        return (
          (this.uint16[u + 0] = e),
          (this.uint16[u + 1] = i),
          (this.uint16[u + 2] = r),
          (this.uint16[u + 3] = n),
          (this.uint16[u + 4] = a),
          (this.uint16[u + 5] = s),
          (this.uint16[u + 6] = o),
          (this.uint16[u + 7] = l),
          (this.uint16[u + 8] = c),
          (this.uint16[u + 9] = h),
          t
        );
      }
    }
    (ls.prototype.bytesPerElement = 20), ca('StructArrayLayout10ui20', ls);
    class cs extends Qa {
      _refreshViews() {
        (this.uint8 = new Uint8Array(this.arrayBuffer)),
          (this.uint16 = new Uint16Array(this.arrayBuffer));
      }
      emplaceBack(t, e, i, r, n, a, s, o) {
        const l = this.length;
        return this.resize(l + 1), this.emplace(l, t, e, i, r, n, a, s, o);
      }
      emplace(t, e, i, r, n, a, s, o, l) {
        const c = 8 * t;
        return (
          (this.uint16[c + 0] = e),
          (this.uint16[c + 1] = i),
          (this.uint16[c + 2] = r),
          (this.uint16[c + 3] = n),
          (this.uint16[c + 4] = a),
          (this.uint16[c + 5] = s),
          (this.uint16[c + 6] = o),
          (this.uint16[c + 7] = l),
          t
        );
      }
    }
    (cs.prototype.bytesPerElement = 16), ca('StructArrayLayout8ui16', cs);
    class hs extends Qa {
      _refreshViews() {
        (this.uint8 = new Uint8Array(this.arrayBuffer)),
          (this.int16 = new Int16Array(this.arrayBuffer)),
          (this.uint16 = new Uint16Array(this.arrayBuffer));
      }
      emplaceBack(t, e, i, r, n, a, s, o, l, c, h, u) {
        const d = this.length;
        return (
          this.resize(d + 1),
          this.emplace(d, t, e, i, r, n, a, s, o, l, c, h, u)
        );
      }
      emplace(t, e, i, r, n, a, s, o, l, c, h, u, d) {
        const p = 12 * t;
        return (
          (this.int16[p + 0] = e),
          (this.int16[p + 1] = i),
          (this.int16[p + 2] = r),
          (this.int16[p + 3] = n),
          (this.uint16[p + 4] = a),
          (this.uint16[p + 5] = s),
          (this.uint16[p + 6] = o),
          (this.uint16[p + 7] = l),
          (this.int16[p + 8] = c),
          (this.int16[p + 9] = h),
          (this.int16[p + 10] = u),
          (this.int16[p + 11] = d),
          t
        );
      }
    }
    (hs.prototype.bytesPerElement = 24), ca('StructArrayLayout4i4ui4i24', hs);
    class us extends Qa {
      _refreshViews() {
        (this.uint8 = new Uint8Array(this.arrayBuffer)),
          (this.float32 = new Float32Array(this.arrayBuffer));
      }
      emplaceBack(t, e, i) {
        const r = this.length;
        return this.resize(r + 1), this.emplace(r, t, e, i);
      }
      emplace(t, e, i, r) {
        const n = 3 * t;
        return (
          (this.float32[n + 0] = e),
          (this.float32[n + 1] = i),
          (this.float32[n + 2] = r),
          t
        );
      }
    }
    (us.prototype.bytesPerElement = 12), ca('StructArrayLayout3f12', us);
    class ds extends Qa {
      _refreshViews() {
        (this.uint8 = new Uint8Array(this.arrayBuffer)),
          (this.uint32 = new Uint32Array(this.arrayBuffer));
      }
      emplaceBack(t) {
        const e = this.length;
        return this.resize(e + 1), this.emplace(e, t);
      }
      emplace(t, e) {
        return (this.uint32[1 * t + 0] = e), t;
      }
    }
    (ds.prototype.bytesPerElement = 4), ca('StructArrayLayout1ul4', ds);
    class ps extends Qa {
      _refreshViews() {
        (this.uint8 = new Uint8Array(this.arrayBuffer)),
          (this.int16 = new Int16Array(this.arrayBuffer)),
          (this.uint32 = new Uint32Array(this.arrayBuffer)),
          (this.uint16 = new Uint16Array(this.arrayBuffer));
      }
      emplaceBack(t, e, i, r, n, a, s, o, l) {
        const c = this.length;
        return this.resize(c + 1), this.emplace(c, t, e, i, r, n, a, s, o, l);
      }
      emplace(t, e, i, r, n, a, s, o, l, c) {
        const h = 10 * t,
          u = 5 * t;
        return (
          (this.int16[h + 0] = e),
          (this.int16[h + 1] = i),
          (this.int16[h + 2] = r),
          (this.int16[h + 3] = n),
          (this.int16[h + 4] = a),
          (this.int16[h + 5] = s),
          (this.uint32[u + 3] = o),
          (this.uint16[h + 8] = l),
          (this.uint16[h + 9] = c),
          t
        );
      }
    }
    (ps.prototype.bytesPerElement = 20), ca('StructArrayLayout6i1ul2ui20', ps);
    class fs extends Qa {
      _refreshViews() {
        (this.uint8 = new Uint8Array(this.arrayBuffer)),
          (this.int16 = new Int16Array(this.arrayBuffer));
      }
      emplaceBack(t, e, i, r, n, a) {
        const s = this.length;
        return this.resize(s + 1), this.emplace(s, t, e, i, r, n, a);
      }
      emplace(t, e, i, r, n, a, s) {
        const o = 6 * t;
        return (
          (this.int16[o + 0] = e),
          (this.int16[o + 1] = i),
          (this.int16[o + 2] = r),
          (this.int16[o + 3] = n),
          (this.int16[o + 4] = a),
          (this.int16[o + 5] = s),
          t
        );
      }
    }
    (fs.prototype.bytesPerElement = 12), ca('StructArrayLayout2i2i2i12', fs);
    class ms extends Qa {
      _refreshViews() {
        (this.uint8 = new Uint8Array(this.arrayBuffer)),
          (this.float32 = new Float32Array(this.arrayBuffer)),
          (this.int16 = new Int16Array(this.arrayBuffer));
      }
      emplaceBack(t, e, i, r, n) {
        const a = this.length;
        return this.resize(a + 1), this.emplace(a, t, e, i, r, n);
      }
      emplace(t, e, i, r, n, a) {
        const s = 4 * t,
          o = 8 * t;
        return (
          (this.float32[s + 0] = e),
          (this.float32[s + 1] = i),
          (this.float32[s + 2] = r),
          (this.int16[o + 6] = n),
          (this.int16[o + 7] = a),
          t
        );
      }
    }
    (ms.prototype.bytesPerElement = 16), ca('StructArrayLayout2f1f2i16', ms);
    class gs extends Qa {
      _refreshViews() {
        (this.uint8 = new Uint8Array(this.arrayBuffer)),
          (this.float32 = new Float32Array(this.arrayBuffer)),
          (this.int16 = new Int16Array(this.arrayBuffer));
      }
      emplaceBack(t, e, i, r, n, a) {
        const s = this.length;
        return this.resize(s + 1), this.emplace(s, t, e, i, r, n, a);
      }
      emplace(t, e, i, r, n, a, s) {
        const o = 16 * t,
          l = 4 * t,
          c = 8 * t;
        return (
          (this.uint8[o + 0] = e),
          (this.uint8[o + 1] = i),
          (this.float32[l + 1] = r),
          (this.float32[l + 2] = n),
          (this.int16[c + 6] = a),
          (this.int16[c + 7] = s),
          t
        );
      }
    }
    (gs.prototype.bytesPerElement = 16), ca('StructArrayLayout2ub2f2i16', gs);
    class _s extends Qa {
      _refreshViews() {
        (this.uint8 = new Uint8Array(this.arrayBuffer)),
          (this.uint16 = new Uint16Array(this.arrayBuffer));
      }
      emplaceBack(t, e, i) {
        const r = this.length;
        return this.resize(r + 1), this.emplace(r, t, e, i);
      }
      emplace(t, e, i, r) {
        const n = 3 * t;
        return (
          (this.uint16[n + 0] = e),
          (this.uint16[n + 1] = i),
          (this.uint16[n + 2] = r),
          t
        );
      }
    }
    (_s.prototype.bytesPerElement = 6), ca('StructArrayLayout3ui6', _s);
    class ys extends Qa {
      _refreshViews() {
        (this.uint8 = new Uint8Array(this.arrayBuffer)),
          (this.int16 = new Int16Array(this.arrayBuffer)),
          (this.uint16 = new Uint16Array(this.arrayBuffer)),
          (this.uint32 = new Uint32Array(this.arrayBuffer)),
          (this.float32 = new Float32Array(this.arrayBuffer));
      }
      emplaceBack(t, e, i, r, n, a, s, o, l, c, h, u, d, p, f, m, g) {
        const _ = this.length;
        return (
          this.resize(_ + 1),
          this.emplace(_, t, e, i, r, n, a, s, o, l, c, h, u, d, p, f, m, g)
        );
      }
      emplace(t, e, i, r, n, a, s, o, l, c, h, u, d, p, f, m, g, _) {
        const y = 24 * t,
          v = 12 * t,
          x = 48 * t;
        return (
          (this.int16[y + 0] = e),
          (this.int16[y + 1] = i),
          (this.uint16[y + 2] = r),
          (this.uint16[y + 3] = n),
          (this.uint32[v + 2] = a),
          (this.uint32[v + 3] = s),
          (this.uint32[v + 4] = o),
          (this.uint16[y + 10] = l),
          (this.uint16[y + 11] = c),
          (this.uint16[y + 12] = h),
          (this.float32[v + 7] = u),
          (this.float32[v + 8] = d),
          (this.uint8[x + 36] = p),
          (this.uint8[x + 37] = f),
          (this.uint8[x + 38] = m),
          (this.uint32[v + 10] = g),
          (this.int16[y + 22] = _),
          t
        );
      }
    }
    (ys.prototype.bytesPerElement = 48),
      ca('StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48', ys);
    class vs extends Qa {
      _refreshViews() {
        (this.uint8 = new Uint8Array(this.arrayBuffer)),
          (this.int16 = new Int16Array(this.arrayBuffer)),
          (this.uint16 = new Uint16Array(this.arrayBuffer)),
          (this.uint32 = new Uint32Array(this.arrayBuffer)),
          (this.float32 = new Float32Array(this.arrayBuffer));
      }
      emplaceBack(
        t,
        e,
        i,
        r,
        n,
        a,
        s,
        o,
        l,
        c,
        h,
        u,
        d,
        p,
        f,
        m,
        g,
        _,
        y,
        v,
        x,
        b,
        w,
        T,
        P,
        C,
        I,
        S
      ) {
        const M = this.length;
        return (
          this.resize(M + 1),
          this.emplace(
            M,
            t,
            e,
            i,
            r,
            n,
            a,
            s,
            o,
            l,
            c,
            h,
            u,
            d,
            p,
            f,
            m,
            g,
            _,
            y,
            v,
            x,
            b,
            w,
            T,
            P,
            C,
            I,
            S
          )
        );
      }
      emplace(
        t,
        e,
        i,
        r,
        n,
        a,
        s,
        o,
        l,
        c,
        h,
        u,
        d,
        p,
        f,
        m,
        g,
        _,
        y,
        v,
        x,
        b,
        w,
        T,
        P,
        C,
        I,
        S,
        M
      ) {
        const D = 32 * t,
          L = 16 * t;
        return (
          (this.int16[D + 0] = e),
          (this.int16[D + 1] = i),
          (this.int16[D + 2] = r),
          (this.int16[D + 3] = n),
          (this.int16[D + 4] = a),
          (this.int16[D + 5] = s),
          (this.int16[D + 6] = o),
          (this.int16[D + 7] = l),
          (this.uint16[D + 8] = c),
          (this.uint16[D + 9] = h),
          (this.uint16[D + 10] = u),
          (this.uint16[D + 11] = d),
          (this.uint16[D + 12] = p),
          (this.uint16[D + 13] = f),
          (this.uint16[D + 14] = m),
          (this.uint16[D + 15] = g),
          (this.uint16[D + 16] = _),
          (this.uint16[D + 17] = y),
          (this.uint16[D + 18] = v),
          (this.uint16[D + 19] = x),
          (this.uint16[D + 20] = b),
          (this.uint16[D + 21] = w),
          (this.uint16[D + 22] = T),
          (this.uint32[L + 12] = P),
          (this.float32[L + 13] = C),
          (this.float32[L + 14] = I),
          (this.uint16[D + 30] = S),
          (this.uint16[D + 31] = M),
          t
        );
      }
    }
    (vs.prototype.bytesPerElement = 64),
      ca('StructArrayLayout8i15ui1ul2f2ui64', vs);
    class xs extends Qa {
      _refreshViews() {
        (this.uint8 = new Uint8Array(this.arrayBuffer)),
          (this.float32 = new Float32Array(this.arrayBuffer));
      }
      emplaceBack(t) {
        const e = this.length;
        return this.resize(e + 1), this.emplace(e, t);
      }
      emplace(t, e) {
        return (this.float32[1 * t + 0] = e), t;
      }
    }
    (xs.prototype.bytesPerElement = 4), ca('StructArrayLayout1f4', xs);
    class bs extends Qa {
      _refreshViews() {
        (this.uint8 = new Uint8Array(this.arrayBuffer)),
          (this.uint16 = new Uint16Array(this.arrayBuffer)),
          (this.float32 = new Float32Array(this.arrayBuffer));
      }
      emplaceBack(t, e, i) {
        const r = this.length;
        return this.resize(r + 1), this.emplace(r, t, e, i);
      }
      emplace(t, e, i, r) {
        const n = 3 * t;
        return (
          (this.uint16[6 * t + 0] = e),
          (this.float32[n + 1] = i),
          (this.float32[n + 2] = r),
          t
        );
      }
    }
    (bs.prototype.bytesPerElement = 12), ca('StructArrayLayout1ui2f12', bs);
    class ws extends Qa {
      _refreshViews() {
        (this.uint8 = new Uint8Array(this.arrayBuffer)),
          (this.uint32 = new Uint32Array(this.arrayBuffer)),
          (this.uint16 = new Uint16Array(this.arrayBuffer));
      }
      emplaceBack(t, e, i) {
        const r = this.length;
        return this.resize(r + 1), this.emplace(r, t, e, i);
      }
      emplace(t, e, i, r) {
        const n = 4 * t;
        return (
          (this.uint32[2 * t + 0] = e),
          (this.uint16[n + 2] = i),
          (this.uint16[n + 3] = r),
          t
        );
      }
    }
    (ws.prototype.bytesPerElement = 8), ca('StructArrayLayout1ul2ui8', ws);
    class Ts extends Qa {
      _refreshViews() {
        (this.uint8 = new Uint8Array(this.arrayBuffer)),
          (this.uint16 = new Uint16Array(this.arrayBuffer));
      }
      emplaceBack(t, e) {
        const i = this.length;
        return this.resize(i + 1), this.emplace(i, t, e);
      }
      emplace(t, e, i) {
        const r = 2 * t;
        return (this.uint16[r + 0] = e), (this.uint16[r + 1] = i), t;
      }
    }
    (Ts.prototype.bytesPerElement = 4), ca('StructArrayLayout2ui4', Ts);
    class Ps extends Qa {
      _refreshViews() {
        (this.uint8 = new Uint8Array(this.arrayBuffer)),
          (this.uint16 = new Uint16Array(this.arrayBuffer));
      }
      emplaceBack(t) {
        const e = this.length;
        return this.resize(e + 1), this.emplace(e, t);
      }
      emplace(t, e) {
        return (this.uint16[1 * t + 0] = e), t;
      }
    }
    (Ps.prototype.bytesPerElement = 2), ca('StructArrayLayout1ui2', Ps);
    class Cs extends Qa {
      _refreshViews() {
        (this.uint8 = new Uint8Array(this.arrayBuffer)),
          (this.float32 = new Float32Array(this.arrayBuffer));
      }
      emplaceBack(t, e, i, r) {
        const n = this.length;
        return this.resize(n + 1), this.emplace(n, t, e, i, r);
      }
      emplace(t, e, i, r, n) {
        const a = 4 * t;
        return (
          (this.float32[a + 0] = e),
          (this.float32[a + 1] = i),
          (this.float32[a + 2] = r),
          (this.float32[a + 3] = n),
          t
        );
      }
    }
    (Cs.prototype.bytesPerElement = 16), ca('StructArrayLayout4f16', Cs);
    class Is extends Ja {
      get anchorPointX() {
        return this._structArray.int16[this._pos2 + 0];
      }
      get anchorPointY() {
        return this._structArray.int16[this._pos2 + 1];
      }
      get x1() {
        return this._structArray.int16[this._pos2 + 2];
      }
      get y1() {
        return this._structArray.int16[this._pos2 + 3];
      }
      get x2() {
        return this._structArray.int16[this._pos2 + 4];
      }
      get y2() {
        return this._structArray.int16[this._pos2 + 5];
      }
      get featureIndex() {
        return this._structArray.uint32[this._pos4 + 3];
      }
      get sourceLayerIndex() {
        return this._structArray.uint16[this._pos2 + 8];
      }
      get bucketIndex() {
        return this._structArray.uint16[this._pos2 + 9];
      }
      get anchorPoint() {
        return new i(this.anchorPointX, this.anchorPointY);
      }
    }
    Is.prototype.size = 20;
    class Ss extends ps {
      get(t) {
        return new Is(this, t);
      }
    }
    ca('CollisionBoxArray', Ss);
    class Ms extends Ja {
      get anchorX() {
        return this._structArray.int16[this._pos2 + 0];
      }
      get anchorY() {
        return this._structArray.int16[this._pos2 + 1];
      }
      get glyphStartIndex() {
        return this._structArray.uint16[this._pos2 + 2];
      }
      get numGlyphs() {
        return this._structArray.uint16[this._pos2 + 3];
      }
      get vertexStartIndex() {
        return this._structArray.uint32[this._pos4 + 2];
      }
      get lineStartIndex() {
        return this._structArray.uint32[this._pos4 + 3];
      }
      get lineLength() {
        return this._structArray.uint32[this._pos4 + 4];
      }
      get segment() {
        return this._structArray.uint16[this._pos2 + 10];
      }
      get lowerSize() {
        return this._structArray.uint16[this._pos2 + 11];
      }
      get upperSize() {
        return this._structArray.uint16[this._pos2 + 12];
      }
      get lineOffsetX() {
        return this._structArray.float32[this._pos4 + 7];
      }
      get lineOffsetY() {
        return this._structArray.float32[this._pos4 + 8];
      }
      get writingMode() {
        return this._structArray.uint8[this._pos1 + 36];
      }
      get placedOrientation() {
        return this._structArray.uint8[this._pos1 + 37];
      }
      set placedOrientation(t) {
        this._structArray.uint8[this._pos1 + 37] = t;
      }
      get hidden() {
        return this._structArray.uint8[this._pos1 + 38];
      }
      set hidden(t) {
        this._structArray.uint8[this._pos1 + 38] = t;
      }
      get crossTileID() {
        return this._structArray.uint32[this._pos4 + 10];
      }
      set crossTileID(t) {
        this._structArray.uint32[this._pos4 + 10] = t;
      }
      get associatedIconIndex() {
        return this._structArray.int16[this._pos2 + 22];
      }
    }
    Ms.prototype.size = 48;
    class Ds extends ys {
      get(t) {
        return new Ms(this, t);
      }
    }
    ca('PlacedSymbolArray', Ds);
    class Ls extends Ja {
      get anchorX() {
        return this._structArray.int16[this._pos2 + 0];
      }
      get anchorY() {
        return this._structArray.int16[this._pos2 + 1];
      }
      get rightJustifiedTextSymbolIndex() {
        return this._structArray.int16[this._pos2 + 2];
      }
      get centerJustifiedTextSymbolIndex() {
        return this._structArray.int16[this._pos2 + 3];
      }
      get leftJustifiedTextSymbolIndex() {
        return this._structArray.int16[this._pos2 + 4];
      }
      get verticalPlacedTextSymbolIndex() {
        return this._structArray.int16[this._pos2 + 5];
      }
      get placedIconSymbolIndex() {
        return this._structArray.int16[this._pos2 + 6];
      }
      get verticalPlacedIconSymbolIndex() {
        return this._structArray.int16[this._pos2 + 7];
      }
      get key() {
        return this._structArray.uint16[this._pos2 + 8];
      }
      get textBoxStartIndex() {
        return this._structArray.uint16[this._pos2 + 9];
      }
      get textBoxEndIndex() {
        return this._structArray.uint16[this._pos2 + 10];
      }
      get verticalTextBoxStartIndex() {
        return this._structArray.uint16[this._pos2 + 11];
      }
      get verticalTextBoxEndIndex() {
        return this._structArray.uint16[this._pos2 + 12];
      }
      get iconBoxStartIndex() {
        return this._structArray.uint16[this._pos2 + 13];
      }
      get iconBoxEndIndex() {
        return this._structArray.uint16[this._pos2 + 14];
      }
      get verticalIconBoxStartIndex() {
        return this._structArray.uint16[this._pos2 + 15];
      }
      get verticalIconBoxEndIndex() {
        return this._structArray.uint16[this._pos2 + 16];
      }
      get featureIndex() {
        return this._structArray.uint16[this._pos2 + 17];
      }
      get numHorizontalGlyphVertices() {
        return this._structArray.uint16[this._pos2 + 18];
      }
      get numVerticalGlyphVertices() {
        return this._structArray.uint16[this._pos2 + 19];
      }
      get numIconVertices() {
        return this._structArray.uint16[this._pos2 + 20];
      }
      get numVerticalIconVertices() {
        return this._structArray.uint16[this._pos2 + 21];
      }
      get useRuntimeCollisionCircles() {
        return this._structArray.uint16[this._pos2 + 22];
      }
      get crossTileID() {
        return this._structArray.uint32[this._pos4 + 12];
      }
      set crossTileID(t) {
        this._structArray.uint32[this._pos4 + 12] = t;
      }
      get textBoxScale() {
        return this._structArray.float32[this._pos4 + 13];
      }
      get collisionCircleDiameter() {
        return this._structArray.float32[this._pos4 + 14];
      }
      get textAnchorOffsetStartIndex() {
        return this._structArray.uint16[this._pos2 + 30];
      }
      get textAnchorOffsetEndIndex() {
        return this._structArray.uint16[this._pos2 + 31];
      }
    }
    Ls.prototype.size = 64;
    class As extends vs {
      get(t) {
        return new Ls(this, t);
      }
    }
    ca('SymbolInstanceArray', As);
    class Es extends xs {
      getoffsetX(t) {
        return this.float32[1 * t + 0];
      }
    }
    ca('GlyphOffsetArray', Es);
    class Rs extends rs {
      getx(t) {
        return this.int16[3 * t + 0];
      }
      gety(t) {
        return this.int16[3 * t + 1];
      }
      gettileUnitDistanceFromAnchor(t) {
        return this.int16[3 * t + 2];
      }
    }
    ca('SymbolLineVertexArray', Rs);
    class zs extends Ja {
      get textAnchor() {
        return this._structArray.uint16[this._pos2 + 0];
      }
      get textOffset0() {
        return this._structArray.float32[this._pos4 + 1];
      }
      get textOffset1() {
        return this._structArray.float32[this._pos4 + 2];
      }
    }
    zs.prototype.size = 12;
    class ks extends bs {
      get(t) {
        return new zs(this, t);
      }
    }
    ca('TextAnchorOffsetArray', ks);
    class Os extends Ja {
      get featureIndex() {
        return this._structArray.uint32[this._pos4 + 0];
      }
      get sourceLayerIndex() {
        return this._structArray.uint16[this._pos2 + 2];
      }
      get bucketIndex() {
        return this._structArray.uint16[this._pos2 + 3];
      }
    }
    Os.prototype.size = 8;
    class Fs extends ws {
      get(t) {
        return new Os(this, t);
      }
    }
    ca('FeatureIndexArray', Fs);
    class Bs extends is {}
    class Ns extends is {}
    class Vs extends is {}
    class js extends as {}
    class Us extends ss {}
    class Gs extends os {}
    class Zs extends ls {}
    class $s extends cs {}
    class qs extends hs {}
    class Hs extends us {}
    class Ws extends ds {}
    class Xs extends fs {}
    class Ys extends gs {}
    class Ks extends _s {}
    class Js extends Ts {}
    const Qs = ts([{ name: 'a_pos', components: 2, type: 'Int16' }], 4),
      { members: to } = Qs;
    class eo {
      constructor(t = []) {
        (this._forceNewSegmentOnNextPrepare = !1), (this.segments = t);
      }
      prepareSegment(t, e, i, r) {
        const n = this.segments[this.segments.length - 1];
        return (
          t > eo.MAX_VERTEX_ARRAY_LENGTH &&
            Z(
              `Max vertices per segment is ${eo.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t}. Consider using the \`fillLargeMeshArrays\` function if you require meshes with more than ${eo.MAX_VERTEX_ARRAY_LENGTH} vertices.`
            ),
          this._forceNewSegmentOnNextPrepare ||
          !n ||
          n.vertexLength + t > eo.MAX_VERTEX_ARRAY_LENGTH ||
          n.sortKey !== r
            ? this.createNewSegment(e, i, r)
            : n
        );
      }
      createNewSegment(t, e, i) {
        const r = {
          vertexOffset: t.length,
          primitiveOffset: e.length,
          vertexLength: 0,
          primitiveLength: 0,
          vaos: {},
        };
        return (
          void 0 !== i && (r.sortKey = i),
          (this._forceNewSegmentOnNextPrepare = !1),
          this.segments.push(r),
          r
        );
      }
      getOrCreateLatestSegment(t, e, i) {
        return this.prepareSegment(0, t, e, i);
      }
      forceNewSegmentOnNextPrepare() {
        this._forceNewSegmentOnNextPrepare = !0;
      }
      get() {
        return this.segments;
      }
      destroy() {
        for (const t of this.segments)
          for (const e in t.vaos) t.vaos[e].destroy();
      }
      static simpleSegment(t, e, i, r) {
        return new eo([
          {
            vertexOffset: t,
            primitiveOffset: e,
            vertexLength: i,
            primitiveLength: r,
            vaos: {},
            sortKey: 0,
          },
        ]);
      }
    }
    function io(t, e) {
      return 256 * (t = O(Math.floor(t), 0, 255)) + O(Math.floor(e), 0, 255);
    }
    (eo.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1), ca('SegmentVector', eo);
    const ro = ts([
        { name: 'a_pattern_from', components: 4, type: 'Uint16' },
        { name: 'a_pattern_to', components: 4, type: 'Uint16' },
        { name: 'a_pixel_ratio_from', components: 1, type: 'Uint16' },
        { name: 'a_pixel_ratio_to', components: 1, type: 'Uint16' },
      ]),
      no = ts([
        { name: 'a_dasharray_from', components: 4, type: 'Uint16' },
        { name: 'a_dasharray_to', components: 4, type: 'Uint16' },
      ]);
    var ao,
      so,
      oo,
      lo = { exports: {} },
      co = { exports: {} },
      ho = { exports: {} },
      uo = (function () {
        if (oo) return lo.exports;
        oo = 1;
        var t =
            (ao ||
              ((ao = 1),
              (co.exports = function (t, e) {
                var i, r, n, a, s, o, l, c;
                for (
                  r = t.length - (i = 3 & t.length),
                    n = e,
                    s = 3432918353,
                    o = 461845907,
                    c = 0;
                  c < r;

                )
                  (l =
                    (255 & t.charCodeAt(c)) |
                    ((255 & t.charCodeAt(++c)) << 8) |
                    ((255 & t.charCodeAt(++c)) << 16) |
                    ((255 & t.charCodeAt(++c)) << 24)),
                    ++c,
                    (n =
                      27492 +
                      (65535 &
                        (a =
                          (5 *
                            (65535 &
                              (n =
                                ((n ^= l =
                                  ((65535 &
                                    (l =
                                      ((l =
                                        ((65535 & l) * s +
                                          ((((l >>> 16) * s) & 65535) << 16)) &
                                        4294967295) <<
                                        15) |
                                      (l >>> 17))) *
                                    o +
                                    ((((l >>> 16) * o) & 65535) << 16)) &
                                  4294967295) <<
                                  13) |
                                (n >>> 19))) +
                            (((5 * (n >>> 16)) & 65535) << 16)) &
                          4294967295)) +
                      (((58964 + (a >>> 16)) & 65535) << 16));
                switch (((l = 0), i)) {
                  case 3:
                    l ^= (255 & t.charCodeAt(c + 2)) << 16;
                  case 2:
                    l ^= (255 & t.charCodeAt(c + 1)) << 8;
                  case 1:
                    n ^= l =
                      ((65535 &
                        (l =
                          ((l =
                            ((65535 & (l ^= 255 & t.charCodeAt(c))) * s +
                              ((((l >>> 16) * s) & 65535) << 16)) &
                            4294967295) <<
                            15) |
                          (l >>> 17))) *
                        o +
                        ((((l >>> 16) * o) & 65535) << 16)) &
                      4294967295;
                }
                return (
                  (n ^= t.length),
                  (n =
                    (2246822507 * (65535 & (n ^= n >>> 16)) +
                      (((2246822507 * (n >>> 16)) & 65535) << 16)) &
                    4294967295),
                  (n =
                    (3266489909 * (65535 & (n ^= n >>> 13)) +
                      (((3266489909 * (n >>> 16)) & 65535) << 16)) &
                    4294967295),
                  (n ^= n >>> 16) >>> 0
                );
              })),
            co.exports),
          e =
            (so ||
              ((so = 1),
              (ho.exports = function (t, e) {
                for (var i, r = t.length, n = e ^ r, a = 0; r >= 4; )
                  (i =
                    1540483477 *
                      (65535 &
                        (i =
                          (255 & t.charCodeAt(a)) |
                          ((255 & t.charCodeAt(++a)) << 8) |
                          ((255 & t.charCodeAt(++a)) << 16) |
                          ((255 & t.charCodeAt(++a)) << 24))) +
                    (((1540483477 * (i >>> 16)) & 65535) << 16)),
                    (n =
                      (1540483477 * (65535 & n) +
                        (((1540483477 * (n >>> 16)) & 65535) << 16)) ^
                      (i =
                        1540483477 * (65535 & (i ^= i >>> 24)) +
                        (((1540483477 * (i >>> 16)) & 65535) << 16))),
                    (r -= 4),
                    ++a;
                switch (r) {
                  case 3:
                    n ^= (255 & t.charCodeAt(a + 2)) << 16;
                  case 2:
                    n ^= (255 & t.charCodeAt(a + 1)) << 8;
                  case 1:
                    n =
                      1540483477 * (65535 & (n ^= 255 & t.charCodeAt(a))) +
                      (((1540483477 * (n >>> 16)) & 65535) << 16);
                }
                return (
                  (n =
                    1540483477 * (65535 & (n ^= n >>> 13)) +
                    (((1540483477 * (n >>> 16)) & 65535) << 16)),
                  (n ^= n >>> 15) >>> 0
                );
              })),
            ho.exports);
        return (
          (lo.exports = t),
          (lo.exports.murmur3 = t),
          (lo.exports.murmur2 = e),
          lo.exports
        );
      })(),
      po = r(uo);
    class fo {
      constructor() {
        (this.ids = []), (this.positions = []), (this.indexed = !1);
      }
      add(t, e, i, r) {
        this.ids.push(mo(t)), this.positions.push(e, i, r);
      }
      getPositions(t) {
        if (!this.indexed)
          throw new Error(
            'Trying to get index, but feature positions are not indexed'
          );
        const e = mo(t);
        let i = 0,
          r = this.ids.length - 1;
        for (; i < r; ) {
          const t = (i + r) >> 1;
          this.ids[t] >= e ? (r = t) : (i = t + 1);
        }
        const n = [];
        for (; this.ids[i] === e; )
          n.push({
            index: this.positions[3 * i],
            start: this.positions[3 * i + 1],
            end: this.positions[3 * i + 2],
          }),
            i++;
        return n;
      }
      static serialize(t, e) {
        const i = new Float64Array(t.ids),
          r = new Uint32Array(t.positions);
        return (
          go(i, r, 0, i.length - 1),
          e && e.push(i.buffer, r.buffer),
          { ids: i, positions: r }
        );
      }
      static deserialize(t) {
        const e = new fo();
        return (
          (e.ids = t.ids), (e.positions = t.positions), (e.indexed = !0), e
        );
      }
    }
    function mo(t) {
      const e = +t;
      return !isNaN(e) && e <= Number.MAX_SAFE_INTEGER ? e : po(String(t));
    }
    function go(t, e, i, r) {
      for (; i < r; ) {
        const n = t[(i + r) >> 1];
        let a = i - 1,
          s = r + 1;
        for (;;) {
          do {
            a++;
          } while (t[a] < n);
          do {
            s--;
          } while (t[s] > n);
          if (a >= s) break;
          _o(t, a, s),
            _o(e, 3 * a, 3 * s),
            _o(e, 3 * a + 1, 3 * s + 1),
            _o(e, 3 * a + 2, 3 * s + 2);
        }
        s - i < r - s
          ? (go(t, e, i, s), (i = s + 1))
          : (go(t, e, s + 1, r), (r = s));
      }
    }
    function _o(t, e, i) {
      const r = t[e];
      (t[e] = t[i]), (t[i] = r);
    }
    ca('FeaturePositionMap', fo);
    class yo {
      constructor(t, e) {
        (this.gl = t.gl), (this.location = e);
      }
    }
    class vo extends yo {
      constructor(t, e) {
        super(t, e), (this.current = 0);
      }
      set(t) {
        this.current !== t &&
          ((this.current = t), this.gl.uniform1f(this.location, t));
      }
    }
    class xo extends yo {
      constructor(t, e) {
        super(t, e), (this.current = [0, 0, 0, 0]);
      }
      set(t) {
        (t[0] === this.current[0] &&
          t[1] === this.current[1] &&
          t[2] === this.current[2] &&
          t[3] === this.current[3]) ||
          ((this.current = t),
          this.gl.uniform4f(this.location, t[0], t[1], t[2], t[3]));
      }
    }
    class bo extends yo {
      constructor(t, e) {
        super(t, e), (this.current = Se.transparent);
      }
      set(t) {
        (t.r === this.current.r &&
          t.g === this.current.g &&
          t.b === this.current.b &&
          t.a === this.current.a) ||
          ((this.current = t),
          this.gl.uniform4f(this.location, t.r, t.g, t.b, t.a));
      }
    }
    const wo = new Float32Array(16);
    function To(t) {
      return [io(255 * t.r, 255 * t.g), io(255 * t.b, 255 * t.a)];
    }
    class Po {
      constructor(t, e, i) {
        (this.value = t),
          (this.uniformNames = e.map((t) => `u_${t}`)),
          (this.type = i);
      }
      setUniform(t, e, i) {
        t.set(i.constantOr(this.value));
      }
      getBinding(t, e, i) {
        return 'color' === this.type ? new bo(t, e) : new vo(t, e);
      }
    }
    class Co {
      constructor(t, e) {
        (this.uniformNames = e.map((t) => `u_${t}`)),
          (this.patternFrom = null),
          (this.patternTo = null),
          (this.pixelRatioFrom = 1),
          (this.pixelRatioTo = 1);
      }
      setConstantPatternPositions(t, e) {
        (this.pixelRatioFrom = e.pixelRatio),
          (this.pixelRatioTo = t.pixelRatio),
          (this.patternFrom = e.tlbr),
          (this.patternTo = t.tlbr);
      }
      setConstantDashPositions(t, e) {
        (this.dashTo = [0, t.y, t.height, t.width]),
          (this.dashFrom = [0, e.y, e.height, e.width]);
      }
      setUniform(t, e, i, r) {
        let n = null;
        'u_pattern_to' === r
          ? (n = this.patternTo)
          : 'u_pattern_from' === r
          ? (n = this.patternFrom)
          : 'u_dasharray_to' === r
          ? (n = this.dashTo)
          : 'u_dasharray_from' === r
          ? (n = this.dashFrom)
          : 'u_pixel_ratio_to' === r
          ? (n = this.pixelRatioTo)
          : 'u_pixel_ratio_from' === r && (n = this.pixelRatioFrom),
          null !== n && t.set(n);
      }
      getBinding(t, e, i) {
        return 'u_pattern' === i.substr(0, 9) ||
          'u_dasharray_' === i.substr(0, 12)
          ? new xo(t, e)
          : new vo(t, e);
      }
    }
    class Io {
      constructor(t, e, i, r) {
        (this.expression = t),
          (this.type = i),
          (this.maxValue = 0),
          (this.paintVertexAttributes = e.map((t) => ({
            name: `a_${t}`,
            type: 'Float32',
            components: 'color' === i ? 2 : 1,
            offset: 0,
          }))),
          (this.paintVertexArray = new r());
      }
      populatePaintArray(t, e, i) {
        const r = this.paintVertexArray.length,
          n = this.expression.evaluate(
            new La(0, i),
            e,
            {},
            i.canonical,
            [],
            i.formattedSection
          );
        this.paintVertexArray.resize(t), this._setPaintValue(r, t, n);
      }
      updatePaintArray(t, e, i, r, n) {
        const a = this.expression.evaluate(new La(0, n), i, r);
        this._setPaintValue(t, e, a);
      }
      _setPaintValue(t, e, i) {
        if ('color' === this.type) {
          const r = To(i);
          for (let i = t; i < e; i++)
            this.paintVertexArray.emplace(i, r[0], r[1]);
        } else {
          for (let r = t; r < e; r++) this.paintVertexArray.emplace(r, i);
          this.maxValue = Math.max(this.maxValue, Math.abs(i));
        }
      }
      upload(t) {
        this.paintVertexArray &&
          this.paintVertexArray.arrayBuffer &&
          (this.paintVertexBuffer && this.paintVertexBuffer.buffer
            ? this.paintVertexBuffer.updateData(this.paintVertexArray)
            : (this.paintVertexBuffer = t.createVertexBuffer(
                this.paintVertexArray,
                this.paintVertexAttributes,
                this.expression.isStateDependent
              )));
      }
      destroy() {
        this.paintVertexBuffer && this.paintVertexBuffer.destroy();
      }
    }
    class So {
      constructor(t, e, i, r, n, a) {
        (this.expression = t),
          (this.uniformNames = e.map((t) => `u_${t}_t`)),
          (this.type = i),
          (this.useIntegerZoom = r),
          (this.zoom = n),
          (this.maxValue = 0),
          (this.paintVertexAttributes = e.map((t) => ({
            name: `a_${t}`,
            type: 'Float32',
            components: 'color' === i ? 4 : 2,
            offset: 0,
          }))),
          (this.paintVertexArray = new a());
      }
      populatePaintArray(t, e, i) {
        const r = this.expression.evaluate(
            new La(this.zoom, i),
            e,
            {},
            i.canonical,
            [],
            i.formattedSection
          ),
          n = this.expression.evaluate(
            new La(this.zoom + 1, i),
            e,
            {},
            i.canonical,
            [],
            i.formattedSection
          ),
          a = this.paintVertexArray.length;
        this.paintVertexArray.resize(t), this._setPaintValue(a, t, r, n);
      }
      updatePaintArray(t, e, i, r, n) {
        const a = this.expression.evaluate(new La(this.zoom, n), i, r),
          s = this.expression.evaluate(new La(this.zoom + 1, n), i, r);
        this._setPaintValue(t, e, a, s);
      }
      _setPaintValue(t, e, i, r) {
        if ('color' === this.type) {
          const n = To(i),
            a = To(r);
          for (let i = t; i < e; i++)
            this.paintVertexArray.emplace(i, n[0], n[1], a[0], a[1]);
        } else {
          for (let n = t; n < e; n++) this.paintVertexArray.emplace(n, i, r);
          this.maxValue = Math.max(this.maxValue, Math.abs(i), Math.abs(r));
        }
      }
      upload(t) {
        this.paintVertexArray &&
          this.paintVertexArray.arrayBuffer &&
          (this.paintVertexBuffer && this.paintVertexBuffer.buffer
            ? this.paintVertexBuffer.updateData(this.paintVertexArray)
            : (this.paintVertexBuffer = t.createVertexBuffer(
                this.paintVertexArray,
                this.paintVertexAttributes,
                this.expression.isStateDependent
              )));
      }
      destroy() {
        this.paintVertexBuffer && this.paintVertexBuffer.destroy();
      }
      setUniform(t, e) {
        const i = this.useIntegerZoom ? Math.floor(e.zoom) : e.zoom,
          r = O(
            this.expression.interpolationFactor(i, this.zoom, this.zoom + 1),
            0,
            1
          );
        t.set(r);
      }
      getBinding(t, e, i) {
        return new vo(t, e);
      }
    }
    class Mo {
      constructor(t, e, i, r, n, a) {
        (this.expression = t),
          (this.type = e),
          (this.useIntegerZoom = i),
          (this.zoom = r),
          (this.layerId = a),
          (this.zoomInPaintVertexArray = new n()),
          (this.zoomOutPaintVertexArray = new n());
      }
      populatePaintArray(t, e, i) {
        const r = this.zoomInPaintVertexArray.length;
        this.zoomInPaintVertexArray.resize(t),
          this.zoomOutPaintVertexArray.resize(t),
          this._setPaintValues(r, t, this.getPositionIds(e), i);
      }
      updatePaintArray(t, e, i, r, n) {
        this._setPaintValues(t, e, this.getPositionIds(i), n);
      }
      _setPaintValues(t, e, i, r) {
        const n = this.getPositions(r);
        if (!n || !i) return;
        const a = n[i.min],
          s = n[i.mid],
          o = n[i.max];
        if (a && s && o)
          for (let l = t; l < e; l++)
            this.emplace(this.zoomInPaintVertexArray, l, s, a),
              this.emplace(this.zoomOutPaintVertexArray, l, s, o);
      }
      upload(t) {
        if (
          this.zoomInPaintVertexArray &&
          this.zoomInPaintVertexArray.arrayBuffer &&
          this.zoomOutPaintVertexArray &&
          this.zoomOutPaintVertexArray.arrayBuffer
        ) {
          const e = this.getVertexAttributes();
          (this.zoomInPaintVertexBuffer = t.createVertexBuffer(
            this.zoomInPaintVertexArray,
            e,
            this.expression.isStateDependent
          )),
            (this.zoomOutPaintVertexBuffer = t.createVertexBuffer(
              this.zoomOutPaintVertexArray,
              e,
              this.expression.isStateDependent
            ));
        }
      }
      destroy() {
        this.zoomOutPaintVertexBuffer &&
          this.zoomOutPaintVertexBuffer.destroy(),
          this.zoomInPaintVertexBuffer &&
            this.zoomInPaintVertexBuffer.destroy();
      }
    }
    class Do extends Mo {
      getPositions(t) {
        return t.imagePositions;
      }
      getPositionIds(t) {
        return t.patterns && t.patterns[this.layerId];
      }
      getVertexAttributes() {
        return ro.members;
      }
      emplace(t, e, i, r) {
        t.emplace(
          e,
          i.tlbr[0],
          i.tlbr[1],
          i.tlbr[2],
          i.tlbr[3],
          r.tlbr[0],
          r.tlbr[1],
          r.tlbr[2],
          r.tlbr[3],
          i.pixelRatio,
          r.pixelRatio
        );
      }
    }
    class Lo extends Mo {
      getPositions(t) {
        return t.dashPositions;
      }
      getPositionIds(t) {
        return t.dashes && t.dashes[this.layerId];
      }
      getVertexAttributes() {
        return no.members;
      }
      emplace(t, e, i, r) {
        t.emplace(e, 0, i.y, i.height, i.width, 0, r.y, r.height, r.width);
      }
    }
    class Ao {
      constructor(t, e, i) {
        (this.binders = {}), (this._buffers = []);
        const r = [];
        for (const n in t.paint._values) {
          if (!i(n)) continue;
          const a = t.paint.get(n);
          if (!(a instanceof Ba && Ur(a.property.specification))) continue;
          const s = Ro(n, t.type),
            o = a.value,
            l = a.property.specification.type,
            c = a.property.useIntegerZoom,
            h = a.property.specification['property-type'],
            u = 'cross-faded' === h || 'cross-faded-data-driven' === h;
          if ('constant' === o.kind)
            (this.binders[n] = u ? new Co(o.value, s) : new Po(o.value, s, l)),
              r.push(`/u_${n}`);
          else if ('source' === o.kind || u) {
            const i = zo(n, l, 'source');
            (this.binders[n] = u
              ? 'line-dasharray' === n
                ? new Lo(o, l, c, e, i, t.id)
                : new Do(o, l, c, e, i, t.id)
              : new Io(o, s, l, i)),
              r.push(`/a_${n}`);
          } else {
            const t = zo(n, l, 'composite');
            (this.binders[n] = new So(o, s, l, c, e, t)), r.push(`/z_${n}`);
          }
        }
        this.cacheKey = r.sort().join('');
      }
      getMaxValue(t) {
        const e = this.binders[t];
        return e instanceof Io || e instanceof So ? e.maxValue : 0;
      }
      populatePaintArrays(t, e, i) {
        for (const r in this.binders) {
          const n = this.binders[r];
          (n instanceof Io || n instanceof So || n instanceof Mo) &&
            n.populatePaintArray(t, e, i);
        }
      }
      setConstantPatternPositions(t, e) {
        for (const i in this.binders) {
          const r = this.binders[i];
          r instanceof Co && r.setConstantPatternPositions(t, e);
        }
      }
      setConstantDashPositions(t, e) {
        for (const i in this.binders) {
          const r = this.binders[i];
          r instanceof Co && r.setConstantDashPositions(t, e);
        }
      }
      updatePaintArrays(t, e, i, r, n) {
        let a = !1;
        for (const s in t) {
          const o = e.getPositions(s);
          for (const e of o) {
            const o = i.feature(e.index);
            for (const i in this.binders) {
              const l = this.binders[i];
              if (
                (l instanceof Io || l instanceof So || l instanceof Mo) &&
                !0 === l.expression.isStateDependent
              ) {
                const c = r.paint.get(i);
                (l.expression = c.value),
                  l.updatePaintArray(e.start, e.end, o, t[s], n),
                  (a = !0);
              }
            }
          }
        }
        return a;
      }
      defines() {
        const t = [];
        for (const e in this.binders) {
          const i = this.binders[e];
          (i instanceof Po || i instanceof Co) &&
            t.push(...i.uniformNames.map((t) => `#define HAS_UNIFORM_${t}`));
        }
        return t;
      }
      getBinderAttributes() {
        const t = [];
        for (const e in this.binders) {
          const i = this.binders[e];
          if (i instanceof Io || i instanceof So)
            for (let e = 0; e < i.paintVertexAttributes.length; e++)
              t.push(i.paintVertexAttributes[e].name);
          else if (i instanceof Mo) {
            const e = i.getVertexAttributes();
            for (const i of e) t.push(i.name);
          }
        }
        return t;
      }
      getBinderUniforms() {
        const t = [];
        for (const e in this.binders) {
          const i = this.binders[e];
          if (i instanceof Po || i instanceof Co || i instanceof So)
            for (const e of i.uniformNames) t.push(e);
        }
        return t;
      }
      getPaintVertexBuffers() {
        return this._buffers;
      }
      getUniforms(t, e) {
        const i = [];
        for (const r in this.binders) {
          const n = this.binders[r];
          if (n instanceof Po || n instanceof Co || n instanceof So)
            for (const a of n.uniformNames)
              if (e[a]) {
                const s = n.getBinding(t, e[a], a);
                i.push({ name: a, property: r, binding: s });
              }
        }
        return i;
      }
      setUniforms(t, e, i, r) {
        for (const { name: n, property: a, binding: s } of e)
          this.binders[a].setUniform(s, r, i.get(a), n);
      }
      updatePaintBuffers(t) {
        this._buffers = [];
        for (const e in this.binders) {
          const i = this.binders[e];
          if (t && i instanceof Mo) {
            const e =
              2 === t.fromScale
                ? i.zoomInPaintVertexBuffer
                : i.zoomOutPaintVertexBuffer;
            e && this._buffers.push(e);
          } else
            (i instanceof Io || i instanceof So) &&
              i.paintVertexBuffer &&
              this._buffers.push(i.paintVertexBuffer);
        }
      }
      upload(t) {
        for (const e in this.binders) {
          const i = this.binders[e];
          (i instanceof Io || i instanceof So || i instanceof Mo) &&
            i.upload(t);
        }
        this.updatePaintBuffers();
      }
      destroy() {
        for (const t in this.binders) {
          const e = this.binders[t];
          (e instanceof Io || e instanceof So || e instanceof Mo) &&
            e.destroy();
        }
      }
    }
    class Eo {
      constructor(t, e, i = () => !0) {
        this.programConfigurations = {};
        for (const r of t) this.programConfigurations[r.id] = new Ao(r, e, i);
        (this.needsUpload = !1),
          (this._featureMap = new fo()),
          (this._bufferOffset = 0);
      }
      populatePaintArrays(t, e, i, r) {
        for (const n in this.programConfigurations)
          this.programConfigurations[n].populatePaintArrays(t, e, r);
        void 0 !== e.id && this._featureMap.add(e.id, i, this._bufferOffset, t),
          (this._bufferOffset = t),
          (this.needsUpload = !0);
      }
      updatePaintArrays(t, e, i, r) {
        for (const n of i)
          this.needsUpload =
            this.programConfigurations[n.id].updatePaintArrays(
              t,
              this._featureMap,
              e,
              n,
              r
            ) || this.needsUpload;
      }
      get(t) {
        return this.programConfigurations[t];
      }
      upload(t) {
        if (this.needsUpload) {
          for (const e in this.programConfigurations)
            this.programConfigurations[e].upload(t);
          this.needsUpload = !1;
        }
      }
      destroy() {
        for (const t in this.programConfigurations)
          this.programConfigurations[t].destroy();
      }
    }
    function Ro(t, e) {
      return (
        {
          'text-opacity': ['opacity'],
          'icon-opacity': ['opacity'],
          'text-color': ['fill_color'],
          'icon-color': ['fill_color'],
          'text-halo-color': ['halo_color'],
          'icon-halo-color': ['halo_color'],
          'text-halo-blur': ['halo_blur'],
          'icon-halo-blur': ['halo_blur'],
          'text-halo-width': ['halo_width'],
          'icon-halo-width': ['halo_width'],
          'line-gap-width': ['gapwidth'],
          'line-dasharray': ['dasharray_to', 'dasharray_from'],
          'line-pattern': [
            'pattern_to',
            'pattern_from',
            'pixel_ratio_to',
            'pixel_ratio_from',
          ],
          'fill-pattern': [
            'pattern_to',
            'pattern_from',
            'pixel_ratio_to',
            'pixel_ratio_from',
          ],
          'fill-extrusion-pattern': [
            'pattern_to',
            'pattern_from',
            'pixel_ratio_to',
            'pixel_ratio_from',
          ],
        }[t] || [t.replace(`${e}-`, '').replace(/-/g, '_')]
      );
    }
    function zo(t, e, i) {
      const r = {
          color: { source: os, composite: Cs },
          number: { source: xs, composite: os },
        },
        n = (function (t) {
          return {
            'line-pattern': { source: Zs, composite: Zs },
            'fill-pattern': { source: Zs, composite: Zs },
            'fill-extrusion-pattern': { source: Zs, composite: Zs },
            'line-dasharray': { source: $s, composite: $s },
          }[t];
        })(t);
      return (n && n[i]) || r[e][i];
    }
    ca('ConstantBinder', Po),
      ca('CrossFadedConstantBinder', Co),
      ca('SourceExpressionBinder', Io),
      ca('CrossFadedPatternBinder', Do),
      ca('CrossFadedDasharrayBinder', Lo),
      ca('CompositeExpressionBinder', So),
      ca('ProgramConfiguration', Ao, { omit: ['_buffers'] }),
      ca('ProgramConfigurationSet', Eo);
    const ko = Math.pow(2, 14) - 1,
      Oo = -ko - 1;
    function Fo(t) {
      const e = D / t.extent,
        i = t.loadGeometry();
      for (let r = 0; r < i.length; r++) {
        const t = i[r];
        for (let i = 0; i < t.length; i++) {
          const r = t[i],
            n = Math.round(r.x * e),
            a = Math.round(r.y * e);
          (r.x = O(n, Oo, ko)),
            (r.y = O(a, Oo, ko)),
            (n < r.x || n > r.x + 1 || a < r.y || a > r.y + 1) &&
              Z(
                'Geometry exceeds allowed extent, reduce your vector tile buffer size'
              );
        }
      }
      return i;
    }
    function Bo(t, e) {
      return {
        type: t.type,
        id: t.id,
        properties: t.properties,
        geometry: e ? Fo(t) : [],
      };
    }
    const No = -32768;
    function Vo(t, e, i, r, n) {
      t.emplaceBack(No + 8 * e + r, No + 8 * i + n);
    }
    class jo {
      constructor(t) {
        (this.zoom = t.zoom),
          (this.overscaling = t.overscaling),
          (this.layers = t.layers),
          (this.layerIds = this.layers.map((t) => t.id)),
          (this.index = t.index),
          (this.hasDependencies = !1),
          (this.layoutVertexArray = new Ns()),
          (this.indexArray = new Ks()),
          (this.segments = new eo()),
          (this.programConfigurations = new Eo(t.layers, t.zoom)),
          (this.stateDependentLayerIds = this.layers
            .filter((t) => t.isStateDependent())
            .map((t) => t.id));
      }
      populate(t, e, i) {
        const r = this.layers[0],
          n = [];
        let a = null,
          s = !1,
          o = 'heatmap' === r.type;
        if ('circle' === r.type) {
          const t = r;
          (a = t.layout.get('circle-sort-key')),
            (s = !a.isConstant()),
            (o = o || 'map' === t.paint.get('circle-pitch-alignment'));
        }
        const l = o ? e.subdivisionGranularity.circle : 1;
        for (const { feature: c, id: h, index: u, sourceLayerIndex: d } of t) {
          const t = this.layers[0]._featureFilter.needGeometry,
            e = Bo(c, t);
          if (!this.layers[0]._featureFilter.filter(new La(this.zoom), e, i))
            continue;
          const r = s ? a.evaluate(e, {}, i) : void 0,
            o = {
              id: h,
              properties: c.properties,
              type: c.type,
              sourceLayerIndex: d,
              index: u,
              geometry: t ? e.geometry : Fo(c),
              patterns: {},
              sortKey: r,
            };
          n.push(o);
        }
        s && n.sort((t, e) => t.sortKey - e.sortKey);
        for (const c of n) {
          const { geometry: r, index: n, sourceLayerIndex: a } = c,
            s = t[n].feature;
          this.addFeature(c, r, n, i, l),
            e.featureIndex.insert(s, r, n, a, this.index);
        }
      }
      update(t, e, i) {
        this.stateDependentLayers.length &&
          this.programConfigurations.updatePaintArrays(
            t,
            e,
            this.stateDependentLayers,
            { imagePositions: i }
          );
      }
      isEmpty() {
        return 0 === this.layoutVertexArray.length;
      }
      uploadPending() {
        return !this.uploaded || this.programConfigurations.needsUpload;
      }
      upload(t) {
        this.uploaded ||
          ((this.layoutVertexBuffer = t.createVertexBuffer(
            this.layoutVertexArray,
            to
          )),
          (this.indexBuffer = t.createIndexBuffer(this.indexArray))),
          this.programConfigurations.upload(t),
          (this.uploaded = !0);
      }
      destroy() {
        this.layoutVertexBuffer &&
          (this.layoutVertexBuffer.destroy(),
          this.indexBuffer.destroy(),
          this.programConfigurations.destroy(),
          this.segments.destroy());
      }
      addFeature(t, e, i, r, n = 1) {
        let a;
        switch (n) {
          case 1:
            a = [0, 7];
            break;
          case 3:
            a = [0, 2, 5, 7];
            break;
          case 5:
            a = [0, 1, 3, 4, 6, 7];
            break;
          case 7:
            a = [0, 1, 2, 3, 4, 5, 6, 7];
            break;
          default:
            throw new Error(
              `Invalid circle bucket granularity: ${n}; valid values are 1, 3, 5, 7.`
            );
        }
        const s = a.length;
        for (const o of e)
          for (const e of o) {
            const i = e.x,
              r = e.y;
            if (i < 0 || i >= D || r < 0 || r >= D) continue;
            const n = this.segments.prepareSegment(
                s * s,
                this.layoutVertexArray,
                this.indexArray,
                t.sortKey
              ),
              o = n.vertexLength;
            for (let t = 0; t < s; t++)
              for (let e = 0; e < s; e++)
                Vo(this.layoutVertexArray, i, r, a[e], a[t]);
            for (let t = 0; t < s - 1; t++)
              for (let e = 0; e < s - 1; e++) {
                const i = o + t * s + e,
                  r = o + (t + 1) * s + e;
                this.indexArray.emplaceBack(i, r + 1, i + 1),
                  this.indexArray.emplaceBack(i, r, r + 1);
              }
            (n.vertexLength += s * s),
              (n.primitiveLength += (s - 1) * (s - 1) * 2);
          }
        this.programConfigurations.populatePaintArrays(
          this.layoutVertexArray.length,
          t,
          i,
          { imagePositions: {}, canonical: r }
        );
      }
    }
    function Uo(t, e) {
      for (let i = 0; i < t.length; i++) if (Ko(e, t[i])) return !0;
      for (let i = 0; i < e.length; i++) if (Ko(t, e[i])) return !0;
      return !!qo(t, e);
    }
    function Go(t, e, i) {
      return !!Ko(t, e) || !!Wo(e, t, i);
    }
    function Zo(t, e) {
      if (1 === t.length) return Yo(e, t[0]);
      for (let i = 0; i < e.length; i++) {
        const r = e[i];
        for (let e = 0; e < r.length; e++) if (Ko(t, r[e])) return !0;
      }
      for (let i = 0; i < t.length; i++) if (Yo(e, t[i])) return !0;
      for (let i = 0; i < e.length; i++) if (qo(t, e[i])) return !0;
      return !1;
    }
    function $o(t, e, i) {
      if (t.length > 1) {
        if (qo(t, e)) return !0;
        for (let r = 0; r < e.length; r++) if (Wo(e[r], t, i)) return !0;
      }
      for (let r = 0; r < t.length; r++) if (Wo(t[r], e, i)) return !0;
      return !1;
    }
    function qo(t, e) {
      if (0 === t.length || 0 === e.length) return !1;
      for (let i = 0; i < t.length - 1; i++) {
        const r = t[i],
          n = t[i + 1];
        for (let t = 0; t < e.length - 1; t++)
          if (Ho(r, n, e[t], e[t + 1])) return !0;
      }
      return !1;
    }
    function Ho(t, e, i, r) {
      return $(t, i, r) !== $(e, i, r) && $(t, e, i) !== $(t, e, r);
    }
    function Wo(t, e, i) {
      const r = i * i;
      if (1 === e.length) return t.distSqr(e[0]) < r;
      for (let n = 1; n < e.length; n++)
        if (Xo(t, e[n - 1], e[n]) < r) return !0;
      return !1;
    }
    function Xo(t, e, i) {
      const r = e.distSqr(i);
      if (0 === r) return t.distSqr(e);
      const n = ((t.x - e.x) * (i.x - e.x) + (t.y - e.y) * (i.y - e.y)) / r;
      return t.distSqr(n < 0 ? e : n > 1 ? i : i.sub(e)._mult(n)._add(e));
    }
    function Yo(t, e) {
      let i,
        r,
        n,
        a = !1;
      for (let s = 0; s < t.length; s++) {
        i = t[s];
        for (let t = 0, s = i.length - 1; t < i.length; s = t++)
          (r = i[t]),
            (n = i[s]),
            r.y > e.y != n.y > e.y &&
              e.x < ((n.x - r.x) * (e.y - r.y)) / (n.y - r.y) + r.x &&
              (a = !a);
      }
      return a;
    }
    function Ko(t, e) {
      let i = !1;
      for (let r = 0, n = t.length - 1; r < t.length; n = r++) {
        const a = t[r],
          s = t[n];
        a.y > e.y != s.y > e.y &&
          e.x < ((s.x - a.x) * (e.y - a.y)) / (s.y - a.y) + a.x &&
          (i = !i);
      }
      return i;
    }
    function Jo(t, e, i) {
      const r = i[0],
        n = i[2];
      if (
        (t.x < r.x && e.x < r.x) ||
        (t.x > n.x && e.x > n.x) ||
        (t.y < r.y && e.y < r.y) ||
        (t.y > n.y && e.y > n.y)
      )
        return !1;
      const a = $(t, e, i[0]);
      return a !== $(t, e, i[1]) || a !== $(t, e, i[2]) || a !== $(t, e, i[3]);
    }
    function Qo(t, e, i) {
      const r = e.paint.get(t).value;
      return 'constant' === r.kind
        ? r.value
        : i.programConfigurations.get(e.id).getMaxValue(t);
    }
    function tl(t) {
      return Math.sqrt(t[0] * t[0] + t[1] * t[1]);
    }
    function el(t, e, r, n, a) {
      if (!e[0] && !e[1]) return t;
      const s = i.convert(e)._mult(a);
      'viewport' === r && s._rotate(-n);
      const o = [];
      for (let i = 0; i < t.length; i++) o.push(t[i].sub(s));
      return o;
    }
    function il({ queryGeometry: t, size: e }, i) {
      return Go(t, i, e);
    }
    function rl(
      {
        queryGeometry: t,
        size: e,
        transform: i,
        unwrappedTileID: r,
        getElevation: n,
      },
      a
    ) {
      return Go(
        t,
        a,
        e *
          (i.projectTileCoordinates(a.x, a.y, r, n).signedDistanceFromCamera /
            i.cameraToCenterDistance)
      );
    }
    function nl(
      {
        queryGeometry: t,
        size: e,
        transform: i,
        unwrappedTileID: r,
        getElevation: n,
      },
      a
    ) {
      const s = i.projectTileCoordinates(
          a.x,
          a.y,
          r,
          n
        ).signedDistanceFromCamera,
        o = e * (i.cameraToCenterDistance / s);
      return Go(t, ol(a, i, r, n), o);
    }
    function al(
      {
        queryGeometry: t,
        size: e,
        transform: i,
        unwrappedTileID: r,
        getElevation: n,
      },
      a
    ) {
      return Go(t, ol(a, i, r, n), e);
    }
    function sl(
      {
        queryGeometry: t,
        size: e,
        transform: i,
        unwrappedTileID: r,
        getElevation: n,
        pitchAlignment: a = 'map',
        pitchScale: s = 'map',
      },
      o
    ) {
      const l = 'map' === a ? ('map' === s ? il : rl) : 'map' === s ? nl : al,
        c = {
          queryGeometry: t,
          size: e,
          transform: i,
          unwrappedTileID: r,
          getElevation: n,
        };
      for (const h of o) for (const t of h) if (l(c, t)) return !0;
      return !1;
    }
    function ol(t, e, r, n) {
      const a = e.projectTileCoordinates(t.x, t.y, r, n).point;
      return new i((0.5 * a.x + 0.5) * e.width, (0.5 * -a.y + 0.5) * e.height);
    }
    let ll, cl;
    ca('CircleBucket', jo, { omit: ['layers'] });
    var hl = {
      get paint() {
        return (cl =
          cl ||
          new $a({
            'circle-radius': new ja(vt.paint_circle['circle-radius']),
            'circle-color': new ja(vt.paint_circle['circle-color']),
            'circle-blur': new ja(vt.paint_circle['circle-blur']),
            'circle-opacity': new ja(vt.paint_circle['circle-opacity']),
            'circle-translate': new Va(vt.paint_circle['circle-translate']),
            'circle-translate-anchor': new Va(
              vt.paint_circle['circle-translate-anchor']
            ),
            'circle-pitch-scale': new Va(vt.paint_circle['circle-pitch-scale']),
            'circle-pitch-alignment': new Va(
              vt.paint_circle['circle-pitch-alignment']
            ),
            'circle-stroke-width': new ja(
              vt.paint_circle['circle-stroke-width']
            ),
            'circle-stroke-color': new ja(
              vt.paint_circle['circle-stroke-color']
            ),
            'circle-stroke-opacity': new ja(
              vt.paint_circle['circle-stroke-opacity']
            ),
          }));
      },
      get layout() {
        return (ll =
          ll ||
          new $a({
            'circle-sort-key': new ja(vt.layout_circle['circle-sort-key']),
          }));
      },
    };
    class ul extends Ha {
      constructor(t, e) {
        super(t, hl, e);
      }
      createBucket(t) {
        return new jo(t);
      }
      queryRadius(t) {
        const e = t;
        return (
          Qo('circle-radius', this, e) +
          Qo('circle-stroke-width', this, e) +
          tl(this.paint.get('circle-translate'))
        );
      }
      queryIntersectsFeature({
        queryGeometry: t,
        feature: e,
        featureState: i,
        geometry: r,
        transform: n,
        pixelsToTileUnits: a,
        unwrappedTileID: s,
        getElevation: o,
      }) {
        const l = el(
            t,
            this.paint.get('circle-translate'),
            this.paint.get('circle-translate-anchor'),
            -n.bearingInRadians,
            a
          ),
          c =
            this.paint.get('circle-radius').evaluate(e, i) +
            this.paint.get('circle-stroke-width').evaluate(e, i),
          h = this.paint.get('circle-pitch-scale'),
          u = this.paint.get('circle-pitch-alignment');
        let d, p;
        return (
          'map' === u
            ? ((d = l), (p = c * a))
            : ((d = (function (t, e, i, r) {
                return t.map((t) => ol(t, e, i, r));
              })(l, n, s, o)),
              (p = c)),
          sl(
            {
              queryGeometry: d,
              size: p,
              transform: n,
              unwrappedTileID: s,
              getElevation: o,
              pitchAlignment: u,
              pitchScale: h,
            },
            r
          )
        );
      }
    }
    class dl extends jo {}
    let pl;
    ca('HeatmapBucket', dl, { omit: ['layers'] });
    var fl = {
      get paint() {
        return (pl =
          pl ||
          new $a({
            'heatmap-radius': new ja(vt.paint_heatmap['heatmap-radius']),
            'heatmap-weight': new ja(vt.paint_heatmap['heatmap-weight']),
            'heatmap-intensity': new Va(vt.paint_heatmap['heatmap-intensity']),
            'heatmap-color': new Za(vt.paint_heatmap['heatmap-color']),
            'heatmap-opacity': new Va(vt.paint_heatmap['heatmap-opacity']),
          }));
      },
    };
    function ml(t, { width: e, height: i }, r, n) {
      if (n) {
        if (n instanceof Uint8ClampedArray) n = new Uint8Array(n.buffer);
        else if (n.length !== e * i * r)
          throw new RangeError(
            `mismatched image size. expected: ${n.length} but got: ${e * i * r}`
          );
      } else n = new Uint8Array(e * i * r);
      return (t.width = e), (t.height = i), (t.data = n), t;
    }
    function gl(t, { width: e, height: i }, r) {
      if (e === t.width && i === t.height) return;
      const n = ml({}, { width: e, height: i }, r);
      _l(
        t,
        n,
        { x: 0, y: 0 },
        { x: 0, y: 0 },
        { width: Math.min(t.width, e), height: Math.min(t.height, i) },
        r
      ),
        (t.width = e),
        (t.height = i),
        (t.data = n.data);
    }
    function _l(t, e, i, r, n, a) {
      if (0 === n.width || 0 === n.height) return e;
      if (
        n.width > t.width ||
        n.height > t.height ||
        i.x > t.width - n.width ||
        i.y > t.height - n.height
      )
        throw new RangeError('out of range source coordinates for image copy');
      if (
        n.width > e.width ||
        n.height > e.height ||
        r.x > e.width - n.width ||
        r.y > e.height - n.height
      )
        throw new RangeError(
          'out of range destination coordinates for image copy'
        );
      const s = t.data,
        o = e.data;
      if (s === o)
        throw new Error('srcData equals dstData, so image is already copied');
      for (let l = 0; l < n.height; l++) {
        const c = ((i.y + l) * t.width + i.x) * a,
          h = ((r.y + l) * e.width + r.x) * a;
        for (let t = 0; t < n.width * a; t++) o[h + t] = s[c + t];
      }
      return e;
    }
    class yl {
      constructor(t, e) {
        ml(this, t, 1, e);
      }
      resize(t) {
        gl(this, t, 1);
      }
      clone() {
        return new yl(
          { width: this.width, height: this.height },
          new Uint8Array(this.data)
        );
      }
      static copy(t, e, i, r, n) {
        _l(t, e, i, r, n, 1);
      }
    }
    class vl {
      constructor(t, e) {
        ml(this, t, 4, e);
      }
      resize(t) {
        gl(this, t, 4);
      }
      replace(t, e) {
        e
          ? this.data.set(t)
          : (this.data =
              t instanceof Uint8ClampedArray ? new Uint8Array(t.buffer) : t);
      }
      clone() {
        return new vl(
          { width: this.width, height: this.height },
          new Uint8Array(this.data)
        );
      }
      static copy(t, e, i, r, n) {
        _l(t, e, i, r, n, 4);
      }
      setPixel(t, e, i) {
        const r = 4 * (t * this.width + e);
        (this.data[r + 0] = Math.round((255 * i.r) / i.a)),
          (this.data[r + 1] = Math.round((255 * i.g) / i.a)),
          (this.data[r + 2] = Math.round((255 * i.b) / i.a)),
          (this.data[r + 3] = Math.round(255 * i.a));
      }
    }
    function xl(t) {
      const e = {},
        i = t.resolution || 256,
        r = t.clips ? t.clips.length : 1,
        n = t.image || new vl({ width: i, height: r });
      if ((Math.log(i) / Math.LN2) % 1 != 0)
        throw new Error(`width is not a power of 2 - ${i}`);
      const a = (r, a, s) => {
        e[t.evaluationKey] = s;
        const o = t.expression.evaluate(e);
        n.setPixel(r / 4 / i, a / 4, o);
      };
      if (t.clips)
        for (let s = 0, o = 0; s < r; ++s, o += 4 * i)
          for (let e = 0, r = 0; e < i; e++, r += 4) {
            const n = e / (i - 1),
              { start: l, end: c } = t.clips[s];
            a(o, r, l * (1 - n) + c * n);
          }
      else for (let s = 0, o = 0; s < i; s++, o += 4) a(0, o, s / (i - 1));
      return n;
    }
    ca('AlphaImage', yl), ca('RGBAImage', vl);
    const bl = 'big-fb';
    class wl extends Ha {
      createBucket(t) {
        return new dl(t);
      }
      constructor(t, e) {
        super(t, fl, e),
          (this.heatmapFbos = new Map()),
          this._updateColorRamp();
      }
      _handleSpecialPaintPropertyUpdate(t) {
        'heatmap-color' === t && this._updateColorRamp();
      }
      _updateColorRamp() {
        (this.colorRamp = xl({
          expression:
            this._transitionablePaint._values['heatmap-color'].value.expression,
          evaluationKey: 'heatmapDensity',
          image: this.colorRamp,
        })),
          (this.colorRampTexture = null);
      }
      resize() {
        this.heatmapFbos.has(bl) && this.heatmapFbos.delete(bl);
      }
      queryRadius(t) {
        return Qo('heatmap-radius', this, t);
      }
      queryIntersectsFeature({
        queryGeometry: t,
        feature: e,
        featureState: i,
        geometry: r,
        transform: n,
        pixelsToTileUnits: a,
        unwrappedTileID: s,
        getElevation: o,
      }) {
        return sl(
          {
            queryGeometry: t,
            size: this.paint.get('heatmap-radius').evaluate(e, i) * a,
            transform: n,
            unwrappedTileID: s,
            getElevation: o,
          },
          r
        );
      }
      hasOffscreenPass() {
        return (
          0 !== this.paint.get('heatmap-opacity') && 'none' !== this.visibility
        );
      }
    }
    let Tl;
    var Pl = {
      get paint() {
        return (Tl =
          Tl ||
          new $a({
            'hillshade-illumination-direction': new Va(
              vt.paint_hillshade['hillshade-illumination-direction']
            ),
            'hillshade-illumination-altitude': new Va(
              vt.paint_hillshade['hillshade-illumination-altitude']
            ),
            'hillshade-illumination-anchor': new Va(
              vt.paint_hillshade['hillshade-illumination-anchor']
            ),
            'hillshade-exaggeration': new Va(
              vt.paint_hillshade['hillshade-exaggeration']
            ),
            'hillshade-shadow-color': new Va(
              vt.paint_hillshade['hillshade-shadow-color']
            ),
            'hillshade-highlight-color': new Va(
              vt.paint_hillshade['hillshade-highlight-color']
            ),
            'hillshade-accent-color': new Va(
              vt.paint_hillshade['hillshade-accent-color']
            ),
            'hillshade-method': new Va(vt.paint_hillshade['hillshade-method']),
          }));
      },
    };
    class Cl extends Ha {
      constructor(t, e) {
        super(t, Pl, e), this.recalculate({ zoom: 0, zoomHistory: {} }, void 0);
      }
      getIlluminationProperties() {
        let t = this.paint.get('hillshade-illumination-direction').values,
          e = this.paint.get('hillshade-illumination-altitude').values,
          i = this.paint.get('hillshade-highlight-color').values,
          r = this.paint.get('hillshade-shadow-color').values;
        const n = Math.max(t.length, e.length, i.length, r.length);
        (t = t.concat(Array(n - t.length).fill(t.at(-1)))),
          (e = e.concat(Array(n - e.length).fill(e.at(-1)))),
          (i = i.concat(Array(n - i.length).fill(i.at(-1)))),
          (r = r.concat(Array(n - r.length).fill(r.at(-1))));
        const a = e.map(et);
        return {
          directionRadians: t.map(et),
          altitudeRadians: a,
          shadowColor: r,
          highlightColor: i,
        };
      }
      hasOffscreenPass() {
        return (
          0 !== this.paint.get('hillshade-exaggeration') &&
          'none' !== this.visibility
        );
      }
    }
    let Il;
    var Sl = {
      get paint() {
        return (Il =
          Il ||
          new $a({
            'color-relief-opacity': new Va(
              vt['paint_color-relief']['color-relief-opacity']
            ),
            'color-relief-color': new Za(
              vt['paint_color-relief']['color-relief-color']
            ),
          }));
      },
    };
    class Ml {
      constructor(t, e, i, r) {
        (this.context = t),
          (this.format = i),
          (this.texture = t.gl.createTexture()),
          this.update(e, r);
      }
      update(t, e, i) {
        const { width: r, height: n } = t,
          a = !((this.size && this.size[0] === r && this.size[1] === n) || i),
          { context: s } = this,
          { gl: o } = s;
        if (
          ((this.useMipmap = Boolean(e && e.useMipmap)),
          o.bindTexture(o.TEXTURE_2D, this.texture),
          s.pixelStoreUnpackFlipY.set(!1),
          s.pixelStoreUnpack.set(1),
          s.pixelStoreUnpackPremultiplyAlpha.set(
            this.format === o.RGBA && (!e || !1 !== e.premultiply)
          ),
          a)
        )
          (this.size = [r, n]),
            t instanceof HTMLImageElement ||
            t instanceof HTMLCanvasElement ||
            t instanceof HTMLVideoElement ||
            t instanceof ImageData ||
            X(t)
              ? o.texImage2D(
                  o.TEXTURE_2D,
                  0,
                  this.format,
                  this.format,
                  o.UNSIGNED_BYTE,
                  t
                )
              : o.texImage2D(
                  o.TEXTURE_2D,
                  0,
                  this.format,
                  r,
                  n,
                  0,
                  this.format,
                  o.UNSIGNED_BYTE,
                  t.data
                );
        else {
          const { x: e, y: a } = i || { x: 0, y: 0 };
          t instanceof HTMLImageElement ||
          t instanceof HTMLCanvasElement ||
          t instanceof HTMLVideoElement ||
          t instanceof ImageData ||
          X(t)
            ? o.texSubImage2D(o.TEXTURE_2D, 0, e, a, o.RGBA, o.UNSIGNED_BYTE, t)
            : o.texSubImage2D(
                o.TEXTURE_2D,
                0,
                e,
                a,
                r,
                n,
                o.RGBA,
                o.UNSIGNED_BYTE,
                t.data
              );
        }
        this.useMipmap &&
          this.isSizePowerOfTwo() &&
          o.generateMipmap(o.TEXTURE_2D),
          s.pixelStoreUnpackFlipY.setDefault(),
          s.pixelStoreUnpack.setDefault(),
          s.pixelStoreUnpackPremultiplyAlpha.setDefault();
      }
      bind(t, e, i) {
        const { context: r } = this,
          { gl: n } = r;
        n.bindTexture(n.TEXTURE_2D, this.texture),
          i !== n.LINEAR_MIPMAP_NEAREST ||
            this.isSizePowerOfTwo() ||
            (i = n.LINEAR),
          t !== this.filter &&
            (n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MAG_FILTER, t),
            n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MIN_FILTER, i || t),
            (this.filter = t)),
          e !== this.wrap &&
            (n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_S, e),
            n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_T, e),
            (this.wrap = e));
      }
      isSizePowerOfTwo() {
        return (
          this.size[0] === this.size[1] &&
          (Math.log(this.size[0]) / Math.LN2) % 1 == 0
        );
      }
      destroy() {
        const { gl: t } = this.context;
        t.deleteTexture(this.texture), (this.texture = null);
      }
    }
    class Dl {
      constructor(t, e, i, r = 1, n = 1, a = 1, s = 0) {
        if (((this.uid = t), e.height !== e.width))
          throw new RangeError('DEM tiles must be square');
        if (i && !['mapbox', 'terrarium', 'custom'].includes(i))
          return void Z(
            `"${i}" is not a valid encoding type. Valid types include "mapbox", "terrarium" and "custom".`
          );
        this.stride = e.height;
        const o = (this.dim = e.height - 2);
        switch (((this.data = new Uint32Array(e.data.buffer)), i)) {
          case 'terrarium':
            (this.redFactor = 256),
              (this.greenFactor = 1),
              (this.blueFactor = 1 / 256),
              (this.baseShift = 32768);
            break;
          case 'custom':
            (this.redFactor = r),
              (this.greenFactor = n),
              (this.blueFactor = a),
              (this.baseShift = s);
            break;
          default:
            (this.redFactor = 6553.6),
              (this.greenFactor = 25.6),
              (this.blueFactor = 0.1),
              (this.baseShift = 1e4);
        }
        for (let l = 0; l < o; l++)
          (this.data[this._idx(-1, l)] = this.data[this._idx(0, l)]),
            (this.data[this._idx(o, l)] = this.data[this._idx(o - 1, l)]),
            (this.data[this._idx(l, -1)] = this.data[this._idx(l, 0)]),
            (this.data[this._idx(l, o)] = this.data[this._idx(l, o - 1)]);
        (this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)]),
          (this.data[this._idx(o, -1)] = this.data[this._idx(o - 1, 0)]),
          (this.data[this._idx(-1, o)] = this.data[this._idx(0, o - 1)]),
          (this.data[this._idx(o, o)] = this.data[this._idx(o - 1, o - 1)]),
          (this.min = Number.MAX_SAFE_INTEGER),
          (this.max = Number.MIN_SAFE_INTEGER);
        for (let l = 0; l < o; l++)
          for (let t = 0; t < o; t++) {
            const e = this.get(l, t);
            e > this.max && (this.max = e), e < this.min && (this.min = e);
          }
      }
      get(t, e) {
        const i = new Uint8Array(this.data.buffer),
          r = 4 * this._idx(t, e);
        return this.unpack(i[r], i[r + 1], i[r + 2]);
      }
      getUnpackVector() {
        return [
          this.redFactor,
          this.greenFactor,
          this.blueFactor,
          this.baseShift,
        ];
      }
      _idx(t, e) {
        if (t < -1 || t >= this.dim + 1 || e < -1 || e >= this.dim + 1)
          throw new RangeError('out of range source coordinates for DEM data');
        return (e + 1) * this.stride + (t + 1);
      }
      unpack(t, e, i) {
        return (
          t * this.redFactor +
          e * this.greenFactor +
          i * this.blueFactor -
          this.baseShift
        );
      }
      pack(t) {
        return Ll(t, this.getUnpackVector());
      }
      getPixels() {
        return new vl(
          { width: this.stride, height: this.stride },
          new Uint8Array(this.data.buffer)
        );
      }
      backfillBorder(t, e, i) {
        if (this.dim !== t.dim) throw new Error('dem dimension mismatch');
        let r = e * this.dim,
          n = e * this.dim + this.dim,
          a = i * this.dim,
          s = i * this.dim + this.dim;
        switch (e) {
          case -1:
            r = n - 1;
            break;
          case 1:
            n = r + 1;
        }
        switch (i) {
          case -1:
            a = s - 1;
            break;
          case 1:
            s = a + 1;
        }
        const o = -e * this.dim,
          l = -i * this.dim;
        for (let c = a; c < s; c++)
          for (let e = r; e < n; e++)
            this.data[this._idx(e, c)] = t.data[this._idx(e + o, c + l)];
      }
    }
    function Ll(t, e) {
      const i = e[0],
        r = e[1],
        n = e[2],
        a = e[3],
        s = Math.min(i, r, n),
        o = Math.round((t + a) / s);
      return {
        r: Math.floor((o * s) / i) % 256,
        g: Math.floor((o * s) / r) % 256,
        b: Math.floor((o * s) / n) % 256,
      };
    }
    ca('DEMData', Dl);
    class Al extends Ha {
      constructor(t, e) {
        super(t, Sl, e);
      }
      _createColorRamp(t) {
        const e = { elevationStops: [], colorStops: [] },
          i =
            this._transitionablePaint._values['color-relief-color'].value
              .expression;
        if (i instanceof nn && i._styleExpression.expression instanceof pi) {
          this.colorRampExpression = i;
          const t = i._styleExpression.expression;
          (e.elevationStops = t.labels), (e.colorStops = []);
          for (const i of e.elevationStops)
            e.colorStops.push(t.evaluate({ globals: { elevation: i } }));
        }
        if (
          (e.elevationStops.length < 1 &&
            ((e.elevationStops = [0]), (e.colorStops = [Se.transparent])),
          e.elevationStops.length < 2 &&
            (e.elevationStops.push(e.elevationStops[0] + 1),
            e.colorStops.push(e.colorStops[0])),
          e.elevationStops.length <= t)
        )
          return e;
        const r = { elevationStops: [], colorStops: [] },
          n = (e.elevationStops.length - 1) / (t - 1);
        for (let a = 0; a < e.elevationStops.length - 0.5; a += n)
          r.elevationStops.push(e.elevationStops[Math.round(a)]),
            r.colorStops.push(e.colorStops[Math.round(a)]);
        return (
          Z(
            `Too many colors in specification of ${this.id} color-relief layer, may not render properly. Max possible colors: ${t}, provided: ${e.elevationStops.length}`
          ),
          r
        );
      }
      _colorRampChanged() {
        return (
          this.colorRampExpression !=
          this._transitionablePaint._values['color-relief-color'].value
            .expression
        );
      }
      getColorRampTextures(t, e, i) {
        if (this.colorRampTextures && !this._colorRampChanged())
          return this.colorRampTextures;
        const r = this._createColorRamp(e),
          n = new vl({ width: r.colorStops.length, height: 1 }),
          a = new vl({ width: r.colorStops.length, height: 1 });
        for (let s = 0; s < r.elevationStops.length; s++) {
          const t = Ll(r.elevationStops[s], i);
          a.setPixel(0, s, new Se(t.r / 255, t.g / 255, t.b / 255, 1)),
            n.setPixel(0, s, r.colorStops[s]);
        }
        return (
          (this.colorRampTextures = {
            elevationTexture: new Ml(t, a, t.gl.RGBA),
            colorTexture: new Ml(t, n, t.gl.RGBA),
          }),
          this.colorRampTextures
        );
      }
      hasOffscreenPass() {
        return 'none' !== this.visibility && !!this.colorRampTextures;
      }
    }
    const El = ts([{ name: 'a_pos', components: 2, type: 'Int16' }], 4),
      { members: Rl } = El;
    function zl(t, e, i) {
      const r = i.patternDependencies;
      let n = !1;
      for (const a of e) {
        const e = a.paint.get(`${t}-pattern`);
        e.isConstant() || (n = !0);
        const i = e.constantOr(null);
        i && ((n = !0), (r[i.to] = !0), (r[i.from] = !0));
      }
      return n;
    }
    function kl(t, e, i, r, n) {
      const { zoom: a } = r,
        s = n.patternDependencies;
      for (const o of e) {
        const e = o.paint.get(`${t}-pattern`).value;
        if ('constant' !== e.kind) {
          let t = e.evaluate({ zoom: a - 1 }, i, {}, n.availableImages),
            r = e.evaluate({ zoom: a }, i, {}, n.availableImages),
            l = e.evaluate({ zoom: a + 1 }, i, {}, n.availableImages);
          (t = t && t.name ? t.name : t),
            (r = r && r.name ? r.name : r),
            (l = l && l.name ? l.name : l),
            (s[t] = !0),
            (s[r] = !0),
            (s[l] = !0),
            (i.patterns[o.id] = { min: t, mid: r, max: l });
        }
      }
      return i;
    }
    function Ol(t, e, i, r, n) {
      let a;
      if (
        n ===
        (function (t, e, i, r) {
          let n = 0;
          for (let a = e, s = i - r; a < i; a += r)
            (n += (t[s] - t[a]) * (t[a + 1] + t[s + 1])), (s = a);
          return n;
        })(t, e, i, r) >
          0
      )
        for (let s = e; s < i; s += r) a = nc((s / r) | 0, t[s], t[s + 1], a);
      else
        for (let s = i - r; s >= e; s -= r)
          a = nc((s / r) | 0, t[s], t[s + 1], a);
      return a && Jl(a, a.next) && (ac(a), (a = a.next)), a;
    }
    function Fl(t, e) {
      if (!t) return t;
      e || (e = t);
      let i,
        r = t;
      do {
        if (
          ((i = !1),
          r.steiner || (!Jl(r, r.next) && 0 !== Kl(r.prev, r, r.next)))
        )
          r = r.next;
        else {
          if ((ac(r), (r = e = r.prev), r === r.next)) break;
          i = !0;
        }
      } while (i || r !== e);
      return e;
    }
    function Bl(t, e, i, r, n, a, s) {
      if (!t) return;
      !s &&
        a &&
        (function (t, e, i, r) {
          let n = t;
          do {
            0 === n.z && (n.z = ql(n.x, n.y, e, i, r)),
              (n.prevZ = n.prev),
              (n.nextZ = n.next),
              (n = n.next);
          } while (n !== t);
          (n.prevZ.nextZ = null),
            (n.prevZ = null),
            (function (t) {
              let e,
                i = 1;
              do {
                let r,
                  n = t;
                t = null;
                let a = null;
                for (e = 0; n; ) {
                  e++;
                  let s = n,
                    o = 0;
                  for (let t = 0; t < i && (o++, (s = s.nextZ), s); t++);
                  let l = i;
                  for (; o > 0 || (l > 0 && s); )
                    0 !== o && (0 === l || !s || n.z <= s.z)
                      ? ((r = n), (n = n.nextZ), o--)
                      : ((r = s), (s = s.nextZ), l--),
                      a ? (a.nextZ = r) : (t = r),
                      (r.prevZ = a),
                      (a = r);
                  n = s;
                }
                (a.nextZ = null), (i *= 2);
              } while (e > 1);
            })(n);
        })(t, r, n, a);
      let o = t;
      for (; t.prev !== t.next; ) {
        const l = t.prev,
          c = t.next;
        if (a ? Vl(t, r, n, a) : Nl(t))
          e.push(l.i, t.i, c.i), ac(t), (t = c.next), (o = c.next);
        else if ((t = c) === o) {
          s
            ? 1 === s
              ? Bl((t = jl(Fl(t), e)), e, i, r, n, a, 2)
              : 2 === s && Ul(t, e, i, r, n, a)
            : Bl(Fl(t), e, i, r, n, a, 1);
          break;
        }
      }
    }
    function Nl(t) {
      const e = t.prev,
        i = t,
        r = t.next;
      if (Kl(e, i, r) >= 0) return !1;
      const n = e.x,
        a = i.x,
        s = r.x,
        o = e.y,
        l = i.y,
        c = r.y,
        h = Math.min(n, a, s),
        u = Math.min(o, l, c),
        d = Math.max(n, a, s),
        p = Math.max(o, l, c);
      let f = r.next;
      for (; f !== e; ) {
        if (
          f.x >= h &&
          f.x <= d &&
          f.y >= u &&
          f.y <= p &&
          Xl(n, o, a, l, s, c, f.x, f.y) &&
          Kl(f.prev, f, f.next) >= 0
        )
          return !1;
        f = f.next;
      }
      return !0;
    }
    function Vl(t, e, i, r) {
      const n = t.prev,
        a = t,
        s = t.next;
      if (Kl(n, a, s) >= 0) return !1;
      const o = n.x,
        l = a.x,
        c = s.x,
        h = n.y,
        u = a.y,
        d = s.y,
        p = Math.min(o, l, c),
        f = Math.min(h, u, d),
        m = Math.max(o, l, c),
        g = Math.max(h, u, d),
        _ = ql(p, f, e, i, r),
        y = ql(m, g, e, i, r);
      let v = t.prevZ,
        x = t.nextZ;
      for (; v && v.z >= _ && x && x.z <= y; ) {
        if (
          v.x >= p &&
          v.x <= m &&
          v.y >= f &&
          v.y <= g &&
          v !== n &&
          v !== s &&
          Xl(o, h, l, u, c, d, v.x, v.y) &&
          Kl(v.prev, v, v.next) >= 0
        )
          return !1;
        if (
          ((v = v.prevZ),
          x.x >= p &&
            x.x <= m &&
            x.y >= f &&
            x.y <= g &&
            x !== n &&
            x !== s &&
            Xl(o, h, l, u, c, d, x.x, x.y) &&
            Kl(x.prev, x, x.next) >= 0)
        )
          return !1;
        x = x.nextZ;
      }
      for (; v && v.z >= _; ) {
        if (
          v.x >= p &&
          v.x <= m &&
          v.y >= f &&
          v.y <= g &&
          v !== n &&
          v !== s &&
          Xl(o, h, l, u, c, d, v.x, v.y) &&
          Kl(v.prev, v, v.next) >= 0
        )
          return !1;
        v = v.prevZ;
      }
      for (; x && x.z <= y; ) {
        if (
          x.x >= p &&
          x.x <= m &&
          x.y >= f &&
          x.y <= g &&
          x !== n &&
          x !== s &&
          Xl(o, h, l, u, c, d, x.x, x.y) &&
          Kl(x.prev, x, x.next) >= 0
        )
          return !1;
        x = x.nextZ;
      }
      return !0;
    }
    function jl(t, e) {
      let i = t;
      do {
        const r = i.prev,
          n = i.next.next;
        !Jl(r, n) &&
          Ql(r, i, i.next, n) &&
          ic(r, n) &&
          ic(n, r) &&
          (e.push(r.i, i.i, n.i), ac(i), ac(i.next), (i = t = n)),
          (i = i.next);
      } while (i !== t);
      return Fl(i);
    }
    function Ul(t, e, i, r, n, a) {
      let s = t;
      do {
        let t = s.next.next;
        for (; t !== s.prev; ) {
          if (s.i !== t.i && Yl(s, t)) {
            let o = rc(s, t);
            return (
              (s = Fl(s, s.next)),
              (o = Fl(o, o.next)),
              Bl(s, e, i, r, n, a, 0),
              void Bl(o, e, i, r, n, a, 0)
            );
          }
          t = t.next;
        }
        s = s.next;
      } while (s !== t);
    }
    function Gl(t, e) {
      let i = t.x - e.x;
      return (
        0 === i &&
          ((i = t.y - e.y), 0 === i) &&
          (i =
            (t.next.y - t.y) / (t.next.x - t.x) -
            (e.next.y - e.y) / (e.next.x - e.x)),
        i
      );
    }
    function Zl(t, e) {
      const i = (function (t, e) {
        let i = e;
        const r = t.x,
          n = t.y;
        let a,
          s = -1 / 0;
        if (Jl(t, i)) return i;
        do {
          if (Jl(t, i.next)) return i.next;
          if (n <= i.y && n >= i.next.y && i.next.y !== i.y) {
            const t = i.x + ((n - i.y) * (i.next.x - i.x)) / (i.next.y - i.y);
            if (
              t <= r &&
              t > s &&
              ((s = t), (a = i.x < i.next.x ? i : i.next), t === r)
            )
              return a;
          }
          i = i.next;
        } while (i !== e);
        if (!a) return null;
        const o = a,
          l = a.x,
          c = a.y;
        let h = 1 / 0;
        i = a;
        do {
          if (
            r >= i.x &&
            i.x >= l &&
            r !== i.x &&
            Wl(n < c ? r : s, n, l, c, n < c ? s : r, n, i.x, i.y)
          ) {
            const e = Math.abs(n - i.y) / (r - i.x);
            ic(i, t) &&
              (e < h ||
                (e === h && (i.x > a.x || (i.x === a.x && $l(a, i))))) &&
              ((a = i), (h = e));
          }
          i = i.next;
        } while (i !== o);
        return a;
      })(t, e);
      if (!i) return e;
      const r = rc(i, t);
      return Fl(r, r.next), Fl(i, i.next);
    }
    function $l(t, e) {
      return Kl(t.prev, t, e.prev) < 0 && Kl(e.next, t, t.next) < 0;
    }
    function ql(t, e, i, r, n) {
      return (
        (t =
          1431655765 &
          ((t =
            858993459 &
            ((t =
              252645135 &
              ((t = 16711935 & ((t = ((t - i) * n) | 0) | (t << 8))) |
                (t << 4))) |
              (t << 2))) |
            (t << 1))) |
        ((e =
          1431655765 &
          ((e =
            858993459 &
            ((e =
              252645135 &
              ((e = 16711935 & ((e = ((e - r) * n) | 0) | (e << 8))) |
                (e << 4))) |
              (e << 2))) |
            (e << 1))) <<
          1)
      );
    }
    function Hl(t) {
      let e = t,
        i = t;
      do {
        (e.x < i.x || (e.x === i.x && e.y < i.y)) && (i = e), (e = e.next);
      } while (e !== t);
      return i;
    }
    function Wl(t, e, i, r, n, a, s, o) {
      return (
        (n - s) * (e - o) >= (t - s) * (a - o) &&
        (t - s) * (r - o) >= (i - s) * (e - o) &&
        (i - s) * (a - o) >= (n - s) * (r - o)
      );
    }
    function Xl(t, e, i, r, n, a, s, o) {
      return !(t === s && e === o) && Wl(t, e, i, r, n, a, s, o);
    }
    function Yl(t, e) {
      return (
        t.next.i !== e.i &&
        t.prev.i !== e.i &&
        !(function (t, e) {
          let i = t;
          do {
            if (
              i.i !== t.i &&
              i.next.i !== t.i &&
              i.i !== e.i &&
              i.next.i !== e.i &&
              Ql(i, i.next, t, e)
            )
              return !0;
            i = i.next;
          } while (i !== t);
          return !1;
        })(t, e) &&
        ((ic(t, e) &&
          ic(e, t) &&
          (function (t, e) {
            let i = t,
              r = !1;
            const n = (t.x + e.x) / 2,
              a = (t.y + e.y) / 2;
            do {
              i.y > a != i.next.y > a &&
                i.next.y !== i.y &&
                n < ((i.next.x - i.x) * (a - i.y)) / (i.next.y - i.y) + i.x &&
                (r = !r),
                (i = i.next);
            } while (i !== t);
            return r;
          })(t, e) &&
          (Kl(t.prev, t, e.prev) || Kl(t, e.prev, e))) ||
          (Jl(t, e) && Kl(t.prev, t, t.next) > 0 && Kl(e.prev, e, e.next) > 0))
      );
    }
    function Kl(t, e, i) {
      return (e.y - t.y) * (i.x - e.x) - (e.x - t.x) * (i.y - e.y);
    }
    function Jl(t, e) {
      return t.x === e.x && t.y === e.y;
    }
    function Ql(t, e, i, r) {
      const n = ec(Kl(t, e, i)),
        a = ec(Kl(t, e, r)),
        s = ec(Kl(i, r, t)),
        o = ec(Kl(i, r, e));
      return (
        (n !== a && s !== o) ||
        !(0 !== n || !tc(t, i, e)) ||
        !(0 !== a || !tc(t, r, e)) ||
        !(0 !== s || !tc(i, t, r)) ||
        !(0 !== o || !tc(i, e, r))
      );
    }
    function tc(t, e, i) {
      return (
        e.x <= Math.max(t.x, i.x) &&
        e.x >= Math.min(t.x, i.x) &&
        e.y <= Math.max(t.y, i.y) &&
        e.y >= Math.min(t.y, i.y)
      );
    }
    function ec(t) {
      return t > 0 ? 1 : t < 0 ? -1 : 0;
    }
    function ic(t, e) {
      return Kl(t.prev, t, t.next) < 0
        ? Kl(t, e, t.next) >= 0 && Kl(t, t.prev, e) >= 0
        : Kl(t, e, t.prev) < 0 || Kl(t, t.next, e) < 0;
    }
    function rc(t, e) {
      const i = sc(t.i, t.x, t.y),
        r = sc(e.i, e.x, e.y),
        n = t.next,
        a = e.prev;
      return (
        (t.next = e),
        (e.prev = t),
        (i.next = n),
        (n.prev = i),
        (r.next = i),
        (i.prev = r),
        (a.next = r),
        (r.prev = a),
        r
      );
    }
    function nc(t, e, i, r) {
      const n = sc(t, e, i);
      return (
        r
          ? ((n.next = r.next), (n.prev = r), (r.next.prev = n), (r.next = n))
          : ((n.prev = n), (n.next = n)),
        n
      );
    }
    function ac(t) {
      (t.next.prev = t.prev),
        (t.prev.next = t.next),
        t.prevZ && (t.prevZ.nextZ = t.nextZ),
        t.nextZ && (t.nextZ.prevZ = t.prevZ);
    }
    function sc(t, e, i) {
      return {
        i: t,
        x: e,
        y: i,
        prev: null,
        next: null,
        z: 0,
        prevZ: null,
        nextZ: null,
        steiner: !1,
      };
    }
    class oc {
      constructor(t, e) {
        if (e > t)
          throw new Error(
            'Min granularity must not be greater than base granularity.'
          );
        (this._baseZoomGranularity = t), (this._minGranularity = e);
      }
      getGranularityForZoomLevel(t) {
        return Math.max(
          Math.floor(this._baseZoomGranularity / (1 << t)),
          this._minGranularity,
          1
        );
      }
    }
    class lc {
      constructor(t) {
        (this.fill = t.fill),
          (this.line = t.line),
          (this.tile = t.tile),
          (this.stencil = t.stencil),
          (this.circle = t.circle);
      }
    }
    (lc.noSubdivision = new lc({
      fill: new oc(0, 0),
      line: new oc(0, 0),
      tile: new oc(0, 0),
      stencil: new oc(0, 0),
      circle: 1,
    })),
      ca('SubdivisionGranularityExpression', oc),
      ca('SubdivisionGranularitySetting', lc);
    const cc = -32768,
      hc = 32767;
    class uc {
      constructor(t, e) {
        (this._vertexBuffer = []),
          (this._vertexDictionary = new Map()),
          (this._used = !1),
          (this._granularity = t),
          (this._granularityCellSize = D / t),
          (this._canonical = e);
      }
      _getKey(t, e) {
        return ((t += 32768) << 16) | (e + 32768);
      }
      _vertexToIndex(t, e) {
        if (t < -32768 || e < -32768 || t > 32767 || e > 32767)
          throw new Error(
            'Vertex coordinates are out of signed 16 bit integer range.'
          );
        const i = 0 | Math.round(t),
          r = 0 | Math.round(e),
          n = this._getKey(i, r);
        if (this._vertexDictionary.has(n)) return this._vertexDictionary.get(n);
        const a = this._vertexBuffer.length / 2;
        return (
          this._vertexDictionary.set(n, a), this._vertexBuffer.push(i, r), a
        );
      }
      _subdivideTrianglesScanline(t) {
        if (this._granularity < 2)
          return (function (t, e) {
            const i = [];
            for (let r = 0; r < e.length; r += 3) {
              const n = e[r],
                a = e[r + 1],
                s = e[r + 2],
                o = t[2 * n],
                l = t[2 * n + 1];
              (t[2 * a] - o) * (t[2 * s + 1] - l) -
                (t[2 * a + 1] - l) * (t[2 * s] - o) >
              0
                ? (i.push(n), i.push(s), i.push(a))
                : (i.push(n), i.push(a), i.push(s));
            }
            return i;
          })(this._vertexBuffer, t);
        const e = [],
          i = t.length;
        for (let r = 0; r < i; r += 3) {
          const i = [t[r + 0], t[r + 1], t[r + 2]],
            n = [
              this._vertexBuffer[2 * t[r + 0] + 0],
              this._vertexBuffer[2 * t[r + 0] + 1],
              this._vertexBuffer[2 * t[r + 1] + 0],
              this._vertexBuffer[2 * t[r + 1] + 1],
              this._vertexBuffer[2 * t[r + 2] + 0],
              this._vertexBuffer[2 * t[r + 2] + 1],
            ];
          let a = 1 / 0,
            s = 1 / 0,
            o = -1 / 0,
            l = -1 / 0;
          for (let t = 0; t < 3; t++) {
            const e = n[2 * t],
              i = n[2 * t + 1];
            (a = Math.min(a, e)),
              (o = Math.max(o, e)),
              (s = Math.min(s, i)),
              (l = Math.max(l, i));
          }
          if (a === o || s === l) continue;
          const c = Math.floor(a / this._granularityCellSize),
            h = Math.ceil(o / this._granularityCellSize),
            u = Math.floor(s / this._granularityCellSize),
            d = Math.ceil(l / this._granularityCellSize);
          if (c !== h || u !== d)
            for (let t = u; t < d; t++) {
              const r = this._scanlineGenerateVertexRingForCellRow(t, n, i);
              fc(this._vertexBuffer, r, e);
            }
          else e.push(...i);
        }
        return e;
      }
      _scanlineGenerateVertexRingForCellRow(t, e, i) {
        const r = t * this._granularityCellSize,
          n = r + this._granularityCellSize,
          a = [];
        for (let s = 0; s < 3; s++) {
          const t = e[2 * s],
            o = e[2 * s + 1],
            l = e[(2 * (s + 1)) % 6],
            c = e[(2 * (s + 1) + 1) % 6],
            h = e[(2 * (s + 2)) % 6],
            u = e[(2 * (s + 2) + 1) % 6],
            d = l - t,
            p = c - o,
            f = 0 === d,
            m = 0 === p,
            g = (r - o) / p,
            _ = (n - o) / p,
            y = Math.min(g, _),
            v = Math.max(g, _);
          if ((!m && (y >= 1 || v <= 0)) || (m && (o < r || o > n))) {
            c >= r && c <= n && a.push(i[(s + 1) % 3]);
            continue;
          }
          !m && y > 0 && a.push(this._vertexToIndex(t + d * y, o + p * y));
          const x = t + d * Math.max(y, 0),
            b = t + d * Math.min(v, 1);
          f || this._generateIntraEdgeVertices(a, t, o, l, c, x, b),
            !m && v < 1 && a.push(this._vertexToIndex(t + d * v, o + p * v)),
            (m || (c >= r && c <= n)) && a.push(i[(s + 1) % 3]),
            !m &&
              (c <= r || c >= n) &&
              this._generateInterEdgeVertices(a, t, o, l, c, h, u, b, r, n);
        }
        return a;
      }
      _generateIntraEdgeVertices(t, e, i, r, n, a, s) {
        const o = r - e,
          l = n - i,
          c = 0 === l,
          h = c ? Math.min(e, r) : Math.min(a, s),
          u = c ? Math.max(e, r) : Math.max(a, s),
          d = Math.floor(h / this._granularityCellSize) + 1,
          p = Math.ceil(u / this._granularityCellSize) - 1;
        if (c ? e < r : a < s)
          for (let f = d; f <= p; f++) {
            const r = f * this._granularityCellSize;
            t.push(this._vertexToIndex(r, i + (l * (r - e)) / o));
          }
        else
          for (let f = p; f >= d; f--) {
            const r = f * this._granularityCellSize;
            t.push(this._vertexToIndex(r, i + (l * (r - e)) / o));
          }
      }
      _generateInterEdgeVertices(t, e, i, r, n, a, s, o, l, c) {
        const h = n - i,
          u = a - r,
          d = s - n,
          p = (l - n) / d,
          f = (c - n) / d,
          m = Math.min(p, f),
          g = Math.max(p, f),
          _ = r + u * m;
        let y = Math.floor(Math.min(_, o) / this._granularityCellSize) + 1,
          v = Math.ceil(Math.max(_, o) / this._granularityCellSize) - 1,
          x = o < _;
        const b = 0 === d;
        if (b && (s === l || s === c)) return;
        if (b || m >= 1 || g <= 0) {
          const t = i - s,
            r = a + (e - a) * Math.min((l - s) / t, (c - s) / t);
          (y = Math.floor(Math.min(r, o) / this._granularityCellSize) + 1),
            (v = Math.ceil(Math.max(r, o) / this._granularityCellSize) - 1),
            (x = o < r);
        }
        const w = h > 0 ? c : l;
        if (x)
          for (let T = y; T <= v; T++)
            t.push(this._vertexToIndex(T * this._granularityCellSize, w));
        else
          for (let T = v; T >= y; T--)
            t.push(this._vertexToIndex(T * this._granularityCellSize, w));
      }
      _generateOutline(t) {
        const e = [];
        for (const i of t) {
          const t = pc(i, this._granularity, !0),
            r = this._pointArrayToIndices(t),
            n = [];
          for (let e = 1; e < r.length; e++) n.push(r[e - 1]), n.push(r[e]);
          e.push(n);
        }
        return e;
      }
      _handlePoles(t) {
        let e = !1,
          i = !1;
        this._canonical &&
          (0 === this._canonical.y && (e = !0),
          this._canonical.y === (1 << this._canonical.z) - 1 && (i = !0)),
          (e || i) && this._fillPoles(t, e, i);
      }
      _ensureNoPoleVertices() {
        const t = this._vertexBuffer;
        for (let e = 0; e < t.length; e += 2) {
          const i = t[e + 1];
          i === cc && (t[e + 1] = -32767), i === hc && (t[e + 1] = 32766);
        }
      }
      _generatePoleQuad(t, e, i, r, n, a) {
        r > n != (a === cc)
          ? (t.push(e),
            t.push(i),
            t.push(this._vertexToIndex(r, a)),
            t.push(i),
            t.push(this._vertexToIndex(n, a)),
            t.push(this._vertexToIndex(r, a)))
          : (t.push(i),
            t.push(e),
            t.push(this._vertexToIndex(r, a)),
            t.push(this._vertexToIndex(n, a)),
            t.push(i),
            t.push(this._vertexToIndex(r, a)));
      }
      _fillPoles(t, e, i) {
        const r = this._vertexBuffer,
          n = D,
          a = t.length;
        for (let s = 2; s < a; s += 3) {
          const a = t[s - 2],
            o = t[s - 1],
            l = t[s],
            c = r[2 * a],
            h = r[2 * a + 1],
            u = r[2 * o],
            d = r[2 * o + 1],
            p = r[2 * l],
            f = r[2 * l + 1];
          e &&
            (0 === h && 0 === d && this._generatePoleQuad(t, a, o, c, u, cc),
            0 === d && 0 === f && this._generatePoleQuad(t, o, l, u, p, cc),
            0 === f && 0 === h && this._generatePoleQuad(t, l, a, p, c, cc)),
            i &&
              (h === n && d === n && this._generatePoleQuad(t, a, o, c, u, hc),
              d === n && f === n && this._generatePoleQuad(t, o, l, u, p, hc),
              f === n && h === n && this._generatePoleQuad(t, l, a, p, c, hc));
        }
      }
      _initializeVertices(t) {
        for (let e = 0; e < t.length; e += 2)
          this._vertexToIndex(t[e], t[e + 1]);
      }
      subdividePolygonInternal(t, e) {
        if (this._used)
          throw new Error('Subdivision: multiple use not allowed.');
        this._used = !0;
        const { flattened: i, holeIndices: r } = (function (t) {
          const e = [],
            i = [];
          for (const r of t)
            if (0 !== r.length) {
              r !== t[0] && e.push(i.length / 2);
              for (let t = 0; t < r.length; t++) i.push(r[t].x), i.push(r[t].y);
            }
          return { flattened: i, holeIndices: e };
        })(t);
        let n;
        this._initializeVertices(i);
        try {
          const t = (function (t, e, i = 2) {
              const r = e && e.length,
                n = r ? e[0] * i : t.length;
              let a = Ol(t, 0, n, i, !0);
              const s = [];
              if (!a || a.next === a.prev) return s;
              let o, l, c;
              if (
                (r &&
                  (a = (function (t, e, i, r) {
                    const n = [];
                    for (let a = 0, s = e.length; a < s; a++) {
                      const i = Ol(
                        t,
                        e[a] * r,
                        a < s - 1 ? e[a + 1] * r : t.length,
                        r,
                        !1
                      );
                      i === i.next && (i.steiner = !0), n.push(Hl(i));
                    }
                    n.sort(Gl);
                    for (let a = 0; a < n.length; a++) i = Zl(n[a], i);
                    return i;
                  })(t, e, a, i)),
                t.length > 80 * i)
              ) {
                (o = t[0]), (l = t[1]);
                let e = o,
                  r = l;
                for (let a = i; a < n; a += i) {
                  const i = t[a],
                    n = t[a + 1];
                  i < o && (o = i),
                    n < l && (l = n),
                    i > e && (e = i),
                    n > r && (r = n);
                }
                (c = Math.max(e - o, r - l)), (c = 0 !== c ? 32767 / c : 0);
              }
              return Bl(a, s, i, o, l, c, 0), s;
            })(i, r),
            e = this._convertIndices(i, t);
          n = this._subdivideTrianglesScanline(e);
        } catch (t) {
          console.error(t);
        }
        let a = [];
        return (
          e && (a = this._generateOutline(t)),
          this._ensureNoPoleVertices(),
          this._handlePoles(n),
          {
            verticesFlattened: this._vertexBuffer,
            indicesTriangles: n,
            indicesLineList: a,
          }
        );
      }
      _convertIndices(t, e) {
        const i = [];
        for (let r = 0; r < e.length; r++)
          i.push(this._vertexToIndex(t[2 * e[r]], t[2 * e[r] + 1]));
        return i;
      }
      _pointArrayToIndices(t) {
        const e = [];
        for (let i = 0; i < t.length; i++) {
          const r = t[i];
          e.push(this._vertexToIndex(r.x, r.y));
        }
        return e;
      }
    }
    function dc(t, e, i, r = !0) {
      return new uc(i, e).subdividePolygonInternal(t, r);
    }
    function pc(t, e, r = !1) {
      if (!t || t.length < 1) return [];
      if (t.length < 2) return [];
      const n = t[0],
        a = t[t.length - 1],
        s = r && (n.x !== a.x || n.y !== a.y);
      if (e < 2) return s ? [...t, t[0]] : [...t];
      const o = Math.floor(D / e),
        l = [];
      l.push(new i(t[0].x, t[0].y));
      const c = t.length,
        h = s ? c : c - 1;
      for (let u = 0; u < h; u++) {
        const e = t[u],
          r = u < c - 1 ? t[u + 1] : t[0],
          n = e.x,
          a = e.y,
          s = r.x,
          h = r.y,
          d = n !== s,
          p = a !== h;
        if (!d && !p) continue;
        const f = s - n,
          m = h - a,
          g = Math.abs(f),
          _ = Math.abs(m);
        let y = n,
          v = a;
        for (;;) {
          const t =
              f > 0 ? (Math.floor(y / o) + 1) * o : (Math.ceil(y / o) - 1) * o,
            e =
              m > 0 ? (Math.floor(v / o) + 1) * o : (Math.ceil(v / o) - 1) * o,
            r = Math.abs(y - t),
            n = Math.abs(v - e),
            a = Math.abs(y - s),
            c = Math.abs(v - h),
            u = d ? r / g : Number.POSITIVE_INFINITY,
            x = p ? n / _ : Number.POSITIVE_INFINITY;
          if ((a <= r || !d) && (c <= n || !p)) break;
          if ((u < x && d) || !p) {
            (y = t), (v += m * u);
            const e = new i(y, Math.round(v));
            (l[l.length - 1].x === e.x && l[l.length - 1].y === e.y) ||
              l.push(e);
          } else {
            (y += f * x), (v = e);
            const t = new i(Math.round(y), v);
            (l[l.length - 1].x === t.x && l[l.length - 1].y === t.y) ||
              l.push(t);
          }
        }
        const x = new i(s, h);
        (l[l.length - 1].x === x.x && l[l.length - 1].y === x.y) || l.push(x);
      }
      return l;
    }
    function fc(t, e, i) {
      if (0 === e.length) throw new Error('Subdivision vertex ring is empty.');
      let r = 0,
        n = t[2 * e[0]];
      for (let l = 1; l < e.length; l++) {
        const i = t[2 * e[l]];
        i < n && ((n = i), (r = l));
      }
      const a = e.length;
      let s = r,
        o = (s + 1) % a;
      for (;;) {
        const r = s - 1 >= 0 ? s - 1 : a - 1,
          n = (o + 1) % a,
          l = t[2 * e[r]],
          c = t[2 * e[n]],
          h = t[2 * e[s]],
          u = t[2 * e[s] + 1],
          d = t[2 * e[o] + 1];
        let p = !1;
        if (l < c) p = !0;
        else if (l > c) p = !1;
        else {
          const i = d - u,
            a = -(t[2 * e[o]] - h),
            s = u < d ? 1 : -1;
          ((l - h) * i + (t[2 * e[r] + 1] - u) * a) * s >
            ((c - h) * i + (t[2 * e[n] + 1] - u) * a) * s && (p = !0);
        }
        if (p) {
          const t = e[r],
            n = e[s],
            l = e[o];
          t !== n && t !== l && n !== l && i.push(l, n, t),
            s--,
            s < 0 && (s = a - 1);
        } else {
          const t = e[n],
            r = e[s],
            l = e[o];
          t !== r && t !== l && r !== l && i.push(l, r, t),
            o++,
            o >= a && (o = 0);
        }
        if (r === n) break;
      }
    }
    function mc(t, e, i, r, n, a, s, o, l) {
      const c = n.length / 2,
        h = s && o && l;
      if (c < eo.MAX_VERTEX_ARRAY_LENGTH) {
        const u = e.prepareSegment(c, i, r),
          d = u.vertexLength;
        for (let t = 0; t < a.length; t += 3)
          r.emplaceBack(d + a[t], d + a[t + 1], d + a[t + 2]);
        let p, f;
        (u.vertexLength += c),
          (u.primitiveLength += a.length / 3),
          h &&
            ((f = s.prepareSegment(c, i, o)),
            (p = f.vertexLength),
            (f.vertexLength += c));
        for (let e = 0; e < n.length; e += 2) t(n[e], n[e + 1]);
        if (h)
          for (let t = 0; t < l.length; t++) {
            const e = l[t];
            for (let t = 1; t < e.length; t += 2)
              o.emplaceBack(p + e[t - 1], p + e[t]);
            f.primitiveLength += e.length / 2;
          }
      } else
        !(function (t, e, i, r, n, a) {
          const s = [];
          for (let u = 0; u < r.length / 2; u++) s.push(-1);
          const o = { count: 0 };
          let l = 0,
            c = t.getOrCreateLatestSegment(e, i),
            h = c.vertexLength;
          for (let u = 2; u < n.length; u += 3) {
            const d = n[u - 2],
              p = n[u - 1],
              f = n[u];
            let m = s[d] < l,
              g = s[p] < l,
              _ = s[f] < l;
            c.vertexLength + ((m ? 1 : 0) + (g ? 1 : 0) + (_ ? 1 : 0)) >
              eo.MAX_VERTEX_ARRAY_LENGTH &&
              ((c = t.createNewSegment(e, i)),
              (l = o.count),
              (m = !0),
              (g = !0),
              (_ = !0),
              (h = 0));
            const y = gc(s, r, a, o, d, m, c),
              v = gc(s, r, a, o, p, g, c),
              x = gc(s, r, a, o, f, _, c);
            i.emplaceBack(h + y - l, h + v - l, h + x - l), c.primitiveLength++;
          }
        })(e, i, r, n, a, t),
          h &&
            (function (t, e, i, r, n, a) {
              const s = [];
              for (let u = 0; u < r.length / 2; u++) s.push(-1);
              const o = { count: 0 };
              let l = 0,
                c = t.getOrCreateLatestSegment(e, i),
                h = c.vertexLength;
              for (let u = 0; u < n.length; u++) {
                const d = n[u];
                for (let p = 1; p < n[u].length; p += 2) {
                  const n = d[p - 1],
                    u = d[p];
                  let f = s[n] < l,
                    m = s[u] < l;
                  c.vertexLength + ((f ? 1 : 0) + (m ? 1 : 0)) >
                    eo.MAX_VERTEX_ARRAY_LENGTH &&
                    ((c = t.createNewSegment(e, i)),
                    (l = o.count),
                    (f = !0),
                    (m = !0),
                    (h = 0));
                  const g = gc(s, r, a, o, n, f, c),
                    _ = gc(s, r, a, o, u, m, c);
                  i.emplaceBack(h + g - l, h + _ - l), c.primitiveLength++;
                }
              }
            })(s, i, o, n, l, t),
          e.forceNewSegmentOnNextPrepare(),
          null == s || s.forceNewSegmentOnNextPrepare();
    }
    function gc(t, e, i, r, n, a, s) {
      if (a) {
        const a = r.count;
        return (
          i(e[2 * n], e[2 * n + 1]),
          (t[n] = r.count),
          r.count++,
          s.vertexLength++,
          a
        );
      }
      return t[n];
    }
    class _c {
      constructor(t) {
        (this.zoom = t.zoom),
          (this.overscaling = t.overscaling),
          (this.layers = t.layers),
          (this.layerIds = this.layers.map((t) => t.id)),
          (this.index = t.index),
          (this.hasDependencies = !1),
          (this.patternFeatures = []),
          (this.layoutVertexArray = new Vs()),
          (this.indexArray = new Ks()),
          (this.indexArray2 = new Js()),
          (this.programConfigurations = new Eo(t.layers, t.zoom)),
          (this.segments = new eo()),
          (this.segments2 = new eo()),
          (this.stateDependentLayerIds = this.layers
            .filter((t) => t.isStateDependent())
            .map((t) => t.id));
      }
      populate(t, e, i) {
        this.hasDependencies = zl('fill', this.layers, e);
        const r = this.layers[0].layout.get('fill-sort-key'),
          n = !r.isConstant(),
          a = [];
        for (const { feature: s, id: o, index: l, sourceLayerIndex: c } of t) {
          const t = this.layers[0]._featureFilter.needGeometry,
            h = Bo(s, t);
          if (!this.layers[0]._featureFilter.filter(new La(this.zoom), h, i))
            continue;
          const u = n ? r.evaluate(h, {}, i, e.availableImages) : void 0,
            d = {
              id: o,
              properties: s.properties,
              type: s.type,
              sourceLayerIndex: c,
              index: l,
              geometry: t ? h.geometry : Fo(s),
              patterns: {},
              sortKey: u,
            };
          a.push(d);
        }
        n && a.sort((t, e) => t.sortKey - e.sortKey);
        for (const s of a) {
          const { geometry: r, index: n, sourceLayerIndex: a } = s;
          if (this.hasDependencies) {
            const t = kl('fill', this.layers, s, { zoom: this.zoom }, e);
            this.patternFeatures.push(t);
          } else this.addFeature(s, r, n, i, {}, e.subdivisionGranularity);
          e.featureIndex.insert(t[n].feature, r, n, a, this.index);
        }
      }
      update(t, e, i) {
        this.stateDependentLayers.length &&
          this.programConfigurations.updatePaintArrays(
            t,
            e,
            this.stateDependentLayers,
            { imagePositions: i }
          );
      }
      addFeatures(t, e, i) {
        for (const r of this.patternFeatures)
          this.addFeature(
            r,
            r.geometry,
            r.index,
            e,
            i,
            t.subdivisionGranularity
          );
      }
      isEmpty() {
        return 0 === this.layoutVertexArray.length;
      }
      uploadPending() {
        return !this.uploaded || this.programConfigurations.needsUpload;
      }
      upload(t) {
        this.uploaded ||
          ((this.layoutVertexBuffer = t.createVertexBuffer(
            this.layoutVertexArray,
            Rl
          )),
          (this.indexBuffer = t.createIndexBuffer(this.indexArray)),
          (this.indexBuffer2 = t.createIndexBuffer(this.indexArray2))),
          this.programConfigurations.upload(t),
          (this.uploaded = !0);
      }
      destroy() {
        this.layoutVertexBuffer &&
          (this.layoutVertexBuffer.destroy(),
          this.indexBuffer.destroy(),
          this.indexBuffer2.destroy(),
          this.programConfigurations.destroy(),
          this.segments.destroy(),
          this.segments2.destroy());
      }
      addFeature(t, e, i, r, n, a) {
        for (const s of tr(e, 500)) {
          const t = dc(s, r, a.fill.getGranularityForZoomLevel(r.z)),
            e = this.layoutVertexArray;
          mc(
            (t, i) => {
              e.emplaceBack(t, i);
            },
            this.segments,
            this.layoutVertexArray,
            this.indexArray,
            t.verticesFlattened,
            t.indicesTriangles,
            this.segments2,
            this.indexArray2,
            t.indicesLineList
          );
        }
        this.programConfigurations.populatePaintArrays(
          this.layoutVertexArray.length,
          t,
          i,
          { imagePositions: n, canonical: r }
        );
      }
    }
    let yc, vc;
    ca('FillBucket', _c, { omit: ['layers', 'patternFeatures'] });
    var xc = {
      get paint() {
        return (vc =
          vc ||
          new $a({
            'fill-antialias': new Va(vt.paint_fill['fill-antialias']),
            'fill-opacity': new ja(vt.paint_fill['fill-opacity']),
            'fill-color': new ja(vt.paint_fill['fill-color']),
            'fill-outline-color': new ja(vt.paint_fill['fill-outline-color']),
            'fill-translate': new Va(vt.paint_fill['fill-translate']),
            'fill-translate-anchor': new Va(
              vt.paint_fill['fill-translate-anchor']
            ),
            'fill-pattern': new Ua(vt.paint_fill['fill-pattern']),
          }));
      },
      get layout() {
        return (yc =
          yc ||
          new $a({ 'fill-sort-key': new ja(vt.layout_fill['fill-sort-key']) }));
      },
    };
    class bc extends Ha {
      constructor(t, e) {
        super(t, xc, e);
      }
      recalculate(t, e) {
        super.recalculate(t, e);
        const i = this.paint._values['fill-outline-color'];
        'constant' === i.value.kind &&
          void 0 === i.value.value &&
          (this.paint._values['fill-outline-color'] =
            this.paint._values['fill-color']);
      }
      createBucket(t) {
        return new _c(t);
      }
      queryRadius() {
        return tl(this.paint.get('fill-translate'));
      }
      queryIntersectsFeature({
        queryGeometry: t,
        geometry: e,
        transform: i,
        pixelsToTileUnits: r,
      }) {
        return Zo(
          el(
            t,
            this.paint.get('fill-translate'),
            this.paint.get('fill-translate-anchor'),
            -i.bearingInRadians,
            r
          ),
          e
        );
      }
      isTileClipped() {
        return !0;
      }
    }
    const wc = ts(
        [
          { name: 'a_pos', components: 2, type: 'Int16' },
          { name: 'a_normal_ed', components: 4, type: 'Int16' },
        ],
        4
      ),
      Tc = ts([{ name: 'a_centroid', components: 2, type: 'Int16' }], 4),
      { members: Pc } = wc;
    class Cc {
      constructor(t, e, i, r, n) {
        (this.properties = {}),
          (this.extent = i),
          (this.type = 0),
          (this.id = void 0),
          (this._pbf = t),
          (this._geometry = -1),
          (this._keys = r),
          (this._values = n),
          t.readFields(Ic, this, e);
      }
      loadGeometry() {
        const t = this._pbf;
        t.pos = this._geometry;
        const e = t.readVarint() + t.pos,
          r = [];
        let n,
          a = 1,
          s = 0,
          o = 0,
          l = 0;
        for (; t.pos < e; ) {
          if (s <= 0) {
            const e = t.readVarint();
            (a = 7 & e), (s = e >> 3);
          }
          if ((s--, 1 === a || 2 === a))
            (o += t.readSVarint()),
              (l += t.readSVarint()),
              1 === a && (n && r.push(n), (n = [])),
              n && n.push(new i(o, l));
          else {
            if (7 !== a) throw new Error(`unknown command ${a}`);
            n && n.push(n[0].clone());
          }
        }
        return n && r.push(n), r;
      }
      bbox() {
        const t = this._pbf;
        t.pos = this._geometry;
        const e = t.readVarint() + t.pos;
        let i = 1,
          r = 0,
          n = 0,
          a = 0,
          s = 1 / 0,
          o = -1 / 0,
          l = 1 / 0,
          c = -1 / 0;
        for (; t.pos < e; ) {
          if (r <= 0) {
            const e = t.readVarint();
            (i = 7 & e), (r = e >> 3);
          }
          if ((r--, 1 === i || 2 === i))
            (n += t.readSVarint()),
              (a += t.readSVarint()),
              n < s && (s = n),
              n > o && (o = n),
              a < l && (l = a),
              a > c && (c = a);
          else if (7 !== i) throw new Error(`unknown command ${i}`);
        }
        return [s, l, o, c];
      }
      toGeoJSON(t, e, i) {
        const r = this.extent * Math.pow(2, i),
          n = this.extent * t,
          a = this.extent * e,
          s = this.loadGeometry();
        function o(t) {
          return [
            (360 * (t.x + n)) / r - 180,
            (360 / Math.PI) *
              Math.atan(Math.exp((1 - (2 * (t.y + a)) / r) * Math.PI)) -
              90,
          ];
        }
        function l(t) {
          return t.map(o);
        }
        let c;
        if (1 === this.type) {
          const t = [];
          for (const i of s) t.push(i[0]);
          const e = l(t);
          c =
            1 === t.length
              ? { type: 'Point', coordinates: e[0] }
              : { type: 'MultiPoint', coordinates: e };
        } else if (2 === this.type) {
          const t = s.map(l);
          c =
            1 === t.length
              ? { type: 'LineString', coordinates: t[0] }
              : { type: 'MultiLineString', coordinates: t };
        } else {
          if (3 !== this.type) throw new Error('unknown feature type');
          {
            const t = (function (t) {
                const e = t.length;
                if (e <= 1) return [t];
                const i = [];
                let r, n;
                for (let a = 0; a < e; a++) {
                  const e = Sc(t[a]);
                  0 !== e &&
                    (void 0 === n && (n = e < 0),
                    n === e < 0
                      ? (r && i.push(r), (r = [t[a]]))
                      : r && r.push(t[a]));
                }
                return r && i.push(r), i;
              })(s),
              e = [];
            for (const i of t) e.push(i.map(l));
            c =
              1 === e.length
                ? { type: 'Polygon', coordinates: e[0] }
                : { type: 'MultiPolygon', coordinates: e };
          }
        }
        const h = { type: 'Feature', geometry: c, properties: this.properties };
        return null != this.id && (h.id = this.id), h;
      }
    }
    function Ic(t, e, i) {
      1 === t
        ? (e.id = i.readVarint())
        : 2 === t
        ? (function (t, e) {
            const i = t.readVarint() + t.pos;
            for (; t.pos < i; ) {
              const i = e._keys[t.readVarint()],
                r = e._values[t.readVarint()];
              e.properties[i] = r;
            }
          })(i, e)
        : 3 === t
        ? (e.type = i.readVarint())
        : 4 === t && (e._geometry = i.pos);
    }
    function Sc(t) {
      let e = 0;
      for (let i, r, n = 0, a = t.length, s = a - 1; n < a; s = n++)
        (i = t[n]), (r = t[s]), (e += (r.x - i.x) * (i.y + r.y));
      return e;
    }
    Cc.types = ['Unknown', 'Point', 'LineString', 'Polygon'];
    class Mc {
      constructor(t, e) {
        (this.version = 1),
          (this.name = ''),
          (this.extent = 4096),
          (this.length = 0),
          (this._pbf = t),
          (this._keys = []),
          (this._values = []),
          (this._features = []),
          t.readFields(Dc, this, e),
          (this.length = this._features.length);
      }
      feature(t) {
        if (t < 0 || t >= this._features.length)
          throw new Error('feature index out of bounds');
        this._pbf.pos = this._features[t];
        const e = this._pbf.readVarint() + this._pbf.pos;
        return new Cc(this._pbf, e, this.extent, this._keys, this._values);
      }
    }
    function Dc(t, e, i) {
      15 === t
        ? (e.version = i.readVarint())
        : 1 === t
        ? (e.name = i.readString())
        : 5 === t
        ? (e.extent = i.readVarint())
        : 2 === t
        ? e._features.push(i.pos)
        : 3 === t
        ? e._keys.push(i.readString())
        : 4 === t &&
          e._values.push(
            (function (t) {
              let e = null;
              const i = t.readVarint() + t.pos;
              for (; t.pos < i; ) {
                const i = t.readVarint() >> 3;
                e =
                  1 === i
                    ? t.readString()
                    : 2 === i
                    ? t.readFloat()
                    : 3 === i
                    ? t.readDouble()
                    : 4 === i
                    ? t.readVarint64()
                    : 5 === i
                    ? t.readVarint()
                    : 6 === i
                    ? t.readSVarint()
                    : 7 === i
                    ? t.readBoolean()
                    : null;
              }
              if (null == e) throw new Error('unknown feature value');
              return e;
            })(i)
          );
    }
    class Lc {
      constructor(t, e) {
        this.layers = t.readFields(Ac, {}, e);
      }
    }
    function Ac(t, e, i) {
      if (3 === t) {
        const t = new Mc(i, i.readVarint() + i.pos);
        t.length && (e[t.name] = t);
      }
    }
    const Ec = Math.pow(2, 13);
    function Rc(t, e, i, r, n, a, s, o) {
      t.emplaceBack(
        e,
        i,
        2 * Math.floor(r * Ec) + s,
        n * Ec * 2,
        a * Ec * 2,
        Math.round(o)
      );
    }
    class zc {
      constructor(t) {
        (this.zoom = t.zoom),
          (this.overscaling = t.overscaling),
          (this.layers = t.layers),
          (this.layerIds = this.layers.map((t) => t.id)),
          (this.index = t.index),
          (this.hasDependencies = !1),
          (this.layoutVertexArray = new js()),
          (this.centroidVertexArray = new Bs()),
          (this.indexArray = new Ks()),
          (this.programConfigurations = new Eo(t.layers, t.zoom)),
          (this.segments = new eo()),
          (this.stateDependentLayerIds = this.layers
            .filter((t) => t.isStateDependent())
            .map((t) => t.id));
      }
      populate(t, e, i) {
        (this.features = []),
          (this.hasDependencies = zl('fill-extrusion', this.layers, e));
        for (const { feature: r, id: n, index: a, sourceLayerIndex: s } of t) {
          const t = this.layers[0]._featureFilter.needGeometry,
            o = Bo(r, t);
          if (!this.layers[0]._featureFilter.filter(new La(this.zoom), o, i))
            continue;
          const l = {
            id: n,
            sourceLayerIndex: s,
            index: a,
            geometry: t ? o.geometry : Fo(r),
            properties: r.properties,
            type: r.type,
            patterns: {},
          };
          this.hasDependencies
            ? this.features.push(
                kl('fill-extrusion', this.layers, l, { zoom: this.zoom }, e)
              )
            : this.addFeature(
                l,
                l.geometry,
                a,
                i,
                {},
                e.subdivisionGranularity
              ),
            e.featureIndex.insert(r, l.geometry, a, s, this.index, !0);
        }
      }
      addFeatures(t, e, i) {
        for (const r of this.features) {
          const { geometry: n } = r;
          this.addFeature(r, n, r.index, e, i, t.subdivisionGranularity);
        }
      }
      update(t, e, i) {
        this.stateDependentLayers.length &&
          this.programConfigurations.updatePaintArrays(
            t,
            e,
            this.stateDependentLayers,
            { imagePositions: i }
          );
      }
      isEmpty() {
        return (
          0 === this.layoutVertexArray.length &&
          0 === this.centroidVertexArray.length
        );
      }
      uploadPending() {
        return !this.uploaded || this.programConfigurations.needsUpload;
      }
      upload(t) {
        this.uploaded ||
          ((this.layoutVertexBuffer = t.createVertexBuffer(
            this.layoutVertexArray,
            Pc
          )),
          (this.centroidVertexBuffer = t.createVertexBuffer(
            this.centroidVertexArray,
            Tc.members,
            !0
          )),
          (this.indexBuffer = t.createIndexBuffer(this.indexArray))),
          this.programConfigurations.upload(t),
          (this.uploaded = !0);
      }
      destroy() {
        this.layoutVertexBuffer &&
          (this.layoutVertexBuffer.destroy(),
          this.indexBuffer.destroy(),
          this.programConfigurations.destroy(),
          this.segments.destroy(),
          this.centroidVertexBuffer.destroy());
      }
      addFeature(t, e, i, r, n, a) {
        for (const s of tr(e, 500)) {
          const e = { x: 0, y: 0, sampleCount: 0 },
            i = this.layoutVertexArray.length;
          this.processPolygon(e, r, t, s, a);
          const n = this.layoutVertexArray.length - i,
            o = Math.floor(e.x / e.sampleCount),
            l = Math.floor(e.y / e.sampleCount);
          for (let t = 0; t < n; t++)
            this.centroidVertexArray.emplaceBack(o, l);
        }
        this.programConfigurations.populatePaintArrays(
          this.layoutVertexArray.length,
          t,
          i,
          { imagePositions: n, canonical: r }
        );
      }
      processPolygon(t, e, i, r, n) {
        if (r.length < 1) return;
        if (Fc(r[0])) return;
        for (const h of r) 0 !== h.length && kc(t, h);
        const a = {
            segment: this.segments.prepareSegment(
              4,
              this.layoutVertexArray,
              this.indexArray
            ),
          },
          s = n.fill.getGranularityForZoomLevel(e.z),
          o = 'Polygon' === Cc.types[i.type];
        for (const h of r) {
          if (0 === h.length) continue;
          if (Fc(h)) continue;
          const t = pc(h, s, o);
          this._generateSideFaces(t, a);
        }
        if (!o) return;
        const l = dc(r, e, s, !1),
          c = this.layoutVertexArray;
        mc(
          (t, e) => {
            Rc(c, t, e, 0, 0, 1, 1, 0);
          },
          this.segments,
          this.layoutVertexArray,
          this.indexArray,
          l.verticesFlattened,
          l.indicesTriangles
        );
      }
      _generateSideFaces(t, e) {
        let i = 0;
        for (let r = 1; r < t.length; r++) {
          const n = t[r],
            a = t[r - 1];
          if (Oc(n, a)) continue;
          e.segment.vertexLength + 4 > eo.MAX_VERTEX_ARRAY_LENGTH &&
            (e.segment = this.segments.prepareSegment(
              4,
              this.layoutVertexArray,
              this.indexArray
            ));
          const s = n.sub(a)._perp()._unit(),
            o = a.dist(n);
          i + o > 32768 && (i = 0),
            Rc(this.layoutVertexArray, n.x, n.y, s.x, s.y, 0, 0, i),
            Rc(this.layoutVertexArray, n.x, n.y, s.x, s.y, 0, 1, i),
            (i += o),
            Rc(this.layoutVertexArray, a.x, a.y, s.x, s.y, 0, 0, i),
            Rc(this.layoutVertexArray, a.x, a.y, s.x, s.y, 0, 1, i);
          const l = e.segment.vertexLength;
          this.indexArray.emplaceBack(l, l + 2, l + 1),
            this.indexArray.emplaceBack(l + 1, l + 2, l + 3),
            (e.segment.vertexLength += 4),
            (e.segment.primitiveLength += 2);
        }
      }
    }
    function kc(t, e) {
      for (let i = 0; i < e.length; i++) {
        const r = e[i];
        (i === e.length - 1 && e[0].x === r.x && e[0].y === r.y) ||
          ((t.x += r.x), (t.y += r.y), t.sampleCount++);
      }
    }
    function Oc(t, e) {
      return (
        (t.x === e.x && (t.x < 0 || t.x > D)) ||
        (t.y === e.y && (t.y < 0 || t.y > D))
      );
    }
    function Fc(t) {
      return (
        t.every((t) => t.x < 0) ||
        t.every((t) => t.x > D) ||
        t.every((t) => t.y < 0) ||
        t.every((t) => t.y > D)
      );
    }
    let Bc;
    ca('FillExtrusionBucket', zc, { omit: ['layers', 'features'] });
    var Nc = {
      get paint() {
        return (Bc =
          Bc ||
          new $a({
            'fill-extrusion-opacity': new Va(
              vt['paint_fill-extrusion']['fill-extrusion-opacity']
            ),
            'fill-extrusion-color': new ja(
              vt['paint_fill-extrusion']['fill-extrusion-color']
            ),
            'fill-extrusion-translate': new Va(
              vt['paint_fill-extrusion']['fill-extrusion-translate']
            ),
            'fill-extrusion-translate-anchor': new Va(
              vt['paint_fill-extrusion']['fill-extrusion-translate-anchor']
            ),
            'fill-extrusion-pattern': new Ua(
              vt['paint_fill-extrusion']['fill-extrusion-pattern']
            ),
            'fill-extrusion-height': new ja(
              vt['paint_fill-extrusion']['fill-extrusion-height']
            ),
            'fill-extrusion-base': new ja(
              vt['paint_fill-extrusion']['fill-extrusion-base']
            ),
            'fill-extrusion-vertical-gradient': new Va(
              vt['paint_fill-extrusion']['fill-extrusion-vertical-gradient']
            ),
          }));
      },
    };
    class Vc extends Ha {
      constructor(t, e) {
        super(t, Nc, e);
      }
      createBucket(t) {
        return new zc(t);
      }
      queryRadius() {
        return tl(this.paint.get('fill-extrusion-translate'));
      }
      is3D() {
        return !0;
      }
      queryIntersectsFeature({
        queryGeometry: t,
        feature: e,
        featureState: r,
        geometry: n,
        transform: a,
        pixelsToTileUnits: s,
        pixelPosMatrix: o,
      }) {
        const l = el(
            t,
            this.paint.get('fill-extrusion-translate'),
            this.paint.get('fill-extrusion-translate-anchor'),
            -a.bearingInRadians,
            s
          ),
          c = this.paint.get('fill-extrusion-height').evaluate(e, r),
          h = this.paint.get('fill-extrusion-base').evaluate(e, r),
          u = (function (t, e) {
            const r = [];
            for (const n of t) {
              const t = [n.x, n.y, 0, 1];
              P(t, t, e), r.push(new i(t[0] / t[3], t[1] / t[3]));
            }
            return r;
          })(l, o),
          d = (function (t, e, r, n) {
            const a = [],
              s = [],
              o = n[8] * e,
              l = n[9] * e,
              c = n[10] * e,
              h = n[11] * e,
              u = n[8] * r,
              d = n[9] * r,
              p = n[10] * r,
              f = n[11] * r;
            for (const m of t) {
              const t = [],
                e = [];
              for (const r of m) {
                const a = r.x,
                  s = r.y,
                  m = n[0] * a + n[4] * s + n[12],
                  g = n[1] * a + n[5] * s + n[13],
                  _ = n[2] * a + n[6] * s + n[14],
                  y = n[3] * a + n[7] * s + n[15],
                  v = _ + c,
                  x = y + h,
                  b = m + u,
                  w = g + d,
                  T = _ + p,
                  P = y + f,
                  C = new i((m + o) / x, (g + l) / x);
                (C.z = v / x), t.push(C);
                const I = new i(b / P, w / P);
                (I.z = T / P), e.push(I);
              }
              a.push(t), s.push(e);
            }
            return [a, s];
          })(n, h, c, o);
        return (function (t, e, i) {
          let r = 1 / 0;
          Zo(i, e) && (r = Uc(i, e[0]));
          for (let n = 0; n < e.length; n++) {
            const a = e[n],
              s = t[n];
            for (let t = 0; t < a.length - 1; t++) {
              const e = a[t],
                n = [e, a[t + 1], s[t + 1], s[t], e];
              Uo(i, n) && (r = Math.min(r, Uc(i, n)));
            }
          }
          return r !== 1 / 0 && r;
        })(d[0], d[1], u);
      }
    }
    function jc(t, e) {
      return t.x * e.x + t.y * e.y;
    }
    function Uc(t, e) {
      if (1 === t.length) {
        let i = 0;
        const r = e[i++];
        let n;
        for (; !n || r.equals(n); ) if (((n = e[i++]), !n)) return 1 / 0;
        for (; i < e.length; i++) {
          const a = e[i],
            s = t[0],
            o = n.sub(r),
            l = a.sub(r),
            c = s.sub(r),
            h = jc(o, o),
            u = jc(o, l),
            d = jc(l, l),
            p = jc(c, o),
            f = jc(c, l),
            m = h * d - u * u,
            g = (d * p - u * f) / m,
            _ = (h * f - u * p) / m,
            y = r.z * (1 - g - _) + n.z * g + a.z * _;
          if (isFinite(y)) return y;
        }
        return 1 / 0;
      }
      {
        let t = 1 / 0;
        for (const i of e) t = Math.min(t, i.z);
        return t;
      }
    }
    const Gc = ts(
        [
          { name: 'a_pos_normal', components: 2, type: 'Int16' },
          { name: 'a_data', components: 4, type: 'Uint8' },
        ],
        4
      ),
      { members: Zc } = Gc,
      $c = ts([
        { name: 'a_uv_x', components: 1, type: 'Float32' },
        { name: 'a_split_index', components: 1, type: 'Float32' },
      ]),
      { members: qc } = $c,
      Hc = Math.cos((Math.PI / 180) * 37.5),
      Wc = Math.pow(2, 14) / 0.5;
    class Xc {
      constructor(t) {
        (this.zoom = t.zoom),
          (this.overscaling = t.overscaling),
          (this.layers = t.layers),
          (this.layerIds = this.layers.map((t) => t.id)),
          (this.index = t.index),
          (this.hasDependencies = !1),
          (this.patternFeatures = []),
          (this.lineClipsArray = []),
          (this.gradients = {}),
          this.layers.forEach((t) => {
            this.gradients[t.id] = {};
          }),
          (this.layoutVertexArray = new Us()),
          (this.layoutVertexArray2 = new Gs()),
          (this.indexArray = new Ks()),
          (this.programConfigurations = new Eo(t.layers, t.zoom)),
          (this.segments = new eo()),
          (this.maxLineLength = 0),
          (this.stateDependentLayerIds = this.layers
            .filter((t) => t.isStateDependent())
            .map((t) => t.id));
      }
      populate(t, e, i) {
        this.hasDependencies =
          zl('line', this.layers, e) || this.hasLineDasharray(this.layers);
        const r = this.layers[0].layout.get('line-sort-key'),
          n = !r.isConstant(),
          a = [];
        for (const { feature: s, id: o, index: l, sourceLayerIndex: c } of t) {
          const t = this.layers[0]._featureFilter.needGeometry,
            e = Bo(s, t);
          if (!this.layers[0]._featureFilter.filter(new La(this.zoom), e, i))
            continue;
          const h = n ? r.evaluate(e, {}, i) : void 0,
            u = {
              id: o,
              properties: s.properties,
              type: s.type,
              sourceLayerIndex: c,
              index: l,
              geometry: t ? e.geometry : Fo(s),
              patterns: {},
              dashes: {},
              sortKey: h,
            };
          a.push(u);
        }
        n && a.sort((t, e) => t.sortKey - e.sortKey);
        for (const s of a) {
          const { geometry: r, index: n, sourceLayerIndex: a } = s;
          this.hasDependencies
            ? (zl('line', this.layers, e)
                ? kl('line', this.layers, s, { zoom: this.zoom }, e)
                : this.hasLineDasharray(this.layers) &&
                  this.addLineDashDependencies(this.layers, s, this.zoom, e),
              this.patternFeatures.push(s))
            : this.addFeature(s, r, n, i, {}, {}, e.subdivisionGranularity),
            e.featureIndex.insert(t[n].feature, r, n, a, this.index);
        }
      }
      update(t, e, i, r) {
        this.stateDependentLayers.length &&
          this.programConfigurations.updatePaintArrays(
            t,
            e,
            this.stateDependentLayers,
            { imagePositions: i, dashPositions: r }
          );
      }
      addFeatures(t, e, i, r) {
        for (const n of this.patternFeatures)
          this.addFeature(
            n,
            n.geometry,
            n.index,
            e,
            i,
            r,
            t.subdivisionGranularity
          );
      }
      isEmpty() {
        return 0 === this.layoutVertexArray.length;
      }
      uploadPending() {
        return !this.uploaded || this.programConfigurations.needsUpload;
      }
      upload(t) {
        this.uploaded ||
          (0 !== this.layoutVertexArray2.length &&
            (this.layoutVertexBuffer2 = t.createVertexBuffer(
              this.layoutVertexArray2,
              qc
            )),
          (this.layoutVertexBuffer = t.createVertexBuffer(
            this.layoutVertexArray,
            Zc
          )),
          (this.indexBuffer = t.createIndexBuffer(this.indexArray))),
          this.programConfigurations.upload(t),
          (this.uploaded = !0);
      }
      destroy() {
        this.layoutVertexBuffer &&
          (this.layoutVertexBuffer.destroy(),
          this.indexBuffer.destroy(),
          this.programConfigurations.destroy(),
          this.segments.destroy());
      }
      lineFeatureClips(t) {
        if (
          t.properties &&
          Object.prototype.hasOwnProperty.call(
            t.properties,
            'mapbox_clip_start'
          ) &&
          Object.prototype.hasOwnProperty.call(t.properties, 'mapbox_clip_end')
        )
          return {
            start: +t.properties.mapbox_clip_start,
            end: +t.properties.mapbox_clip_end,
          };
      }
      addFeature(t, e, i, r, n, a, s) {
        const o = this.layers[0].layout,
          l = o.get('line-join').evaluate(t, {}),
          c = o.get('line-cap'),
          h = o.get('line-miter-limit'),
          u = o.get('line-round-limit');
        this.lineClips = this.lineFeatureClips(t);
        for (const d of e) this.addLine(d, t, l, c, h, u, r, s);
        this.programConfigurations.populatePaintArrays(
          this.layoutVertexArray.length,
          t,
          i,
          { imagePositions: n, dashPositions: a, canonical: r }
        );
      }
      addLine(t, e, i, r, n, a, s, o) {
        if (
          ((this.distance = 0),
          (this.scaledDistance = 0),
          (this.totalDistance = 0),
          (t = pc(t, s ? o.line.getGranularityForZoomLevel(s.z) : 1)),
          this.lineClips)
        ) {
          this.lineClipsArray.push(this.lineClips);
          for (let e = 0; e < t.length - 1; e++)
            this.totalDistance += t[e].dist(t[e + 1]);
          this.updateScaledDistance(),
            (this.maxLineLength = Math.max(
              this.maxLineLength,
              this.totalDistance
            ));
        }
        const l = 'Polygon' === Cc.types[e.type];
        let c = t.length;
        for (; c >= 2 && t[c - 1].equals(t[c - 2]); ) c--;
        let h = 0;
        for (; h < c - 1 && t[h].equals(t[h + 1]); ) h++;
        if (c < (l ? 3 : 2)) return;
        'bevel' === i && (n = 1.05);
        const u =
            this.overscaling <= 16 ? 122880 / (512 * this.overscaling) : 0,
          d = this.segments.prepareSegment(
            10 * c,
            this.layoutVertexArray,
            this.indexArray
          );
        let p, f, m, g, _;
        (this.e1 = this.e2 = -1),
          l && ((p = t[c - 2]), (_ = t[h].sub(p)._unit()._perp()));
        for (let y = h; y < c; y++) {
          if (
            ((m = y === c - 1 ? (l ? t[h + 1] : void 0) : t[y + 1]),
            m && t[y].equals(m))
          )
            continue;
          _ && (g = _),
            p && (f = p),
            (p = t[y]),
            (_ = m ? m.sub(p)._unit()._perp() : g),
            (g = g || _);
          let e = g.add(_);
          (0 === e.x && 0 === e.y) || e._unit();
          const s = g.x * _.x + g.y * _.y,
            o = e.x * _.x + e.y * _.y,
            v = 0 !== o ? 1 / o : 1 / 0,
            x = 2 * Math.sqrt(2 - 2 * o),
            b = o < Hc && f && m,
            w = g.x * _.y - g.y * _.x > 0;
          if (b && y > h) {
            const t = p.dist(f);
            if (t > 2 * u) {
              const e = p.sub(
                p
                  .sub(f)
                  ._mult(u / t)
                  ._round()
              );
              this.updateDistance(f, e),
                this.addCurrentVertex(e, g, 0, 0, d),
                (f = e);
            }
          }
          const T = f && m;
          let P = T ? i : l ? 'butt' : r;
          if (
            (T &&
              'round' === P &&
              (v < a ? (P = 'miter') : v <= 2 && (P = 'fakeround')),
            'miter' === P && v > n && (P = 'bevel'),
            'bevel' === P &&
              (v > 2 && (P = 'flipbevel'), v < n && (P = 'miter')),
            f && this.updateDistance(f, p),
            'miter' === P)
          )
            e._mult(v), this.addCurrentVertex(p, e, 0, 0, d);
          else if ('flipbevel' === P) {
            if (v > 100) e = _.mult(-1);
            else {
              const t = (v * g.add(_).mag()) / g.sub(_).mag();
              e._perp()._mult(t * (w ? -1 : 1));
            }
            this.addCurrentVertex(p, e, 0, 0, d),
              this.addCurrentVertex(p, e.mult(-1), 0, 0, d);
          } else if ('bevel' === P || 'fakeround' === P) {
            const t = -Math.sqrt(v * v - 1),
              e = w ? t : 0,
              i = w ? 0 : t;
            if (
              (f && this.addCurrentVertex(p, g, e, i, d), 'fakeround' === P)
            ) {
              const t = Math.round((180 * x) / Math.PI / 20);
              for (let e = 1; e < t; e++) {
                let i = e / t;
                if (0.5 !== i) {
                  const t = i - 0.5;
                  i +=
                    i *
                    t *
                    (i - 1) *
                    ((1.0904 + s * (s * (3.55645 - 1.43519 * s) - 3.2452)) *
                      t *
                      t +
                      (0.848013 + s * (0.215638 * s - 1.06021)));
                }
                const r = _.sub(g)
                  ._mult(i)
                  ._add(g)
                  ._unit()
                  ._mult(w ? -1 : 1);
                this.addHalfVertex(p, r.x, r.y, !1, w, 0, d);
              }
            }
            m && this.addCurrentVertex(p, _, -e, -i, d);
          } else if ('butt' === P) this.addCurrentVertex(p, e, 0, 0, d);
          else if ('square' === P) {
            const t = f ? 1 : -1;
            this.addCurrentVertex(p, e, t, t, d);
          } else
            'round' === P &&
              (f &&
                (this.addCurrentVertex(p, g, 0, 0, d),
                this.addCurrentVertex(p, g, 1, 1, d, !0)),
              m &&
                (this.addCurrentVertex(p, _, -1, -1, d, !0),
                this.addCurrentVertex(p, _, 0, 0, d)));
          if (b && y < c - 1) {
            const t = p.dist(m);
            if (t > 2 * u) {
              const e = p.add(
                m
                  .sub(p)
                  ._mult(u / t)
                  ._round()
              );
              this.updateDistance(p, e),
                this.addCurrentVertex(e, _, 0, 0, d),
                (p = e);
            }
          }
        }
      }
      addCurrentVertex(t, e, i, r, n, a = !1) {
        const s = e.y * r - e.x,
          o = -e.y - e.x * r;
        this.addHalfVertex(t, e.x + e.y * i, e.y - e.x * i, a, !1, i, n),
          this.addHalfVertex(t, s, o, a, !0, -r, n),
          this.distance > Wc / 2 &&
            0 === this.totalDistance &&
            ((this.distance = 0),
            this.updateScaledDistance(),
            this.addCurrentVertex(t, e, i, r, n, a));
      }
      addHalfVertex({ x: t, y: e }, i, r, n, a, s, o) {
        const l =
          0.5 *
          (this.lineClips
            ? this.scaledDistance * (Wc - 1)
            : this.scaledDistance);
        this.layoutVertexArray.emplaceBack(
          (t << 1) + (n ? 1 : 0),
          (e << 1) + (a ? 1 : 0),
          Math.round(63 * i) + 128,
          Math.round(63 * r) + 128,
          (1 + (0 === s ? 0 : s < 0 ? -1 : 1)) | ((63 & l) << 2),
          l >> 6
        ),
          this.lineClips &&
            this.layoutVertexArray2.emplaceBack(
              (this.scaledDistance - this.lineClips.start) /
                (this.lineClips.end - this.lineClips.start),
              this.lineClipsArray.length
            );
        const c = o.vertexLength++;
        this.e1 >= 0 &&
          this.e2 >= 0 &&
          (this.indexArray.emplaceBack(this.e1, c, this.e2),
          o.primitiveLength++),
          a ? (this.e2 = c) : (this.e1 = c);
      }
      updateScaledDistance() {
        this.scaledDistance = this.lineClips
          ? this.lineClips.start +
            ((this.lineClips.end - this.lineClips.start) * this.distance) /
              this.totalDistance
          : this.distance;
      }
      updateDistance(t, e) {
        (this.distance += t.dist(e)), this.updateScaledDistance();
      }
      hasLineDasharray(t) {
        for (const e of t) {
          const t = e.paint.get('line-dasharray');
          if (t && !t.isConstant()) return !0;
        }
        return !1;
      }
      addLineDashDependencies(t, e, i, r) {
        for (const n of t) {
          const t = n.paint.get('line-dasharray');
          if (!t || 'constant' === t.value.kind) continue;
          const a = 'round' === n.layout.get('line-cap'),
            s = {
              dasharray: t.value.evaluate({ zoom: i - 1 }, e, {}),
              round: a,
            },
            o = { dasharray: t.value.evaluate({ zoom: i }, e, {}), round: a },
            l = {
              dasharray: t.value.evaluate({ zoom: i + 1 }, e, {}),
              round: a,
            },
            c = `${s.dasharray.join(',')},${s.round}`,
            h = `${o.dasharray.join(',')},${o.round}`,
            u = `${l.dasharray.join(',')},${l.round}`;
          (r.dashDependencies[c] = s),
            (r.dashDependencies[h] = o),
            (r.dashDependencies[u] = l),
            (e.dashes[n.id] = { min: c, mid: h, max: u });
        }
      }
    }
    let Yc, Kc;
    ca('LineBucket', Xc, { omit: ['layers', 'patternFeatures'] });
    var Jc = {
      get paint() {
        return (Kc =
          Kc ||
          new $a({
            'line-opacity': new ja(vt.paint_line['line-opacity']),
            'line-color': new ja(vt.paint_line['line-color']),
            'line-translate': new Va(vt.paint_line['line-translate']),
            'line-translate-anchor': new Va(
              vt.paint_line['line-translate-anchor']
            ),
            'line-width': new ja(vt.paint_line['line-width']),
            'line-gap-width': new ja(vt.paint_line['line-gap-width']),
            'line-offset': new ja(vt.paint_line['line-offset']),
            'line-blur': new ja(vt.paint_line['line-blur']),
            'line-dasharray': new Ua(vt.paint_line['line-dasharray']),
            'line-pattern': new Ua(vt.paint_line['line-pattern']),
            'line-gradient': new Za(vt.paint_line['line-gradient']),
          }));
      },
      get layout() {
        return (Yc =
          Yc ||
          new $a({
            'line-cap': new Va(vt.layout_line['line-cap']),
            'line-join': new ja(vt.layout_line['line-join']),
            'line-miter-limit': new Va(vt.layout_line['line-miter-limit']),
            'line-round-limit': new Va(vt.layout_line['line-round-limit']),
            'line-sort-key': new ja(vt.layout_line['line-sort-key']),
          }));
      },
    };
    class Qc extends ja {
      possiblyEvaluate(t, e) {
        return (
          (e = new La(Math.floor(e.zoom), {
            now: e.now,
            fadeDuration: e.fadeDuration,
            zoomHistory: e.zoomHistory,
            transition: e.transition,
          })),
          super.possiblyEvaluate(t, e)
        );
      }
      evaluate(t, e, i, r) {
        return (
          (e = B({}, e, { zoom: Math.floor(e.zoom) })),
          super.evaluate(t, e, i, r)
        );
      }
    }
    let th;
    class eh extends Ha {
      constructor(t, e) {
        super(t, Jc, e),
          (this.gradientVersion = 0),
          th ||
            ((th = new Qc(Jc.paint.properties['line-width'].specification)),
            (th.useIntegerZoom = !0));
      }
      _handleSpecialPaintPropertyUpdate(t) {
        if ('line-gradient' === t) {
          const t = this.gradientExpression();
          (this.stepInterpolant =
            !!(function (t) {
              return void 0 !== t._styleExpression;
            })(t) && t._styleExpression.expression instanceof oi),
            (this.gradientVersion =
              (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER);
        }
      }
      gradientExpression() {
        return this
          ._transitionablePaint._values['line-gradient'].value.expression;
      }
      recalculate(t, e) {
        super.recalculate(t, e),
          (this.paint._values['line-floorwidth'] = th.possiblyEvaluate(
            this._transitioningPaint._values['line-width'].value,
            t
          ));
      }
      createBucket(t) {
        return new Xc(t);
      }
      queryRadius(t) {
        const e = t,
          i = ih(Qo('line-width', this, e), Qo('line-gap-width', this, e)),
          r = Qo('line-offset', this, e);
        return i / 2 + Math.abs(r) + tl(this.paint.get('line-translate'));
      }
      queryIntersectsFeature({
        queryGeometry: t,
        feature: e,
        featureState: r,
        geometry: n,
        transform: a,
        pixelsToTileUnits: s,
      }) {
        const o = el(
            t,
            this.paint.get('line-translate'),
            this.paint.get('line-translate-anchor'),
            -a.bearingInRadians,
            s
          ),
          l =
            (s / 2) *
            ih(
              this.paint.get('line-width').evaluate(e, r),
              this.paint.get('line-gap-width').evaluate(e, r)
            ),
          c = this.paint.get('line-offset').evaluate(e, r);
        return (
          c &&
            (n = (function (t, e) {
              const r = [];
              for (let n = 0; n < t.length; n++) {
                const a = t[n],
                  s = [];
                for (let t = 0; t < a.length; t++) {
                  const r = a[t - 1],
                    n = a[t],
                    o = a[t + 1],
                    l = 0 === t ? new i(0, 0) : n.sub(r)._unit()._perp(),
                    c =
                      t === a.length - 1
                        ? new i(0, 0)
                        : o.sub(n)._unit()._perp(),
                    h = l._add(c)._unit(),
                    u = h.x * c.x + h.y * c.y;
                  0 !== u && h._mult(1 / u), s.push(h._mult(e)._add(n));
                }
                r.push(s);
              }
              return r;
            })(n, c * s)),
          (function (t, e, i) {
            for (let r = 0; r < e.length; r++) {
              const n = e[r];
              if (t.length >= 3)
                for (let e = 0; e < n.length; e++) if (Ko(t, n[e])) return !0;
              if ($o(t, n, i)) return !0;
            }
            return !1;
          })(o, n, l)
        );
      }
      isTileClipped() {
        return !0;
      }
    }
    function ih(t, e) {
      return e > 0 ? e + 2 * t : t;
    }
    const rh = ts(
        [
          { name: 'a_pos_offset', components: 4, type: 'Int16' },
          { name: 'a_data', components: 4, type: 'Uint16' },
          { name: 'a_pixeloffset', components: 4, type: 'Int16' },
        ],
        4
      ),
      nh = ts([{ name: 'a_projected_pos', components: 3, type: 'Float32' }], 4);
    ts([{ name: 'a_fade_opacity', components: 1, type: 'Uint32' }], 4);
    const ah = ts([
      { name: 'a_placed', components: 2, type: 'Uint8' },
      { name: 'a_shift', components: 2, type: 'Float32' },
      { name: 'a_box_real', components: 2, type: 'Int16' },
    ]);
    ts([
      { type: 'Int16', name: 'anchorPointX' },
      { type: 'Int16', name: 'anchorPointY' },
      { type: 'Int16', name: 'x1' },
      { type: 'Int16', name: 'y1' },
      { type: 'Int16', name: 'x2' },
      { type: 'Int16', name: 'y2' },
      { type: 'Uint32', name: 'featureIndex' },
      { type: 'Uint16', name: 'sourceLayerIndex' },
      { type: 'Uint16', name: 'bucketIndex' },
    ]);
    const sh = ts(
        [
          { name: 'a_pos', components: 2, type: 'Int16' },
          { name: 'a_anchor_pos', components: 2, type: 'Int16' },
          { name: 'a_extrude', components: 2, type: 'Int16' },
        ],
        4
      ),
      oh = ts(
        [
          { name: 'a_pos', components: 2, type: 'Float32' },
          { name: 'a_radius', components: 1, type: 'Float32' },
          { name: 'a_flags', components: 2, type: 'Int16' },
        ],
        4
      );
    function lh(t, e, i) {
      return (
        t.sections.forEach((t) => {
          t.text = (function (t, e, i) {
            const r = e.layout.get('text-transform').evaluate(i, {});
            return (
              'uppercase' === r
                ? (t = t.toLocaleUpperCase())
                : 'lowercase' === r && (t = t.toLocaleLowerCase()),
              Da.applyArabicShaping && (t = Da.applyArabicShaping(t)),
              t
            );
          })(t.text, e, i);
        }),
        t
      );
    }
    ts([{ name: 'triangle', components: 3, type: 'Uint16' }]),
      ts([
        { type: 'Int16', name: 'anchorX' },
        { type: 'Int16', name: 'anchorY' },
        { type: 'Uint16', name: 'glyphStartIndex' },
        { type: 'Uint16', name: 'numGlyphs' },
        { type: 'Uint32', name: 'vertexStartIndex' },
        { type: 'Uint32', name: 'lineStartIndex' },
        { type: 'Uint32', name: 'lineLength' },
        { type: 'Uint16', name: 'segment' },
        { type: 'Uint16', name: 'lowerSize' },
        { type: 'Uint16', name: 'upperSize' },
        { type: 'Float32', name: 'lineOffsetX' },
        { type: 'Float32', name: 'lineOffsetY' },
        { type: 'Uint8', name: 'writingMode' },
        { type: 'Uint8', name: 'placedOrientation' },
        { type: 'Uint8', name: 'hidden' },
        { type: 'Uint32', name: 'crossTileID' },
        { type: 'Int16', name: 'associatedIconIndex' },
      ]),
      ts([
        { type: 'Int16', name: 'anchorX' },
        { type: 'Int16', name: 'anchorY' },
        { type: 'Int16', name: 'rightJustifiedTextSymbolIndex' },
        { type: 'Int16', name: 'centerJustifiedTextSymbolIndex' },
        { type: 'Int16', name: 'leftJustifiedTextSymbolIndex' },
        { type: 'Int16', name: 'verticalPlacedTextSymbolIndex' },
        { type: 'Int16', name: 'placedIconSymbolIndex' },
        { type: 'Int16', name: 'verticalPlacedIconSymbolIndex' },
        { type: 'Uint16', name: 'key' },
        { type: 'Uint16', name: 'textBoxStartIndex' },
        { type: 'Uint16', name: 'textBoxEndIndex' },
        { type: 'Uint16', name: 'verticalTextBoxStartIndex' },
        { type: 'Uint16', name: 'verticalTextBoxEndIndex' },
        { type: 'Uint16', name: 'iconBoxStartIndex' },
        { type: 'Uint16', name: 'iconBoxEndIndex' },
        { type: 'Uint16', name: 'verticalIconBoxStartIndex' },
        { type: 'Uint16', name: 'verticalIconBoxEndIndex' },
        { type: 'Uint16', name: 'featureIndex' },
        { type: 'Uint16', name: 'numHorizontalGlyphVertices' },
        { type: 'Uint16', name: 'numVerticalGlyphVertices' },
        { type: 'Uint16', name: 'numIconVertices' },
        { type: 'Uint16', name: 'numVerticalIconVertices' },
        { type: 'Uint16', name: 'useRuntimeCollisionCircles' },
        { type: 'Uint32', name: 'crossTileID' },
        { type: 'Float32', name: 'textBoxScale' },
        { type: 'Float32', name: 'collisionCircleDiameter' },
        { type: 'Uint16', name: 'textAnchorOffsetStartIndex' },
        { type: 'Uint16', name: 'textAnchorOffsetEndIndex' },
      ]),
      ts([{ type: 'Float32', name: 'offsetX' }]),
      ts([
        { type: 'Int16', name: 'x' },
        { type: 'Int16', name: 'y' },
        { type: 'Int16', name: 'tileUnitDistanceFromAnchor' },
      ]),
      ts([
        { type: 'Uint16', name: 'textAnchor' },
        { type: 'Float32', components: 2, name: 'textOffset' },
      ]);
    const ch = {
      '!': '',
      '#': '',
      '$': '',
      '%': '',
      '&': '',
      '(': '',
      ')': '',
      '*': '',
      '+': '',
      ',': '',
      '-': '',
      '.': '',
      '/': '',
      ':': '',
      ';': '',
      '<': '',
      '=': '',
      '>': '',
      '?': '',
      '@': '',
      '[': '',
      '\\': '',
      ']': '',
      '^': '',
      '_': '',
      '`': '',
      '{': '',
      '|': '',
      '}': '',
      '~': '',
      '': '',
      '': '',
      '': '',
      '': '',
      '': '',
      '': '',
      '': '',
      '': '',
      '': '',
      '': '',
      '': '',
      '': '',
      '': '',
      '': '',
      '': '',
      '': '',
      '': '',
      '': '',
      '': '',
      '': '',
      '': '',
      '': '',
      '': '',
      '': '',
      '': '',
      '': '',
      '': '',
      '': '',
      '': '',
      '': '',
      '': '',
      '': '',
      '': '',
      '': '',
      '': '',
      '': '',
      '': '',
      '': '',
      '': '',
      '': '',
      '': '',
      '': '',
      '': '',
      '': '',
      '': '',
      '': '',
      '': '',
      '': '',
      '': '',
      '': '',
      '': '',
      '': '',
      '': '',
    };
    var hh = 24;
    const uh = 4294967296,
      dh = 1 / uh,
      ph = 'undefined' == typeof TextDecoder ? null : new TextDecoder('utf-8');
    class fh {
      constructor(t = new Uint8Array(16)) {
        (this.buf = ArrayBuffer.isView(t) ? t : new Uint8Array(t)),
          (this.dataView = new DataView(this.buf.buffer)),
          (this.pos = 0),
          (this.type = 0),
          (this.length = this.buf.length);
      }
      readFields(t, e, i = this.length) {
        for (; this.pos < i; ) {
          const i = this.readVarint(),
            r = i >> 3,
            n = this.pos;
          (this.type = 7 & i), t(r, e, this), this.pos === n && this.skip(i);
        }
        return e;
      }
      readMessage(t, e) {
        return this.readFields(t, e, this.readVarint() + this.pos);
      }
      readFixed32() {
        const t = this.dataView.getUint32(this.pos, !0);
        return (this.pos += 4), t;
      }
      readSFixed32() {
        const t = this.dataView.getInt32(this.pos, !0);
        return (this.pos += 4), t;
      }
      readFixed64() {
        const t =
          this.dataView.getUint32(this.pos, !0) +
          this.dataView.getUint32(this.pos + 4, !0) * uh;
        return (this.pos += 8), t;
      }
      readSFixed64() {
        const t =
          this.dataView.getUint32(this.pos, !0) +
          this.dataView.getInt32(this.pos + 4, !0) * uh;
        return (this.pos += 8), t;
      }
      readFloat() {
        const t = this.dataView.getFloat32(this.pos, !0);
        return (this.pos += 4), t;
      }
      readDouble() {
        const t = this.dataView.getFloat64(this.pos, !0);
        return (this.pos += 8), t;
      }
      readVarint(t) {
        const e = this.buf;
        let i, r;
        return (
          (r = e[this.pos++]),
          (i = 127 & r),
          r < 128
            ? i
            : ((r = e[this.pos++]),
              (i |= (127 & r) << 7),
              r < 128
                ? i
                : ((r = e[this.pos++]),
                  (i |= (127 & r) << 14),
                  r < 128
                    ? i
                    : ((r = e[this.pos++]),
                      (i |= (127 & r) << 21),
                      r < 128
                        ? i
                        : ((r = e[this.pos]),
                          (i |= (15 & r) << 28),
                          (function (t, e, i) {
                            const r = i.buf;
                            let n, a;
                            if (
                              ((a = r[i.pos++]), (n = (112 & a) >> 4), a < 128)
                            )
                              return mh(t, n, e);
                            if (
                              ((a = r[i.pos++]), (n |= (127 & a) << 3), a < 128)
                            )
                              return mh(t, n, e);
                            if (
                              ((a = r[i.pos++]),
                              (n |= (127 & a) << 10),
                              a < 128)
                            )
                              return mh(t, n, e);
                            if (
                              ((a = r[i.pos++]),
                              (n |= (127 & a) << 17),
                              a < 128)
                            )
                              return mh(t, n, e);
                            if (
                              ((a = r[i.pos++]),
                              (n |= (127 & a) << 24),
                              a < 128)
                            )
                              return mh(t, n, e);
                            if (
                              ((a = r[i.pos++]), (n |= (1 & a) << 31), a < 128)
                            )
                              return mh(t, n, e);
                            throw new Error(
                              'Expected varint not more than 10 bytes'
                            );
                          })(i, t, this)))))
        );
      }
      readVarint64() {
        return this.readVarint(!0);
      }
      readSVarint() {
        const t = this.readVarint();
        return t % 2 == 1 ? (t + 1) / -2 : t / 2;
      }
      readBoolean() {
        return Boolean(this.readVarint());
      }
      readString() {
        const t = this.readVarint() + this.pos,
          e = this.pos;
        return (
          (this.pos = t),
          t - e >= 12 && ph
            ? ph.decode(this.buf.subarray(e, t))
            : (function (t, e, i) {
                let r = '',
                  n = e;
                for (; n < i; ) {
                  const e = t[n];
                  let a,
                    s,
                    o,
                    l = null,
                    c = e > 239 ? 4 : e > 223 ? 3 : e > 191 ? 2 : 1;
                  if (n + c > i) break;
                  1 === c
                    ? e < 128 && (l = e)
                    : 2 === c
                    ? ((a = t[n + 1]),
                      128 == (192 & a) &&
                        ((l = ((31 & e) << 6) | (63 & a)),
                        l <= 127 && (l = null)))
                    : 3 === c
                    ? ((a = t[n + 1]),
                      (s = t[n + 2]),
                      128 == (192 & a) &&
                        128 == (192 & s) &&
                        ((l = ((15 & e) << 12) | ((63 & a) << 6) | (63 & s)),
                        (l <= 2047 || (l >= 55296 && l <= 57343)) &&
                          (l = null)))
                    : 4 === c &&
                      ((a = t[n + 1]),
                      (s = t[n + 2]),
                      (o = t[n + 3]),
                      128 == (192 & a) &&
                        128 == (192 & s) &&
                        128 == (192 & o) &&
                        ((l =
                          ((15 & e) << 18) |
                          ((63 & a) << 12) |
                          ((63 & s) << 6) |
                          (63 & o)),
                        (l <= 65535 || l >= 1114112) && (l = null))),
                    null === l
                      ? ((l = 65533), (c = 1))
                      : l > 65535 &&
                        ((l -= 65536),
                        (r += String.fromCharCode(((l >>> 10) & 1023) | 55296)),
                        (l = 56320 | (1023 & l))),
                    (r += String.fromCharCode(l)),
                    (n += c);
                }
                return r;
              })(this.buf, e, t)
        );
      }
      readBytes() {
        const t = this.readVarint() + this.pos,
          e = this.buf.subarray(this.pos, t);
        return (this.pos = t), e;
      }
      readPackedVarint(t = [], e) {
        const i = this.readPackedEnd();
        for (; this.pos < i; ) t.push(this.readVarint(e));
        return t;
      }
      readPackedSVarint(t = []) {
        const e = this.readPackedEnd();
        for (; this.pos < e; ) t.push(this.readSVarint());
        return t;
      }
      readPackedBoolean(t = []) {
        const e = this.readPackedEnd();
        for (; this.pos < e; ) t.push(this.readBoolean());
        return t;
      }
      readPackedFloat(t = []) {
        const e = this.readPackedEnd();
        for (; this.pos < e; ) t.push(this.readFloat());
        return t;
      }
      readPackedDouble(t = []) {
        const e = this.readPackedEnd();
        for (; this.pos < e; ) t.push(this.readDouble());
        return t;
      }
      readPackedFixed32(t = []) {
        const e = this.readPackedEnd();
        for (; this.pos < e; ) t.push(this.readFixed32());
        return t;
      }
      readPackedSFixed32(t = []) {
        const e = this.readPackedEnd();
        for (; this.pos < e; ) t.push(this.readSFixed32());
        return t;
      }
      readPackedFixed64(t = []) {
        const e = this.readPackedEnd();
        for (; this.pos < e; ) t.push(this.readFixed64());
        return t;
      }
      readPackedSFixed64(t = []) {
        const e = this.readPackedEnd();
        for (; this.pos < e; ) t.push(this.readSFixed64());
        return t;
      }
      readPackedEnd() {
        return 2 === this.type ? this.readVarint() + this.pos : this.pos + 1;
      }
      skip(t) {
        const e = 7 & t;
        if (0 === e) for (; this.buf[this.pos++] > 127; );
        else if (2 === e) this.pos = this.readVarint() + this.pos;
        else if (5 === e) this.pos += 4;
        else {
          if (1 !== e) throw new Error(`Unimplemented type: ${e}`);
          this.pos += 8;
        }
      }
      writeTag(t, e) {
        this.writeVarint((t << 3) | e);
      }
      realloc(t) {
        let e = this.length || 16;
        for (; e < this.pos + t; ) e *= 2;
        if (e !== this.length) {
          const t = new Uint8Array(e);
          t.set(this.buf),
            (this.buf = t),
            (this.dataView = new DataView(t.buffer)),
            (this.length = e);
        }
      }
      finish() {
        return (
          (this.length = this.pos),
          (this.pos = 0),
          this.buf.subarray(0, this.length)
        );
      }
      writeFixed32(t) {
        this.realloc(4),
          this.dataView.setInt32(this.pos, t, !0),
          (this.pos += 4);
      }
      writeSFixed32(t) {
        this.realloc(4),
          this.dataView.setInt32(this.pos, t, !0),
          (this.pos += 4);
      }
      writeFixed64(t) {
        this.realloc(8),
          this.dataView.setInt32(this.pos, -1 & t, !0),
          this.dataView.setInt32(this.pos + 4, Math.floor(t * dh), !0),
          (this.pos += 8);
      }
      writeSFixed64(t) {
        this.realloc(8),
          this.dataView.setInt32(this.pos, -1 & t, !0),
          this.dataView.setInt32(this.pos + 4, Math.floor(t * dh), !0),
          (this.pos += 8);
      }
      writeVarint(t) {
        (t = +t || 0) > 268435455 || t < 0
          ? (function (t, e) {
              let i, r;
              if (
                (t >= 0
                  ? ((i = t % 4294967296 | 0), (r = (t / 4294967296) | 0))
                  : ((i = ~(-t % 4294967296)),
                    (r = ~(-t / 4294967296)),
                    4294967295 ^ i
                      ? (i = (i + 1) | 0)
                      : ((i = 0), (r = (r + 1) | 0))),
                t >= 0x10000000000000000 || t < -0x10000000000000000)
              )
                throw new Error("Given varint doesn't fit into 10 bytes");
              e.realloc(10),
                (function (t, e, i) {
                  (i.buf[i.pos++] = (127 & t) | 128),
                    (t >>>= 7),
                    (i.buf[i.pos++] = (127 & t) | 128),
                    (t >>>= 7),
                    (i.buf[i.pos++] = (127 & t) | 128),
                    (t >>>= 7),
                    (i.buf[i.pos++] = (127 & t) | 128),
                    (i.buf[i.pos] = 127 & (t >>>= 7));
                })(i, 0, e),
                (function (t, e) {
                  const i = (7 & t) << 4;
                  (e.buf[e.pos++] |= i | ((t >>>= 3) ? 128 : 0)),
                    t &&
                      ((e.buf[e.pos++] = (127 & t) | ((t >>>= 7) ? 128 : 0)),
                      t &&
                        ((e.buf[e.pos++] = (127 & t) | ((t >>>= 7) ? 128 : 0)),
                        t &&
                          ((e.buf[e.pos++] =
                            (127 & t) | ((t >>>= 7) ? 128 : 0)),
                          t &&
                            ((e.buf[e.pos++] =
                              (127 & t) | ((t >>>= 7) ? 128 : 0)),
                            t && (e.buf[e.pos++] = 127 & t)))));
                })(r, e);
            })(t, this)
          : (this.realloc(4),
            (this.buf[this.pos++] = (127 & t) | (t > 127 ? 128 : 0)),
            t <= 127 ||
              ((this.buf[this.pos++] =
                (127 & (t >>>= 7)) | (t > 127 ? 128 : 0)),
              t <= 127 ||
                ((this.buf[this.pos++] =
                  (127 & (t >>>= 7)) | (t > 127 ? 128 : 0)),
                t <= 127 || (this.buf[this.pos++] = (t >>> 7) & 127))));
      }
      writeSVarint(t) {
        this.writeVarint(t < 0 ? 2 * -t - 1 : 2 * t);
      }
      writeBoolean(t) {
        this.writeVarint(+t);
      }
      writeString(t) {
        (t = String(t)), this.realloc(4 * t.length), this.pos++;
        const e = this.pos;
        this.pos = (function (t, e, i) {
          for (let r, n, a = 0; a < e.length; a++) {
            if (((r = e.charCodeAt(a)), r > 55295 && r < 57344)) {
              if (!n) {
                r > 56319 || a + 1 === e.length
                  ? ((t[i++] = 239), (t[i++] = 191), (t[i++] = 189))
                  : (n = r);
                continue;
              }
              if (r < 56320) {
                (t[i++] = 239), (t[i++] = 191), (t[i++] = 189), (n = r);
                continue;
              }
              (r = ((n - 55296) << 10) | (r - 56320) | 65536), (n = null);
            } else
              n && ((t[i++] = 239), (t[i++] = 191), (t[i++] = 189), (n = null));
            r < 128
              ? (t[i++] = r)
              : (r < 2048
                  ? (t[i++] = (r >> 6) | 192)
                  : (r < 65536
                      ? (t[i++] = (r >> 12) | 224)
                      : ((t[i++] = (r >> 18) | 240),
                        (t[i++] = ((r >> 12) & 63) | 128)),
                    (t[i++] = ((r >> 6) & 63) | 128)),
                (t[i++] = (63 & r) | 128));
          }
          return i;
        })(this.buf, t, this.pos);
        const i = this.pos - e;
        i >= 128 && gh(e, i, this),
          (this.pos = e - 1),
          this.writeVarint(i),
          (this.pos += i);
      }
      writeFloat(t) {
        this.realloc(4),
          this.dataView.setFloat32(this.pos, t, !0),
          (this.pos += 4);
      }
      writeDouble(t) {
        this.realloc(8),
          this.dataView.setFloat64(this.pos, t, !0),
          (this.pos += 8);
      }
      writeBytes(t) {
        const e = t.length;
        this.writeVarint(e), this.realloc(e);
        for (let i = 0; i < e; i++) this.buf[this.pos++] = t[i];
      }
      writeRawMessage(t, e) {
        this.pos++;
        const i = this.pos;
        t(e, this);
        const r = this.pos - i;
        r >= 128 && gh(i, r, this),
          (this.pos = i - 1),
          this.writeVarint(r),
          (this.pos += r);
      }
      writeMessage(t, e, i) {
        this.writeTag(t, 2), this.writeRawMessage(e, i);
      }
      writePackedVarint(t, e) {
        e.length && this.writeMessage(t, _h, e);
      }
      writePackedSVarint(t, e) {
        e.length && this.writeMessage(t, yh, e);
      }
      writePackedBoolean(t, e) {
        e.length && this.writeMessage(t, bh, e);
      }
      writePackedFloat(t, e) {
        e.length && this.writeMessage(t, vh, e);
      }
      writePackedDouble(t, e) {
        e.length && this.writeMessage(t, xh, e);
      }
      writePackedFixed32(t, e) {
        e.length && this.writeMessage(t, wh, e);
      }
      writePackedSFixed32(t, e) {
        e.length && this.writeMessage(t, Th, e);
      }
      writePackedFixed64(t, e) {
        e.length && this.writeMessage(t, Ph, e);
      }
      writePackedSFixed64(t, e) {
        e.length && this.writeMessage(t, Ch, e);
      }
      writeBytesField(t, e) {
        this.writeTag(t, 2), this.writeBytes(e);
      }
      writeFixed32Field(t, e) {
        this.writeTag(t, 5), this.writeFixed32(e);
      }
      writeSFixed32Field(t, e) {
        this.writeTag(t, 5), this.writeSFixed32(e);
      }
      writeFixed64Field(t, e) {
        this.writeTag(t, 1), this.writeFixed64(e);
      }
      writeSFixed64Field(t, e) {
        this.writeTag(t, 1), this.writeSFixed64(e);
      }
      writeVarintField(t, e) {
        this.writeTag(t, 0), this.writeVarint(e);
      }
      writeSVarintField(t, e) {
        this.writeTag(t, 0), this.writeSVarint(e);
      }
      writeStringField(t, e) {
        this.writeTag(t, 2), this.writeString(e);
      }
      writeFloatField(t, e) {
        this.writeTag(t, 5), this.writeFloat(e);
      }
      writeDoubleField(t, e) {
        this.writeTag(t, 1), this.writeDouble(e);
      }
      writeBooleanField(t, e) {
        this.writeVarintField(t, +e);
      }
    }
    function mh(t, e, i) {
      return i
        ? 4294967296 * e + (t >>> 0)
        : 4294967296 * (e >>> 0) + (t >>> 0);
    }
    function gh(t, e, i) {
      const r =
        e <= 16383
          ? 1
          : e <= 2097151
          ? 2
          : e <= 268435455
          ? 3
          : Math.floor(Math.log(e) / (7 * Math.LN2));
      i.realloc(r);
      for (let n = i.pos - 1; n >= t; n--) i.buf[n + r] = i.buf[n];
    }
    function _h(t, e) {
      for (let i = 0; i < t.length; i++) e.writeVarint(t[i]);
    }
    function yh(t, e) {
      for (let i = 0; i < t.length; i++) e.writeSVarint(t[i]);
    }
    function vh(t, e) {
      for (let i = 0; i < t.length; i++) e.writeFloat(t[i]);
    }
    function xh(t, e) {
      for (let i = 0; i < t.length; i++) e.writeDouble(t[i]);
    }
    function bh(t, e) {
      for (let i = 0; i < t.length; i++) e.writeBoolean(t[i]);
    }
    function wh(t, e) {
      for (let i = 0; i < t.length; i++) e.writeFixed32(t[i]);
    }
    function Th(t, e) {
      for (let i = 0; i < t.length; i++) e.writeSFixed32(t[i]);
    }
    function Ph(t, e) {
      for (let i = 0; i < t.length; i++) e.writeFixed64(t[i]);
    }
    function Ch(t, e) {
      for (let i = 0; i < t.length; i++) e.writeSFixed64(t[i]);
    }
    function Ih(t, e, i) {
      1 === t && i.readMessage(Sh, e);
    }
    function Sh(t, e, i) {
      if (3 === t) {
        const {
          id: t,
          bitmap: r,
          width: n,
          height: a,
          left: s,
          top: o,
          advance: l,
        } = i.readMessage(Mh, {});
        e.push({
          id: t,
          bitmap: new yl({ width: n + 6, height: a + 6 }, r),
          metrics: { width: n, height: a, left: s, top: o, advance: l },
        });
      }
    }
    function Mh(t, e, i) {
      1 === t
        ? (e.id = i.readVarint())
        : 2 === t
        ? (e.bitmap = i.readBytes())
        : 3 === t
        ? (e.width = i.readVarint())
        : 4 === t
        ? (e.height = i.readVarint())
        : 5 === t
        ? (e.left = i.readSVarint())
        : 6 === t
        ? (e.top = i.readSVarint())
        : 7 === t && (e.advance = i.readVarint());
    }
    function Dh(t) {
      let e = 0,
        i = 0;
      for (const s of t) (e += s.w * s.h), (i = Math.max(i, s.w));
      t.sort((t, e) => e.h - t.h);
      const r = [
        {
          x: 0,
          y: 0,
          w: Math.max(Math.ceil(Math.sqrt(e / 0.95)), i),
          h: 1 / 0,
        },
      ];
      let n = 0,
        a = 0;
      for (const s of t)
        for (let t = r.length - 1; t >= 0; t--) {
          const e = r[t];
          if (!(s.w > e.w || s.h > e.h)) {
            if (
              ((s.x = e.x),
              (s.y = e.y),
              (a = Math.max(a, s.y + s.h)),
              (n = Math.max(n, s.x + s.w)),
              s.w === e.w && s.h === e.h)
            ) {
              const e = r.pop();
              e && t < r.length && (r[t] = e);
            } else
              s.h === e.h
                ? ((e.x += s.w), (e.w -= s.w))
                : s.w === e.w
                ? ((e.y += s.h), (e.h -= s.h))
                : (r.push({ x: e.x + s.w, y: e.y, w: e.w - s.w, h: s.h }),
                  (e.y += s.h),
                  (e.h -= s.h));
            break;
          }
        }
      return { w: n, h: a, fill: e / (n * a) || 0 };
    }
    class Lh {
      constructor(
        t,
        {
          pixelRatio: e,
          version: i,
          stretchX: r,
          stretchY: n,
          content: a,
          textFitWidth: s,
          textFitHeight: o,
        }
      ) {
        (this.paddedRect = t),
          (this.pixelRatio = e),
          (this.stretchX = r),
          (this.stretchY = n),
          (this.content = a),
          (this.version = i),
          (this.textFitWidth = s),
          (this.textFitHeight = o);
      }
      get tl() {
        return [this.paddedRect.x + 1, this.paddedRect.y + 1];
      }
      get br() {
        return [
          this.paddedRect.x + this.paddedRect.w - 1,
          this.paddedRect.y + this.paddedRect.h - 1,
        ];
      }
      get tlbr() {
        return this.tl.concat(this.br);
      }
      get displaySize() {
        return [
          (this.paddedRect.w - 2) / this.pixelRatio,
          (this.paddedRect.h - 2) / this.pixelRatio,
        ];
      }
    }
    class Ah {
      constructor(t, e) {
        const i = {},
          r = {};
        this.haveRenderCallbacks = [];
        const n = [];
        this.addImages(t, i, n), this.addImages(e, r, n);
        const { w: a, h: s } = Dh(n),
          o = new vl({ width: a || 1, height: s || 1 });
        for (const l in t) {
          const e = t[l],
            r = i[l].paddedRect;
          vl.copy(
            e.data,
            o,
            { x: 0, y: 0 },
            { x: r.x + 1, y: r.y + 1 },
            e.data
          );
        }
        for (const l in e) {
          const t = e[l],
            i = r[l].paddedRect,
            n = i.x + 1,
            a = i.y + 1,
            s = t.data.width,
            c = t.data.height;
          vl.copy(t.data, o, { x: 0, y: 0 }, { x: n, y: a }, t.data),
            vl.copy(
              t.data,
              o,
              { x: 0, y: c - 1 },
              { x: n, y: a - 1 },
              { width: s, height: 1 }
            ),
            vl.copy(
              t.data,
              o,
              { x: 0, y: 0 },
              { x: n, y: a + c },
              { width: s, height: 1 }
            ),
            vl.copy(
              t.data,
              o,
              { x: s - 1, y: 0 },
              { x: n - 1, y: a },
              { width: 1, height: c }
            ),
            vl.copy(
              t.data,
              o,
              { x: 0, y: 0 },
              { x: n + s, y: a },
              { width: 1, height: c }
            );
        }
        (this.image = o), (this.iconPositions = i), (this.patternPositions = r);
      }
      addImages(t, e, i) {
        for (const r in t) {
          const n = t[r],
            a = { x: 0, y: 0, w: n.data.width + 2, h: n.data.height + 2 };
          i.push(a),
            (e[r] = new Lh(a, n)),
            n.hasRenderCallback && this.haveRenderCallbacks.push(r);
        }
      }
      patchUpdatedImages(t, e) {
        t.dispatchRenderCallbacks(this.haveRenderCallbacks);
        for (const i in t.updatedImages)
          this.patchUpdatedImage(this.iconPositions[i], t.getImage(i), e),
            this.patchUpdatedImage(this.patternPositions[i], t.getImage(i), e);
      }
      patchUpdatedImage(t, e, i) {
        if (!t || !e) return;
        if (t.version === e.version) return;
        t.version = e.version;
        const [r, n] = t.tl;
        i.update(e.data, void 0, { x: r, y: n });
      }
    }
    var Eh;
    ca('ImagePosition', Lh),
      ca('ImageAtlas', Ah),
      (t.as = void 0),
      ((Eh = t.as || (t.as = {}))[(Eh.none = 0)] = 'none'),
      (Eh[(Eh.horizontal = 1)] = 'horizontal'),
      (Eh[(Eh.vertical = 2)] = 'vertical'),
      (Eh[(Eh.horizontalOnly = 3)] = 'horizontalOnly');
    class Rh {
      constructor() {
        (this.scale = 1),
          (this.fontStack = ''),
          (this.imageName = null),
          (this.verticalAlign = 'bottom');
      }
      static forText(t, e, i) {
        const r = new Rh();
        return (
          (r.scale = t || 1),
          (r.fontStack = e),
          (r.verticalAlign = i || 'bottom'),
          r
        );
      }
      static forImage(t, e) {
        const i = new Rh();
        return (i.imageName = t), (i.verticalAlign = e || 'bottom'), i;
      }
    }
    class zh {
      constructor() {
        (this.text = ''),
          (this.sectionIndex = []),
          (this.sections = []),
          (this.imageSectionID = null);
      }
      static fromFeature(t, e) {
        const i = new zh();
        for (let r = 0; r < t.sections.length; r++) {
          const n = t.sections[r];
          n.image ? i.addImageSection(n) : i.addTextSection(n, e);
        }
        return i;
      }
      length() {
        return this.text.length;
      }
      getSection(t) {
        return this.sections[this.sectionIndex[t]];
      }
      getSectionIndex(t) {
        return this.sectionIndex[t];
      }
      getCharCode(t) {
        return this.text.charCodeAt(t);
      }
      verticalizePunctuation() {
        this.text = (function (t) {
          let e = '';
          for (let i = 0; i < t.length; i++) {
            const r = t.charCodeAt(i + 1) || null,
              n = t.charCodeAt(i - 1) || null;
            e +=
              (r && Pa(r) && !ch[t[i + 1]]) ||
              (n && Pa(n) && !ch[t[i - 1]]) ||
              !ch[t[i]]
                ? t[i]
                : ch[t[i]];
          }
          return e;
        })(this.text);
      }
      trim() {
        let t = 0;
        for (
          let i = 0;
          i < this.text.length && Oh[this.text.charCodeAt(i)];
          i++
        )
          t++;
        let e = this.text.length;
        for (
          let i = this.text.length - 1;
          i >= 0 && i >= t && Oh[this.text.charCodeAt(i)];
          i--
        )
          e--;
        (this.text = this.text.substring(t, e)),
          (this.sectionIndex = this.sectionIndex.slice(t, e));
      }
      substring(t, e) {
        const i = new zh();
        return (
          (i.text = this.text.substring(t, e)),
          (i.sectionIndex = this.sectionIndex.slice(t, e)),
          (i.sections = this.sections),
          i
        );
      }
      toString() {
        return this.text;
      }
      getMaxScale() {
        return this.sectionIndex.reduce(
          (t, e) => Math.max(t, this.sections[e].scale),
          0
        );
      }
      getMaxImageSize(t) {
        let e = 0,
          i = 0;
        for (let r = 0; r < this.length(); r++) {
          const n = this.getSection(r);
          if (n.imageName) {
            const r = t[n.imageName];
            if (!r) continue;
            const a = r.displaySize;
            (e = Math.max(e, a[0])), (i = Math.max(i, a[1]));
          }
        }
        return { maxImageWidth: e, maxImageHeight: i };
      }
      addTextSection(t, e) {
        (this.text += t.text),
          this.sections.push(
            Rh.forText(t.scale, t.fontStack || e, t.verticalAlign)
          );
        const i = this.sections.length - 1;
        for (let r = 0; r < t.text.length; ++r) this.sectionIndex.push(i);
      }
      addImageSection(t) {
        const e = t.image ? t.image.name : '';
        if (0 === e.length)
          return void Z("Can't add FormattedSection with an empty image.");
        const i = this.getNextImageSectionCharCode();
        i
          ? ((this.text += String.fromCharCode(i)),
            this.sections.push(Rh.forImage(e, t.verticalAlign)),
            this.sectionIndex.push(this.sections.length - 1))
          : Z('Reached maximum number of images 6401');
      }
      getNextImageSectionCharCode() {
        return this.imageSectionID
          ? this.imageSectionID >= 63743
            ? null
            : ++this.imageSectionID
          : ((this.imageSectionID = 57344), this.imageSectionID);
      }
    }
    function kh(e, i, r, n, a, s, o, l, c, h, u, d, p, f, m) {
      const g = zh.fromFeature(e, a);
      let _;
      d === t.as.vertical && g.verticalizePunctuation();
      const { processBidirectionalText: y, processStyledBidirectionalText: v } =
        Da;
      if (y && 1 === g.sections.length) {
        _ = [];
        const t = y(g.toString(), Zh(g, h, s, i, n, f));
        for (const e of t) {
          const t = new zh();
          (t.text = e), (t.sections = g.sections);
          for (let i = 0; i < e.length; i++) t.sectionIndex.push(0);
          _.push(t);
        }
      } else if (v) {
        _ = [];
        const t = v(g.text, g.sectionIndex, Zh(g, h, s, i, n, f));
        for (const e of t) {
          const t = new zh();
          (t.text = e[0]),
            (t.sectionIndex = e[1]),
            (t.sections = g.sections),
            _.push(t);
        }
      } else
        _ = (function (t, e) {
          const i = [],
            r = t.text;
          let n = 0;
          for (const a of e) i.push(t.substring(n, a)), (n = a);
          return n < r.length && i.push(t.substring(n, r.length)), i;
        })(g, Zh(g, h, s, i, n, f));
      const x = [],
        b = {
          positionedLines: x,
          text: g.toString(),
          top: u[1],
          bottom: u[1],
          left: u[0],
          right: u[0],
          writingMode: d,
          iconsInText: !1,
          verticalizable: !1,
        };
      return (
        (function (t, e, i, r, n, a, s, o, l, c, h, u) {
          let d = 0,
            p = 0,
            f = 0,
            m = 0;
          const g = 'right' === o ? 1 : 'left' === o ? 0 : 0.5,
            _ = hh / u;
          let y = 0;
          for (const b of n) {
            b.trim();
            const n = b.getMaxScale(),
              s = { positionedGlyphs: [], lineOffset: 0 };
            t.positionedLines[y] = s;
            const o = s.positionedGlyphs;
            let u = 0;
            if (!b.length()) {
              (p += a), ++y;
              continue;
            }
            const v = qh(r, b, _);
            for (let a = 0; a < b.length(); a++) {
              const s = b.getSection(a),
                f = b.getSectionIndex(a),
                m = b.getCharCode(a),
                g = Wh(l, h, m);
              let y;
              if (s.imageName) {
                if (
                  ((t.iconsInText = !0),
                  (s.scale = s.scale * _),
                  (y = Yh(s, g, n, v, r)),
                  !y)
                )
                  continue;
                u = Math.max(u, y.imageOffset);
              } else if (((y = Xh(s, m, g, v, e, i)), !y)) continue;
              const { rect: x, metrics: w, baselineOffset: T } = y;
              o.push({
                glyph: m,
                imageName: s.imageName,
                x: d,
                y: p + T + -17,
                vertical: g,
                scale: s.scale,
                fontStack: s.fontStack,
                sectionIndex: f,
                metrics: w,
                rect: x,
              }),
                g
                  ? ((t.verticalizable = !0),
                    (d += (s.imageName ? w.advance : hh) * s.scale + c))
                  : (d += w.advance * s.scale + c);
            }
            0 !== o.length &&
              ((f = Math.max(d - c, f)), Kh(o, 0, o.length - 1, g)),
              (d = 0),
              (s.lineOffset = Math.max(u, (n - 1) * hh));
            const x = a * n + u;
            (p += x), (m = Math.max(x, m)), ++y;
          }
          const { horizontalAlign: v, verticalAlign: x } = $h(s);
          (function (t, e, i, r, n, a, s, o, l) {
            const c = (e - i) * n;
            let h = 0;
            h = a !== s ? -o * r - -17 : -r * l * s + 0.5 * s;
            for (const u of t)
              for (const t of u.positionedGlyphs) (t.x += c), (t.y += h);
          })(t.positionedLines, g, v, x, f, m, a, p, n.length),
            (t.top += -x * p),
            (t.bottom = t.top + p),
            (t.left += -v * f),
            (t.right = t.left + f);
        })(b, i, r, n, _, o, l, c, d, h, p, m),
        !(function (t) {
          for (const e of t) if (0 !== e.positionedGlyphs.length) return !1;
          return !0;
        })(x) && b
      );
    }
    const Oh = { 9: !0, 10: !0, 11: !0, 12: !0, 13: !0, 32: !0 },
      Fh = {
        10: !0,
        32: !0,
        38: !0,
        41: !0,
        43: !0,
        45: !0,
        47: !0,
        173: !0,
        183: !0,
        8203: !0,
        8208: !0,
        8211: !0,
        8231: !0,
      },
      Bh = { 40: !0 };
    function Nh(t, e, i, r, n, a) {
      if (e.imageName) {
        const t = r[e.imageName];
        return t ? (t.displaySize[0] * e.scale * hh) / a + n : 0;
      }
      {
        const r = i[e.fontStack],
          a = r && r[t];
        return a ? a.metrics.advance * e.scale + n : 0;
      }
    }
    function Vh(t, e, i, r) {
      const n = Math.pow(t - e, 2);
      return r ? (t < e ? n / 2 : 2 * n) : n + Math.abs(i) * i;
    }
    function jh(t, e, i) {
      let r = 0;
      return (
        10 === t && (r -= 1e4),
        i && (r += 150),
        (40 !== t && 65288 !== t) || (r += 50),
        (41 !== e && 65289 !== e) || (r += 50),
        r
      );
    }
    function Uh(t, e, i, r, n, a) {
      let s = null,
        o = Vh(e, i, n, a);
      for (const l of r) {
        const t = Vh(e - l.x, i, n, a) + l.badness;
        t <= o && ((s = l), (o = t));
      }
      return { index: t, x: e, priorBreak: s, badness: o };
    }
    function Gh(t) {
      return t ? Gh(t.priorBreak).concat(t.index) : [];
    }
    function Zh(t, e, i, r, n, a) {
      if (!t) return [];
      const s = [],
        o = (function (t, e, i, r, n, a) {
          let s = 0;
          for (let o = 0; o < t.length(); o++) {
            const i = t.getSection(o);
            s += Nh(t.getCharCode(o), i, r, n, e, a);
          }
          return s / Math.max(1, Math.ceil(s / i));
        })(t, e, i, r, n, a),
        l = t.text.indexOf('') >= 0;
      let c = 0;
      for (let u = 0; u < t.length(); u++) {
        const i = t.getSection(u),
          d = t.getCharCode(u);
        if ((Oh[d] || (c += Nh(d, i, r, n, e, a)), u < t.length() - 1)) {
          const e =
            !((h = d) < 11904) &&
            (!!ga['CJK Compatibility Forms'](h) ||
              !!ga['CJK Compatibility'](h) ||
              !!ga['CJK Strokes'](h) ||
              !!ga['CJK Symbols and Punctuation'](h) ||
              !!ga['Enclosed CJK Letters and Months'](h) ||
              !!ga['Halfwidth and Fullwidth Forms'](h) ||
              !!ga['Ideographic Description Characters'](h) ||
              !!ga['Vertical Forms'](h) ||
              wa.test(String.fromCodePoint(h)));
          (Fh[d] ||
            e ||
            i.imageName ||
            (u !== t.length() - 2 && Bh[t.getCharCode(u + 1)])) &&
            s.push(Uh(u + 1, c, o, s, jh(d, t.getCharCode(u + 1), e && l), !1));
        }
      }
      var h;
      return Gh(Uh(t.length(), c, o, s, 0, !0));
    }
    function $h(t) {
      let e = 0.5,
        i = 0.5;
      switch (t) {
        case 'right':
        case 'top-right':
        case 'bottom-right':
          e = 1;
          break;
        case 'left':
        case 'top-left':
        case 'bottom-left':
          e = 0;
      }
      switch (t) {
        case 'bottom':
        case 'bottom-right':
        case 'bottom-left':
          i = 1;
          break;
        case 'top':
        case 'top-right':
        case 'top-left':
          i = 0;
      }
      return { horizontalAlign: e, verticalAlign: i };
    }
    function qh(t, e, i) {
      const r = e.getMaxScale() * hh,
        { maxImageWidth: n, maxImageHeight: a } = e.getMaxImageSize(t),
        s = Math.max(r, a * i);
      return {
        verticalLineContentWidth: Math.max(r, n * i),
        horizontalLineContentHeight: s,
      };
    }
    function Hh(t) {
      switch (t) {
        case 'top':
          return 0;
        case 'center':
          return 0.5;
        default:
          return 1;
      }
    }
    function Wh(e, i, r) {
      return !(
        e === t.as.horizontal ||
        (!i && !Ta(r)) ||
        (i &&
          (Oh[r] || ((n = r), /\p{sc=Arab}/u.test(String.fromCodePoint(n)))))
      );
      var n;
    }
    function Xh(t, e, i, r, n, a) {
      const s = a[t.fontStack],
        o = (function (t, e, i, r) {
          if (t && t.rect) return t;
          const n = e[i.fontStack],
            a = n && n[r];
          return a ? { rect: null, metrics: a.metrics } : null;
        })(s && s[e], n, t, e);
      if (null === o) return null;
      let l;
      if (i) l = r.verticalLineContentWidth - t.scale * hh;
      else {
        const e = Hh(t.verticalAlign);
        l = (r.horizontalLineContentHeight - t.scale * hh) * e;
      }
      return { rect: o.rect, metrics: o.metrics, baselineOffset: l };
    }
    function Yh(t, e, i, r, n) {
      const a = n[t.imageName];
      if (!a) return null;
      const s = a.paddedRect,
        o = a.displaySize,
        l = {
          width: o[0],
          height: o[1],
          left: 1,
          top: -3,
          advance: e ? o[1] : o[0],
        };
      let c;
      if (e) c = r.verticalLineContentWidth - o[1] * t.scale;
      else {
        const e = Hh(t.verticalAlign);
        c = (r.horizontalLineContentHeight - o[1] * t.scale) * e;
      }
      return {
        rect: s,
        metrics: l,
        baselineOffset: c,
        imageOffset: (e ? o[0] : o[1]) * t.scale - hh * i,
      };
    }
    function Kh(t, e, i, r) {
      if (0 === r) return;
      const n = t[i],
        a = (t[i].x + n.metrics.advance * n.scale) * r;
      for (let s = e; s <= i; s++) t[s].x -= a;
    }
    function Jh(t, e, i) {
      const { horizontalAlign: r, verticalAlign: n } = $h(i),
        a = e[0] - t.displaySize[0] * r,
        s = e[1] - t.displaySize[1] * n;
      return {
        image: t,
        top: s,
        bottom: s + t.displaySize[1],
        left: a,
        right: a + t.displaySize[0],
      };
    }
    function Qh(t) {
      var e, i;
      let r = t.left,
        n = t.top,
        a = t.right - r,
        s = t.bottom - n;
      const o =
          null !== (e = t.image.textFitWidth) && void 0 !== e
            ? e
            : 'stretchOrShrink',
        l =
          null !== (i = t.image.textFitHeight) && void 0 !== i
            ? i
            : 'stretchOrShrink',
        c =
          (t.image.content[2] - t.image.content[0]) /
          (t.image.content[3] - t.image.content[1]);
      if ('proportional' === l) {
        if (('stretchOnly' === o && a / s < c) || 'proportional' === o) {
          const t = Math.ceil(s * c);
          (r *= t / a), (a = t);
        }
      } else if (
        'proportional' === o &&
        'stretchOnly' === l &&
        0 !== c &&
        a / s > c
      ) {
        const t = Math.ceil(a / c);
        (n *= t / s), (s = t);
      }
      return { x1: r, y1: n, x2: r + a, y2: n + s };
    }
    function tu(t, e, i, r, n, a) {
      const s = t.image;
      let o;
      if (s.content) {
        const t = s.content,
          e = s.pixelRatio || 1;
        o = [
          t[0] / e,
          t[1] / e,
          s.displaySize[0] - t[2] / e,
          s.displaySize[1] - t[3] / e,
        ];
      }
      const l = e.left * a,
        c = e.right * a;
      let h, u, d, p;
      'width' === i || 'both' === i
        ? ((p = n[0] + l - r[3]), (u = n[0] + c + r[1]))
        : ((p = n[0] + (l + c - s.displaySize[0]) / 2),
          (u = p + s.displaySize[0]));
      const f = e.top * a,
        m = e.bottom * a;
      return (
        'height' === i || 'both' === i
          ? ((h = n[1] + f - r[0]), (d = n[1] + m + r[2]))
          : ((h = n[1] + (f + m - s.displaySize[1]) / 2),
            (d = h + s.displaySize[1])),
        { image: s, top: h, right: u, bottom: d, left: p, collisionPadding: o }
      );
    }
    const eu = 128,
      iu = 32640;
    function ru(t, e) {
      const { expression: i } = e;
      if ('constant' === i.kind)
        return { kind: 'constant', layoutSize: i.evaluate(new La(t + 1)) };
      if ('source' === i.kind) return { kind: 'source' };
      {
        const { zoomStops: e, interpolationType: r } = i;
        let n = 0;
        for (; n < e.length && e[n] <= t; ) n++;
        n = Math.max(0, n - 1);
        let a = n;
        for (; a < e.length && e[a] < t + 1; ) a++;
        a = Math.min(e.length - 1, a);
        const s = e[n],
          o = e[a];
        return 'composite' === i.kind
          ? { kind: 'composite', minZoom: s, maxZoom: o, interpolationType: r }
          : {
              kind: 'camera',
              minZoom: s,
              maxZoom: o,
              minSize: i.evaluate(new La(s)),
              maxSize: i.evaluate(new La(o)),
              interpolationType: r,
            };
      }
    }
    function nu(t, e, i) {
      let r = 'never';
      const n = t.get(e);
      return n ? (r = n) : t.get(i) && (r = 'always'), r;
    }
    const au = [
      { name: 'a_fade_opacity', components: 1, type: 'Uint8', offset: 0 },
    ];
    function su(t, e, i, r, n, a, s, o, l, c, h, u, d) {
      const p = o ? Math.min(iu, Math.round(o[0])) : 0,
        f = o ? Math.min(iu, Math.round(o[1])) : 0;
      t.emplaceBack(
        e,
        i,
        Math.round(32 * r),
        Math.round(32 * n),
        a,
        s,
        (p << 1) + (l ? 1 : 0),
        f,
        16 * c,
        16 * h,
        256 * u,
        256 * d
      );
    }
    function ou(t, e, i) {
      t.emplaceBack(e.x, e.y, i),
        t.emplaceBack(e.x, e.y, i),
        t.emplaceBack(e.x, e.y, i),
        t.emplaceBack(e.x, e.y, i);
    }
    function lu(t) {
      for (const e of t.sections) if (Ma(e.text)) return !0;
      return !1;
    }
    class cu {
      constructor(t) {
        (this.layoutVertexArray = new qs()),
          (this.indexArray = new Ks()),
          (this.programConfigurations = t),
          (this.segments = new eo()),
          (this.dynamicLayoutVertexArray = new Hs()),
          (this.opacityVertexArray = new Ws()),
          (this.hasVisibleVertices = !1),
          (this.placedSymbolArray = new Ds());
      }
      isEmpty() {
        return (
          0 === this.layoutVertexArray.length &&
          0 === this.indexArray.length &&
          0 === this.dynamicLayoutVertexArray.length &&
          0 === this.opacityVertexArray.length
        );
      }
      upload(t, e, i, r) {
        this.isEmpty() ||
          (i &&
            ((this.layoutVertexBuffer = t.createVertexBuffer(
              this.layoutVertexArray,
              rh.members
            )),
            (this.indexBuffer = t.createIndexBuffer(this.indexArray, e)),
            (this.dynamicLayoutVertexBuffer = t.createVertexBuffer(
              this.dynamicLayoutVertexArray,
              nh.members,
              !0
            )),
            (this.opacityVertexBuffer = t.createVertexBuffer(
              this.opacityVertexArray,
              au,
              !0
            )),
            (this.opacityVertexBuffer.itemSize = 1)),
          (i || r) && this.programConfigurations.upload(t));
      }
      destroy() {
        this.layoutVertexBuffer &&
          (this.layoutVertexBuffer.destroy(),
          this.indexBuffer.destroy(),
          this.programConfigurations.destroy(),
          this.segments.destroy(),
          this.dynamicLayoutVertexBuffer.destroy(),
          this.opacityVertexBuffer.destroy());
      }
    }
    ca('SymbolBuffers', cu);
    class hu {
      constructor(t, e, i) {
        (this.layoutVertexArray = new t()),
          (this.layoutAttributes = e),
          (this.indexArray = new i()),
          (this.segments = new eo()),
          (this.collisionVertexArray = new Ys());
      }
      upload(t) {
        (this.layoutVertexBuffer = t.createVertexBuffer(
          this.layoutVertexArray,
          this.layoutAttributes
        )),
          (this.indexBuffer = t.createIndexBuffer(this.indexArray)),
          (this.collisionVertexBuffer = t.createVertexBuffer(
            this.collisionVertexArray,
            ah.members,
            !0
          ));
      }
      destroy() {
        this.layoutVertexBuffer &&
          (this.layoutVertexBuffer.destroy(),
          this.indexBuffer.destroy(),
          this.segments.destroy(),
          this.collisionVertexBuffer.destroy());
      }
    }
    ca('CollisionBuffers', hu);
    class uu {
      constructor(e) {
        (this.collisionBoxArray = e.collisionBoxArray),
          (this.zoom = e.zoom),
          (this.overscaling = W(globalThis)
            ? Math.min(e.overscaling, 128)
            : e.overscaling),
          (this.layers = e.layers),
          (this.layerIds = this.layers.map((t) => t.id)),
          (this.index = e.index),
          (this.pixelRatio = e.pixelRatio),
          (this.sourceLayerIndex = e.sourceLayerIndex),
          (this.hasDependencies = !1),
          (this.hasRTLText = !1),
          (this.sortKeyRanges = []),
          (this.collisionCircleArray = []);
        const i = this.layers[0]._unevaluatedLayout._values;
        (this.textSizeData = ru(this.zoom, i['text-size'])),
          (this.iconSizeData = ru(this.zoom, i['icon-size']));
        const r = this.layers[0].layout,
          n = r.get('symbol-sort-key'),
          a = r.get('symbol-z-order');
        (this.canOverlap =
          'never' !== nu(r, 'text-overlap', 'text-allow-overlap') ||
          'never' !== nu(r, 'icon-overlap', 'icon-allow-overlap') ||
          r.get('text-ignore-placement') ||
          r.get('icon-ignore-placement')),
          (this.sortFeaturesByKey = 'viewport-y' !== a && !n.isConstant()),
          (this.sortFeaturesByY =
            ('viewport-y' === a || ('auto' === a && !this.sortFeaturesByKey)) &&
            this.canOverlap),
          'point' === r.get('symbol-placement') &&
            (this.writingModes = r
              .get('text-writing-mode')
              .map((e) => t.as[e])),
          (this.stateDependentLayerIds = this.layers
            .filter((t) => t.isStateDependent())
            .map((t) => t.id)),
          (this.sourceID = e.sourceID);
      }
      createArrays() {
        (this.text = new cu(
          new Eo(this.layers, this.zoom, (t) => /^text/.test(t))
        )),
          (this.icon = new cu(
            new Eo(this.layers, this.zoom, (t) => /^icon/.test(t))
          )),
          (this.glyphOffsetArray = new Es()),
          (this.lineVertexArray = new Rs()),
          (this.symbolInstances = new As()),
          (this.textAnchorOffsets = new ks());
      }
      calculateGlyphDependencies(t, e, i, r, n) {
        for (let a = 0; a < t.length; a++)
          if (((e[t.charCodeAt(a)] = !0), (i || r) && n)) {
            const i = ch[t.charAt(a)];
            i && (e[i.charCodeAt(0)] = !0);
          }
      }
      populate(e, i, r) {
        const n = this.layers[0],
          a = n.layout,
          s = a.get('text-font'),
          o = a.get('text-field'),
          l = a.get('icon-image'),
          c =
            ('constant' !== o.value.kind ||
              (o.value.value instanceof Ae && !o.value.value.isEmpty()) ||
              o.value.value.toString().length > 0) &&
            ('constant' !== s.value.kind || s.value.value.length > 0),
          h =
            'constant' !== l.value.kind ||
            !!l.value.value ||
            Object.keys(l.parameters).length > 0,
          u = a.get('symbol-sort-key');
        if (((this.features = []), !c && !h)) return;
        const d = i.iconDependencies,
          p = i.glyphDependencies,
          f = i.availableImages,
          m = new La(this.zoom);
        for (const { feature: g, id: _, index: y, sourceLayerIndex: v } of e) {
          const e = n._featureFilter.needGeometry,
            i = Bo(g, e);
          if (!n._featureFilter.filter(m, i, r)) continue;
          let o, l;
          if ((e || (i.geometry = Fo(g)), c)) {
            const t = n.getValueAndResolveTokens('text-field', i, r, f),
              e = Ae.factory(t),
              a = (this.hasRTLText = this.hasRTLText || lu(e));
            (!a ||
              'unavailable' === Da.getRTLTextPluginStatus() ||
              (a && Da.isParsed())) &&
              (o = lh(e, n, i));
          }
          if (h) {
            const t = n.getValueAndResolveTokens('icon-image', i, r, f);
            l = t instanceof Be ? t : Be.fromString(t);
          }
          if (!o && !l) continue;
          const x = this.sortFeaturesByKey ? u.evaluate(i, {}, r) : void 0;
          if (
            (this.features.push({
              id: _,
              text: o,
              icon: l,
              index: y,
              sourceLayerIndex: v,
              geometry: i.geometry,
              properties: g.properties,
              type: Cc.types[g.type],
              sortKey: x,
            }),
            l && (d[l.name] = !0),
            o)
          ) {
            const e = s.evaluate(i, {}, r).join(','),
              n =
                'viewport' !== a.get('text-rotation-alignment') &&
                'point' !== a.get('symbol-placement');
            this.allowVerticalPlacement =
              this.writingModes &&
              this.writingModes.indexOf(t.as.vertical) >= 0;
            for (const t of o.sections)
              if (t.image) d[t.image.name] = !0;
              else {
                const i = _a(o.toString()),
                  r = t.fontStack || e,
                  a = (p[r] = p[r] || {});
                this.calculateGlyphDependencies(
                  t.text,
                  a,
                  n,
                  this.allowVerticalPlacement,
                  i
                );
              }
          }
        }
        'line' === a.get('symbol-placement') &&
          (this.features = (function (t) {
            const e = {},
              i = {},
              r = [];
            let n = 0;
            function a(e) {
              r.push(t[e]), n++;
            }
            function s(t, e, n) {
              const a = i[t];
              return (
                delete i[t],
                (i[e] = a),
                r[a].geometry[0].pop(),
                (r[a].geometry[0] = r[a].geometry[0].concat(n[0])),
                a
              );
            }
            function o(t, i, n) {
              const a = e[i];
              return (
                delete e[i],
                (e[t] = a),
                r[a].geometry[0].shift(),
                (r[a].geometry[0] = n[0].concat(r[a].geometry[0])),
                a
              );
            }
            function l(t, e, i) {
              const r = i ? e[0][e[0].length - 1] : e[0][0];
              return `${t}:${r.x}:${r.y}`;
            }
            for (let c = 0; c < t.length; c++) {
              const h = t[c],
                u = h.geometry,
                d = h.text ? h.text.toString() : null;
              if (!d) {
                a(c);
                continue;
              }
              const p = l(d, u),
                f = l(d, u, !0);
              if (p in i && f in e && i[p] !== e[f]) {
                const t = o(p, f, u),
                  n = s(p, f, r[t].geometry);
                delete e[p],
                  delete i[f],
                  (i[l(d, r[n].geometry, !0)] = n),
                  (r[t].geometry = null);
              } else
                p in i
                  ? s(p, f, u)
                  : f in e
                  ? o(p, f, u)
                  : (a(c), (e[p] = n - 1), (i[f] = n - 1));
            }
            return r.filter((t) => t.geometry);
          })(this.features)),
          this.sortFeaturesByKey &&
            this.features.sort((t, e) => t.sortKey - e.sortKey);
      }
      update(t, e, i) {
        this.stateDependentLayers.length &&
          (this.text.programConfigurations.updatePaintArrays(
            t,
            e,
            this.layers,
            { imagePositions: i }
          ),
          this.icon.programConfigurations.updatePaintArrays(t, e, this.layers, {
            imagePositions: i,
          }));
      }
      isEmpty() {
        return 0 === this.symbolInstances.length && !this.hasRTLText;
      }
      uploadPending() {
        return (
          !this.uploaded ||
          this.text.programConfigurations.needsUpload ||
          this.icon.programConfigurations.needsUpload
        );
      }
      upload(t) {
        !this.uploaded &&
          this.hasDebugData() &&
          (this.textCollisionBox.upload(t), this.iconCollisionBox.upload(t)),
          this.text.upload(
            t,
            this.sortFeaturesByY,
            !this.uploaded,
            this.text.programConfigurations.needsUpload
          ),
          this.icon.upload(
            t,
            this.sortFeaturesByY,
            !this.uploaded,
            this.icon.programConfigurations.needsUpload
          ),
          (this.uploaded = !0);
      }
      destroyDebugData() {
        this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
      }
      destroy() {
        this.text.destroy(),
          this.icon.destroy(),
          this.hasDebugData() && this.destroyDebugData();
      }
      addToLineVertexArray(t, e) {
        const i = this.lineVertexArray.length;
        if (void 0 !== t.segment) {
          let i = t.dist(e[t.segment + 1]),
            r = t.dist(e[t.segment]);
          const n = {};
          for (let a = t.segment + 1; a < e.length; a++)
            (n[a] = { x: e[a].x, y: e[a].y, tileUnitDistanceFromAnchor: i }),
              a < e.length - 1 && (i += e[a + 1].dist(e[a]));
          for (let a = t.segment || 0; a >= 0; a--)
            (n[a] = { x: e[a].x, y: e[a].y, tileUnitDistanceFromAnchor: r }),
              a > 0 && (r += e[a - 1].dist(e[a]));
          for (let t = 0; t < e.length; t++) {
            const e = n[t];
            this.lineVertexArray.emplaceBack(
              e.x,
              e.y,
              e.tileUnitDistanceFromAnchor
            );
          }
        }
        return {
          lineStartIndex: i,
          lineLength: this.lineVertexArray.length - i,
        };
      }
      addSymbols(e, i, r, n, a, s, o, l, c, h, u, d) {
        const p = e.indexArray,
          f = e.layoutVertexArray,
          m = e.segments.prepareSegment(
            4 * i.length,
            f,
            p,
            this.canOverlap ? s.sortKey : void 0
          ),
          g = this.glyphOffsetArray.length,
          _ = m.vertexLength,
          y =
            this.allowVerticalPlacement && o === t.as.vertical
              ? Math.PI / 2
              : 0,
          v = s.text && s.text.sections;
        for (let t = 0; t < i.length; t++) {
          const {
              tl: n,
              tr: a,
              bl: o,
              br: c,
              tex: h,
              pixelOffsetTL: u,
              pixelOffsetBR: g,
              minFontScaleX: _,
              minFontScaleY: x,
              glyphOffset: b,
              isSDF: w,
              sectionIndex: T,
            } = i[t],
            P = m.vertexLength,
            C = b[1];
          su(f, l.x, l.y, n.x, C + n.y, h.x, h.y, r, w, u.x, u.y, _, x),
            su(f, l.x, l.y, a.x, C + a.y, h.x + h.w, h.y, r, w, g.x, u.y, _, x),
            su(f, l.x, l.y, o.x, C + o.y, h.x, h.y + h.h, r, w, u.x, g.y, _, x),
            su(
              f,
              l.x,
              l.y,
              c.x,
              C + c.y,
              h.x + h.w,
              h.y + h.h,
              r,
              w,
              g.x,
              g.y,
              _,
              x
            ),
            ou(e.dynamicLayoutVertexArray, l, y),
            p.emplaceBack(P, P + 2, P + 1),
            p.emplaceBack(P + 1, P + 2, P + 3),
            (m.vertexLength += 4),
            (m.primitiveLength += 2),
            this.glyphOffsetArray.emplaceBack(b[0]),
            (t !== i.length - 1 && T === i[t + 1].sectionIndex) ||
              e.programConfigurations.populatePaintArrays(
                f.length,
                s,
                s.index,
                {
                  imagePositions: {},
                  canonical: d,
                  formattedSection: v && v[T],
                }
              );
        }
        e.placedSymbolArray.emplaceBack(
          l.x,
          l.y,
          g,
          this.glyphOffsetArray.length - g,
          _,
          c,
          h,
          l.segment,
          r ? r[0] : 0,
          r ? r[1] : 0,
          n[0],
          n[1],
          o,
          0,
          !1,
          0,
          u
        );
      }
      _addCollisionDebugVertex(t, e, i, r, n, a) {
        return (
          e.emplaceBack(0, 0),
          t.emplaceBack(i.x, i.y, r, n, Math.round(a.x), Math.round(a.y))
        );
      }
      addCollisionDebugVertices(t, e, r, n, a, s, o) {
        const l = a.segments.prepareSegment(
            4,
            a.layoutVertexArray,
            a.indexArray
          ),
          c = l.vertexLength,
          h = a.layoutVertexArray,
          u = a.collisionVertexArray,
          d = o.anchorX,
          p = o.anchorY;
        this._addCollisionDebugVertex(h, u, s, d, p, new i(t, e)),
          this._addCollisionDebugVertex(h, u, s, d, p, new i(r, e)),
          this._addCollisionDebugVertex(h, u, s, d, p, new i(r, n)),
          this._addCollisionDebugVertex(h, u, s, d, p, new i(t, n)),
          (l.vertexLength += 4);
        const f = a.indexArray;
        f.emplaceBack(c, c + 1),
          f.emplaceBack(c + 1, c + 2),
          f.emplaceBack(c + 2, c + 3),
          f.emplaceBack(c + 3, c),
          (l.primitiveLength += 4);
      }
      addDebugCollisionBoxes(t, e, i, r) {
        for (let n = t; n < e; n++) {
          const t = this.collisionBoxArray.get(n);
          this.addCollisionDebugVertices(
            t.x1,
            t.y1,
            t.x2,
            t.y2,
            r ? this.textCollisionBox : this.iconCollisionBox,
            t.anchorPoint,
            i
          );
        }
      }
      generateCollisionDebugBuffers() {
        this.hasDebugData() && this.destroyDebugData(),
          (this.textCollisionBox = new hu(Xs, sh.members, Js)),
          (this.iconCollisionBox = new hu(Xs, sh.members, Js));
        for (let t = 0; t < this.symbolInstances.length; t++) {
          const e = this.symbolInstances.get(t);
          this.addDebugCollisionBoxes(
            e.textBoxStartIndex,
            e.textBoxEndIndex,
            e,
            !0
          ),
            this.addDebugCollisionBoxes(
              e.verticalTextBoxStartIndex,
              e.verticalTextBoxEndIndex,
              e,
              !0
            ),
            this.addDebugCollisionBoxes(
              e.iconBoxStartIndex,
              e.iconBoxEndIndex,
              e,
              !1
            ),
            this.addDebugCollisionBoxes(
              e.verticalIconBoxStartIndex,
              e.verticalIconBoxEndIndex,
              e,
              !1
            );
        }
      }
      _deserializeCollisionBoxesForSymbol(t, e, i, r, n, a, s, o, l) {
        const c = {};
        for (let h = e; h < i; h++) {
          const e = t.get(h);
          (c.textBox = {
            x1: e.x1,
            y1: e.y1,
            x2: e.x2,
            y2: e.y2,
            anchorPointX: e.anchorPointX,
            anchorPointY: e.anchorPointY,
          }),
            (c.textFeatureIndex = e.featureIndex);
          break;
        }
        for (let h = r; h < n; h++) {
          const e = t.get(h);
          (c.verticalTextBox = {
            x1: e.x1,
            y1: e.y1,
            x2: e.x2,
            y2: e.y2,
            anchorPointX: e.anchorPointX,
            anchorPointY: e.anchorPointY,
          }),
            (c.verticalTextFeatureIndex = e.featureIndex);
          break;
        }
        for (let h = a; h < s; h++) {
          const e = t.get(h);
          (c.iconBox = {
            x1: e.x1,
            y1: e.y1,
            x2: e.x2,
            y2: e.y2,
            anchorPointX: e.anchorPointX,
            anchorPointY: e.anchorPointY,
          }),
            (c.iconFeatureIndex = e.featureIndex);
          break;
        }
        for (let h = o; h < l; h++) {
          const e = t.get(h);
          (c.verticalIconBox = {
            x1: e.x1,
            y1: e.y1,
            x2: e.x2,
            y2: e.y2,
            anchorPointX: e.anchorPointX,
            anchorPointY: e.anchorPointY,
          }),
            (c.verticalIconFeatureIndex = e.featureIndex);
          break;
        }
        return c;
      }
      deserializeCollisionBoxes(t) {
        this.collisionArrays = [];
        for (let e = 0; e < this.symbolInstances.length; e++) {
          const i = this.symbolInstances.get(e);
          this.collisionArrays.push(
            this._deserializeCollisionBoxesForSymbol(
              t,
              i.textBoxStartIndex,
              i.textBoxEndIndex,
              i.verticalTextBoxStartIndex,
              i.verticalTextBoxEndIndex,
              i.iconBoxStartIndex,
              i.iconBoxEndIndex,
              i.verticalIconBoxStartIndex,
              i.verticalIconBoxEndIndex
            )
          );
        }
      }
      hasTextData() {
        return this.text.segments.get().length > 0;
      }
      hasIconData() {
        return this.icon.segments.get().length > 0;
      }
      hasDebugData() {
        return this.textCollisionBox && this.iconCollisionBox;
      }
      hasTextCollisionBoxData() {
        return (
          this.hasDebugData() && this.textCollisionBox.segments.get().length > 0
        );
      }
      hasIconCollisionBoxData() {
        return (
          this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0
        );
      }
      addIndicesForPlacedSymbol(t, e) {
        const i = t.placedSymbolArray.get(e),
          r = i.vertexStartIndex + 4 * i.numGlyphs;
        for (let n = i.vertexStartIndex; n < r; n += 4)
          t.indexArray.emplaceBack(n, n + 2, n + 1),
            t.indexArray.emplaceBack(n + 1, n + 2, n + 3);
      }
      getSortedSymbolIndexes(t) {
        if (this.sortedAngle === t && void 0 !== this.symbolInstanceIndexes)
          return this.symbolInstanceIndexes;
        const e = Math.sin(t),
          i = Math.cos(t),
          r = [],
          n = [],
          a = [];
        for (let s = 0; s < this.symbolInstances.length; ++s) {
          a.push(s);
          const t = this.symbolInstances.get(s);
          r.push(0 | Math.round(e * t.anchorX + i * t.anchorY)),
            n.push(t.featureIndex);
        }
        return a.sort((t, e) => r[t] - r[e] || n[e] - n[t]), a;
      }
      addToSortKeyRanges(t, e) {
        const i = this.sortKeyRanges[this.sortKeyRanges.length - 1];
        i && i.sortKey === e
          ? (i.symbolInstanceEnd = t + 1)
          : this.sortKeyRanges.push({
              sortKey: e,
              symbolInstanceStart: t,
              symbolInstanceEnd: t + 1,
            });
      }
      sortFeatures(t) {
        if (
          this.sortFeaturesByY &&
          this.sortedAngle !== t &&
          !(
            this.text.segments.get().length > 1 ||
            this.icon.segments.get().length > 1
          )
        ) {
          (this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t)),
            (this.sortedAngle = t),
            this.text.indexArray.clear(),
            this.icon.indexArray.clear(),
            (this.featureSortOrder = []);
          for (const t of this.symbolInstanceIndexes) {
            const e = this.symbolInstances.get(t);
            this.featureSortOrder.push(e.featureIndex),
              [
                e.rightJustifiedTextSymbolIndex,
                e.centerJustifiedTextSymbolIndex,
                e.leftJustifiedTextSymbolIndex,
              ].forEach((t, e, i) => {
                t >= 0 &&
                  i.indexOf(t) === e &&
                  this.addIndicesForPlacedSymbol(this.text, t);
              }),
              e.verticalPlacedTextSymbolIndex >= 0 &&
                this.addIndicesForPlacedSymbol(
                  this.text,
                  e.verticalPlacedTextSymbolIndex
                ),
              e.placedIconSymbolIndex >= 0 &&
                this.addIndicesForPlacedSymbol(
                  this.icon,
                  e.placedIconSymbolIndex
                ),
              e.verticalPlacedIconSymbolIndex >= 0 &&
                this.addIndicesForPlacedSymbol(
                  this.icon,
                  e.verticalPlacedIconSymbolIndex
                );
          }
          this.text.indexBuffer &&
            this.text.indexBuffer.updateData(this.text.indexArray),
            this.icon.indexBuffer &&
              this.icon.indexBuffer.updateData(this.icon.indexArray);
        }
      }
    }
    let du, pu;
    ca('SymbolBucket', uu, {
      omit: ['layers', 'collisionBoxArray', 'features', 'compareText'],
    }),
      (uu.MAX_GLYPHS = 65535),
      (uu.addDynamicAttributes = ou);
    var fu = {
      get paint() {
        return (pu =
          pu ||
          new $a({
            'icon-opacity': new ja(vt.paint_symbol['icon-opacity']),
            'icon-color': new ja(vt.paint_symbol['icon-color']),
            'icon-halo-color': new ja(vt.paint_symbol['icon-halo-color']),
            'icon-halo-width': new ja(vt.paint_symbol['icon-halo-width']),
            'icon-halo-blur': new ja(vt.paint_symbol['icon-halo-blur']),
            'icon-translate': new Va(vt.paint_symbol['icon-translate']),
            'icon-translate-anchor': new Va(
              vt.paint_symbol['icon-translate-anchor']
            ),
            'text-opacity': new ja(vt.paint_symbol['text-opacity']),
            'text-color': new ja(vt.paint_symbol['text-color'], {
              runtimeType: Nt,
              getOverride: (t) => t.textColor,
              hasOverride: (t) => !!t.textColor,
            }),
            'text-halo-color': new ja(vt.paint_symbol['text-halo-color']),
            'text-halo-width': new ja(vt.paint_symbol['text-halo-width']),
            'text-halo-blur': new ja(vt.paint_symbol['text-halo-blur']),
            'text-translate': new Va(vt.paint_symbol['text-translate']),
            'text-translate-anchor': new Va(
              vt.paint_symbol['text-translate-anchor']
            ),
          }));
      },
      get layout() {
        return (du =
          du ||
          new $a({
            'symbol-placement': new Va(vt.layout_symbol['symbol-placement']),
            'symbol-spacing': new Va(vt.layout_symbol['symbol-spacing']),
            'symbol-avoid-edges': new Va(
              vt.layout_symbol['symbol-avoid-edges']
            ),
            'symbol-sort-key': new ja(vt.layout_symbol['symbol-sort-key']),
            'symbol-z-order': new Va(vt.layout_symbol['symbol-z-order']),
            'icon-allow-overlap': new Va(
              vt.layout_symbol['icon-allow-overlap']
            ),
            'icon-overlap': new Va(vt.layout_symbol['icon-overlap']),
            'icon-ignore-placement': new Va(
              vt.layout_symbol['icon-ignore-placement']
            ),
            'icon-optional': new Va(vt.layout_symbol['icon-optional']),
            'icon-rotation-alignment': new Va(
              vt.layout_symbol['icon-rotation-alignment']
            ),
            'icon-size': new ja(vt.layout_symbol['icon-size']),
            'icon-text-fit': new Va(vt.layout_symbol['icon-text-fit']),
            'icon-text-fit-padding': new Va(
              vt.layout_symbol['icon-text-fit-padding']
            ),
            'icon-image': new ja(vt.layout_symbol['icon-image']),
            'icon-rotate': new ja(vt.layout_symbol['icon-rotate']),
            'icon-padding': new ja(vt.layout_symbol['icon-padding']),
            'icon-keep-upright': new Va(vt.layout_symbol['icon-keep-upright']),
            'icon-offset': new ja(vt.layout_symbol['icon-offset']),
            'icon-anchor': new ja(vt.layout_symbol['icon-anchor']),
            'icon-pitch-alignment': new Va(
              vt.layout_symbol['icon-pitch-alignment']
            ),
            'text-pitch-alignment': new Va(
              vt.layout_symbol['text-pitch-alignment']
            ),
            'text-rotation-alignment': new Va(
              vt.layout_symbol['text-rotation-alignment']
            ),
            'text-field': new ja(vt.layout_symbol['text-field']),
            'text-font': new ja(vt.layout_symbol['text-font']),
            'text-size': new ja(vt.layout_symbol['text-size']),
            'text-max-width': new ja(vt.layout_symbol['text-max-width']),
            'text-line-height': new Va(vt.layout_symbol['text-line-height']),
            'text-letter-spacing': new ja(
              vt.layout_symbol['text-letter-spacing']
            ),
            'text-justify': new ja(vt.layout_symbol['text-justify']),
            'text-radial-offset': new ja(
              vt.layout_symbol['text-radial-offset']
            ),
            'text-variable-anchor': new Va(
              vt.layout_symbol['text-variable-anchor']
            ),
            'text-variable-anchor-offset': new ja(
              vt.layout_symbol['text-variable-anchor-offset']
            ),
            'text-anchor': new ja(vt.layout_symbol['text-anchor']),
            'text-max-angle': new Va(vt.layout_symbol['text-max-angle']),
            'text-writing-mode': new Va(vt.layout_symbol['text-writing-mode']),
            'text-rotate': new ja(vt.layout_symbol['text-rotate']),
            'text-padding': new Va(vt.layout_symbol['text-padding']),
            'text-keep-upright': new Va(vt.layout_symbol['text-keep-upright']),
            'text-transform': new ja(vt.layout_symbol['text-transform']),
            'text-offset': new ja(vt.layout_symbol['text-offset']),
            'text-allow-overlap': new Va(
              vt.layout_symbol['text-allow-overlap']
            ),
            'text-overlap': new Va(vt.layout_symbol['text-overlap']),
            'text-ignore-placement': new Va(
              vt.layout_symbol['text-ignore-placement']
            ),
            'text-optional': new Va(vt.layout_symbol['text-optional']),
          }));
      },
    };
    class mu {
      constructor(t) {
        if (void 0 === t.property.overrides)
          throw new Error(
            'overrides must be provided to instantiate FormatSectionOverride class'
          );
        (this.type = t.property.overrides
          ? t.property.overrides.runtimeType
          : kt),
          (this.defaultValue = t);
      }
      evaluate(t) {
        if (t.formattedSection) {
          const e = this.defaultValue.property.overrides;
          if (e && e.hasOverride(t.formattedSection))
            return e.getOverride(t.formattedSection);
        }
        return t.feature && t.featureState
          ? this.defaultValue.evaluate(t.feature, t.featureState)
          : this.defaultValue.property.specification.default;
      }
      eachChild(t) {
        this.defaultValue.isConstant() ||
          t(this.defaultValue.value._styleExpression.expression);
      }
      outputDefined() {
        return !1;
      }
      serialize() {
        return null;
      }
    }
    ca('FormatSectionOverride', mu, { omit: ['defaultValue'] });
    class gu extends Ha {
      constructor(t, e) {
        super(t, fu, e);
      }
      recalculate(t, e) {
        if (
          (super.recalculate(t, e),
          'auto' === this.layout.get('icon-rotation-alignment') &&
            (this.layout._values['icon-rotation-alignment'] =
              'point' !== this.layout.get('symbol-placement')
                ? 'map'
                : 'viewport'),
          'auto' === this.layout.get('text-rotation-alignment') &&
            (this.layout._values['text-rotation-alignment'] =
              'point' !== this.layout.get('symbol-placement')
                ? 'map'
                : 'viewport'),
          'auto' === this.layout.get('text-pitch-alignment') &&
            (this.layout._values['text-pitch-alignment'] =
              'map' === this.layout.get('text-rotation-alignment')
                ? 'map'
                : 'viewport'),
          'auto' === this.layout.get('icon-pitch-alignment') &&
            (this.layout._values['icon-pitch-alignment'] = this.layout.get(
              'icon-rotation-alignment'
            )),
          'point' === this.layout.get('symbol-placement'))
        ) {
          const t = this.layout.get('text-writing-mode');
          if (t) {
            const e = [];
            for (const i of t) e.indexOf(i) < 0 && e.push(i);
            this.layout._values['text-writing-mode'] = e;
          } else this.layout._values['text-writing-mode'] = ['horizontal'];
        }
        this._setPaintOverrides();
      }
      getValueAndResolveTokens(t, e, i, r) {
        const n = this.layout.get(t).evaluate(e, {}, i, r),
          a = this._unevaluatedLayout._values[t];
        return a.isDataDriven() || en(a.value) || !n
          ? n
          : (function (t, e) {
              return e.replace(/{([^{}]+)}/g, (e, i) =>
                t && i in t ? String(t[i]) : ''
              );
            })(e.properties, n);
      }
      createBucket(t) {
        return new uu(t);
      }
      queryRadius() {
        return 0;
      }
      queryIntersectsFeature() {
        throw new Error('Should take a different path in FeatureIndex');
      }
      _setPaintOverrides() {
        for (const t of fu.paint.overridableProperties) {
          if (!gu.hasPaintOverride(this.layout, t)) continue;
          const e = this.paint.get(t),
            i = new mu(e),
            r = new tn(i, e.property.specification);
          let n = null;
          (n =
            'constant' === e.value.kind || 'source' === e.value.kind
              ? new nn('source', r)
              : new an('composite', r, e.value.zoomStops)),
            (this.paint._values[t] = new Ba(e.property, n, e.parameters));
        }
      }
      _handleOverridablePaintPropertyUpdate(t, e, i) {
        return (
          !(!this.layout || e.isDataDriven() || i.isDataDriven()) &&
          gu.hasPaintOverride(this.layout, t)
        );
      }
      static hasPaintOverride(t, e) {
        const i = t.get('text-field'),
          r = fu.paint.properties[e];
        let n = !1;
        const a = (t) => {
          for (const e of t)
            if (r.overrides && r.overrides.hasOverride(e)) return void (n = !0);
        };
        if ('constant' === i.value.kind && i.value.value instanceof Ae)
          a(i.value.value.sections);
        else if ('source' === i.value.kind || 'composite' === i.value.kind) {
          const t = (e) => {
              n ||
                (e instanceof Ze && Ue(e.value) === Zt
                  ? a(e.value.sections)
                  : e instanceof Mi
                  ? a(e.sections)
                  : e.eachChild(t));
            },
            e = i.value;
          e._styleExpression && t(e._styleExpression.expression);
        }
        return n;
      }
    }
    let _u;
    var yu = {
      get paint() {
        return (_u =
          _u ||
          new $a({
            'background-color': new Va(vt.paint_background['background-color']),
            'background-pattern': new Ga(
              vt.paint_background['background-pattern']
            ),
            'background-opacity': new Va(
              vt.paint_background['background-opacity']
            ),
          }));
      },
    };
    class vu extends Ha {
      constructor(t, e) {
        super(t, yu, e);
      }
    }
    class xu extends Ha {
      constructor(t, e) {
        super(t, {}, e),
          (this.onAdd = (t) => {
            this.implementation.onAdd &&
              this.implementation.onAdd(t, t.painter.context.gl);
          }),
          (this.onRemove = (t) => {
            this.implementation.onRemove &&
              this.implementation.onRemove(t, t.painter.context.gl);
          }),
          (this.implementation = t);
      }
      is3D() {
        return '3d' === this.implementation.renderingMode;
      }
      hasOffscreenPass() {
        return void 0 !== this.implementation.prerender;
      }
      recalculate() {}
      updateTransitions() {}
      hasTransition() {
        return !1;
      }
      serialize() {
        throw new Error('Custom layers cannot be serialized');
      }
    }
    class bu {
      constructor(t) {
        (this._methodToThrottle = t),
          (this._triggered = !1),
          'undefined' != typeof MessageChannel &&
            ((this._channel = new MessageChannel()),
            (this._channel.port2.onmessage = () => {
              (this._triggered = !1), this._methodToThrottle();
            }));
      }
      trigger() {
        this._triggered ||
          ((this._triggered = !0),
          this._channel
            ? this._channel.port1.postMessage(!0)
            : setTimeout(() => {
                (this._triggered = !1), this._methodToThrottle();
              }, 0));
      }
      remove() {
        delete this._channel, (this._methodToThrottle = () => {});
      }
    }
    const wu = { once: !0 },
      Tu = 6371008.8;
    class Pu {
      constructor(t, e) {
        if (isNaN(t) || isNaN(e))
          throw new Error(`Invalid LngLat object: (${t}, ${e})`);
        if (((this.lng = +t), (this.lat = +e), this.lat > 90 || this.lat < -90))
          throw new Error(
            'Invalid LngLat latitude value: must be between -90 and 90'
          );
      }
      wrap() {
        return new Pu(F(this.lng, -180, 180), this.lat);
      }
      toArray() {
        return [this.lng, this.lat];
      }
      toString() {
        return `LngLat(${this.lng}, ${this.lat})`;
      }
      distanceTo(t) {
        const e = Math.PI / 180,
          i = this.lat * e,
          r = t.lat * e,
          n =
            Math.sin(i) * Math.sin(r) +
            Math.cos(i) * Math.cos(r) * Math.cos((t.lng - this.lng) * e);
        return Tu * Math.acos(Math.min(n, 1));
      }
      static convert(t) {
        if (t instanceof Pu) return t;
        if (Array.isArray(t) && (2 === t.length || 3 === t.length))
          return new Pu(Number(t[0]), Number(t[1]));
        if (!Array.isArray(t) && 'object' == typeof t && null !== t)
          return new Pu(Number('lng' in t ? t.lng : t.lon), Number(t.lat));
        throw new Error(
          '`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]'
        );
      }
    }
    const Cu = 2 * Math.PI * Tu;
    function Iu(t) {
      return Cu * Math.cos((t * Math.PI) / 180);
    }
    function Su(t) {
      return (180 + t) / 360;
    }
    function Mu(t) {
      return (
        (180 -
          (180 / Math.PI) *
            Math.log(Math.tan(Math.PI / 4 + (t * Math.PI) / 360))) /
        360
      );
    }
    function Du(t, e) {
      return t / Iu(e);
    }
    function Lu(t) {
      return 360 * t - 180;
    }
    function Au(t) {
      return (
        (360 / Math.PI) *
          Math.atan(Math.exp(((180 - 360 * t) * Math.PI) / 180)) -
        90
      );
    }
    function Eu(t, e) {
      return t * Iu(Au(e));
    }
    class Ru {
      constructor(t, e, i = 0) {
        (this.x = +t), (this.y = +e), (this.z = +i);
      }
      static fromLngLat(t, e = 0) {
        const i = Pu.convert(t);
        return new Ru(Su(i.lng), Mu(i.lat), Du(e, i.lat));
      }
      toLngLat() {
        return new Pu(Lu(this.x), Au(this.y));
      }
      toAltitude() {
        return Eu(this.z, this.y);
      }
      meterInMercatorCoordinateUnits() {
        return (1 / Cu) * ((t = Au(this.y)), 1 / Math.cos((t * Math.PI) / 180));
        var t;
      }
    }
    function zu(t, e, i) {
      var r = (2 * Math.PI * 6378137) / 256 / Math.pow(2, i);
      return [
        t * r - (2 * Math.PI * 6378137) / 2,
        e * r - (2 * Math.PI * 6378137) / 2,
      ];
    }
    class ku {
      constructor(t, e, i) {
        if (
          !(function (t, e, i) {
            return !(
              t < 0 ||
              t > 25 ||
              i < 0 ||
              i >= Math.pow(2, t) ||
              e < 0 ||
              e >= Math.pow(2, t)
            );
          })(t, e, i)
        )
          throw new Error(
            `x=${e}, y=${i}, z=${t} outside of bounds. 0<=x<${Math.pow(
              2,
              t
            )}, 0<=y<${Math.pow(2, t)} 0<=z<=25 `
          );
        (this.z = t),
          (this.x = e),
          (this.y = i),
          (this.key = Bu(0, t, t, e, i));
      }
      equals(t) {
        return this.z === t.z && this.x === t.x && this.y === t.y;
      }
      url(t, e, i) {
        const r =
          ((a = this.y),
          (s = this.z),
          (o = zu(256 * (n = this.x), 256 * (a = Math.pow(2, s) - a - 1), s)),
          (l = zu(256 * (n + 1), 256 * (a + 1), s)),
          o[0] + ',' + o[1] + ',' + l[0] + ',' + l[1]);
        var n, a, s, o, l;
        const c = (function (t, e, i) {
          let r,
            n = '';
          for (let a = t; a > 0; a--)
            (r = 1 << (a - 1)), (n += (e & r ? 1 : 0) + (i & r ? 2 : 0));
          return n;
        })(this.z, this.x, this.y);
        return t[(this.x + this.y) % t.length]
          .replace(
            /{prefix}/g,
            (this.x % 16).toString(16) + (this.y % 16).toString(16)
          )
          .replace(/{z}/g, String(this.z))
          .replace(/{x}/g, String(this.x))
          .replace(
            /{y}/g,
            String('tms' === i ? Math.pow(2, this.z) - this.y - 1 : this.y)
          )
          .replace(/{ratio}/g, e > 1 ? '@2x' : '')
          .replace(/{quadkey}/g, c)
          .replace(/{bbox-epsg-3857}/g, r);
      }
      isChildOf(t) {
        const e = this.z - t.z;
        return e > 0 && t.x === this.x >> e && t.y === this.y >> e;
      }
      getTilePoint(t) {
        const e = Math.pow(2, this.z);
        return new i((t.x * e - this.x) * D, (t.y * e - this.y) * D);
      }
      toString() {
        return `${this.z}/${this.x}/${this.y}`;
      }
    }
    class Ou {
      constructor(t, e) {
        (this.wrap = t),
          (this.canonical = e),
          (this.key = Bu(t, e.z, e.z, e.x, e.y));
      }
    }
    class Fu {
      constructor(t, e, i, r, n) {
        if (((this.terrainRttPosMatrix32f = null), t < i))
          throw new Error(
            `overscaledZ should be >= z; overscaledZ = ${t}; z = ${i}`
          );
        (this.overscaledZ = t),
          (this.wrap = e),
          (this.canonical = new ku(i, +r, +n)),
          (this.key = Bu(e, t, i, r, n));
      }
      clone() {
        return new Fu(
          this.overscaledZ,
          this.wrap,
          this.canonical.z,
          this.canonical.x,
          this.canonical.y
        );
      }
      equals(t) {
        return (
          this.overscaledZ === t.overscaledZ &&
          this.wrap === t.wrap &&
          this.canonical.equals(t.canonical)
        );
      }
      scaledTo(t) {
        if (t > this.overscaledZ)
          throw new Error(
            `targetZ > this.overscaledZ; targetZ = ${t}; overscaledZ = ${this.overscaledZ}`
          );
        const e = this.canonical.z - t;
        return t > this.canonical.z
          ? new Fu(
              t,
              this.wrap,
              this.canonical.z,
              this.canonical.x,
              this.canonical.y
            )
          : new Fu(
              t,
              this.wrap,
              t,
              this.canonical.x >> e,
              this.canonical.y >> e
            );
      }
      isOverscaled() {
        return this.overscaledZ > this.canonical.z;
      }
      calculateScaledKey(t, e) {
        if (t > this.overscaledZ)
          throw new Error(
            `targetZ > this.overscaledZ; targetZ = ${t}; overscaledZ = ${this.overscaledZ}`
          );
        const i = this.canonical.z - t;
        return t > this.canonical.z
          ? Bu(
              this.wrap * +e,
              t,
              this.canonical.z,
              this.canonical.x,
              this.canonical.y
            )
          : Bu(
              this.wrap * +e,
              t,
              t,
              this.canonical.x >> i,
              this.canonical.y >> i
            );
      }
      isChildOf(t) {
        if (t.wrap !== this.wrap) return !1;
        if (this.overscaledZ - t.overscaledZ <= 0) return !1;
        if (0 === t.overscaledZ) return this.overscaledZ > 0;
        const e = this.canonical.z - t.canonical.z;
        return (
          !(e < 0) &&
          t.canonical.x === this.canonical.x >> e &&
          t.canonical.y === this.canonical.y >> e
        );
      }
      children(t) {
        if (this.overscaledZ >= t)
          return [
            new Fu(
              this.overscaledZ + 1,
              this.wrap,
              this.canonical.z,
              this.canonical.x,
              this.canonical.y
            ),
          ];
        const e = this.canonical.z + 1,
          i = 2 * this.canonical.x,
          r = 2 * this.canonical.y;
        return [
          new Fu(e, this.wrap, e, i, r),
          new Fu(e, this.wrap, e, i + 1, r),
          new Fu(e, this.wrap, e, i, r + 1),
          new Fu(e, this.wrap, e, i + 1, r + 1),
        ];
      }
      isLessThan(t) {
        return (
          this.wrap < t.wrap ||
          (!(this.wrap > t.wrap) &&
            (this.overscaledZ < t.overscaledZ ||
              (!(this.overscaledZ > t.overscaledZ) &&
                (this.canonical.x < t.canonical.x ||
                  (!(this.canonical.x > t.canonical.x) &&
                    this.canonical.y < t.canonical.y)))))
        );
      }
      wrapped() {
        return new Fu(
          this.overscaledZ,
          0,
          this.canonical.z,
          this.canonical.x,
          this.canonical.y
        );
      }
      unwrapTo(t) {
        return new Fu(
          this.overscaledZ,
          t,
          this.canonical.z,
          this.canonical.x,
          this.canonical.y
        );
      }
      overscaleFactor() {
        return Math.pow(2, this.overscaledZ - this.canonical.z);
      }
      toUnwrapped() {
        return new Ou(this.wrap, this.canonical);
      }
      toString() {
        return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
      }
      getTilePoint(t) {
        return this.canonical.getTilePoint(new Ru(t.x - this.wrap, t.y));
      }
    }
    function Bu(t, e, i, r, n) {
      (t *= 2) < 0 && (t = -1 * t - 1);
      const a = 1 << i;
      return (
        (a * a * t + a * n + r).toString(36) + i.toString(36) + e.toString(36)
      );
    }
    function Nu(t, e) {
      return e ? t.properties[e] : t.id;
    }
    ca('CanonicalTileID', ku),
      ca('OverscaledTileID', Fu, { omit: ['terrainRttPosMatrix32f'] });
    class Vu {
      constructor() {
        (this.minX = 1 / 0),
          (this.maxX = -1 / 0),
          (this.minY = 1 / 0),
          (this.maxY = -1 / 0);
      }
      extend(t) {
        return (
          (this.minX = Math.min(this.minX, t.x)),
          (this.minY = Math.min(this.minY, t.y)),
          (this.maxX = Math.max(this.maxX, t.x)),
          (this.maxY = Math.max(this.maxY, t.y)),
          this
        );
      }
      expandBy(t) {
        return (
          (this.minX -= t),
          (this.minY -= t),
          (this.maxX += t),
          (this.maxY += t),
          (this.minX > this.maxX || this.minY > this.maxY) &&
            ((this.minX = 1 / 0),
            (this.maxX = -1 / 0),
            (this.minY = 1 / 0),
            (this.maxY = -1 / 0)),
          this
        );
      }
      shrinkBy(t) {
        return this.expandBy(-t);
      }
      map(t) {
        const e = new Vu();
        return (
          e.extend(t(new i(this.minX, this.minY))),
          e.extend(t(new i(this.maxX, this.minY))),
          e.extend(t(new i(this.minX, this.maxY))),
          e.extend(t(new i(this.maxX, this.maxY))),
          e
        );
      }
      static fromPoints(t) {
        const e = new Vu();
        for (const i of t) e.extend(i);
        return e;
      }
      contains(t) {
        return (
          t.x >= this.minX &&
          t.x <= this.maxX &&
          t.y >= this.minY &&
          t.y <= this.maxY
        );
      }
      empty() {
        return this.minX > this.maxX;
      }
      width() {
        return this.maxX - this.minX;
      }
      height() {
        return this.maxY - this.minY;
      }
      covers(t) {
        return (
          !this.empty() &&
          !t.empty() &&
          t.minX >= this.minX &&
          t.maxX <= this.maxX &&
          t.minY >= this.minY &&
          t.maxY <= this.maxY
        );
      }
      intersects(t) {
        return (
          !this.empty() &&
          !t.empty() &&
          t.minX <= this.maxX &&
          t.maxX >= this.minX &&
          t.minY <= this.maxY &&
          t.maxY >= this.minY
        );
      }
    }
    class ju {
      constructor(t) {
        (this._stringToNumber = {}), (this._numberToString = []);
        for (let e = 0; e < t.length; e++) {
          const i = t[e];
          (this._stringToNumber[i] = e), (this._numberToString[e] = i);
        }
      }
      encode(t) {
        return this._stringToNumber[t];
      }
      decode(t) {
        if (t >= this._numberToString.length)
          throw new Error(
            `Out of bounds. Index requested n=${t} can't be >= this._numberToString.length ${this._numberToString.length}`
          );
        return this._numberToString[t];
      }
    }
    class Uu {
      constructor(t, e, i, r, n) {
        (this.type = 'Feature'),
          (this._vectorTileFeature = t),
          (t._z = e),
          (t._x = i),
          (t._y = r),
          (this.properties = t.properties),
          (this.id = n);
      }
      get geometry() {
        return (
          void 0 === this._geometry &&
            (this._geometry = this._vectorTileFeature.toGeoJSON(
              this._vectorTileFeature._x,
              this._vectorTileFeature._y,
              this._vectorTileFeature._z
            ).geometry),
          this._geometry
        );
      }
      set geometry(t) {
        this._geometry = t;
      }
      toJSON() {
        const t = { geometry: this.geometry };
        for (const e in this)
          '_geometry' !== e && '_vectorTileFeature' !== e && (t[e] = this[e]);
        return t;
      }
    }
    class Gu {
      constructor(t, e) {
        (this.tileID = t),
          (this.x = t.canonical.x),
          (this.y = t.canonical.y),
          (this.z = t.canonical.z),
          (this.grid = new oa(D, 16, 0)),
          (this.grid3D = new oa(D, 16, 0)),
          (this.featureIndexArray = new Fs()),
          (this.promoteId = e);
      }
      insert(t, e, i, r, n, a) {
        const s = this.featureIndexArray.length;
        this.featureIndexArray.emplaceBack(i, r, n);
        const o = a ? this.grid3D : this.grid;
        for (let l = 0; l < e.length; l++) {
          const t = e[l],
            i = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          for (let e = 0; e < t.length; e++) {
            const r = t[e];
            (i[0] = Math.min(i[0], r.x)),
              (i[1] = Math.min(i[1], r.y)),
              (i[2] = Math.max(i[2], r.x)),
              (i[3] = Math.max(i[3], r.y));
          }
          i[0] < D &&
            i[1] < D &&
            i[2] >= 0 &&
            i[3] >= 0 &&
            o.insert(s, i[0], i[1], i[2], i[3]);
        }
      }
      loadVTLayers() {
        return (
          this.vtLayers ||
            ((this.vtLayers = new Lc(new fh(this.rawTileData)).layers),
            (this.sourceLayerCoder = new ju(
              this.vtLayers
                ? Object.keys(this.vtLayers).sort()
                : ['_geojsonTileLayer']
            ))),
          this.vtLayers
        );
      }
      query(t, e, r, n) {
        this.loadVTLayers();
        const a = t.params,
          s = D / t.tileSize / t.scale,
          o = pn(a.filter, a.globalState),
          l = t.queryGeometry,
          c = t.queryPadding * s,
          h = Vu.fromPoints(l),
          u = this.grid.query(h.minX - c, h.minY - c, h.maxX + c, h.maxY + c),
          d = Vu.fromPoints(t.cameraQueryGeometry).expandBy(c),
          p = this.grid3D.query(d.minX, d.minY, d.maxX, d.maxY, (e, r, n, a) =>
            (function (t, e, r, n, a) {
              for (const i of t)
                if (e <= i.x && r <= i.y && n >= i.x && a >= i.y) return !0;
              const s = [new i(e, r), new i(e, a), new i(n, a), new i(n, r)];
              if (t.length > 2) for (const i of s) if (Ko(t, i)) return !0;
              for (let i = 0; i < t.length - 1; i++)
                if (Jo(t[i], t[i + 1], s)) return !0;
              return !1;
            })(t.cameraQueryGeometry, e - c, r - c, n + c, a + c)
          );
        for (const i of p) u.push(i);
        u.sort($u);
        const f = {};
        let m;
        for (let i = 0; i < u.length; i++) {
          const c = u[i];
          if (c === m) continue;
          m = c;
          const h = this.featureIndexArray.get(c);
          let d = null;
          this.loadMatchingFeature(
            f,
            h.bucketIndex,
            h.sourceLayerIndex,
            h.featureIndex,
            o,
            a.layers,
            a.availableImages,
            e,
            r,
            n,
            (e, i, r) => (
              d || (d = Fo(e)),
              i.queryIntersectsFeature({
                queryGeometry: l,
                feature: e,
                featureState: r,
                geometry: d,
                zoom: this.z,
                transform: t.transform,
                pixelsToTileUnits: s,
                pixelPosMatrix: t.pixelPosMatrix,
                unwrappedTileID: this.tileID.toUnwrapped(),
                getElevation: t.getElevation,
              })
            )
          );
        }
        return f;
      }
      loadMatchingFeature(t, e, i, r, n, a, s, o, l, c, h) {
        const u = this.bucketLayerIDs[e];
        if (a && !u.some((t) => a.has(t))) return;
        const d = this.sourceLayerCoder.decode(i),
          p = this.vtLayers[d].feature(r);
        if (n.needGeometry) {
          const t = Bo(p, !0);
          if (
            !n.filter(new La(this.tileID.overscaledZ), t, this.tileID.canonical)
          )
            return;
        } else if (!n.filter(new La(this.tileID.overscaledZ), p)) return;
        const f = this.getId(p, d);
        for (let m = 0; m < u.length; m++) {
          const e = u[m];
          if (a && !a.has(e)) continue;
          const i = o[e];
          if (!i) continue;
          let n = {};
          f && c && (n = c.getState(i.sourceLayer || '_geojsonTileLayer', f));
          const d = B({}, l[e]);
          (d.paint = Zu(d.paint, i.paint, p, n, s)),
            (d.layout = Zu(d.layout, i.layout, p, n, s));
          const g = !h || h(p, i, n);
          if (!g) continue;
          const _ = new Uu(p, this.z, this.x, this.y, f);
          _.layer = d;
          let y = t[e];
          void 0 === y && (y = t[e] = []),
            y.push({ featureIndex: r, feature: _, intersectionZ: g });
        }
      }
      lookupSymbolFeatures(t, e, i, r, n, a, s, o) {
        const l = {};
        this.loadVTLayers();
        const c = pn(n.filterSpec, n.globalState);
        for (const h of t) this.loadMatchingFeature(l, i, r, h, c, a, s, o, e);
        return l;
      }
      hasLayer(t) {
        for (const e of this.bucketLayerIDs)
          for (const i of e) if (t === i) return !0;
        return !1;
      }
      getId(t, e) {
        var i;
        let r = t.id;
        return (
          this.promoteId &&
            ((r =
              t.properties[
                'string' == typeof this.promoteId
                  ? this.promoteId
                  : this.promoteId[e]
              ]),
            'boolean' == typeof r && (r = Number(r)),
            void 0 === r &&
              (null === (i = t.properties) || void 0 === i
                ? void 0
                : i.cluster) &&
              this.promoteId &&
              (r = Number(t.properties.cluster_id))),
          r
        );
      }
    }
    function Zu(t, e, i, r, n) {
      return V(t, (t, a) => {
        const s = e instanceof Na ? e.get(a) : null;
        return s && s.evaluate ? s.evaluate(i, r, n) : s;
      });
    }
    function $u(t, e) {
      return e - t;
    }
    function qu(t, e, r, n, a) {
      const s = [];
      for (let o = 0; o < t.length; o++) {
        const l = t[o];
        let c;
        for (let t = 0; t < l.length - 1; t++) {
          let o = l[t],
            h = l[t + 1];
          (o.x < e && h.x < e) ||
            (o.x < e
              ? (o = new i(
                  e,
                  o.y + ((e - o.x) / (h.x - o.x)) * (h.y - o.y)
                )._round())
              : h.x < e &&
                (h = new i(
                  e,
                  o.y + ((e - o.x) / (h.x - o.x)) * (h.y - o.y)
                )._round()),
            (o.y < r && h.y < r) ||
              (o.y < r
                ? (o = new i(
                    o.x + ((r - o.y) / (h.y - o.y)) * (h.x - o.x),
                    r
                  )._round())
                : h.y < r &&
                  (h = new i(
                    o.x + ((r - o.y) / (h.y - o.y)) * (h.x - o.x),
                    r
                  )._round()),
              (o.x >= n && h.x >= n) ||
                (o.x >= n
                  ? (o = new i(
                      n,
                      o.y + ((n - o.x) / (h.x - o.x)) * (h.y - o.y)
                    )._round())
                  : h.x >= n &&
                    (h = new i(
                      n,
                      o.y + ((n - o.x) / (h.x - o.x)) * (h.y - o.y)
                    )._round()),
                (o.y >= a && h.y >= a) ||
                  (o.y >= a
                    ? (o = new i(
                        o.x + ((a - o.y) / (h.y - o.y)) * (h.x - o.x),
                        a
                      )._round())
                    : h.y >= a &&
                      (h = new i(
                        o.x + ((a - o.y) / (h.y - o.y)) * (h.x - o.x),
                        a
                      )._round()),
                  (c && o.equals(c[c.length - 1])) || ((c = [o]), s.push(c)),
                  c.push(h)))));
        }
      }
      return s;
    }
    ca('FeatureIndex', Gu, { omit: ['rawTileData', 'sourceLayerCoder'] });
    class Hu extends i {
      constructor(t, e, i, r) {
        super(t, e), (this.angle = i), void 0 !== r && (this.segment = r);
      }
      clone() {
        return new Hu(this.x, this.y, this.angle, this.segment);
      }
    }
    function Wu(t, e, i, r, n) {
      if (void 0 === e.segment || 0 === i) return !0;
      let a = e,
        s = e.segment + 1,
        o = 0;
      for (; o > -i / 2; ) {
        if ((s--, s < 0)) return !1;
        (o -= t[s].dist(a)), (a = t[s]);
      }
      (o += t[s].dist(t[s + 1])), s++;
      const l = [];
      let c = 0;
      for (; o < i / 2; ) {
        const e = t[s],
          i = t[s + 1];
        if (!i) return !1;
        let a = t[s - 1].angleTo(e) - e.angleTo(i);
        for (
          a = Math.abs(((a + 3 * Math.PI) % (2 * Math.PI)) - Math.PI),
            l.push({ distance: o, angleDelta: a }),
            c += a;
          o - l[0].distance > r;

        )
          c -= l.shift().angleDelta;
        if (c > n) return !1;
        s++, (o += e.dist(i));
      }
      return !0;
    }
    function Xu(t) {
      let e = 0;
      for (let i = 0; i < t.length - 1; i++) e += t[i].dist(t[i + 1]);
      return e;
    }
    function Yu(t, e, i) {
      return t ? 0.6 * e * i : 0;
    }
    function Ku(t, e) {
      return Math.max(t ? t.right - t.left : 0, e ? e.right - e.left : 0);
    }
    function Ju(t, e, i, r, n, a) {
      const s = Yu(i, n, a),
        o = Ku(i, r) * a;
      let l = 0;
      const c = Xu(t) / 2;
      for (let h = 0; h < t.length - 1; h++) {
        const i = t[h],
          r = t[h + 1],
          n = i.dist(r);
        if (l + n > c) {
          const a = (c - l) / n,
            u = mi.number(i.x, r.x, a),
            d = mi.number(i.y, r.y, a),
            p = new Hu(u, d, r.angleTo(i), h);
          return p._round(), !s || Wu(t, p, o, s, e) ? p : void 0;
        }
        l += n;
      }
    }
    function Qu(t, e, i, r, n, a, s, o, l) {
      const c = Yu(r, a, s),
        h = Ku(r, n),
        u = h * s,
        d = 0 === t[0].x || t[0].x === l || 0 === t[0].y || t[0].y === l;
      return (
        e - u < e / 4 && (e = u + e / 4),
        td(
          t,
          d ? ((e / 2) * o) % e : ((h / 2 + 2 * a) * s * o) % e,
          e,
          c,
          i,
          u,
          d,
          !1,
          l
        )
      );
    }
    function td(t, e, i, r, n, a, s, o, l) {
      const c = a / 2,
        h = Xu(t);
      let u = 0,
        d = e - i,
        p = [];
      for (let f = 0; f < t.length - 1; f++) {
        const e = t[f],
          s = t[f + 1],
          o = e.dist(s),
          m = s.angleTo(e);
        for (; d + i < u + o; ) {
          d += i;
          const g = (d - u) / o,
            _ = mi.number(e.x, s.x, g),
            y = mi.number(e.y, s.y, g);
          if (_ >= 0 && _ < l && y >= 0 && y < l && d - c >= 0 && d + c <= h) {
            const e = new Hu(_, y, m, f);
            e._round(), (r && !Wu(t, e, a, r, n)) || p.push(e);
          }
        }
        u += o;
      }
      return o || p.length || s || (p = td(t, u / 2, i, r, n, a, s, !0, l)), p;
    }
    function ed(t, e, r, n) {
      const a = [],
        s = t.image,
        o = s.pixelRatio,
        l = s.paddedRect.w - 2,
        c = s.paddedRect.h - 2;
      let h = { x1: t.left, y1: t.top, x2: t.right, y2: t.bottom };
      const u = s.stretchX || [[0, l]],
        d = s.stretchY || [[0, c]],
        p = (t, e) => t + e[1] - e[0],
        f = u.reduce(p, 0),
        m = d.reduce(p, 0),
        g = l - f,
        _ = c - m;
      let y = 0,
        v = f,
        x = 0,
        b = m,
        w = 0,
        T = g,
        P = 0,
        C = _;
      if (s.content && n) {
        const e = s.content,
          i = e[2] - e[0],
          r = e[3] - e[1];
        (s.textFitWidth || s.textFitHeight) && (h = Qh(t)),
          (y = id(u, 0, e[0])),
          (x = id(d, 0, e[1])),
          (v = id(u, e[0], e[2])),
          (b = id(d, e[1], e[3])),
          (w = e[0] - y),
          (P = e[1] - x),
          (T = i - v),
          (C = r - b);
      }
      const I = h.x1,
        S = h.y1,
        M = h.x2 - I,
        D = h.y2 - S,
        L = (t, n, a, l) => {
          const c = nd(t.stretch - y, v, M, I),
            h = ad(t.fixed - w, T, t.stretch, f),
            u = nd(n.stretch - x, b, D, S),
            d = ad(n.fixed - P, C, n.stretch, m),
            p = nd(a.stretch - y, v, M, I),
            g = ad(a.fixed - w, T, a.stretch, f),
            _ = nd(l.stretch - x, b, D, S),
            L = ad(l.fixed - P, C, l.stretch, m),
            A = new i(c, u),
            E = new i(p, u),
            R = new i(p, _),
            z = new i(c, _),
            k = new i(h / o, d / o),
            O = new i(g / o, L / o),
            F = (e * Math.PI) / 180;
          if (F) {
            const t = Math.sin(F),
              e = Math.cos(F),
              i = [e, -t, t, e];
            A._matMult(i), E._matMult(i), z._matMult(i), R._matMult(i);
          }
          const B = t.stretch + t.fixed,
            N = n.stretch + n.fixed;
          return {
            tl: A,
            tr: E,
            bl: z,
            br: R,
            tex: {
              x: s.paddedRect.x + 1 + B,
              y: s.paddedRect.y + 1 + N,
              w: a.stretch + a.fixed - B,
              h: l.stretch + l.fixed - N,
            },
            writingMode: void 0,
            glyphOffset: [0, 0],
            sectionIndex: 0,
            pixelOffsetTL: k,
            pixelOffsetBR: O,
            minFontScaleX: T / o / M,
            minFontScaleY: C / o / D,
            isSDF: r,
          };
        };
      if (n && (s.stretchX || s.stretchY)) {
        const t = rd(u, g, f),
          e = rd(d, _, m);
        for (let i = 0; i < t.length - 1; i++) {
          const r = t[i],
            n = t[i + 1];
          for (let t = 0; t < e.length - 1; t++)
            a.push(L(r, e[t], n, e[t + 1]));
        }
      } else a.push(L({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: l + 1 }, { fixed: 0, stretch: c + 1 }));
      return a;
    }
    function id(t, e, i) {
      let r = 0;
      for (const n of t)
        r += Math.max(e, Math.min(i, n[1])) - Math.max(e, Math.min(i, n[0]));
      return r;
    }
    function rd(t, e, i) {
      const r = [{ fixed: -1, stretch: 0 }];
      for (const [n, a] of t) {
        const t = r[r.length - 1];
        r.push({ fixed: n - t.stretch, stretch: t.stretch }),
          r.push({ fixed: n - t.stretch, stretch: t.stretch + (a - n) });
      }
      return r.push({ fixed: e + 1, stretch: i }), r;
    }
    function nd(t, e, i, r) {
      return (t / e) * i + r;
    }
    function ad(t, e, i, r) {
      return t - (e * i) / r;
    }
    ca('Anchor', Hu);
    class sd {
      constructor(t, e, r, n, a, s, o, l, c, h) {
        var u;
        if (((this.boxStartIndex = t.length), c)) {
          let t = s.top,
            e = s.bottom;
          const i = s.collisionPadding;
          i && ((t -= i[1]), (e += i[3]));
          let r = e - t;
          r > 0 && ((r = Math.max(10, r)), (this.circleDiameter = r));
        } else {
          const c =
            (null === (u = s.image) || void 0 === u ? void 0 : u.content) &&
            (s.image.textFitWidth || s.image.textFitHeight)
              ? Qh(s)
              : { x1: s.left, y1: s.top, x2: s.right, y2: s.bottom };
          (c.y1 = c.y1 * o - l[0]),
            (c.y2 = c.y2 * o + l[2]),
            (c.x1 = c.x1 * o - l[3]),
            (c.x2 = c.x2 * o + l[1]);
          const d = s.collisionPadding;
          if (
            (d &&
              ((c.x1 -= d[0] * o),
              (c.y1 -= d[1] * o),
              (c.x2 += d[2] * o),
              (c.y2 += d[3] * o)),
            h)
          ) {
            const t = new i(c.x1, c.y1),
              e = new i(c.x2, c.y1),
              r = new i(c.x1, c.y2),
              n = new i(c.x2, c.y2),
              a = (h * Math.PI) / 180;
            t._rotate(a),
              e._rotate(a),
              r._rotate(a),
              n._rotate(a),
              (c.x1 = Math.min(t.x, e.x, r.x, n.x)),
              (c.x2 = Math.max(t.x, e.x, r.x, n.x)),
              (c.y1 = Math.min(t.y, e.y, r.y, n.y)),
              (c.y2 = Math.max(t.y, e.y, r.y, n.y));
          }
          t.emplaceBack(e.x, e.y, c.x1, c.y1, c.x2, c.y2, r, n, a);
        }
        this.boxEndIndex = t.length;
      }
    }
    class od {
      constructor(t = [], e = (t, e) => (t < e ? -1 : t > e ? 1 : 0)) {
        if (
          ((this.data = t),
          (this.length = this.data.length),
          (this.compare = e),
          this.length > 0)
        )
          for (let i = (this.length >> 1) - 1; i >= 0; i--) this._down(i);
      }
      push(t) {
        this.data.push(t), this._up(this.length++);
      }
      pop() {
        if (0 === this.length) return;
        const t = this.data[0],
          e = this.data.pop();
        return --this.length > 0 && ((this.data[0] = e), this._down(0)), t;
      }
      peek() {
        return this.data[0];
      }
      _up(t) {
        const { data: e, compare: i } = this,
          r = e[t];
        for (; t > 0; ) {
          const n = (t - 1) >> 1,
            a = e[n];
          if (i(r, a) >= 0) break;
          (e[t] = a), (t = n);
        }
        e[t] = r;
      }
      _down(t) {
        const { data: e, compare: i } = this,
          r = this.length >> 1,
          n = e[t];
        for (; t < r; ) {
          let r = 1 + (t << 1);
          const a = r + 1;
          if (
            (a < this.length && i(e[a], e[r]) < 0 && (r = a), i(e[r], n) >= 0)
          )
            break;
          (e[t] = e[r]), (t = r);
        }
        e[t] = n;
      }
    }
    function ld(t, e = 1, r = !1) {
      const n = Vu.fromPoints(t[0]),
        a = Math.min(n.width(), n.height());
      let s = a / 2;
      const o = new od([], cd),
        { minX: l, minY: c, maxX: h, maxY: u } = n;
      if (0 === a) return new i(l, c);
      for (let i = l; i < h; i += a)
        for (let e = c; e < u; e += a) o.push(new hd(i + s, e + s, s, t));
      let d = (function (t) {
          let e = 0,
            i = 0,
            r = 0;
          const n = t[0];
          for (let a = 0, s = n.length, o = s - 1; a < s; o = a++) {
            const t = n[a],
              s = n[o],
              l = t.x * s.y - s.x * t.y;
            (i += (t.x + s.x) * l), (r += (t.y + s.y) * l), (e += 3 * l);
          }
          return new hd(i / e, r / e, 0, t);
        })(t),
        p = o.length;
      for (; o.length; ) {
        const i = o.pop();
        (i.d > d.d || !d.d) &&
          ((d = i),
          r &&
            console.log(
              'found best %d after %d probes',
              Math.round(1e4 * i.d) / 1e4,
              p
            )),
          i.max - d.d <= e ||
            ((s = i.h / 2),
            o.push(new hd(i.p.x - s, i.p.y - s, s, t)),
            o.push(new hd(i.p.x + s, i.p.y - s, s, t)),
            o.push(new hd(i.p.x - s, i.p.y + s, s, t)),
            o.push(new hd(i.p.x + s, i.p.y + s, s, t)),
            (p += 4));
      }
      return (
        r &&
          (console.log(`num probes: ${p}`),
          console.log(`best distance: ${d.d}`)),
        d.p
      );
    }
    function cd(t, e) {
      return e.max - t.max;
    }
    function hd(t, e, r, n) {
      (this.p = new i(t, e)),
        (this.h = r),
        (this.d = (function (t, e) {
          let i = !1,
            r = 1 / 0;
          for (let n = 0; n < e.length; n++) {
            const a = e[n];
            for (let e = 0, n = a.length, s = n - 1; e < n; s = e++) {
              const n = a[e],
                o = a[s];
              n.y > t.y != o.y > t.y &&
                t.x < ((o.x - n.x) * (t.y - n.y)) / (o.y - n.y) + n.x &&
                (i = !i),
                (r = Math.min(r, Xo(t, n, o)));
            }
          }
          return (i ? 1 : -1) * Math.sqrt(r);
        })(this.p, n)),
        (this.max = this.d + this.h * Math.SQRT2);
    }
    var ud;
    (t.aI = void 0),
      ((ud = t.aI || (t.aI = {}))[(ud.center = 1)] = 'center'),
      (ud[(ud.left = 2)] = 'left'),
      (ud[(ud.right = 3)] = 'right'),
      (ud[(ud.top = 4)] = 'top'),
      (ud[(ud.bottom = 5)] = 'bottom'),
      (ud[(ud['top-left'] = 6)] = 'top-left'),
      (ud[(ud['top-right'] = 7)] = 'top-right'),
      (ud[(ud['bottom-left'] = 8)] = 'bottom-left'),
      (ud[(ud['bottom-right'] = 9)] = 'bottom-right');
    const dd = Number.POSITIVE_INFINITY;
    function pd(t, e) {
      return e[1] !== dd
        ? (function (t, e, i) {
            let r = 0,
              n = 0;
            switch (((e = Math.abs(e)), (i = Math.abs(i)), t)) {
              case 'top-right':
              case 'top-left':
              case 'top':
                n = i - 7;
                break;
              case 'bottom-right':
              case 'bottom-left':
              case 'bottom':
                n = 7 - i;
            }
            switch (t) {
              case 'top-right':
              case 'bottom-right':
              case 'right':
                r = -e;
                break;
              case 'top-left':
              case 'bottom-left':
              case 'left':
                r = e;
            }
            return [r, n];
          })(t, e[0], e[1])
        : (function (t, e) {
            let i = 0,
              r = 0;
            e < 0 && (e = 0);
            const n = e / Math.SQRT2;
            switch (t) {
              case 'top-right':
              case 'top-left':
                r = n - 7;
                break;
              case 'bottom-right':
              case 'bottom-left':
                r = 7 - n;
                break;
              case 'bottom':
                r = 7 - e;
                break;
              case 'top':
                r = e - 7;
            }
            switch (t) {
              case 'top-right':
              case 'bottom-right':
                i = -n;
                break;
              case 'top-left':
              case 'bottom-left':
                i = n;
                break;
              case 'left':
                i = e;
                break;
              case 'right':
                i = -e;
            }
            return [i, r];
          })(t, e[0]);
    }
    function fd(t, e, i) {
      var r;
      const n = t.layout,
        a =
          null === (r = n.get('text-variable-anchor-offset')) || void 0 === r
            ? void 0
            : r.evaluate(e, {}, i);
      if (a) {
        const t = a.values,
          e = [];
        for (let i = 0; i < t.length; i += 2) {
          const r = (e[i] = t[i]),
            n = t[i + 1].map((t) => t * hh);
          r.startsWith('top')
            ? (n[1] -= 7)
            : r.startsWith('bottom') && (n[1] += 7),
            (e[i + 1] = n);
        }
        return new Fe(e);
      }
      const s = n.get('text-variable-anchor');
      if (s) {
        let r;
        r =
          void 0 !== t._unevaluatedLayout.getValue('text-radial-offset')
            ? [n.get('text-radial-offset').evaluate(e, {}, i) * hh, dd]
            : n
                .get('text-offset')
                .evaluate(e, {}, i)
                .map((t) => t * hh);
        const a = [];
        for (const t of s) a.push(t, pd(t, r));
        return new Fe(a);
      }
      return null;
    }
    function md(t) {
      switch (t) {
        case 'right':
        case 'top-right':
        case 'bottom-right':
          return 'right';
        case 'left':
        case 'top-left':
        case 'bottom-left':
          return 'left';
      }
      return 'center';
    }
    function gd(e, i, r, n, a, s, o, l, c, h, u, d) {
      let p = s.textMaxSize.evaluate(i, {});
      void 0 === p && (p = o);
      const f = e.layers[0].layout,
        m = f.get('icon-offset').evaluate(i, {}, u),
        g = yd(r.horizontal),
        _ = o / 24,
        y = e.tilePixelRatio * _,
        v = (e.tilePixelRatio * p) / 24,
        x = e.tilePixelRatio * l,
        b = e.tilePixelRatio * f.get('symbol-spacing'),
        w = f.get('text-padding') * e.tilePixelRatio,
        T = (function (t, e, i, r = 1) {
          const n = t.get('icon-padding').evaluate(e, {}, i),
            a = n && n.values;
          return [a[0] * r, a[1] * r, a[2] * r, a[3] * r];
        })(f, i, u, e.tilePixelRatio),
        P = (f.get('text-max-angle') / 180) * Math.PI,
        C =
          'viewport' !== f.get('text-rotation-alignment') &&
          'point' !== f.get('symbol-placement'),
        I =
          'map' === f.get('icon-rotation-alignment') &&
          'point' !== f.get('symbol-placement'),
        S = f.get('symbol-placement'),
        M = b / 2,
        L = f.get('icon-text-fit');
      let A;
      n &&
        'none' !== L &&
        (e.allowVerticalPlacement &&
          r.vertical &&
          (A = tu(n, r.vertical, L, f.get('icon-text-fit-padding'), m, _)),
        g && (n = tu(n, g, L, f.get('icon-text-fit-padding'), m, _)));
      const E = u ? d.line.getGranularityForZoomLevel(u.z) : 1,
        R = (l, d) => {
          d.x < 0 ||
            d.x >= D ||
            d.y < 0 ||
            d.y >= D ||
            (function (
              e,
              i,
              r,
              n,
              a,
              s,
              o,
              l,
              c,
              h,
              u,
              d,
              p,
              f,
              m,
              g,
              _,
              y,
              v,
              x,
              b,
              w,
              T,
              P,
              C
            ) {
              const I = e.addToLineVertexArray(i, r);
              let S,
                M,
                D,
                L,
                A = 0,
                E = 0,
                R = 0,
                z = 0,
                k = -1,
                O = -1;
              const F = {};
              let B = po('');
              if (e.allowVerticalPlacement && n.vertical) {
                const t = l.layout.get('text-rotate').evaluate(b, {}, P) + 90;
                (D = new sd(c, i, h, u, d, n.vertical, p, f, m, t)),
                  o && (L = new sd(c, i, h, u, d, o, _, y, m, t));
              }
              if (a) {
                const r = l.layout.get('icon-rotate').evaluate(b, {}),
                  n = 'none' !== l.layout.get('icon-text-fit'),
                  s = ed(a, r, T, n),
                  p = o ? ed(o, r, T, n) : void 0;
                (M = new sd(c, i, h, u, d, a, _, y, !1, r)), (A = 4 * s.length);
                const f = e.iconSizeData;
                let m = null;
                'source' === f.kind
                  ? ((m = [eu * l.layout.get('icon-size').evaluate(b, {})]),
                    m[0] > iu &&
                      Z(
                        `${e.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`
                      ))
                  : 'composite' === f.kind &&
                    ((m = [
                      eu * w.compositeIconSizes[0].evaluate(b, {}, P),
                      eu * w.compositeIconSizes[1].evaluate(b, {}, P),
                    ]),
                    (m[0] > iu || m[1] > iu) &&
                      Z(
                        `${e.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`
                      )),
                  e.addSymbols(
                    e.icon,
                    s,
                    m,
                    x,
                    v,
                    b,
                    t.as.none,
                    i,
                    I.lineStartIndex,
                    I.lineLength,
                    -1,
                    P
                  ),
                  (k = e.icon.placedSymbolArray.length - 1),
                  p &&
                    ((E = 4 * p.length),
                    e.addSymbols(
                      e.icon,
                      p,
                      m,
                      x,
                      v,
                      b,
                      t.as.vertical,
                      i,
                      I.lineStartIndex,
                      I.lineLength,
                      -1,
                      P
                    ),
                    (O = e.icon.placedSymbolArray.length - 1));
              }
              const N = Object.keys(n.horizontal);
              for (const Z of N) {
                const r = n.horizontal[Z];
                if (!S) {
                  B = po(r.text);
                  const t = l.layout.get('text-rotate').evaluate(b, {}, P);
                  S = new sd(c, i, h, u, d, r, p, f, m, t);
                }
                const a = 1 === r.positionedLines.length;
                if (
                  ((R += _d(
                    e,
                    i,
                    r,
                    s,
                    l,
                    m,
                    b,
                    g,
                    I,
                    n.vertical ? t.as.horizontal : t.as.horizontalOnly,
                    a ? N : [Z],
                    F,
                    k,
                    w,
                    P
                  )),
                  a)
                )
                  break;
              }
              n.vertical &&
                (z += _d(
                  e,
                  i,
                  n.vertical,
                  s,
                  l,
                  m,
                  b,
                  g,
                  I,
                  t.as.vertical,
                  ['vertical'],
                  F,
                  O,
                  w,
                  P
                ));
              const V = S ? S.boxStartIndex : e.collisionBoxArray.length,
                j = S ? S.boxEndIndex : e.collisionBoxArray.length,
                U = D ? D.boxStartIndex : e.collisionBoxArray.length,
                G = D ? D.boxEndIndex : e.collisionBoxArray.length,
                $ = M ? M.boxStartIndex : e.collisionBoxArray.length,
                q = M ? M.boxEndIndex : e.collisionBoxArray.length,
                H = L ? L.boxStartIndex : e.collisionBoxArray.length,
                W = L ? L.boxEndIndex : e.collisionBoxArray.length;
              let X = -1;
              const Y = (t, e) =>
                t && t.circleDiameter ? Math.max(t.circleDiameter, e) : e;
              (X = Y(S, X)), (X = Y(D, X)), (X = Y(M, X)), (X = Y(L, X));
              const K = X > -1 ? 1 : 0;
              K && (X *= C / hh),
                e.glyphOffsetArray.length >= uu.MAX_GLYPHS &&
                  Z(
                    'Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907'
                  ),
                void 0 !== b.sortKey &&
                  e.addToSortKeyRanges(e.symbolInstances.length, b.sortKey);
              const J = fd(l, b, P),
                [Q, tt] = (function (e, i) {
                  const r = e.length,
                    n = null == i ? void 0 : i.values;
                  if ((null == n ? void 0 : n.length) > 0)
                    for (let a = 0; a < n.length; a += 2) {
                      const i = n[a + 1];
                      e.emplaceBack(t.aI[n[a]], i[0], i[1]);
                    }
                  return [r, e.length];
                })(e.textAnchorOffsets, J);
              e.symbolInstances.emplaceBack(
                i.x,
                i.y,
                F.right >= 0 ? F.right : -1,
                F.center >= 0 ? F.center : -1,
                F.left >= 0 ? F.left : -1,
                F.vertical || -1,
                k,
                O,
                B,
                V,
                j,
                U,
                G,
                $,
                q,
                H,
                W,
                h,
                R,
                z,
                A,
                E,
                K,
                0,
                p,
                X,
                Q,
                tt
              );
            })(
              e,
              d,
              l,
              r,
              n,
              a,
              A,
              e.layers[0],
              e.collisionBoxArray,
              i.index,
              i.sourceLayerIndex,
              e.index,
              y,
              [w, w, w, w],
              C,
              c,
              x,
              T,
              I,
              m,
              i,
              s,
              h,
              u,
              o
            );
        };
      if ('line' === S)
        for (const t of qu(i.geometry, 0, 0, D, D)) {
          const i = pc(t, E),
            a = Qu(i, b, P, r.vertical || g, n, 24, v, e.overscaling, D);
          for (const t of a) (g && vd(e, g.text, M, t)) || R(i, t);
        }
      else if ('line-center' === S) {
        for (const t of i.geometry)
          if (t.length > 1) {
            const e = pc(t, E),
              i = Ju(e, P, r.vertical || g, n, 24, v);
            i && R(e, i);
          }
      } else if ('Polygon' === i.type)
        for (const t of tr(i.geometry, 0)) {
          const e = ld(t, 16);
          R(pc(t[0], E, !0), new Hu(e.x, e.y, 0));
        }
      else if ('LineString' === i.type)
        for (const t of i.geometry) {
          const e = pc(t, E);
          R(e, new Hu(e[0].x, e[0].y, 0));
        }
      else if ('Point' === i.type)
        for (const t of i.geometry)
          for (const e of t) R([e], new Hu(e.x, e.y, 0));
    }
    function _d(t, e, r, n, a, s, o, l, c, h, u, d, p, f, m) {
      const g = (function (t, e, r, n, a, s, o, l) {
          const c =
              (n.layout.get('text-rotate').evaluate(s, {}) * Math.PI) / 180,
            h = [];
          for (const u of e.positionedLines)
            for (const t of u.positionedGlyphs) {
              if (!t.rect) continue;
              const n = t.rect || {};
              let s = 4,
                d = !0,
                p = 1,
                f = 0;
              const m = (a || l) && t.vertical,
                g = (t.metrics.advance * t.scale) / 2;
              if (
                (l &&
                  e.verticalizable &&
                  (f =
                    u.lineOffset / 2 -
                    (t.imageName
                      ? -(hh - t.metrics.width * t.scale) / 2
                      : (t.scale - 1) * hh)),
                t.imageName)
              ) {
                const e = o[t.imageName];
                (d = e.sdf), (p = e.pixelRatio), (s = 1 / p);
              }
              const _ = a ? [t.x + g, t.y] : [0, 0];
              let y = a ? [0, 0] : [t.x + g + r[0], t.y + r[1] - f],
                v = [0, 0];
              m && ((v = y), (y = [0, 0]));
              const x = t.metrics.isDoubleResolution ? 2 : 1,
                b = (t.metrics.left - s) * t.scale - g + y[0],
                w = (-t.metrics.top - s) * t.scale + y[1],
                T = b + ((n.w / x) * t.scale) / p,
                P = w + ((n.h / x) * t.scale) / p,
                C = new i(b, w),
                I = new i(T, w),
                S = new i(b, P),
                M = new i(T, P);
              if (m) {
                const e = new i(-g, g - -17),
                  r = -Math.PI / 2,
                  n = 12 - g,
                  a = new i(22 - n, -(t.imageName ? n : 0)),
                  s = new i(...v);
                C._rotateAround(r, e)._add(a)._add(s),
                  I._rotateAround(r, e)._add(a)._add(s),
                  S._rotateAround(r, e)._add(a)._add(s),
                  M._rotateAround(r, e)._add(a)._add(s);
              }
              if (c) {
                const t = Math.sin(c),
                  e = Math.cos(c),
                  i = [e, -t, t, e];
                C._matMult(i), I._matMult(i), S._matMult(i), M._matMult(i);
              }
              const D = new i(0, 0),
                L = new i(0, 0);
              h.push({
                tl: C,
                tr: I,
                bl: S,
                br: M,
                tex: n,
                writingMode: e.writingMode,
                glyphOffset: _,
                sectionIndex: t.sectionIndex,
                isSDF: d,
                pixelOffsetTL: D,
                pixelOffsetBR: L,
                minFontScaleX: 0,
                minFontScaleY: 0,
              });
            }
          return h;
        })(0, r, l, a, s, o, n, t.allowVerticalPlacement),
        _ = t.textSizeData;
      let y = null;
      'source' === _.kind
        ? ((y = [eu * a.layout.get('text-size').evaluate(o, {})]),
          y[0] > iu &&
            Z(
              `${t.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`
            ))
        : 'composite' === _.kind &&
          ((y = [
            eu * f.compositeTextSizes[0].evaluate(o, {}, m),
            eu * f.compositeTextSizes[1].evaluate(o, {}, m),
          ]),
          (y[0] > iu || y[1] > iu) &&
            Z(
              `${t.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`
            )),
        t.addSymbols(
          t.text,
          g,
          y,
          l,
          s,
          o,
          h,
          e,
          c.lineStartIndex,
          c.lineLength,
          p,
          m
        );
      for (const i of u) d[i] = t.text.placedSymbolArray.length - 1;
      return 4 * g.length;
    }
    function yd(t) {
      for (const e in t) return t[e];
      return null;
    }
    function vd(t, e, i, r) {
      const n = t.compareText;
      if (e in n) {
        const t = n[e];
        for (let e = t.length - 1; e >= 0; e--) if (r.dist(t[e]) < i) return !0;
      } else n[e] = [];
      return n[e].push(r), !1;
    }
    const xd = [
      Int8Array,
      Uint8Array,
      Uint8ClampedArray,
      Int16Array,
      Uint16Array,
      Int32Array,
      Uint32Array,
      Float32Array,
      Float64Array,
    ];
    class bd {
      static from(t) {
        if (!(t instanceof ArrayBuffer))
          throw new Error('Data must be an instance of ArrayBuffer.');
        const [e, i] = new Uint8Array(t, 0, 2);
        if (219 !== e)
          throw new Error('Data does not appear to be in a KDBush format.');
        const r = i >> 4;
        if (1 !== r) throw new Error(`Got v${r} data when expected v1.`);
        const n = xd[15 & i];
        if (!n) throw new Error('Unrecognized array type.');
        const [a] = new Uint16Array(t, 2, 1),
          [s] = new Uint32Array(t, 4, 1);
        return new bd(s, a, n, t);
      }
      constructor(t, e = 64, i = Float64Array, r) {
        if (isNaN(t) || t < 0)
          throw new Error(`Unpexpected numItems value: ${t}.`);
        (this.numItems = +t),
          (this.nodeSize = Math.min(Math.max(+e, 2), 65535)),
          (this.ArrayType = i),
          (this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array);
        const n = xd.indexOf(this.ArrayType),
          a = 2 * t * this.ArrayType.BYTES_PER_ELEMENT,
          s = t * this.IndexArrayType.BYTES_PER_ELEMENT,
          o = (8 - (s % 8)) % 8;
        if (n < 0) throw new Error(`Unexpected typed array class: ${i}.`);
        r && r instanceof ArrayBuffer
          ? ((this.data = r),
            (this.ids = new this.IndexArrayType(this.data, 8, t)),
            (this.coords = new this.ArrayType(this.data, 8 + s + o, 2 * t)),
            (this._pos = 2 * t),
            (this._finished = !0))
          : ((this.data = new ArrayBuffer(8 + a + s + o)),
            (this.ids = new this.IndexArrayType(this.data, 8, t)),
            (this.coords = new this.ArrayType(this.data, 8 + s + o, 2 * t)),
            (this._pos = 0),
            (this._finished = !1),
            new Uint8Array(this.data, 0, 2).set([219, 16 + n]),
            (new Uint16Array(this.data, 2, 1)[0] = e),
            (new Uint32Array(this.data, 4, 1)[0] = t));
      }
      add(t, e) {
        const i = this._pos >> 1;
        return (
          (this.ids[i] = i),
          (this.coords[this._pos++] = t),
          (this.coords[this._pos++] = e),
          i
        );
      }
      finish() {
        const t = this._pos >> 1;
        if (t !== this.numItems)
          throw new Error(`Added ${t} items when expected ${this.numItems}.`);
        return (
          wd(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0),
          (this._finished = !0),
          this
        );
      }
      range(t, e, i, r) {
        if (!this._finished)
          throw new Error('Data not yet indexed - call index.finish().');
        const { ids: n, coords: a, nodeSize: s } = this,
          o = [0, n.length - 1, 0],
          l = [];
        for (; o.length; ) {
          const c = o.pop() || 0,
            h = o.pop() || 0,
            u = o.pop() || 0;
          if (h - u <= s) {
            for (let s = u; s <= h; s++) {
              const o = a[2 * s],
                c = a[2 * s + 1];
              o >= t && o <= i && c >= e && c <= r && l.push(n[s]);
            }
            continue;
          }
          const d = (u + h) >> 1,
            p = a[2 * d],
            f = a[2 * d + 1];
          p >= t && p <= i && f >= e && f <= r && l.push(n[d]),
            (0 === c ? t <= p : e <= f) &&
              (o.push(u), o.push(d - 1), o.push(1 - c)),
            (0 === c ? i >= p : r >= f) &&
              (o.push(d + 1), o.push(h), o.push(1 - c));
        }
        return l;
      }
      within(t, e, i) {
        if (!this._finished)
          throw new Error('Data not yet indexed - call index.finish().');
        const { ids: r, coords: n, nodeSize: a } = this,
          s = [0, r.length - 1, 0],
          o = [],
          l = i * i;
        for (; s.length; ) {
          const c = s.pop() || 0,
            h = s.pop() || 0,
            u = s.pop() || 0;
          if (h - u <= a) {
            for (let i = u; i <= h; i++)
              Id(n[2 * i], n[2 * i + 1], t, e) <= l && o.push(r[i]);
            continue;
          }
          const d = (u + h) >> 1,
            p = n[2 * d],
            f = n[2 * d + 1];
          Id(p, f, t, e) <= l && o.push(r[d]),
            (0 === c ? t - i <= p : e - i <= f) &&
              (s.push(u), s.push(d - 1), s.push(1 - c)),
            (0 === c ? t + i >= p : e + i >= f) &&
              (s.push(d + 1), s.push(h), s.push(1 - c));
        }
        return o;
      }
    }
    function wd(t, e, i, r, n, a) {
      if (n - r <= i) return;
      const s = (r + n) >> 1;
      Td(t, e, s, r, n, a),
        wd(t, e, i, r, s - 1, 1 - a),
        wd(t, e, i, s + 1, n, 1 - a);
    }
    function Td(t, e, i, r, n, a) {
      for (; n > r; ) {
        if (n - r > 600) {
          const s = n - r + 1,
            o = i - r + 1,
            l = Math.log(s),
            c = 0.5 * Math.exp((2 * l) / 3),
            h =
              0.5 * Math.sqrt((l * c * (s - c)) / s) * (o - s / 2 < 0 ? -1 : 1);
          Td(
            t,
            e,
            i,
            Math.max(r, Math.floor(i - (o * c) / s + h)),
            Math.min(n, Math.floor(i + ((s - o) * c) / s + h)),
            a
          );
        }
        const s = e[2 * i + a];
        let o = r,
          l = n;
        for (Pd(t, e, r, i), e[2 * n + a] > s && Pd(t, e, r, n); o < l; ) {
          for (Pd(t, e, o, l), o++, l--; e[2 * o + a] < s; ) o++;
          for (; e[2 * l + a] > s; ) l--;
        }
        e[2 * r + a] === s ? Pd(t, e, r, l) : (l++, Pd(t, e, l, n)),
          l <= i && (r = l + 1),
          i <= l && (n = l - 1);
      }
    }
    function Pd(t, e, i, r) {
      Cd(t, i, r), Cd(e, 2 * i, 2 * r), Cd(e, 2 * i + 1, 2 * r + 1);
    }
    function Cd(t, e, i) {
      const r = t[e];
      (t[e] = t[i]), (t[i] = r);
    }
    function Id(t, e, i, r) {
      const n = t - i,
        a = e - r;
      return n * n + a * a;
    }
    var Sd;
    (t.cA = void 0),
      ((Sd = t.cA || (t.cA = {})).create = 'create'),
      (Sd.load = 'load'),
      (Sd.fullLoad = 'fullLoad');
    let Md = null,
      Dd = [];
    const Ld = 1e3 / 60,
      Ad = 'loadTime',
      Ed = 'fullLoadTime',
      Rd = {
        mark(t) {
          performance.mark(t);
        },
        frame(t) {
          const e = t;
          null != Md && Dd.push(e - Md), (Md = e);
        },
        clearMetrics() {
          (Md = null),
            (Dd = []),
            performance.clearMeasures(Ad),
            performance.clearMeasures(Ed);
          for (const e in t.cA) performance.clearMarks(t.cA[e]);
        },
        getPerformanceMetrics() {
          performance.measure(Ad, t.cA.create, t.cA.load),
            performance.measure(Ed, t.cA.create, t.cA.fullLoad);
          const e = performance.getEntriesByName(Ad)[0].duration,
            i = performance.getEntriesByName(Ed)[0].duration,
            r = Dd.length,
            n = 1 / (Dd.reduce((t, e) => t + e, 0) / r / 1e3),
            a = Dd.filter((t) => t > Ld).reduce((t, e) => t + (e - Ld) / Ld, 0);
          return {
            loadTime: e,
            fullLoadTime: i,
            fps: n,
            percentDroppedFrames: (a / (r + a)) * 100,
            totalFrames: r,
          };
        },
      };
    (t.$ = K),
      (t.A = p),
      (t.B = ea),
      (t.C = function ([t, e, i]) {
        return (
          (e += 90),
          (e *= Math.PI / 180),
          (i *= Math.PI / 180),
          {
            x: t * Math.cos(e) * Math.sin(i),
            y: t * Math.sin(e) * Math.sin(i),
            z: t * Math.cos(i),
          }
        );
      }),
      (t.D = Va),
      (t.E = yt),
      (t.F = mi),
      (t.G = La),
      (t.H = ra),
      (t.I = Lh),
      (t.J = W),
      (t.K = class {
        constructor(t, e) {
          (this.target = t),
            (this.mapId = e),
            (this.resolveRejects = {}),
            (this.tasks = {}),
            (this.taskQueue = []),
            (this.abortControllers = {}),
            (this.messageHandlers = {}),
            (this.invoker = new bu(() => this.process())),
            (this.subscription = tt(
              this.target,
              'message',
              (t) => this.receive(t),
              !1
            )),
            (this.globalScope = q(self) ? t : window);
        }
        registerMessageHandler(t, e) {
          this.messageHandlers[t] = e;
        }
        sendAsync(t, e) {
          return new Promise((i, r) => {
            const n = Math.round(1e18 * Math.random())
                .toString(36)
                .substring(0, 10),
              a = e
                ? tt(
                    e.signal,
                    'abort',
                    () => {
                      null == a || a.unsubscribe(),
                        delete this.resolveRejects[n];
                      const e = {
                        id: n,
                        type: '<cancel>',
                        origin: location.origin,
                        targetMapId: t.targetMapId,
                        sourceMapId: this.mapId,
                      };
                      this.target.postMessage(e);
                    },
                    wu
                  )
                : null;
            this.resolveRejects[n] = {
              resolve: (t) => {
                null == a || a.unsubscribe(), i(t);
              },
              reject: (t) => {
                null == a || a.unsubscribe(), r(t);
              },
            };
            const s = [],
              o = Object.assign(Object.assign({}, t), {
                id: n,
                sourceMapId: this.mapId,
                origin: location.origin,
                data: pa(t.data, s),
              });
            this.target.postMessage(o, { transfer: s });
          });
        }
        receive(t) {
          const e = t.data,
            i = e.id;
          if (
            !(
              ('file://' !== e.origin &&
                'file://' !== location.origin &&
                'resource://android' !== e.origin &&
                'resource://android' !== location.origin &&
                e.origin !== location.origin) ||
              (e.targetMapId && this.mapId !== e.targetMapId)
            )
          ) {
            if ('<cancel>' === e.type) {
              delete this.tasks[i];
              const t = this.abortControllers[i];
              return delete this.abortControllers[i], void (t && t.abort());
            }
            if (q(self) || e.mustQueue)
              return (
                (this.tasks[i] = e),
                this.taskQueue.push(i),
                void this.invoker.trigger()
              );
            this.processTask(i, e);
          }
        }
        process() {
          if (0 === this.taskQueue.length) return;
          const t = this.taskQueue.shift(),
            e = this.tasks[t];
          delete this.tasks[t],
            this.taskQueue.length > 0 && this.invoker.trigger(),
            e && this.processTask(t, e);
        }
        processTask(t, i) {
          return e(this, void 0, void 0, function* () {
            if ('<response>' === i.type) {
              const e = this.resolveRejects[t];
              if ((delete this.resolveRejects[t], !e)) return;
              return void (i.error
                ? e.reject(fa(i.error))
                : e.resolve(fa(i.data)));
            }
            if (!this.messageHandlers[i.type])
              return void this.completeTask(
                t,
                new Error(
                  `Could not find a registered handler for ${i.type}, map ID: ${
                    this.mapId
                  }, available handlers: ${Object.keys(
                    this.messageHandlers
                  ).join(', ')}`
                )
              );
            const e = fa(i.data),
              r = new AbortController();
            this.abortControllers[t] = r;
            try {
              const n = yield this.messageHandlers[i.type](i.sourceMapId, e, r);
              this.completeTask(t, null, n);
            } catch (e) {
              this.completeTask(t, e);
            }
          });
        }
        completeTask(t, e, i) {
          const r = [];
          delete this.abortControllers[t];
          const n = {
            id: t,
            type: '<response>',
            sourceMapId: this.mapId,
            origin: location.origin,
            error: e ? pa(e) : null,
            data: pa(i, r),
          };
          this.target.postMessage(n, { transfer: r });
        }
        remove() {
          this.invoker.remove(), this.subscription.unsubscribe();
        }
      }),
      (t.L = ct),
      (t.M = function () {
        var t = new p(16);
        return (
          p != Float32Array &&
            ((t[1] = 0),
            (t[2] = 0),
            (t[3] = 0),
            (t[4] = 0),
            (t[6] = 0),
            (t[7] = 0),
            (t[8] = 0),
            (t[9] = 0),
            (t[11] = 0),
            (t[12] = 0),
            (t[13] = 0),
            (t[14] = 0)),
          (t[0] = 1),
          (t[5] = 1),
          (t[10] = 1),
          (t[15] = 1),
          t
        );
      }),
      (t.N = function (t, e, i) {
        var r,
          n,
          a,
          s,
          o,
          l,
          c,
          h,
          u,
          d,
          p,
          f,
          m = i[0],
          g = i[1],
          _ = i[2];
        return (
          e === t
            ? ((t[12] = e[0] * m + e[4] * g + e[8] * _ + e[12]),
              (t[13] = e[1] * m + e[5] * g + e[9] * _ + e[13]),
              (t[14] = e[2] * m + e[6] * g + e[10] * _ + e[14]),
              (t[15] = e[3] * m + e[7] * g + e[11] * _ + e[15]))
            : ((n = e[1]),
              (a = e[2]),
              (s = e[3]),
              (o = e[4]),
              (l = e[5]),
              (c = e[6]),
              (h = e[7]),
              (u = e[8]),
              (d = e[9]),
              (p = e[10]),
              (f = e[11]),
              (t[0] = r = e[0]),
              (t[1] = n),
              (t[2] = a),
              (t[3] = s),
              (t[4] = o),
              (t[5] = l),
              (t[6] = c),
              (t[7] = h),
              (t[8] = u),
              (t[9] = d),
              (t[10] = p),
              (t[11] = f),
              (t[12] = r * m + o * g + u * _ + e[12]),
              (t[13] = n * m + l * g + d * _ + e[13]),
              (t[14] = a * m + c * g + p * _ + e[14]),
              (t[15] = s * m + h * g + f * _ + e[15])),
          t
        );
      }),
      (t.O = function (t, e, i) {
        var r = i[0],
          n = i[1],
          a = i[2];
        return (
          (t[0] = e[0] * r),
          (t[1] = e[1] * r),
          (t[2] = e[2] * r),
          (t[3] = e[3] * r),
          (t[4] = e[4] * n),
          (t[5] = e[5] * n),
          (t[6] = e[6] * n),
          (t[7] = e[7] * n),
          (t[8] = e[8] * a),
          (t[9] = e[9] * a),
          (t[10] = e[10] * a),
          (t[11] = e[11] * a),
          (t[12] = e[12]),
          (t[13] = e[13]),
          (t[14] = e[14]),
          (t[15] = e[15]),
          t
        );
      }),
      (t.P = i),
      (t.Q = function (t, e, i) {
        var r = e[0],
          n = e[1],
          a = e[2],
          s = e[3],
          o = e[4],
          l = e[5],
          c = e[6],
          h = e[7],
          u = e[8],
          d = e[9],
          p = e[10],
          f = e[11],
          m = e[12],
          g = e[13],
          _ = e[14],
          y = e[15],
          v = i[0],
          x = i[1],
          b = i[2],
          w = i[3];
        return (
          (t[0] = v * r + x * o + b * u + w * m),
          (t[1] = v * n + x * l + b * d + w * g),
          (t[2] = v * a + x * c + b * p + w * _),
          (t[3] = v * s + x * h + b * f + w * y),
          (t[4] =
            (v = i[4]) * r + (x = i[5]) * o + (b = i[6]) * u + (w = i[7]) * m),
          (t[5] = v * n + x * l + b * d + w * g),
          (t[6] = v * a + x * c + b * p + w * _),
          (t[7] = v * s + x * h + b * f + w * y),
          (t[8] =
            (v = i[8]) * r +
            (x = i[9]) * o +
            (b = i[10]) * u +
            (w = i[11]) * m),
          (t[9] = v * n + x * l + b * d + w * g),
          (t[10] = v * a + x * c + b * p + w * _),
          (t[11] = v * s + x * h + b * f + w * y),
          (t[12] =
            (v = i[12]) * r +
            (x = i[13]) * o +
            (b = i[14]) * u +
            (w = i[15]) * m),
          (t[13] = v * n + x * l + b * d + w * g),
          (t[14] = v * a + x * c + b * p + w * _),
          (t[15] = v * s + x * h + b * f + w * y),
          t
        );
      }),
      (t.R = vl),
      (t.S = function (t, e) {
        const i = {};
        for (let r = 0; r < e.length; r++) {
          const n = e[r];
          n in t && (i[n] = t[n]);
        }
        return i;
      }),
      (t.T = Ml),
      (t.U = Pu),
      (t.V = F),
      (t.W = Mu),
      (t.X = Su),
      (t.Y = h),
      (t.Z = u),
      (t._ = e),
      (t.a = ot),
      (t.a$ = function (t, e, i) {
        return (
          (t[0] = e[0] * i[0]),
          (t[1] = e[1] * i[1]),
          (t[2] = e[2] * i[2]),
          (t[3] = e[3] * i[3]),
          t
        );
      }),
      (t.a0 = Fu),
      (t.a1 = Lu),
      (t.a2 = Au),
      (t.a3 = D),
      (t.a4 = function (t, e) {
        var i, r, n, a, s;
        if (!t) return null != e ? e : {};
        if (!e) return t;
        let o = Object.assign({}, t);
        if ((e.removeAll && (o = { removeAll: !0 }), e.remove)) {
          const r = new Set(e.remove);
          o.add && (o.add = o.add.filter((t) => !r.has(t.id))),
            o.update && (o.update = o.update.filter((t) => !r.has(t.id)));
          const n = new Set(
            (null !== (i = t.add) && void 0 !== i ? i : []).map((t) => t.id)
          );
          e.remove = e.remove.filter((t) => !n.has(t));
        }
        if (e.remove) {
          const t = new Set(o.remove ? o.remove.concat(e.remove) : e.remove);
          o.remove = Array.from(t.values());
        }
        if (e.add) {
          const t = o.add ? o.add.concat(e.add) : e.add,
            i = new Map(t.map((t) => [t.id, t]));
          o.add = Array.from(i.values());
        }
        if (e.update) {
          const t = new Map(
            null === (r = o.update) || void 0 === r
              ? void 0
              : r.map((t) => [t.id, t])
          );
          for (const i of e.update) {
            const e =
              null !== (n = t.get(i.id)) && void 0 !== n ? n : { id: i.id };
            i.newGeometry && (e.newGeometry = i.newGeometry),
              i.addOrUpdateProperties &&
                (e.addOrUpdateProperties = (
                  null !== (a = e.addOrUpdateProperties) && void 0 !== a
                    ? a
                    : []
                ).concat(i.addOrUpdateProperties)),
              i.removeProperties &&
                (e.removeProperties = (
                  null !== (s = e.removeProperties) && void 0 !== s ? s : []
                ).concat(i.removeProperties)),
              i.removeAllProperties && (e.removeAllProperties = !0),
              t.set(i.id, e);
          }
          o.update = Array.from(t.values());
        }
        return (
          o.remove &&
            o.add &&
            (o.remove = o.remove.filter(
              (t) => -1 === o.add.findIndex((e) => e.id === t)
            )),
          o
        );
      }),
      (t.a5 = Ru),
      (t.a6 = Vu),
      (t.a7 = 25),
      (t.a8 = ku),
      (t.a9 = (t) => {
        const e = window.document.createElement('video');
        return (
          (e.muted = !0),
          new Promise((i) => {
            e.onloadstart = () => {
              i(e);
            };
            for (const r of t) {
              const t = window.document.createElement('source');
              pt(r) || (e.crossOrigin = 'Anonymous'),
                (t.src = r),
                e.appendChild(t);
            }
          })
        );
      }),
      (t.aA = P),
      (t.aB = function (t, e, r, n) {
        const a = e.y - t.y,
          s = e.x - t.x,
          o = n.y - r.y,
          l = n.x - r.x,
          c = o * s - l * a;
        if (0 === c) return null;
        const h = (l * (t.y - r.y) - o * (t.x - r.x)) / c;
        return new i(t.x + h * s, t.y + h * a);
      }),
      (t.aC = qu),
      (t.aD = Uo),
      (t.aE = function (t) {
        let e = 1 / 0,
          i = 1 / 0,
          r = -1 / 0,
          n = -1 / 0;
        for (const a of t)
          (e = Math.min(e, a.x)),
            (i = Math.min(i, a.y)),
            (r = Math.max(r, a.x)),
            (n = Math.max(n, a.y));
        return [e, i, r, n];
      }),
      (t.aF = hh),
      (t.aG = L),
      (t.aH = function (t, e, i, r, n = !1) {
        if (!i[0] && !i[1]) return [0, 0];
        const a = n
          ? 'map' === r
            ? -t.bearingInRadians
            : 0
          : 'viewport' === r
          ? t.bearingInRadians
          : 0;
        if (a) {
          const t = Math.sin(a),
            e = Math.cos(a);
          i = [i[0] * e - i[1] * t, i[0] * t + i[1] * e];
        }
        return [n ? i[0] : L(e, i[0], t.zoom), n ? i[1] : L(e, i[1], t.zoom)];
      }),
      (t.aJ = nu),
      (t.aK = md),
      (t.aL = $h),
      (t.aM = bd),
      (t.aN = ts),
      (t.aO = lc),
      (t.aP = Bs),
      (t.aQ = eo),
      (t.aR = Ks),
      (t.aS = it),
      (t.aT = Eu),
      (t.aU = x),
      (t.aV = v),
      (t.aW = function (t) {
        var e = new p(3);
        return (e[0] = t[0]), (e[1] = t[1]), (e[2] = t[2]), e;
      }),
      (t.aX = function (t, e, i) {
        return (
          (t[0] = e[0] - i[0]), (t[1] = e[1] - i[1]), (t[2] = e[2] - i[2]), t
        );
      }),
      (t.aY = function (t, e) {
        var i = e[0],
          r = e[1],
          n = e[2],
          a = i * i + r * r + n * n;
        return (
          a > 0 && (a = 1 / Math.sqrt(a)),
          (t[0] = e[0] * a),
          (t[1] = e[1] * a),
          (t[2] = e[2] * a),
          t
        );
      }),
      (t.aZ = b),
      (t.a_ = function (t, e) {
        return t[0] * e[0] + t[1] * e[1] + t[2] * e[2];
      }),
      (t.aa = At),
      (t.ab = function () {
        return N++;
      }),
      (t.ac = Ss),
      (t.ad = uu),
      (t.ae = pn),
      (t.af = Bo),
      (t.ag = Uu),
      (t.ah = function (t) {
        const e = {};
        if (
          (t.replace(
            /(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g,
            (t, i, r, n) => {
              const a = r || n;
              return (e[i] = !a || a.toLowerCase()), '';
            }
          ),
          e['max-age'])
        ) {
          const t = parseInt(e['max-age'], 10);
          isNaN(t) ? delete e['max-age'] : (e['max-age'] = t);
        }
        return e;
      }),
      (t.ai = O),
      (t.aj = 85.051129),
      (t.ak = et),
      (t.al = function (t) {
        return Math.pow(2, t);
      }),
      (t.am = m),
      (t.an = Du),
      (t.ao = function (t) {
        return Math.log(t) / Math.LN2;
      }),
      (t.ap = function (t) {
        var e = t[0],
          i = t[1];
        return e * e + i * i;
      }),
      (t.aq = function (t) {
        if (!t.length) return new Set();
        const e = Math.max(...t.map((t) => t.canonical.z));
        let i = 1 / 0,
          r = -1 / 0,
          n = 1 / 0,
          a = -1 / 0;
        const s = [];
        for (const l of t) {
          const { x: t, y: o, z: c } = l.canonical,
            h = Math.pow(2, e - c),
            u = t * h,
            d = o * h;
          s.push({ id: l, x: u, y: d }),
            u < i && (i = u),
            u > r && (r = u),
            d < n && (n = d),
            d > a && (a = d);
        }
        const o = new Set();
        for (const l of s)
          (l.x !== i && l.x !== r && l.y !== n && l.y !== a) || o.add(l.id);
        return o;
      }),
      (t.ar = function (t, e) {
        let i = 0,
          r = 0;
        if ('constant' === t.kind) r = t.layoutSize;
        else if ('source' !== t.kind) {
          const { interpolationType: n, minZoom: a, maxZoom: s } = t,
            o = n ? O(pi.interpolationFactor(n, e, a, s), 0, 1) : 0;
          'camera' === t.kind
            ? (r = mi.number(t.minSize, t.maxSize, o))
            : (i = o);
        }
        return { uSizeT: i, uSize: r };
      }),
      (t.at = function (
        t,
        { uSize: e, uSizeT: i },
        { lowerSize: r, upperSize: n }
      ) {
        return 'source' === t.kind
          ? r / eu
          : 'composite' === t.kind
          ? mi.number(r / eu, n / eu, i)
          : e;
      }),
      (t.au = function (t, e) {
        var i = e[0],
          r = e[1],
          n = e[2],
          a = e[3],
          s = e[4],
          o = e[5],
          l = e[6],
          c = e[7],
          h = e[8],
          u = e[9],
          d = e[10],
          p = e[11],
          f = e[12],
          m = e[13],
          g = e[14],
          _ = e[15],
          y = i * o - r * s,
          v = i * l - n * s,
          x = i * c - a * s,
          b = r * l - n * o,
          w = r * c - a * o,
          T = n * c - a * l,
          P = h * m - u * f,
          C = h * g - d * f,
          I = h * _ - p * f,
          S = u * g - d * m,
          M = u * _ - p * m,
          D = d * _ - p * g,
          L = y * D - v * M + x * S + b * I - w * C + T * P;
        return L
          ? ((t[0] = (o * D - l * M + c * S) * (L = 1 / L)),
            (t[1] = (n * M - r * D - a * S) * L),
            (t[2] = (m * T - g * w + _ * b) * L),
            (t[3] = (d * w - u * T - p * b) * L),
            (t[4] = (l * I - s * D - c * C) * L),
            (t[5] = (i * D - n * I + a * C) * L),
            (t[6] = (g * x - f * T - _ * v) * L),
            (t[7] = (h * T - d * x + p * v) * L),
            (t[8] = (s * M - o * I + c * P) * L),
            (t[9] = (r * I - i * M - a * P) * L),
            (t[10] = (f * w - m * x + _ * y) * L),
            (t[11] = (u * x - h * w - p * y) * L),
            (t[12] = (o * C - s * S - l * P) * L),
            (t[13] = (i * S - r * C + n * P) * L),
            (t[14] = (m * v - f * b - g * y) * L),
            (t[15] = (h * b - u * v + d * y) * L),
            t)
          : null;
      }),
      (t.av = S),
      (t.aw = function (t) {
        var e = t[0],
          i = t[1];
        return Math.sqrt(e * e + i * i);
      }),
      (t.ax = function (t) {
        return (t[0] = 0), (t[1] = 0), t;
      }),
      (t.ay = function (t, e, i) {
        return (t[0] = e[0] * i), (t[1] = e[1] * i), t;
      }),
      (t.az = ou),
      (t.b = X),
      (t.b$ = function (t, e, i) {
        var r = e[0],
          n = e[1],
          a = e[2];
        return (
          (t[0] = r * i[0] + n * i[3] + a * i[6]),
          (t[1] = r * i[1] + n * i[4] + a * i[7]),
          (t[2] = r * i[2] + n * i[5] + a * i[8]),
          t
        );
      }),
      (t.b0 = _),
      (t.b1 = function (t, e, i) {
        const r = e[0] * i[0] + e[1] * i[1] + e[2] * i[2];
        return 0 === r
          ? null
          : (-(t[0] * i[0] + t[1] * i[1] + t[2] * i[2]) - i[3]) / r;
      }),
      (t.b2 = T),
      (t.b3 = function (t, e, i) {
        return (
          (t[0] = e[0] * i),
          (t[1] = e[1] * i),
          (t[2] = e[2] * i),
          (t[3] = e[3] * i),
          t
        );
      }),
      (t.b4 = function (t, e) {
        return t[0] * e[0] + t[1] * e[1] + t[2] * e[2] + t[3];
      }),
      (t.b5 = Ou),
      (t.b6 = Bu),
      (t.b7 = function (t, e, i, r, n) {
        var a = 1 / Math.tan(e / 2);
        if (
          ((t[0] = a / i),
          (t[1] = 0),
          (t[2] = 0),
          (t[3] = 0),
          (t[4] = 0),
          (t[5] = a),
          (t[6] = 0),
          (t[7] = 0),
          (t[8] = 0),
          (t[9] = 0),
          (t[11] = -1),
          (t[12] = 0),
          (t[13] = 0),
          (t[15] = 0),
          null != n && n !== 1 / 0)
        ) {
          var s = 1 / (r - n);
          (t[10] = (n + r) * s), (t[14] = 2 * n * r * s);
        } else (t[10] = -1), (t[14] = -2 * r);
        return t;
      }),
      (t.b8 = function (t) {
        var e = new p(16);
        return (
          (e[0] = t[0]),
          (e[1] = t[1]),
          (e[2] = t[2]),
          (e[3] = t[3]),
          (e[4] = t[4]),
          (e[5] = t[5]),
          (e[6] = t[6]),
          (e[7] = t[7]),
          (e[8] = t[8]),
          (e[9] = t[9]),
          (e[10] = t[10]),
          (e[11] = t[11]),
          (e[12] = t[12]),
          (e[13] = t[13]),
          (e[14] = t[14]),
          (e[15] = t[15]),
          e
        );
      }),
      (t.b9 = function (t, e, i) {
        var r = Math.sin(i),
          n = Math.cos(i),
          a = e[0],
          s = e[1],
          o = e[2],
          l = e[3],
          c = e[4],
          h = e[5],
          u = e[6],
          d = e[7];
        return (
          e !== t &&
            ((t[8] = e[8]),
            (t[9] = e[9]),
            (t[10] = e[10]),
            (t[11] = e[11]),
            (t[12] = e[12]),
            (t[13] = e[13]),
            (t[14] = e[14]),
            (t[15] = e[15])),
          (t[0] = a * n + c * r),
          (t[1] = s * n + h * r),
          (t[2] = o * n + u * r),
          (t[3] = l * n + d * r),
          (t[4] = c * n - a * r),
          (t[5] = h * n - s * r),
          (t[6] = u * n - o * r),
          (t[7] = d * n - l * r),
          t
        );
      }),
      (t.bA = function (t, e, i, r) {
        var n = [],
          a = [];
        return (
          (n[0] = e[0] - i[0]),
          (n[1] = e[1] - i[1]),
          (n[2] = e[2] - i[2]),
          (a[0] = n[0]),
          (a[1] = n[1] * Math.cos(r) - n[2] * Math.sin(r)),
          (a[2] = n[1] * Math.sin(r) + n[2] * Math.cos(r)),
          (t[0] = a[0] + i[0]),
          (t[1] = a[1] + i[1]),
          (t[2] = a[2] + i[2]),
          t
        );
      }),
      (t.bB = function (t, e, i, r) {
        var n = [],
          a = [];
        return (
          (n[0] = e[0] - i[0]),
          (n[1] = e[1] - i[1]),
          (n[2] = e[2] - i[2]),
          (a[0] = n[2] * Math.sin(r) + n[0] * Math.cos(r)),
          (a[1] = n[1]),
          (a[2] = n[2] * Math.cos(r) - n[0] * Math.sin(r)),
          (t[0] = a[0] + i[0]),
          (t[1] = a[1] + i[1]),
          (t[2] = a[2] + i[2]),
          t
        );
      }),
      (t.bC = function (t, e, i) {
        var r = Math.sin(i),
          n = Math.cos(i),
          a = e[0],
          s = e[1],
          o = e[2],
          l = e[3],
          c = e[8],
          h = e[9],
          u = e[10],
          d = e[11];
        return (
          e !== t &&
            ((t[4] = e[4]),
            (t[5] = e[5]),
            (t[6] = e[6]),
            (t[7] = e[7]),
            (t[12] = e[12]),
            (t[13] = e[13]),
            (t[14] = e[14]),
            (t[15] = e[15])),
          (t[0] = a * n - c * r),
          (t[1] = s * n - h * r),
          (t[2] = o * n - u * r),
          (t[3] = l * n - d * r),
          (t[8] = a * r + c * n),
          (t[9] = s * r + h * n),
          (t[10] = o * r + u * n),
          (t[11] = l * r + d * n),
          t
        );
      }),
      (t.bD = function (t, e) {
        const i = A(t, 360),
          r = A(e, 360),
          n = r - i,
          a = r > i ? n - 360 : n + 360;
        return Math.abs(n) < Math.abs(a) ? n : a;
      }),
      (t.bE = function (t) {
        return (t[0] = 0), (t[1] = 0), (t[2] = 0), t;
      }),
      (t.bF = function (t, e, i, r) {
        const n = Math.sqrt(t * t + e * e),
          a = Math.sqrt(i * i + r * r);
        (t /= n), (e /= n), (i /= a), (r /= a);
        const s = Math.acos(t * i + e * r);
        return -e * i + t * r > 0 ? s : -s;
      }),
      (t.bG = function (t, e) {
        const i = A(t, 2 * Math.PI),
          r = A(e, 2 * Math.PI);
        return Math.min(
          Math.abs(i - r),
          Math.abs(i - r + 2 * Math.PI),
          Math.abs(i - r - 2 * Math.PI)
        );
      }),
      (t.bH = function () {
        const t = {},
          e = vt.$version;
        for (const i in vt.$root) {
          const r = vt.$root[i];
          if (r.required) {
            let n = null;
            (n = 'version' === i ? e : 'array' === r.type ? [] : {}),
              null != n && (t[i] = n);
          }
        }
        return t;
      }),
      (t.bI = ma),
      (t.bJ = ut),
      (t.bK = function t(e, i) {
        if (Array.isArray(e)) {
          if (!Array.isArray(i) || e.length !== i.length) return !1;
          for (let r = 0; r < e.length; r++) if (!t(e[r], i[r])) return !1;
          return !0;
        }
        if ('object' == typeof e && null !== e && null !== i) {
          if ('object' != typeof i) return !1;
          if (Object.keys(e).length !== Object.keys(i).length) return !1;
          for (const r in e) if (!t(e[r], i[r])) return !1;
          return !0;
        }
        return e === i;
      }),
      (t.bL = function (t) {
        t = t.slice();
        const e = Object.create(null);
        for (let i = 0; i < t.length; i++) e[t[i].id] = t[i];
        for (let i = 0; i < t.length; i++)
          'ref' in t[i] && (t[i] = bt(t[i], e[t[i].ref]));
        return t;
      }),
      (t.bM = function (t, e) {
        if ('custom' === t.type) return new xu(t, e);
        switch (t.type) {
          case 'background':
            return new vu(t, e);
          case 'circle':
            return new ul(t, e);
          case 'color-relief':
            return new Al(t, e);
          case 'fill':
            return new bc(t, e);
          case 'fill-extrusion':
            return new Vc(t, e);
          case 'heatmap':
            return new wl(t, e);
          case 'hillshade':
            return new Cl(t, e);
          case 'line':
            return new eh(t, e);
          case 'raster':
            return new Ya(t, e);
          case 'symbol':
            return new gu(t, e);
        }
      }),
      (t.bN = (t) => 'raster' === t.type),
      (t.bO = U),
      (t.bP = function (t, e) {
        if (!t) return [{ command: 'setStyle', args: [e] }];
        let i = [];
        try {
          if (!wt(t.version, e.version))
            return [{ command: 'setStyle', args: [e] }];
          wt(t.center, e.center) ||
            i.push({ command: 'setCenter', args: [e.center] }),
            wt(t.state, e.state) ||
              i.push({ command: 'setGlobalState', args: [e.state] }),
            wt(t.centerAltitude, e.centerAltitude) ||
              i.push({
                command: 'setCenterAltitude',
                args: [e.centerAltitude],
              }),
            wt(t.zoom, e.zoom) ||
              i.push({ command: 'setZoom', args: [e.zoom] }),
            wt(t.bearing, e.bearing) ||
              i.push({ command: 'setBearing', args: [e.bearing] }),
            wt(t.pitch, e.pitch) ||
              i.push({ command: 'setPitch', args: [e.pitch] }),
            wt(t.roll, e.roll) ||
              i.push({ command: 'setRoll', args: [e.roll] }),
            wt(t.sprite, e.sprite) ||
              i.push({ command: 'setSprite', args: [e.sprite] }),
            wt(t.glyphs, e.glyphs) ||
              i.push({ command: 'setGlyphs', args: [e.glyphs] }),
            wt(t.transition, e.transition) ||
              i.push({ command: 'setTransition', args: [e.transition] }),
            wt(t.light, e.light) ||
              i.push({ command: 'setLight', args: [e.light] }),
            wt(t.terrain, e.terrain) ||
              i.push({ command: 'setTerrain', args: [e.terrain] }),
            wt(t.sky, e.sky) || i.push({ command: 'setSky', args: [e.sky] }),
            wt(t.projection, e.projection) ||
              i.push({ command: 'setProjection', args: [e.projection] });
          const r = {},
            n = [];
          !(function (t, e, i, r) {
            let n;
            for (n in ((e = e || {}), (t = t || {})))
              Object.prototype.hasOwnProperty.call(t, n) &&
                (Object.prototype.hasOwnProperty.call(e, n) || Ct(n, i, r));
            for (n in e)
              Object.prototype.hasOwnProperty.call(e, n) &&
                (Object.prototype.hasOwnProperty.call(t, n)
                  ? wt(t[n], e[n]) ||
                    ('geojson' === t[n].type &&
                    'geojson' === e[n].type &&
                    St(t, e, n)
                      ? Tt(i, {
                          command: 'setGeoJSONSourceData',
                          args: [n, e[n].data],
                        })
                      : It(n, e, i, r))
                  : Pt(n, e, i));
          })(t.sources, e.sources, n, r);
          const a = [];
          t.layers &&
            t.layers.forEach((t) => {
              'source' in t && r[t.source]
                ? i.push({ command: 'removeLayer', args: [t.id] })
                : a.push(t);
            }),
            (i = i.concat(n)),
            (function (t, e, i) {
              e = e || [];
              const r = (t = t || []).map(Dt),
                n = e.map(Dt),
                a = t.reduce(Lt, {}),
                s = e.reduce(Lt, {}),
                o = r.slice(),
                l = Object.create(null);
              let c, h, u, d, p;
              for (let f = 0, m = 0; f < r.length; f++)
                (c = r[f]),
                  Object.prototype.hasOwnProperty.call(s, c)
                    ? m++
                    : (Tt(i, { command: 'removeLayer', args: [c] }),
                      o.splice(o.indexOf(c, m), 1));
              for (let f = 0, m = 0; f < n.length; f++)
                (c = n[n.length - 1 - f]),
                  o[o.length - 1 - f] !== c &&
                    (Object.prototype.hasOwnProperty.call(a, c)
                      ? (Tt(i, { command: 'removeLayer', args: [c] }),
                        o.splice(o.lastIndexOf(c, o.length - m), 1))
                      : m++,
                    (d = o[o.length - f]),
                    Tt(i, { command: 'addLayer', args: [s[c], d] }),
                    o.splice(o.length - f, 0, c),
                    (l[c] = !0));
              for (let f = 0; f < n.length; f++)
                if (((c = n[f]), (h = a[c]), (u = s[c]), !l[c] && !wt(h, u)))
                  if (
                    wt(h.source, u.source) &&
                    wt(h['source-layer'], u['source-layer']) &&
                    wt(h.type, u.type)
                  ) {
                    for (p in (Mt(
                      h.layout,
                      u.layout,
                      i,
                      c,
                      null,
                      'setLayoutProperty'
                    ),
                    Mt(h.paint, u.paint, i, c, null, 'setPaintProperty'),
                    wt(h.filter, u.filter) ||
                      Tt(i, { command: 'setFilter', args: [c, u.filter] }),
                    (wt(h.minzoom, u.minzoom) && wt(h.maxzoom, u.maxzoom)) ||
                      Tt(i, {
                        command: 'setLayerZoomRange',
                        args: [c, u.minzoom, u.maxzoom],
                      }),
                    h))
                      Object.prototype.hasOwnProperty.call(h, p) &&
                        'layout' !== p &&
                        'paint' !== p &&
                        'filter' !== p &&
                        'metadata' !== p &&
                        'minzoom' !== p &&
                        'maxzoom' !== p &&
                        (0 === p.indexOf('paint.')
                          ? Mt(h[p], u[p], i, c, p.slice(6), 'setPaintProperty')
                          : wt(h[p], u[p]) ||
                            Tt(i, {
                              command: 'setLayerProperty',
                              args: [c, p, u[p]],
                            }));
                    for (p in u)
                      Object.prototype.hasOwnProperty.call(u, p) &&
                        !Object.prototype.hasOwnProperty.call(h, p) &&
                        'layout' !== p &&
                        'paint' !== p &&
                        'filter' !== p &&
                        'metadata' !== p &&
                        'minzoom' !== p &&
                        'maxzoom' !== p &&
                        (0 === p.indexOf('paint.')
                          ? Mt(h[p], u[p], i, c, p.slice(6), 'setPaintProperty')
                          : wt(h[p], u[p]) ||
                            Tt(i, {
                              command: 'setLayerProperty',
                              args: [c, p, u[p]],
                            }));
                  } else
                    Tt(i, { command: 'removeLayer', args: [c] }),
                      (d = o[o.lastIndexOf(c) + 1]),
                      Tt(i, { command: 'addLayer', args: [u, d] });
            })(a, e.layers, i);
        } catch (t) {
          console.warn('Unable to compute style diff:', t),
            (i = [{ command: 'setStyle', args: [e] }]);
        }
        return i;
      }),
      (t.bQ = function (t) {
        const e = [],
          i = t.id;
        return (
          void 0 === i &&
            e.push({ message: `layers.${i}: missing required property "id"` }),
          void 0 === t.render &&
            e.push({
              message: `layers.${i}: missing required method "render"`,
            }),
          t.renderingMode &&
            '2d' !== t.renderingMode &&
            '3d' !== t.renderingMode &&
            e.push({
              message: `layers.${i}: property "renderingMode" must be either "2d" or "3d"`,
            }),
          e
        );
      }),
      (t.bR = V),
      (t.bS = j),
      (t.bT = class extends yo {
        constructor(t, e) {
          super(t, e), (this.current = 0);
        }
        set(t) {
          this.current !== t &&
            ((this.current = t), this.gl.uniform1i(this.location, t));
        }
      }),
      (t.bU = bo),
      (t.bV = class extends yo {
        constructor(t, e) {
          super(t, e), (this.current = wo);
        }
        set(t) {
          if (t[12] !== this.current[12] || t[0] !== this.current[0])
            return (
              (this.current = t),
              void this.gl.uniformMatrix4fv(this.location, !1, t)
            );
          for (let e = 1; e < 16; e++)
            if (t[e] !== this.current[e]) {
              (this.current = t),
                this.gl.uniformMatrix4fv(this.location, !1, t);
              break;
            }
        }
      }),
      (t.bW = xo),
      (t.bX = class extends yo {
        constructor(t, e) {
          super(t, e), (this.current = [0, 0, 0]);
        }
        set(t) {
          (t[0] === this.current[0] &&
            t[1] === this.current[1] &&
            t[2] === this.current[2]) ||
            ((this.current = t),
            this.gl.uniform3f(this.location, t[0], t[1], t[2]));
        }
      }),
      (t.bY = class extends yo {
        constructor(t, e) {
          super(t, e), (this.current = [0, 0]);
        }
        set(t) {
          (t[0] === this.current[0] && t[1] === this.current[1]) ||
            ((this.current = t), this.gl.uniform2f(this.location, t[0], t[1]));
        }
      }),
      (t.bZ = f),
      (t.b_ = function (t, e) {
        var i = Math.sin(e),
          r = Math.cos(e);
        return (
          (t[0] = r),
          (t[1] = i),
          (t[2] = 0),
          (t[3] = -i),
          (t[4] = r),
          (t[5] = 0),
          (t[6] = 0),
          (t[7] = 0),
          (t[8] = 1),
          t
        );
      }),
      (t.ba = function (t, e, i) {
        var r = Math.sin(i),
          n = Math.cos(i),
          a = e[4],
          s = e[5],
          o = e[6],
          l = e[7],
          c = e[8],
          h = e[9],
          u = e[10],
          d = e[11];
        return (
          e !== t &&
            ((t[0] = e[0]),
            (t[1] = e[1]),
            (t[2] = e[2]),
            (t[3] = e[3]),
            (t[12] = e[12]),
            (t[13] = e[13]),
            (t[14] = e[14]),
            (t[15] = e[15])),
          (t[4] = a * n + c * r),
          (t[5] = s * n + h * r),
          (t[6] = o * n + u * r),
          (t[7] = l * n + d * r),
          (t[8] = c * n - a * r),
          (t[9] = h * n - s * r),
          (t[10] = u * n - o * r),
          (t[11] = d * n - l * r),
          t
        );
      }),
      (t.bb = function () {
        const t = new Float32Array(16);
        return m(t), t;
      }),
      (t.bc = function () {
        const t = new Float64Array(16);
        return m(t), t;
      }),
      (t.bd = function () {
        return new Float64Array(16);
      }),
      (t.be = function (t, e, i) {
        const r = new Float64Array(4);
        return I(r, t, e - 90, i), r;
      }),
      (t.bf = function (t, e, i, r) {
        var n,
          a,
          s,
          o,
          l,
          c = e[0],
          h = e[1],
          u = e[2],
          p = e[3],
          f = i[0],
          m = i[1],
          g = i[2],
          _ = i[3];
        return (
          (a = c * f + h * m + u * g + p * _) < 0 &&
            ((a = -a), (f = -f), (m = -m), (g = -g), (_ = -_)),
          1 - a > d
            ? ((n = Math.acos(a)),
              (s = Math.sin(n)),
              (o = Math.sin((1 - r) * n) / s),
              (l = Math.sin(r * n) / s))
            : ((o = 1 - r), (l = r)),
          (t[0] = o * c + l * f),
          (t[1] = o * h + l * m),
          (t[2] = o * u + l * g),
          (t[3] = o * p + l * _),
          t
        );
      }),
      (t.bg = function (t) {
        const e = new Float64Array(9);
        var i, r, n, a, s, o, l, c, h, u, d, p, f, m, g, _, y, v;
        (u = (n = (r = t)[0]) * (l = n + n)),
          (d = (a = r[1]) * l),
          (f = (s = r[2]) * l),
          (m = s * (c = a + a)),
          (_ = (o = r[3]) * l),
          (y = o * c),
          (v = o * (h = s + s)),
          ((i = e)[0] = 1 - (p = a * c) - (g = s * h)),
          (i[3] = d - v),
          (i[6] = f + y),
          (i[1] = d + v),
          (i[4] = 1 - u - g),
          (i[7] = m - _),
          (i[2] = f - y),
          (i[5] = m + _),
          (i[8] = 1 - u - p);
        const x = it(-Math.asin(O(e[2], -1, 1)));
        let b, w;
        return (
          Math.hypot(e[5], e[8]) < 0.001
            ? ((b = 0), (w = -it(Math.atan2(e[3], e[4]))))
            : ((b = it(0 === e[5] && 0 === e[8] ? 0 : Math.atan2(e[5], e[8]))),
              (w = it(0 === e[1] && 0 === e[0] ? 0 : Math.atan2(e[1], e[0])))),
          { roll: b, pitch: x + 90, bearing: w }
        );
      }),
      (t.bh = function (t, e) {
        return t.roll == e.roll && t.pitch == e.pitch && t.bearing == e.bearing;
      }),
      (t.bi = Se),
      (t.bj = vo),
      (t.bk = cc),
      (t.bl = hc),
      (t.bm = oc),
      (t.bn = E),
      (t.bo = R),
      (t.bp = Ne),
      (t.bq = function (t, e, i, r, n) {
        return E(r, n, O((t - e) / (i - e), 0, 1));
      }),
      (t.br = A),
      (t.bs = function () {
        return new Float64Array(3);
      }),
      (t.bt = function (t, e, i, r) {
        return (
          (t[0] = e[0] + i[0] * r),
          (t[1] = e[1] + i[1] * r),
          (t[2] = e[2] + i[2] * r),
          t
        );
      }),
      (t.bu = I),
      (t.bv = function (t, e, i) {
        var r = i[0],
          n = i[1],
          a = i[2],
          s = i[3],
          o = e[0],
          l = e[1],
          c = e[2],
          h = n * c - a * l,
          u = a * o - r * c,
          d = r * l - n * o;
        return (
          (t[0] = o + s * (h += h) + n * (d += d) - a * (u += u)),
          (t[1] = l + s * u + a * h - r * d),
          (t[2] = c + s * d + r * u - n * h),
          t
        );
      }),
      (t.bw = function (t, e, i) {
        const r =
          (n = [t[0], t[1], t[2], e[0], e[1], e[2], i[0], i[1], i[2]])[0] *
            ((h = n[8]) * (s = n[4]) - (o = n[5]) * (c = n[7])) +
          n[1] * (-h * (a = n[3]) + o * (l = n[6])) +
          n[2] * (c * a - s * l);
        var n, a, s, o, l, c, h;
        if (0 === r) return null;
        const u = b([], [e[0], e[1], e[2]], [i[0], i[1], i[2]]),
          d = b([], [i[0], i[1], i[2]], [t[0], t[1], t[2]]),
          p = b([], [t[0], t[1], t[2]], [e[0], e[1], e[2]]),
          f = x([], u, -t[3]);
        return (
          v(f, f, x([], d, -e[3])), v(f, f, x([], p, -i[3])), x(f, f, 1 / r), f
        );
      }),
      (t.bx = Tu),
      (t.by = function () {
        return new Float64Array(4);
      }),
      (t.bz = function (t, e, i, r) {
        var n = [],
          a = [];
        return (
          (n[0] = e[0] - i[0]),
          (n[1] = e[1] - i[1]),
          (n[2] = e[2] - i[2]),
          (a[0] = n[0] * Math.cos(r) - n[1] * Math.sin(r)),
          (a[1] = n[0] * Math.sin(r) + n[1] * Math.cos(r)),
          (a[2] = n[2]),
          (t[0] = a[0] + i[0]),
          (t[1] = a[1] + i[1]),
          (t[2] = a[2] + i[2]),
          t
        );
      }),
      (t.c = st),
      (t.c0 = function (t, e, i, r, n, a, s) {
        var o = 1 / (e - i),
          l = 1 / (r - n),
          c = 1 / (a - s);
        return (
          (t[0] = -2 * o),
          (t[1] = 0),
          (t[2] = 0),
          (t[3] = 0),
          (t[4] = 0),
          (t[5] = -2 * l),
          (t[6] = 0),
          (t[7] = 0),
          (t[8] = 0),
          (t[9] = 0),
          (t[10] = 2 * c),
          (t[11] = 0),
          (t[12] = (e + i) * o),
          (t[13] = (n + r) * l),
          (t[14] = (s + a) * c),
          (t[15] = 1),
          t
        );
      }),
      (t.c1 = class extends yo {
        constructor(t, e) {
          super(t, e), (this.current = new Array());
        }
        set(t) {
          if (t != this.current) {
            this.current = t;
            const e = new Float32Array(4 * t.length);
            for (let i = 0; i < t.length; i++)
              (e[4 * i] = t[i].r),
                (e[4 * i + 1] = t[i].g),
                (e[4 * i + 2] = t[i].b),
                (e[4 * i + 3] = t[i].a);
            this.gl.uniform4fv(this.location, e);
          }
        }
      }),
      (t.c2 = class extends yo {
        constructor(t, e) {
          super(t, e), (this.current = new Array());
        }
        set(t) {
          if (t != this.current) {
            this.current = t;
            const e = new Float32Array(t);
            this.gl.uniform1fv(this.location, e);
          }
        }
      }),
      (t.c3 = class extends ms {}),
      (t.c4 = oh),
      (t.c5 = class extends _s {}),
      (t.c6 = bl),
      (t.c7 = function (t) {
        return t <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(t) / Math.LN2));
      }),
      (t.c8 = xl),
      (t.c9 = function (t, e, i) {
        var r = e[0],
          n = e[1],
          a = e[2],
          s = i[3] * r + i[7] * n + i[11] * a + i[15];
        return (
          (t[0] = (i[0] * r + i[4] * n + i[8] * a + i[12]) / (s = s || 1)),
          (t[1] = (i[1] * r + i[5] * n + i[9] * a + i[13]) / s),
          (t[2] = (i[2] * r + i[6] * n + i[10] * a + i[14]) / s),
          t
        );
      }),
      (t.cB = function (t) {
        return t.message === at;
      }),
      (t.cC = ht),
      (t.cD = function (t, e) {
        ot.REGISTERED_PROTOCOLS[t] = e;
      }),
      (t.cE = function (t) {
        delete ot.REGISTERED_PROTOCOLS[t];
      }),
      (t.cF = function (t, e) {
        const i = {};
        for (let n = 0; n < t.length; n++) {
          const r = (e && e[t[n].id]) || wn(t[n]);
          e && (e[t[n].id] = r);
          let a = i[r];
          a || (a = i[r] = []), a.push(t[n]);
        }
        const r = [];
        for (const n in i) r.push(i[n]);
        return r;
      }),
      (t.cG = ca),
      (t.cH = ju),
      (t.cI = Gu),
      (t.cJ = Ah),
      (t.cK = function (e) {
        e.bucket.createArrays(),
          (e.bucket.tilePixelRatio = D / (512 * e.bucket.overscaling)),
          (e.bucket.compareText = {}),
          (e.bucket.iconsNeedLinear = !1);
        const i = e.bucket.layers[0],
          r = i.layout,
          n = i._unevaluatedLayout._values,
          a = {
            layoutIconSize: n['icon-size'].possiblyEvaluate(
              new La(e.bucket.zoom + 1),
              e.canonical
            ),
            layoutTextSize: n['text-size'].possiblyEvaluate(
              new La(e.bucket.zoom + 1),
              e.canonical
            ),
            textMaxSize: n['text-size'].possiblyEvaluate(new La(18)),
          };
        if ('composite' === e.bucket.textSizeData.kind) {
          const { minZoom: t, maxZoom: i } = e.bucket.textSizeData;
          a.compositeTextSizes = [
            n['text-size'].possiblyEvaluate(new La(t), e.canonical),
            n['text-size'].possiblyEvaluate(new La(i), e.canonical),
          ];
        }
        if ('composite' === e.bucket.iconSizeData.kind) {
          const { minZoom: t, maxZoom: i } = e.bucket.iconSizeData;
          a.compositeIconSizes = [
            n['icon-size'].possiblyEvaluate(new La(t), e.canonical),
            n['icon-size'].possiblyEvaluate(new La(i), e.canonical),
          ];
        }
        const s = r.get('text-line-height') * hh,
          o =
            'viewport' !== r.get('text-rotation-alignment') &&
            'point' !== r.get('symbol-placement'),
          l = r.get('text-keep-upright'),
          c = r.get('text-size');
        for (const h of e.bucket.features) {
          const n = r.get('text-font').evaluate(h, {}, e.canonical).join(','),
            u = c.evaluate(h, {}, e.canonical),
            d = a.layoutTextSize.evaluate(h, {}, e.canonical),
            p = a.layoutIconSize.evaluate(h, {}, e.canonical),
            f = { horizontal: {}, vertical: void 0 },
            m = h.text;
          let g,
            _ = [0, 0];
          if (m) {
            const a = m.toString(),
              c =
                r.get('text-letter-spacing').evaluate(h, {}, e.canonical) * hh,
              p = ya(a) ? c : 0,
              g = r.get('text-anchor').evaluate(h, {}, e.canonical),
              y = fd(i, h, e.canonical);
            if (!y) {
              const t = r
                .get('text-radial-offset')
                .evaluate(h, {}, e.canonical);
              _ = t
                ? pd(g, [t * hh, dd])
                : r
                    .get('text-offset')
                    .evaluate(h, {}, e.canonical)
                    .map((t) => t * hh);
            }
            let v = o
              ? 'center'
              : r.get('text-justify').evaluate(h, {}, e.canonical);
            const x =
                'point' === r.get('symbol-placement')
                  ? r.get('text-max-width').evaluate(h, {}, e.canonical) * hh
                  : 1 / 0,
              b = () => {
                e.bucket.allowVerticalPlacement &&
                  _a(a) &&
                  (f.vertical = kh(
                    m,
                    e.glyphMap,
                    e.glyphPositions,
                    e.imagePositions,
                    n,
                    x,
                    s,
                    g,
                    'left',
                    p,
                    _,
                    t.as.vertical,
                    !0,
                    d,
                    u
                  ));
              };
            if (!o && y) {
              const i = new Set();
              if ('auto' === v)
                for (let t = 0; t < y.values.length; t += 2)
                  i.add(md(y.values[t]));
              else i.add(v);
              let r = !1;
              for (const a of i)
                if (!f.horizontal[a])
                  if (r) f.horizontal[a] = f.horizontal[0];
                  else {
                    const i = kh(
                      m,
                      e.glyphMap,
                      e.glyphPositions,
                      e.imagePositions,
                      n,
                      x,
                      s,
                      'center',
                      a,
                      p,
                      _,
                      t.as.horizontal,
                      !1,
                      d,
                      u
                    );
                    i &&
                      ((f.horizontal[a] = i),
                      (r = 1 === i.positionedLines.length));
                  }
              b();
            } else {
              'auto' === v && (v = md(g));
              const i = kh(
                m,
                e.glyphMap,
                e.glyphPositions,
                e.imagePositions,
                n,
                x,
                s,
                g,
                v,
                p,
                _,
                t.as.horizontal,
                !1,
                d,
                u
              );
              i && (f.horizontal[v] = i),
                b(),
                _a(a) &&
                  o &&
                  l &&
                  (f.vertical = kh(
                    m,
                    e.glyphMap,
                    e.glyphPositions,
                    e.imagePositions,
                    n,
                    x,
                    s,
                    g,
                    v,
                    p,
                    _,
                    t.as.vertical,
                    !1,
                    d,
                    u
                  ));
            }
          }
          let y = !1;
          if (h.icon && h.icon.name) {
            const t = e.imageMap[h.icon.name];
            t &&
              ((g = Jh(
                e.imagePositions[h.icon.name],
                r.get('icon-offset').evaluate(h, {}, e.canonical),
                r.get('icon-anchor').evaluate(h, {}, e.canonical)
              )),
              (y = !!t.sdf),
              void 0 === e.bucket.sdfIcons
                ? (e.bucket.sdfIcons = y)
                : e.bucket.sdfIcons !== y &&
                  Z(
                    'Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer'
                  ),
              (t.pixelRatio !== e.bucket.pixelRatio ||
                0 !== r.get('icon-rotate').constantOr(1)) &&
                (e.bucket.iconsNeedLinear = !0));
          }
          const v = yd(f.horizontal) || f.vertical;
          (e.bucket.iconsInText = !!v && v.iconsInText),
            (v || g) &&
              gd(
                e.bucket,
                h,
                f,
                g,
                e.imageMap,
                a,
                d,
                p,
                _,
                y,
                e.canonical,
                e.subdivisionGranularity
              );
        }
        e.showCollisionBoxes && e.bucket.generateCollisionDebugBuffers();
      }),
      (t.cL = _c),
      (t.cM = zc),
      (t.cN = Xc),
      (t.cO = Lc),
      (t.cP = fh),
      (t.cQ = class {
        constructor(t) {
          (this._marks = {
            start: [t.url, 'start'].join('#'),
            end: [t.url, 'end'].join('#'),
            measure: t.url.toString(),
          }),
            performance.mark(this._marks.start);
        }
        finish() {
          performance.mark(this._marks.end);
          let t = performance.getEntriesByName(this._marks.measure);
          return (
            0 === t.length &&
              (performance.measure(
                this._marks.measure,
                this._marks.start,
                this._marks.end
              ),
              (t = performance.getEntriesByName(this._marks.measure)),
              performance.clearMarks(this._marks.start),
              performance.clearMarks(this._marks.end),
              performance.clearMeasures(this._marks.measure)),
            t
          );
        }
      }),
      (t.cR = function (t, i, r, n, a) {
        return e(this, void 0, void 0, function* () {
          if (u())
            try {
              return yield K(t, i, r, n, a);
            } catch (t) {}
          return (function (t, e, i, r, n) {
            const a = t.width,
              s = t.height;
            (J && Q) ||
              ((J = new OffscreenCanvas(a, s)),
              (Q = J.getContext('2d', { willReadFrequently: !0 }))),
              (J.width = a),
              (J.height = s),
              Q.drawImage(t, 0, 0, a, s);
            const o = Q.getImageData(e, i, r, n);
            return Q.clearRect(0, 0, a, s), o.data;
          })(t, i, r, n, a);
        });
      }),
      (t.cS = Dl),
      (t.cT = r),
      (t.cU = Mc),
      (t.cV = Cc),
      (t.cW = rn),
      (t.cX = function (t, e) {
        const i = new Map();
        if (null == t);
        else if ('Feature' === t.type) i.set(Nu(t, e), t);
        else for (const r of t.features) i.set(Nu(r, e), r);
        return i;
      }),
      (t.cY = function (t, e) {
        if (null == t) return !0;
        if ('Feature' === t.type) return null != Nu(t, e);
        if ('FeatureCollection' === t.type) {
          const i = new Set();
          for (const r of t.features) {
            const t = Nu(r, e);
            if (null == t) return !1;
            if (i.has(t)) return !1;
            i.add(t);
          }
          return !0;
        }
        return !1;
      }),
      (t.cZ = function (t, e, i) {
        var r, n, a, s;
        if ((e.removeAll && t.clear(), e.remove))
          for (const o of e.remove) t.delete(o);
        if (e.add)
          for (const o of e.add) {
            const e = Nu(o, i);
            null != e && t.set(e, o);
          }
        if (e.update)
          for (const o of e.update) {
            let e = t.get(o.id);
            if (null == e) continue;
            const i =
              !o.removeAllProperties &&
              ((null === (r = o.removeProperties) || void 0 === r
                ? void 0
                : r.length) > 0 ||
                (null === (n = o.addOrUpdateProperties) || void 0 === n
                  ? void 0
                  : n.length) > 0);
            if (
              ((o.newGeometry || o.removeAllProperties || i) &&
                ((e = Object.assign({}, e)),
                t.set(o.id, e),
                i && (e.properties = Object.assign({}, e.properties))),
              o.newGeometry && (e.geometry = o.newGeometry),
              o.removeAllProperties)
            )
              e.properties = {};
            else if (
              (null === (a = o.removeProperties) || void 0 === a
                ? void 0
                : a.length) > 0
            )
              for (const t of o.removeProperties)
                Object.prototype.hasOwnProperty.call(e.properties, t) &&
                  delete e.properties[t];
            if (
              (null === (s = o.addOrUpdateProperties) || void 0 === s
                ? void 0
                : s.length) > 0
            )
              for (const { key: t, value: r } of o.addOrUpdateProperties)
                e.properties[t] = r;
          }
      }),
      (t.c_ = Da),
      (t.ca = class extends ns {}),
      (t.cb = class extends Ps {}),
      (t.cc = function (t, e) {
        return (
          t[0] === e[0] &&
          t[1] === e[1] &&
          t[2] === e[2] &&
          t[3] === e[3] &&
          t[4] === e[4] &&
          t[5] === e[5] &&
          t[6] === e[6] &&
          t[7] === e[7] &&
          t[8] === e[8] &&
          t[9] === e[9] &&
          t[10] === e[10] &&
          t[11] === e[11] &&
          t[12] === e[12] &&
          t[13] === e[13] &&
          t[14] === e[14] &&
          t[15] === e[15]
        );
      }),
      (t.cd = function (t, e) {
        var i = t[0],
          r = t[1],
          n = t[2],
          a = t[3],
          s = t[4],
          o = t[5],
          l = t[6],
          c = t[7],
          h = t[8],
          u = t[9],
          p = t[10],
          f = t[11],
          m = t[12],
          g = t[13],
          _ = t[14],
          y = t[15],
          v = e[0],
          x = e[1],
          b = e[2],
          w = e[3],
          T = e[4],
          P = e[5],
          C = e[6],
          I = e[7],
          S = e[8],
          M = e[9],
          D = e[10],
          L = e[11],
          A = e[12],
          E = e[13],
          R = e[14],
          z = e[15];
        return (
          Math.abs(i - v) <= d * Math.max(1, Math.abs(i), Math.abs(v)) &&
          Math.abs(r - x) <= d * Math.max(1, Math.abs(r), Math.abs(x)) &&
          Math.abs(n - b) <= d * Math.max(1, Math.abs(n), Math.abs(b)) &&
          Math.abs(a - w) <= d * Math.max(1, Math.abs(a), Math.abs(w)) &&
          Math.abs(s - T) <= d * Math.max(1, Math.abs(s), Math.abs(T)) &&
          Math.abs(o - P) <= d * Math.max(1, Math.abs(o), Math.abs(P)) &&
          Math.abs(l - C) <= d * Math.max(1, Math.abs(l), Math.abs(C)) &&
          Math.abs(c - I) <= d * Math.max(1, Math.abs(c), Math.abs(I)) &&
          Math.abs(h - S) <= d * Math.max(1, Math.abs(h), Math.abs(S)) &&
          Math.abs(u - M) <= d * Math.max(1, Math.abs(u), Math.abs(M)) &&
          Math.abs(p - D) <= d * Math.max(1, Math.abs(p), Math.abs(D)) &&
          Math.abs(f - L) <= d * Math.max(1, Math.abs(f), Math.abs(L)) &&
          Math.abs(m - A) <= d * Math.max(1, Math.abs(m), Math.abs(A)) &&
          Math.abs(g - E) <= d * Math.max(1, Math.abs(g), Math.abs(E)) &&
          Math.abs(_ - R) <= d * Math.max(1, Math.abs(_), Math.abs(R)) &&
          Math.abs(y - z) <= d * Math.max(1, Math.abs(y), Math.abs(z))
        );
      }),
      (t.ce = function (t, e) {
        return (
          (t[0] = e[0]),
          (t[1] = e[1]),
          (t[2] = e[2]),
          (t[3] = e[3]),
          (t[4] = e[4]),
          (t[5] = e[5]),
          (t[6] = e[6]),
          (t[7] = e[7]),
          (t[8] = e[8]),
          (t[9] = e[9]),
          (t[10] = e[10]),
          (t[11] = e[11]),
          (t[12] = e[12]),
          (t[13] = e[13]),
          (t[14] = e[14]),
          (t[15] = e[15]),
          t
        );
      }),
      (t.cf = (t) => 'symbol' === t.type),
      (t.cg = (t) => 'circle' === t.type),
      (t.ch = (t) => 'heatmap' === t.type),
      (t.ci = (t) => 'line' === t.type),
      (t.cj = (t) => 'fill' === t.type),
      (t.ck = (t) => 'fill-extrusion' === t.type),
      (t.cl = (t) => 'hillshade' === t.type),
      (t.cm = (t) => 'color-relief' === t.type),
      (t.cn = (t) => 'background' === t.type),
      (t.co = (t) => 'custom' === t.type),
      (t.cp = z),
      (t.cq = function (t, e, i) {
        const r = M(e.x - i.x, e.y - i.y),
          n = M(t.x - i.x, t.y - i.y);
        var a, s;
        return it(
          Math.atan2(
            r[0] * n[1] - r[1] * n[0],
            (a = r)[0] * (s = n)[0] + a[1] * s[1]
          )
        );
      }),
      (t.cr = k),
      (t.cs = function (t, e) {
        return nt[e] && (t instanceof MouseEvent || t instanceof WheelEvent);
      }),
      (t.ct = function (t, e) {
        return rt[e] && 'touches' in t;
      }),
      (t.cu = function (t) {
        return rt[t] || nt[t];
      }),
      (t.cv = function (t, e, i) {
        var r = e[0],
          n = e[1];
        return (
          (t[0] = i[0] * r + i[4] * n + i[12]),
          (t[1] = i[1] * r + i[5] * n + i[13]),
          t
        );
      }),
      (t.cw = function (t, e) {
        const { x: i, y: r } = Ru.fromLngLat(e);
        return !(t < 0 || t > 25 || r < 0 || r >= 1 || i < 0 || i >= 1);
      }),
      (t.cx = function (t, e) {
        return (
          (t[0] = e[0]),
          (t[1] = 0),
          (t[2] = 0),
          (t[3] = 0),
          (t[4] = 0),
          (t[5] = e[1]),
          (t[6] = 0),
          (t[7] = 0),
          (t[8] = 0),
          (t[9] = 0),
          (t[10] = e[2]),
          (t[11] = 0),
          (t[12] = 0),
          (t[13] = 0),
          (t[14] = 0),
          (t[15] = 1),
          t
        );
      }),
      (t.cy = class extends rs {}),
      (t.cz = Rd),
      (t.d = pt),
      (t.e = B),
      (t.f = (t) =>
        e(void 0, void 0, void 0, function* () {
          if (0 === t.byteLength) return createImageBitmap(new ImageData(1, 1));
          const e = new Blob([new Uint8Array(t)], { type: 'image/png' });
          try {
            return createImageBitmap(e);
          } catch (t) {
            throw new Error(
              `Could not load image because of ${t.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`
            );
          }
        })),
      (t.g = lt),
      (t.h = (t) =>
        new Promise((e, i) => {
          const r = new Image();
          (r.onload = () => {
            e(r),
              URL.revokeObjectURL(r.src),
              (r.onload = null),
              window.requestAnimationFrame(() => {
                r.src = Y;
              });
          }),
            (r.onerror = () =>
              i(
                new Error(
                  'Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.'
                )
              ));
          const n = new Blob([new Uint8Array(t)], { type: 'image/png' });
          r.src = t.byteLength ? URL.createObjectURL(n) : Y;
        })),
      (t.i = q),
      (t.j = (t, e) => dt(B(t, { type: 'json' }), e)),
      (t.k = _t),
      (t.l = gt),
      (t.m = dt),
      (t.n = (t, e) => dt(B(t, { type: 'arrayBuffer' }), e)),
      (t.o = function (t) {
        return new fh(t).readFields(Ih, []);
      }),
      (t.p = Dh),
      (t.q = yl),
      (t.r = $a),
      (t.s = tt),
      (t.t = vt),
      (t.u = ga),
      (t.v = ta),
      (t.w = Z),
      (t.x = za),
      (t.y = ia),
      (t.z = sa);
  }),
    i('worker', ['./shared'], function (t) {
      class e {
        constructor(t, e) {
          (this.keyCache = {}), t && this.replace(t, e);
        }
        replace(t, e) {
          (this._layerConfigs = {}), (this._layers = {}), this.update(t, [], e);
        }
        update(e, i, r) {
          for (const a of e) {
            this._layerConfigs[a.id] = a;
            const e = (this._layers[a.id] = t.bM(a, r));
            (e._featureFilter = t.ae(e.filter, r)),
              this.keyCache[a.id] && delete this.keyCache[a.id];
          }
          for (const t of i)
            delete this.keyCache[t],
              delete this._layerConfigs[t],
              delete this._layers[t];
          this.familiesBySource = {};
          const n = t.cF(Object.values(this._layerConfigs), this.keyCache);
          for (const t of n) {
            const e = t.map((t) => this._layers[t.id]),
              i = e[0];
            if ('none' === i.visibility) continue;
            const r = i.source || '';
            let n = this.familiesBySource[r];
            n || (n = this.familiesBySource[r] = {});
            const a = i.sourceLayer || '_geojsonTileLayer';
            let s = n[a];
            s || (s = n[a] = []), s.push(e);
          }
        }
      }
      class i {
        constructor(e) {
          const i = {},
            r = [];
          for (const t in e) {
            const n = e[t],
              a = (i[t] = {});
            for (const t in n) {
              const e = n[+t];
              if (!e || 0 === e.bitmap.width || 0 === e.bitmap.height) continue;
              const i = {
                x: 0,
                y: 0,
                w: e.bitmap.width + 2,
                h: e.bitmap.height + 2,
              };
              r.push(i), (a[t] = { rect: i, metrics: e.metrics });
            }
          }
          const { w: n, h: a } = t.p(r),
            s = new t.q({ width: n || 1, height: a || 1 });
          for (const o in e) {
            const r = e[o];
            for (const e in r) {
              const n = r[+e];
              if (!n || 0 === n.bitmap.width || 0 === n.bitmap.height) continue;
              const a = i[o][e].rect;
              t.q.copy(
                n.bitmap,
                s,
                { x: 0, y: 0 },
                { x: a.x + 1, y: a.y + 1 },
                n.bitmap
              );
            }
          }
          (this.image = s), (this.positions = i);
        }
      }
      t.cG('GlyphAtlas', i);
      class r {
        constructor(e) {
          (this.tileID = new t.a0(
            e.tileID.overscaledZ,
            e.tileID.wrap,
            e.tileID.canonical.z,
            e.tileID.canonical.x,
            e.tileID.canonical.y
          )),
            (this.uid = e.uid),
            (this.zoom = e.zoom),
            (this.pixelRatio = e.pixelRatio),
            (this.tileSize = e.tileSize),
            (this.source = e.source),
            (this.overscaling = this.tileID.overscaleFactor()),
            (this.showCollisionBoxes = e.showCollisionBoxes),
            (this.collectResourceTiming = !!e.collectResourceTiming),
            (this.returnDependencies = !!e.returnDependencies),
            (this.promoteId = e.promoteId),
            (this.inFlightDependencies = []);
        }
        parse(e, r, a, s, o) {
          return t._(this, void 0, void 0, function* () {
            (this.status = 'parsing'),
              (this.data = e),
              (this.collisionBoxArray = new t.ac());
            const l = new t.cH(Object.keys(e.layers).sort()),
              c = new t.cI(this.tileID, this.promoteId);
            c.bucketLayerIDs = [];
            const h = {},
              u = {
                featureIndex: c,
                iconDependencies: {},
                patternDependencies: {},
                glyphDependencies: {},
                dashDependencies: {},
                availableImages: a,
                subdivisionGranularity: o,
              },
              d = r.familiesBySource[this.source];
            for (const i in d) {
              const r = e.layers[i];
              if (!r) continue;
              1 === r.version &&
                t.w(
                  `Vector tile source "${this.source}" layer "${i}" does not use vector tile spec v2 and therefore may have some rendering errors.`
                );
              const s = l.encode(i),
                o = [];
              for (let t = 0; t < r.length; t++) {
                const e = r.feature(t),
                  n = c.getId(e, i);
                o.push({ feature: e, id: n, index: t, sourceLayerIndex: s });
              }
              for (const e of d[i]) {
                const i = e[0];
                i.source !== this.source &&
                  t.w(
                    `layer.source = ${i.source} does not equal this.source = ${this.source}`
                  ),
                  i.isHidden(this.zoom, !0) ||
                    (n(e, this.zoom, a),
                    (h[i.id] = i.createBucket({
                      index: c.bucketLayerIDs.length,
                      layers: e,
                      zoom: this.zoom,
                      pixelRatio: this.pixelRatio,
                      overscaling: this.overscaling,
                      collisionBoxArray: this.collisionBoxArray,
                      sourceLayerIndex: s,
                      sourceID: this.source,
                    })).populate(o, u, this.tileID.canonical),
                    c.bucketLayerIDs.push(e.map((t) => t.id)));
              }
            }
            const p = t.bR(u.glyphDependencies, (t) =>
              Object.keys(t).map(Number)
            );
            this.inFlightDependencies.forEach((t) =>
              null == t ? void 0 : t.abort()
            ),
              (this.inFlightDependencies = []);
            let f = Promise.resolve({});
            if (Object.keys(p).length) {
              const t = new AbortController();
              this.inFlightDependencies.push(t),
                (f = s.sendAsync(
                  {
                    type: 'GG',
                    data: {
                      stacks: p,
                      source: this.source,
                      tileID: this.tileID,
                      type: 'glyphs',
                    },
                  },
                  t
                ));
            }
            const m = Object.keys(u.iconDependencies);
            let g = Promise.resolve({});
            if (m.length) {
              const t = new AbortController();
              this.inFlightDependencies.push(t),
                (g = s.sendAsync(
                  {
                    type: 'GI',
                    data: {
                      icons: m,
                      source: this.source,
                      tileID: this.tileID,
                      type: 'icons',
                    },
                  },
                  t
                ));
            }
            const _ = Object.keys(u.patternDependencies);
            let y = Promise.resolve({});
            if (_.length) {
              const t = new AbortController();
              this.inFlightDependencies.push(t),
                (y = s.sendAsync(
                  {
                    type: 'GI',
                    data: {
                      icons: _,
                      source: this.source,
                      tileID: this.tileID,
                      type: 'patterns',
                    },
                  },
                  t
                ));
            }
            const v = u.dashDependencies;
            let x = Promise.resolve({});
            if (Object.keys(v).length) {
              const t = new AbortController();
              this.inFlightDependencies.push(t),
                (x = s.sendAsync({ type: 'GDA', data: { dashes: v } }, t));
            }
            const [b, w, T, P] = yield Promise.all([f, g, y, x]),
              C = new i(b),
              I = new t.cJ(w, T);
            for (const e in h) {
              const i = h[e];
              i instanceof t.ad
                ? (n(i.layers, this.zoom, a),
                  t.cK({
                    bucket: i,
                    glyphMap: b,
                    glyphPositions: C.positions,
                    imageMap: w,
                    imagePositions: I.iconPositions,
                    showCollisionBoxes: this.showCollisionBoxes,
                    canonical: this.tileID.canonical,
                    subdivisionGranularity: u.subdivisionGranularity,
                  }))
                : i.hasDependencies &&
                  (i instanceof t.cL ||
                    i instanceof t.cM ||
                    i instanceof t.cN) &&
                  (n(i.layers, this.zoom, a),
                  i.addFeatures(
                    u,
                    this.tileID.canonical,
                    I.patternPositions,
                    P
                  ));
            }
            return (
              (this.status = 'done'),
              {
                buckets: Object.values(h).filter((t) => !t.isEmpty()),
                featureIndex: c,
                collisionBoxArray: this.collisionBoxArray,
                glyphAtlasImage: C.image,
                imageAtlas: I,
                dashPositions: P,
                glyphMap: this.returnDependencies ? b : null,
                iconMap: this.returnDependencies ? w : null,
                glyphPositions: this.returnDependencies ? C.positions : null,
              }
            );
          });
        }
      }
      function n(e, i, r) {
        const n = new t.G(i);
        for (const t of e) t.recalculate(n, r);
      }
      class a {
        constructor(t, e, i) {
          (this.actor = t),
            (this.layerIndex = e),
            (this.availableImages = i),
            (this.fetching = {}),
            (this.loading = {}),
            (this.loaded = {});
        }
        loadVectorTile(e, i) {
          return t._(this, void 0, void 0, function* () {
            const r = yield t.n(e.request, i);
            try {
              return {
                vectorTile: new t.cO(new t.cP(r.data)),
                rawData: r.data,
                cacheControl: r.cacheControl,
                expires: r.expires,
              };
            } catch (t) {
              const n = new Uint8Array(r.data);
              let a = `Unable to parse the tile at ${e.request.url}, `;
              throw (
                ((a +=
                  31 === n[0] && 139 === n[1]
                    ? 'please make sure the data is not gzipped and that you have configured the relevant header in the server'
                    : `got error: ${t.message}`),
                new Error(a))
              );
            }
          });
        }
        loadTile(e) {
          return t._(this, void 0, void 0, function* () {
            const i = e.uid,
              n =
                !!(e && e.request && e.request.collectResourceTiming) &&
                new t.cQ(e.request),
              a = new r(e);
            this.loading[i] = a;
            const s = new AbortController();
            a.abort = s;
            try {
              const r = yield this.loadVectorTile(e, s);
              if ((delete this.loading[i], !r)) return null;
              const o = r.rawData,
                l = {};
              r.expires && (l.expires = r.expires),
                r.cacheControl && (l.cacheControl = r.cacheControl);
              const c = {};
              if (n) {
                const t = n.finish();
                t && (c.resourceTiming = JSON.parse(JSON.stringify(t)));
              }
              a.vectorTile = r.vectorTile;
              const h = a.parse(
                r.vectorTile,
                this.layerIndex,
                this.availableImages,
                this.actor,
                e.subdivisionGranularity
              );
              (this.loaded[i] = a),
                (this.fetching[i] = {
                  rawTileData: o,
                  cacheControl: l,
                  resourceTiming: c,
                });
              try {
                const e = yield h;
                return t.e({ rawTileData: o.slice(0) }, e, l, c);
              } finally {
                delete this.fetching[i];
              }
            } catch (t) {
              throw (
                (delete this.loading[i],
                (a.status = 'done'),
                (this.loaded[i] = a),
                t)
              );
            }
          });
        }
        reloadTile(e) {
          return t._(this, void 0, void 0, function* () {
            const i = e.uid;
            if (!this.loaded || !this.loaded[i])
              throw new Error(
                'Should not be trying to reload a tile that was never loaded or has been removed'
              );
            const r = this.loaded[i];
            if (
              ((r.showCollisionBoxes = e.showCollisionBoxes),
              'parsing' === r.status)
            ) {
              const n = yield r.parse(
                r.vectorTile,
                this.layerIndex,
                this.availableImages,
                this.actor,
                e.subdivisionGranularity
              );
              let a;
              if (this.fetching[i]) {
                const {
                  rawTileData: e,
                  cacheControl: r,
                  resourceTiming: s,
                } = this.fetching[i];
                delete this.fetching[i],
                  (a = t.e({ rawTileData: e.slice(0) }, n, r, s));
              } else a = n;
              return a;
            }
            if ('done' === r.status && r.vectorTile)
              return r.parse(
                r.vectorTile,
                this.layerIndex,
                this.availableImages,
                this.actor,
                e.subdivisionGranularity
              );
          });
        }
        abortTile(e) {
          return t._(this, void 0, void 0, function* () {
            const t = this.loading,
              i = e.uid;
            t && t[i] && t[i].abort && (t[i].abort.abort(), delete t[i]);
          });
        }
        removeTile(e) {
          return t._(this, void 0, void 0, function* () {
            this.loaded && this.loaded[e.uid] && delete this.loaded[e.uid];
          });
        }
      }
      class s {
        constructor() {
          this.loaded = {};
        }
        loadTile(e) {
          return t._(this, void 0, void 0, function* () {
            const {
                uid: i,
                encoding: r,
                rawImageData: n,
                redFactor: a,
                greenFactor: s,
                blueFactor: o,
                baseShift: l,
              } = e,
              c = n.width + 2,
              h = n.height + 2,
              u = t.b(n)
                ? new t.R({ width: c, height: h }, yield t.cR(n, -1, -1, c, h))
                : n,
              d = new t.cS(i, u, r, a, s, o, l);
            return (this.loaded = this.loaded || {}), (this.loaded[i] = d), d;
          });
        }
        removeTile(t) {
          const e = this.loaded,
            i = t.uid;
          e && e[i] && delete e[i];
        }
      }
      var o,
        l,
        c = (function () {
          if (l) return o;
          function t(t, i) {
            if (0 !== t.length) {
              e(t[0], i);
              for (var r = 1; r < t.length; r++) e(t[r], !i);
            }
          }
          function e(t, e) {
            for (
              var i = 0, r = 0, n = 0, a = t.length, s = a - 1;
              n < a;
              s = n++
            ) {
              var o = (t[n][0] - t[s][0]) * (t[s][1] + t[n][1]),
                l = i + o;
              (r += Math.abs(i) >= Math.abs(o) ? i - l + o : o - l + i),
                (i = l);
            }
            i + r >= 0 != !!e && t.reverse();
          }
          return (
            (l = 1),
            (o = function e(i, r) {
              var n,
                a = i && i.type;
              if ('FeatureCollection' === a)
                for (n = 0; n < i.features.length; n++) e(i.features[n], r);
              else if ('GeometryCollection' === a)
                for (n = 0; n < i.geometries.length; n++) e(i.geometries[n], r);
              else if ('Feature' === a) e(i.geometry, r);
              else if ('Polygon' === a) t(i.coordinates, r);
              else if ('MultiPolygon' === a)
                for (n = 0; n < i.coordinates.length; n++)
                  t(i.coordinates[n], r);
              return i;
            })
          );
        })(),
        h = t.cT(c);
      class u extends t.cV {
        constructor(e, i) {
          super(new t.cP(), 0, i, [], []),
            (this.feature = e),
            (this.type = e.type),
            (this.properties = e.tags ? e.tags : {}),
            'id' in e &&
              ('string' == typeof e.id
                ? (this.id = parseInt(e.id, 10))
                : 'number' != typeof e.id || isNaN(e.id) || (this.id = e.id));
        }
        loadGeometry() {
          const e = [],
            i =
              1 === this.feature.type
                ? [this.feature.geometry]
                : this.feature.geometry;
          for (const r of i) {
            const i = [];
            for (const e of r) i.push(new t.P(e[0], e[1]));
            e.push(i);
          }
          return e;
        }
      }
      class d extends t.cU {
        constructor(e, i) {
          super(new t.cP()),
            (this.layers = { _geojsonTileLayer: this }),
            (this.name = '_geojsonTileLayer'),
            (this.version = i ? i.version : 1),
            (this.extent = i ? i.extent : 4096),
            (this.length = e.length),
            (this.features = e);
        }
        feature(t) {
          return new u(this.features[t], this.extent);
        }
      }
      function p(t, e) {
        e.writeVarintField(15, t.version || 1),
          e.writeStringField(1, t.name || ''),
          e.writeVarintField(5, t.extent || 4096);
        const i = { keys: [], values: [], keycache: {}, valuecache: {} };
        for (let a = 0; a < t.length; a++)
          (i.feature = t.feature(a)), e.writeMessage(2, f, i);
        const r = i.keys;
        for (const a of r) e.writeStringField(3, a);
        const n = i.values;
        for (const a of n) e.writeMessage(4, v, a);
      }
      function f(t, e) {
        if (!t.feature) return;
        const i = t.feature;
        void 0 !== i.id && e.writeVarintField(1, i.id),
          e.writeMessage(2, m, t),
          e.writeVarintField(3, i.type),
          e.writeMessage(4, y, i);
      }
      function m(t, e) {
        for (const i in t.feature?.properties) {
          let r = t.feature.properties[i],
            n = t.keycache[i];
          if (null === r) continue;
          void 0 === n &&
            (t.keys.push(i), (n = t.keys.length - 1), (t.keycache[i] = n)),
            e.writeVarint(n),
            'string' != typeof r &&
              'boolean' != typeof r &&
              'number' != typeof r &&
              (r = JSON.stringify(r));
          const a = typeof r + ':' + r;
          let s = t.valuecache[a];
          void 0 === s &&
            (t.values.push(r),
            (s = t.values.length - 1),
            (t.valuecache[a] = s)),
            e.writeVarint(s);
        }
      }
      function g(t, e) {
        return (e << 3) + (7 & t);
      }
      function _(t) {
        return (t << 1) ^ (t >> 31);
      }
      function y(t, e) {
        const i = t.loadGeometry(),
          r = t.type;
        let n = 0,
          a = 0;
        for (const s of i) {
          let i = 1;
          1 === r && (i = s.length), e.writeVarint(g(1, i));
          const o = 3 === r ? s.length - 1 : s.length;
          for (let t = 0; t < o; t++) {
            1 === t && 1 !== r && e.writeVarint(g(2, o - 1));
            const i = s[t].x - n,
              l = s[t].y - a;
            e.writeVarint(_(i)), e.writeVarint(_(l)), (n += i), (a += l);
          }
          3 === t.type && e.writeVarint(g(7, 1));
        }
      }
      function v(t, e) {
        const i = typeof t;
        'string' === i
          ? e.writeStringField(1, t)
          : 'boolean' === i
          ? e.writeBooleanField(7, t)
          : 'number' === i &&
            (t % 1 != 0
              ? e.writeDoubleField(3, t)
              : t < 0
              ? e.writeSVarintField(6, t)
              : e.writeVarintField(5, t));
      }
      const x = {
          minZoom: 0,
          maxZoom: 16,
          minPoints: 2,
          radius: 40,
          extent: 512,
          nodeSize: 64,
          log: !1,
          generateId: !1,
          reduce: null,
          map: (t) => t,
        },
        b =
          Math.fround ||
          ((w = new Float32Array(1)), (t) => ((w[0] = +t), w[0]));
      var w;
      class T {
        constructor(t) {
          (this.options = Object.assign(Object.create(x), t)),
            (this.trees = new Array(this.options.maxZoom + 1)),
            (this.stride = this.options.reduce ? 7 : 6),
            (this.clusterProps = []);
        }
        load(t) {
          const { log: e, minZoom: i, maxZoom: r } = this.options;
          e && console.time('total time');
          const n = `prepare ${t.length} points`;
          e && console.time(n), (this.points = t);
          const a = [];
          for (let o = 0; o < t.length; o++) {
            const e = t[o];
            if (!e.geometry) continue;
            const [i, r] = e.geometry.coordinates,
              n = b(I(i)),
              s = b(S(r));
            a.push(n, s, 1 / 0, o, -1, 1), this.options.reduce && a.push(0);
          }
          let s = (this.trees[r + 1] = this._createTree(a));
          e && console.timeEnd(n);
          for (let o = r; o >= i; o--) {
            const t = +Date.now();
            (s = this.trees[o] = this._createTree(this._cluster(s, o))),
              e &&
                console.log(
                  'z%d: %d clusters in %dms',
                  o,
                  s.numItems,
                  +Date.now() - t
                );
          }
          return e && console.timeEnd('total time'), this;
        }
        getClusters(t, e) {
          let i = ((((t[0] + 180) % 360) + 360) % 360) - 180;
          const r = Math.max(-90, Math.min(90, t[1]));
          let n =
            180 === t[2] ? 180 : ((((t[2] + 180) % 360) + 360) % 360) - 180;
          const a = Math.max(-90, Math.min(90, t[3]));
          if (t[2] - t[0] >= 360) (i = -180), (n = 180);
          else if (i > n) {
            const t = this.getClusters([i, r, 180, a], e),
              s = this.getClusters([-180, r, n, a], e);
            return t.concat(s);
          }
          const s = this.trees[this._limitZoom(e)],
            o = s.range(I(i), S(a), I(n), S(r)),
            l = s.data,
            c = [];
          for (const h of o) {
            const t = this.stride * h;
            c.push(
              l[t + 5] > 1 ? P(l, t, this.clusterProps) : this.points[l[t + 3]]
            );
          }
          return c;
        }
        getChildren(t) {
          const e = this._getOriginId(t),
            i = this._getOriginZoom(t),
            r = 'No cluster with the specified id.',
            n = this.trees[i];
          if (!n) throw new Error(r);
          const a = n.data;
          if (e * this.stride >= a.length) throw new Error(r);
          const s =
              this.options.radius / (this.options.extent * Math.pow(2, i - 1)),
            o = n.within(a[e * this.stride], a[e * this.stride + 1], s),
            l = [];
          for (const c of o) {
            const e = c * this.stride;
            a[e + 4] === t &&
              l.push(
                a[e + 5] > 1
                  ? P(a, e, this.clusterProps)
                  : this.points[a[e + 3]]
              );
          }
          if (0 === l.length) throw new Error(r);
          return l;
        }
        getLeaves(t, e, i) {
          const r = [];
          return this._appendLeaves(r, t, (e = e || 10), (i = i || 0), 0), r;
        }
        getTile(t, e, i) {
          const r = this.trees[this._limitZoom(t)],
            n = Math.pow(2, t),
            { extent: a, radius: s } = this.options,
            o = s / a,
            l = (i - o) / n,
            c = (i + 1 + o) / n,
            h = { features: [] };
          return (
            this._addTileFeatures(
              r.range((e - o) / n, l, (e + 1 + o) / n, c),
              r.data,
              e,
              i,
              n,
              h
            ),
            0 === e &&
              this._addTileFeatures(
                r.range(1 - o / n, l, 1, c),
                r.data,
                n,
                i,
                n,
                h
              ),
            e === n - 1 &&
              this._addTileFeatures(
                r.range(0, l, o / n, c),
                r.data,
                -1,
                i,
                n,
                h
              ),
            h.features.length ? h : null
          );
        }
        getClusterExpansionZoom(t) {
          let e = this._getOriginZoom(t) - 1;
          for (; e <= this.options.maxZoom; ) {
            const i = this.getChildren(t);
            if ((e++, 1 !== i.length)) break;
            t = i[0].properties.cluster_id;
          }
          return e;
        }
        _appendLeaves(t, e, i, r, n) {
          const a = this.getChildren(e);
          for (const s of a) {
            const e = s.properties;
            if (
              (e && e.cluster
                ? n + e.point_count <= r
                  ? (n += e.point_count)
                  : (n = this._appendLeaves(t, e.cluster_id, i, r, n))
                : n < r
                ? n++
                : t.push(s),
              t.length === i)
            )
              break;
          }
          return n;
        }
        _createTree(e) {
          const i = new t.aM(
            (e.length / this.stride) | 0,
            this.options.nodeSize,
            Float32Array
          );
          for (let t = 0; t < e.length; t += this.stride) i.add(e[t], e[t + 1]);
          return i.finish(), (i.data = e), i;
        }
        _addTileFeatures(t, e, i, r, n, a) {
          for (const s of t) {
            const t = s * this.stride,
              o = e[t + 5] > 1;
            let l, c, h;
            if (o) (l = C(e, t, this.clusterProps)), (c = e[t]), (h = e[t + 1]);
            else {
              const i = this.points[e[t + 3]];
              l = i.properties;
              const [r, n] = i.geometry.coordinates;
              (c = I(r)), (h = S(n));
            }
            const u = {
              type: 1,
              geometry: [
                [
                  Math.round(this.options.extent * (c * n - i)),
                  Math.round(this.options.extent * (h * n - r)),
                ],
              ],
              tags: l,
            };
            let d;
            (d =
              o || this.options.generateId
                ? e[t + 3]
                : this.points[e[t + 3]].id),
              void 0 !== d && (u.id = d),
              a.features.push(u);
          }
        }
        _limitZoom(t) {
          return Math.max(
            this.options.minZoom,
            Math.min(Math.floor(+t), this.options.maxZoom + 1)
          );
        }
        _cluster(t, e) {
          const {
              radius: i,
              extent: r,
              reduce: n,
              minPoints: a,
            } = this.options,
            s = i / (r * Math.pow(2, e)),
            o = t.data,
            l = [],
            c = this.stride;
          for (let h = 0; h < o.length; h += c) {
            if (o[h + 2] <= e) continue;
            o[h + 2] = e;
            const i = o[h],
              r = o[h + 1],
              u = t.within(o[h], o[h + 1], s),
              d = o[h + 5];
            let p = d;
            for (const t of u) {
              const i = t * c;
              o[i + 2] > e && (p += o[i + 5]);
            }
            if (p > d && p >= a) {
              let t,
                a = i * d,
                s = r * d,
                f = -1;
              const m = ((h / c) << 5) + (e + 1) + this.points.length;
              for (const i of u) {
                const r = i * c;
                if (o[r + 2] <= e) continue;
                o[r + 2] = e;
                const l = o[r + 5];
                (a += o[r] * l),
                  (s += o[r + 1] * l),
                  (o[r + 4] = m),
                  n &&
                    (t ||
                      ((t = this._map(o, h, !0)),
                      (f = this.clusterProps.length),
                      this.clusterProps.push(t)),
                    n(t, this._map(o, r)));
              }
              (o[h + 4] = m),
                l.push(a / p, s / p, 1 / 0, m, -1, p),
                n && l.push(f);
            } else {
              for (let t = 0; t < c; t++) l.push(o[h + t]);
              if (p > 1)
                for (const t of u) {
                  const i = t * c;
                  if (!(o[i + 2] <= e)) {
                    o[i + 2] = e;
                    for (let t = 0; t < c; t++) l.push(o[i + t]);
                  }
                }
            }
          }
          return l;
        }
        _getOriginId(t) {
          return (t - this.points.length) >> 5;
        }
        _getOriginZoom(t) {
          return (t - this.points.length) % 32;
        }
        _map(t, e, i) {
          if (t[e + 5] > 1) {
            const r = this.clusterProps[t[e + 6]];
            return i ? Object.assign({}, r) : r;
          }
          const r = this.points[t[e + 3]].properties,
            n = this.options.map(r);
          return i && n === r ? Object.assign({}, n) : n;
        }
      }
      function P(t, e, i) {
        return {
          type: 'Feature',
          id: t[e + 3],
          properties: C(t, e, i),
          geometry: {
            type: 'Point',
            coordinates: [((r = t[e]), 360 * (r - 0.5)), M(t[e + 1])],
          },
        };
        var r;
      }
      function C(t, e, i) {
        const r = t[e + 5],
          n =
            r >= 1e4
              ? `${Math.round(r / 1e3)}k`
              : r >= 1e3
              ? Math.round(r / 100) / 10 + 'k'
              : r,
          a = t[e + 6],
          s = -1 === a ? {} : Object.assign({}, i[a]);
        return Object.assign(s, {
          cluster: !0,
          cluster_id: t[e + 3],
          point_count: r,
          point_count_abbreviated: n,
        });
      }
      function I(t) {
        return t / 360 + 0.5;
      }
      function S(t) {
        const e = Math.sin((t * Math.PI) / 180),
          i = 0.5 - (0.25 * Math.log((1 + e) / (1 - e))) / Math.PI;
        return i < 0 ? 0 : i > 1 ? 1 : i;
      }
      function M(t) {
        const e = ((180 - 360 * t) * Math.PI) / 180;
        return (360 * Math.atan(Math.exp(e))) / Math.PI - 90;
      }
      function D(t, e, i, r) {
        let n = r;
        const a = e + ((i - e) >> 1);
        let s,
          o = i - e;
        const l = t[e],
          c = t[e + 1],
          h = t[i],
          u = t[i + 1];
        for (let d = e + 3; d < i; d += 3) {
          const e = L(t[d], t[d + 1], l, c, h, u);
          if (e > n) (s = d), (n = e);
          else if (e === n) {
            const t = Math.abs(d - a);
            t < o && ((s = d), (o = t));
          }
        }
        n > r &&
          (s - e > 3 && D(t, e, s, r),
          (t[s + 2] = n),
          i - s > 3 && D(t, s, i, r));
      }
      function L(t, e, i, r, n, a) {
        let s = n - i,
          o = a - r;
        if (0 !== s || 0 !== o) {
          const l = ((t - i) * s + (e - r) * o) / (s * s + o * o);
          l > 1 ? ((i = n), (r = a)) : l > 0 && ((i += s * l), (r += o * l));
        }
        return (s = t - i), (o = e - r), s * s + o * o;
      }
      function A(t, e, i, r) {
        const n = {
          id: null == t ? null : t,
          type: e,
          geometry: i,
          tags: r,
          minX: 1 / 0,
          minY: 1 / 0,
          maxX: -1 / 0,
          maxY: -1 / 0,
        };
        if ('Point' === e || 'MultiPoint' === e || 'LineString' === e) E(n, i);
        else if ('Polygon' === e) E(n, i[0]);
        else if ('MultiLineString' === e) for (const a of i) E(n, a);
        else if ('MultiPolygon' === e) for (const a of i) E(n, a[0]);
        return n;
      }
      function E(t, e) {
        for (let i = 0; i < e.length; i += 3)
          (t.minX = Math.min(t.minX, e[i])),
            (t.minY = Math.min(t.minY, e[i + 1])),
            (t.maxX = Math.max(t.maxX, e[i])),
            (t.maxY = Math.max(t.maxY, e[i + 1]));
      }
      function R(t, e, i, r) {
        if (!e.geometry) return;
        const n = e.geometry.coordinates;
        if (n && 0 === n.length) return;
        const a = e.geometry.type,
          s = Math.pow(i.tolerance / ((1 << i.maxZoom) * i.extent), 2);
        let o = [],
          l = e.id;
        if (
          (i.promoteId
            ? (l = e.properties[i.promoteId])
            : i.generateId && (l = r || 0),
          'Point' === a)
        )
          z(n, o);
        else if ('MultiPoint' === a) for (const c of n) z(c, o);
        else if ('LineString' === a) k(n, o, s, !1);
        else if ('MultiLineString' === a) {
          if (i.lineMetrics) {
            for (const i of n)
              (o = []),
                k(i, o, s, !1),
                t.push(A(l, 'LineString', o, e.properties));
            return;
          }
          O(n, o, s, !1);
        } else if ('Polygon' === a) O(n, o, s, !0);
        else {
          if ('MultiPolygon' !== a) {
            if ('GeometryCollection' === a) {
              for (const n of e.geometry.geometries)
                R(t, { id: l, geometry: n, properties: e.properties }, i, r);
              return;
            }
            throw new Error('Input data is not a valid GeoJSON object.');
          }
          for (const t of n) {
            const e = [];
            O(t, e, s, !0), o.push(e);
          }
        }
        t.push(A(l, a, o, e.properties));
      }
      function z(t, e) {
        e.push(F(t[0]), B(t[1]), 0);
      }
      function k(t, e, i, r) {
        let n,
          a,
          s = 0;
        for (let l = 0; l < t.length; l++) {
          const i = F(t[l][0]),
            o = B(t[l][1]);
          e.push(i, o, 0),
            l > 0 &&
              (s += r
                ? (n * o - i * a) / 2
                : Math.sqrt(Math.pow(i - n, 2) + Math.pow(o - a, 2))),
            (n = i),
            (a = o);
        }
        const o = e.length - 3;
        (e[2] = 1),
          D(e, 0, o, i),
          (e[o + 2] = 1),
          (e.size = Math.abs(s)),
          (e.start = 0),
          (e.end = e.size);
      }
      function O(t, e, i, r) {
        for (let n = 0; n < t.length; n++) {
          const a = [];
          k(t[n], a, i, r), e.push(a);
        }
      }
      function F(t) {
        return t / 360 + 0.5;
      }
      function B(t) {
        const e = Math.sin((t * Math.PI) / 180),
          i = 0.5 - (0.25 * Math.log((1 + e) / (1 - e))) / Math.PI;
        return i < 0 ? 0 : i > 1 ? 1 : i;
      }
      function N(t, e, i, r, n, a, s, o) {
        if (((r /= e), a >= (i /= e) && s < r)) return t;
        if (s < i || a >= r) return null;
        const l = [];
        for (const c of t) {
          const t = c.geometry;
          let e = c.type;
          const a = 0 === n ? c.minX : c.minY,
            s = 0 === n ? c.maxX : c.maxY;
          if (a >= i && s < r) {
            l.push(c);
            continue;
          }
          if (s < i || a >= r) continue;
          let h = [];
          if ('Point' === e || 'MultiPoint' === e) V(t, h, i, r, n);
          else if ('LineString' === e) j(t, h, i, r, n, !1, o.lineMetrics);
          else if ('MultiLineString' === e) G(t, h, i, r, n, !1);
          else if ('Polygon' === e) G(t, h, i, r, n, !0);
          else if ('MultiPolygon' === e)
            for (const o of t) {
              const t = [];
              G(o, t, i, r, n, !0), t.length && h.push(t);
            }
          if (h.length) {
            if (o.lineMetrics && 'LineString' === e) {
              for (const t of h) l.push(A(c.id, e, t, c.tags));
              continue;
            }
            ('LineString' !== e && 'MultiLineString' !== e) ||
              (1 === h.length
                ? ((e = 'LineString'), (h = h[0]))
                : (e = 'MultiLineString')),
              ('Point' !== e && 'MultiPoint' !== e) ||
                (e = 3 === h.length ? 'Point' : 'MultiPoint'),
              l.push(A(c.id, e, h, c.tags));
          }
        }
        return l.length ? l : null;
      }
      function V(t, e, i, r, n) {
        for (let a = 0; a < t.length; a += 3) {
          const s = t[a + n];
          s >= i && s <= r && Z(e, t[a], t[a + 1], t[a + 2]);
        }
      }
      function j(t, e, i, r, n, a, s) {
        let o = U(t);
        const l = 0 === n ? $ : q;
        let c,
          h,
          u = t.start;
        for (let g = 0; g < t.length - 3; g += 3) {
          const d = t[g],
            p = t[g + 1],
            f = t[g + 2],
            m = t[g + 3],
            _ = t[g + 4],
            y = 0 === n ? d : p,
            v = 0 === n ? m : _;
          let x = !1;
          s && (c = Math.sqrt(Math.pow(d - m, 2) + Math.pow(p - _, 2))),
            y < i
              ? v > i && ((h = l(o, d, p, m, _, i)), s && (o.start = u + c * h))
              : y > r
              ? v < r && ((h = l(o, d, p, m, _, r)), s && (o.start = u + c * h))
              : Z(o, d, p, f),
            v < i && y >= i && ((h = l(o, d, p, m, _, i)), (x = !0)),
            v > r && y <= r && ((h = l(o, d, p, m, _, r)), (x = !0)),
            !a && x && (s && (o.end = u + c * h), e.push(o), (o = U(t))),
            s && (u += c);
        }
        let d = t.length - 3;
        const p = t[d],
          f = t[d + 1],
          m = 0 === n ? p : f;
        m >= i && m <= r && Z(o, p, f, t[d + 2]),
          (d = o.length - 3),
          a &&
            d >= 3 &&
            (o[d] !== o[0] || o[d + 1] !== o[1]) &&
            Z(o, o[0], o[1], o[2]),
          o.length && e.push(o);
      }
      function U(t) {
        const e = [];
        return (e.size = t.size), (e.start = t.start), (e.end = t.end), e;
      }
      function G(t, e, i, r, n, a) {
        for (const s of t) j(s, e, i, r, n, a, !1);
      }
      function Z(t, e, i, r) {
        t.push(e, i, r);
      }
      function $(t, e, i, r, n, a) {
        const s = (a - e) / (r - e);
        return Z(t, a, i + (n - i) * s, 1), s;
      }
      function q(t, e, i, r, n, a) {
        const s = (a - i) / (n - i);
        return Z(t, e + (r - e) * s, a, 1), s;
      }
      function H(t, e) {
        const i = [];
        for (let r = 0; r < t.length; r++) {
          const n = t[r],
            a = n.type;
          let s;
          if ('Point' === a || 'MultiPoint' === a || 'LineString' === a)
            s = W(n.geometry, e);
          else if ('MultiLineString' === a || 'Polygon' === a) {
            s = [];
            for (const t of n.geometry) s.push(W(t, e));
          } else if ('MultiPolygon' === a) {
            s = [];
            for (const t of n.geometry) {
              const i = [];
              for (const r of t) i.push(W(r, e));
              s.push(i);
            }
          }
          i.push(A(n.id, a, s, n.tags));
        }
        return i;
      }
      function W(t, e) {
        const i = [];
        (i.size = t.size),
          void 0 !== t.start && ((i.start = t.start), (i.end = t.end));
        for (let r = 0; r < t.length; r += 3)
          i.push(t[r] + e, t[r + 1], t[r + 2]);
        return i;
      }
      function X(t, e) {
        if (t.transformed) return t;
        const i = 1 << t.z,
          r = t.x,
          n = t.y;
        for (const a of t.features) {
          const t = a.geometry,
            s = a.type;
          if (((a.geometry = []), 1 === s))
            for (let o = 0; o < t.length; o += 2)
              a.geometry.push(Y(t[o], t[o + 1], e, i, r, n));
          else
            for (let o = 0; o < t.length; o++) {
              const s = [];
              for (let a = 0; a < t[o].length; a += 2)
                s.push(Y(t[o][a], t[o][a + 1], e, i, r, n));
              a.geometry.push(s);
            }
        }
        return (t.transformed = !0), t;
      }
      function Y(t, e, i, r, n, a) {
        return [Math.round(i * (t * r - n)), Math.round(i * (e * r - a))];
      }
      function K(t, e, i, r, n) {
        const a = e === n.maxZoom ? 0 : n.tolerance / ((1 << e) * n.extent),
          s = {
            features: [],
            numPoints: 0,
            numSimplified: 0,
            numFeatures: t.length,
            source: null,
            x: i,
            y: r,
            z: e,
            transformed: !1,
            minX: 2,
            minY: 1,
            maxX: -1,
            maxY: 0,
          };
        for (const o of t) J(s, o, a, n);
        return s;
      }
      function J(t, e, i, r) {
        const n = e.geometry,
          a = e.type,
          s = [];
        if (
          ((t.minX = Math.min(t.minX, e.minX)),
          (t.minY = Math.min(t.minY, e.minY)),
          (t.maxX = Math.max(t.maxX, e.maxX)),
          (t.maxY = Math.max(t.maxY, e.maxY)),
          'Point' === a || 'MultiPoint' === a)
        )
          for (let o = 0; o < n.length; o += 3)
            s.push(n[o], n[o + 1]), t.numPoints++, t.numSimplified++;
        else if ('LineString' === a) Q(s, n, t, i, !1, !1);
        else if ('MultiLineString' === a || 'Polygon' === a)
          for (let o = 0; o < n.length; o++)
            Q(s, n[o], t, i, 'Polygon' === a, 0 === o);
        else if ('MultiPolygon' === a)
          for (let o = 0; o < n.length; o++) {
            const e = n[o];
            for (let r = 0; r < e.length; r++) Q(s, e[r], t, i, !0, 0 === r);
          }
        if (s.length) {
          let i = e.tags || null;
          if ('LineString' === a && r.lineMetrics) {
            i = {};
            for (const t in e.tags) i[t] = e.tags[t];
            (i.mapbox_clip_start = n.start / n.size),
              (i.mapbox_clip_end = n.end / n.size);
          }
          const o = {
            geometry: s,
            type:
              'Polygon' === a || 'MultiPolygon' === a
                ? 3
                : 'LineString' === a || 'MultiLineString' === a
                ? 2
                : 1,
            tags: i,
          };
          null !== e.id && (o.id = e.id), t.features.push(o);
        }
      }
      function Q(t, e, i, r, n, a) {
        const s = r * r;
        if (r > 0 && e.size < (n ? s : r))
          return void (i.numPoints += e.length / 3);
        const o = [];
        for (let l = 0; l < e.length; l += 3)
          (0 === r || e[l + 2] > s) &&
            (i.numSimplified++, o.push(e[l], e[l + 1])),
            i.numPoints++;
        n &&
          (function (t, e) {
            let i = 0;
            for (let r = 0, n = t.length, a = n - 2; r < n; a = r, r += 2)
              i += (t[r] - t[a]) * (t[r + 1] + t[a + 1]);
            if (i > 0 === e)
              for (let r = 0, n = t.length; r < n / 2; r += 2) {
                const e = t[r],
                  i = t[r + 1];
                (t[r] = t[n - 2 - r]),
                  (t[r + 1] = t[n - 1 - r]),
                  (t[n - 2 - r] = e),
                  (t[n - 1 - r] = i);
              }
          })(o, a),
          t.push(o);
      }
      const tt = {
        maxZoom: 14,
        indexMaxZoom: 5,
        indexMaxPoints: 1e5,
        tolerance: 3,
        extent: 4096,
        buffer: 64,
        lineMetrics: !1,
        promoteId: null,
        generateId: !1,
        debug: 0,
      };
      class et {
        constructor(t, e) {
          const i = (e = this.options =
            (function (t, e) {
              for (const i in e) t[i] = e[i];
              return t;
            })(Object.create(tt), e)).debug;
          if (
            (i && console.time('preprocess data'),
            e.maxZoom < 0 || e.maxZoom > 24)
          )
            throw new Error('maxZoom should be in the 0-24 range');
          if (e.promoteId && e.generateId)
            throw new Error(
              'promoteId and generateId cannot be used together.'
            );
          let r = (function (t, e) {
            const i = [];
            if ('FeatureCollection' === t.type)
              for (let r = 0; r < t.features.length; r++)
                R(i, t.features[r], e, r);
            else R(i, 'Feature' === t.type ? t : { geometry: t }, e);
            return i;
          })(t, e);
          (this.tiles = {}),
            (this.tileCoords = []),
            i &&
              (console.timeEnd('preprocess data'),
              console.log(
                'index: maxZoom: %d, maxPoints: %d',
                e.indexMaxZoom,
                e.indexMaxPoints
              ),
              console.time('generate tiles'),
              (this.stats = {}),
              (this.total = 0)),
            (r = (function (t, e) {
              const i = e.buffer / e.extent;
              let r = t;
              const n = N(t, 1, -1 - i, i, 0, -1, 2, e),
                a = N(t, 1, 1 - i, 2 + i, 0, -1, 2, e);
              return (
                (n || a) &&
                  ((r = N(t, 1, -i, 1 + i, 0, -1, 2, e) || []),
                  n && (r = H(n, 1).concat(r)),
                  a && (r = r.concat(H(a, -1)))),
                r
              );
            })(r, e)),
            r.length && this.splitTile(r, 0, 0, 0),
            i &&
              (r.length &&
                console.log(
                  'features: %d, points: %d',
                  this.tiles[0].numFeatures,
                  this.tiles[0].numPoints
                ),
              console.timeEnd('generate tiles'),
              console.log(
                'tiles generated:',
                this.total,
                JSON.stringify(this.stats)
              ));
        }
        splitTile(t, e, i, r, n, a, s) {
          const o = [t, e, i, r],
            l = this.options,
            c = l.debug;
          for (; o.length; ) {
            (r = o.pop()), (i = o.pop()), (e = o.pop()), (t = o.pop());
            const h = 1 << e,
              u = it(e, i, r);
            let d = this.tiles[u];
            if (
              !d &&
              (c > 1 && console.time('creation'),
              (d = this.tiles[u] = K(t, e, i, r, l)),
              this.tileCoords.push({ z: e, x: i, y: r }),
              c)
            ) {
              c > 1 &&
                (console.log(
                  'tile z%d-%d-%d (features: %d, points: %d, simplified: %d)',
                  e,
                  i,
                  r,
                  d.numFeatures,
                  d.numPoints,
                  d.numSimplified
                ),
                console.timeEnd('creation'));
              const t = `z${e}`;
              (this.stats[t] = (this.stats[t] || 0) + 1), this.total++;
            }
            if (((d.source = t), null == n)) {
              if (e === l.indexMaxZoom || d.numPoints <= l.indexMaxPoints)
                continue;
            } else {
              if (e === l.maxZoom || e === n) continue;
              if (null != n) {
                const t = n - e;
                if (i !== a >> t || r !== s >> t) continue;
              }
            }
            if (((d.source = null), 0 === t.length)) continue;
            c > 1 && console.time('clipping');
            const p = (0.5 * l.buffer) / l.extent,
              f = 0.5 - p,
              m = 0.5 + p,
              g = 1 + p;
            let _ = null,
              y = null,
              v = null,
              x = null,
              b = N(t, h, i - p, i + m, 0, d.minX, d.maxX, l),
              w = N(t, h, i + f, i + g, 0, d.minX, d.maxX, l);
            (t = null),
              b &&
                ((_ = N(b, h, r - p, r + m, 1, d.minY, d.maxY, l)),
                (y = N(b, h, r + f, r + g, 1, d.minY, d.maxY, l)),
                (b = null)),
              w &&
                ((v = N(w, h, r - p, r + m, 1, d.minY, d.maxY, l)),
                (x = N(w, h, r + f, r + g, 1, d.minY, d.maxY, l)),
                (w = null)),
              c > 1 && console.timeEnd('clipping'),
              o.push(_ || [], e + 1, 2 * i, 2 * r),
              o.push(y || [], e + 1, 2 * i, 2 * r + 1),
              o.push(v || [], e + 1, 2 * i + 1, 2 * r),
              o.push(x || [], e + 1, 2 * i + 1, 2 * r + 1);
          }
        }
        getTile(t, e, i) {
          (t = +t), (e = +e), (i = +i);
          const r = this.options,
            { extent: n, debug: a } = r;
          if (t < 0 || t > 24) return null;
          const s = 1 << t,
            o = it(t, (e = (e + s) & (s - 1)), i);
          if (this.tiles[o]) return X(this.tiles[o], n);
          a > 1 && console.log('drilling down to z%d-%d-%d', t, e, i);
          let l,
            c = t,
            h = e,
            u = i;
          for (; !l && c > 0; )
            c--, (h >>= 1), (u >>= 1), (l = this.tiles[it(c, h, u)]);
          return l && l.source
            ? (a > 1 &&
                (console.log('found parent tile z%d-%d-%d', c, h, u),
                console.time('drilling down')),
              this.splitTile(l.source, c, h, u, t, e, i),
              a > 1 && console.timeEnd('drilling down'),
              this.tiles[o] ? X(this.tiles[o], n) : null)
            : null;
        }
      }
      function it(t, e, i) {
        return 32 * ((1 << t) * i + e) + t;
      }
      class rt extends a {
        constructor(t, e, i, r = nt) {
          super(t, e, i),
            (this._dataUpdateable = new Map()),
            (this._createGeoJSONIndex = r);
        }
        loadVectorTile(e, i) {
          return t._(this, void 0, void 0, function* () {
            const i = e.tileID.canonical;
            if (!this._geoJSONIndex)
              throw new Error(
                'Unable to parse the data into a cluster or geojson'
              );
            const r = this._geoJSONIndex.getTile(i.z, i.x, i.y);
            if (!r) return null;
            const n = new d(r.features, { version: 2, extent: t.a3 });
            let a = (function (e) {
              const i = new t.cP();
              return (
                (function (t, e) {
                  for (const i in t.layers) e.writeMessage(3, p, t.layers[i]);
                })(e, i),
                i.finish()
              );
            })(n);
            return (
              (0 === a.byteOffset && a.byteLength === a.buffer.byteLength) ||
                (a = new Uint8Array(a)),
              { vectorTile: n, rawData: a.buffer }
            );
          });
        }
        loadData(e) {
          return t._(this, void 0, void 0, function* () {
            var i;
            null === (i = this._pendingRequest) || void 0 === i || i.abort();
            const r =
              !!(e && e.request && e.request.collectResourceTiming) &&
              new t.cQ(e.request);
            this._pendingRequest = new AbortController();
            try {
              (!this._pendingData || e.request || e.data || e.dataDiff) &&
                (this._pendingData = this.loadAndProcessGeoJSON(
                  e,
                  this._pendingRequest
                ));
              const t = yield this._pendingData;
              (this._geoJSONIndex = this._createGeoJSONIndex(t, e)),
                (this.loaded = {});
              const i = { data: t };
              if (r) {
                const t = r.finish();
                t &&
                  ((i.resourceTiming = {}),
                  (i.resourceTiming[e.source] = JSON.parse(JSON.stringify(t))));
              }
              return i;
            } catch (e) {
              if ((delete this._pendingRequest, t.cB(e)))
                return { abandoned: !0 };
              throw e;
            }
          });
        }
        getData() {
          return t._(this, void 0, void 0, function* () {
            return this._pendingData;
          });
        }
        reloadTile(t) {
          const e = this.loaded;
          return e && e[t.uid] ? super.reloadTile(t) : this.loadTile(t);
        }
        loadAndProcessGeoJSON(e, i) {
          return t._(this, void 0, void 0, function* () {
            let r = yield this.loadGeoJSON(e, i);
            if ((delete this._pendingRequest, 'object' != typeof r))
              throw new Error(
                `Input data given to '${e.source}' is not a valid GeoJSON object.`
              );
            if ((h(r, !0), e.filter)) {
              const i = t.cW(e.filter, {
                'type': 'boolean',
                'property-type': 'data-driven',
                'overridable': !1,
                'transition': !1,
              });
              if ('error' === i.result)
                throw new Error(
                  i.value.map((t) => `${t.key}: ${t.message}`).join(', ')
                );
              const n = r.features.filter((t) =>
                i.value.evaluate({ zoom: 0 }, t)
              );
              r = { type: 'FeatureCollection', features: n };
            }
            return r;
          });
        }
        loadGeoJSON(e, i) {
          return t._(this, void 0, void 0, function* () {
            const { promoteId: r } = e;
            if (e.request) {
              const n = yield t.j(e.request, i);
              return (
                (this._dataUpdateable = t.cY(n.data, r)
                  ? t.cX(n.data, r)
                  : void 0),
                n.data
              );
            }
            if ('string' == typeof e.data)
              try {
                const i = JSON.parse(e.data);
                return (
                  (this._dataUpdateable = t.cY(i, r) ? t.cX(i, r) : void 0), i
                );
              } catch (t) {
                throw new Error(
                  `Input data given to '${e.source}' is not a valid GeoJSON object.`
                );
              }
            if (!e.dataDiff)
              throw new Error(
                `Input data given to '${e.source}' is not a valid GeoJSON object.`
              );
            if (!this._dataUpdateable)
              throw new Error(
                `Cannot update existing geojson data in ${e.source}`
              );
            return (
              t.cZ(this._dataUpdateable, e.dataDiff, r),
              {
                type: 'FeatureCollection',
                features: Array.from(this._dataUpdateable.values()),
              }
            );
          });
        }
        removeSource(e) {
          return t._(this, void 0, void 0, function* () {
            this._pendingRequest && this._pendingRequest.abort();
          });
        }
        getClusterExpansionZoom(t) {
          return this._geoJSONIndex.getClusterExpansionZoom(t.clusterId);
        }
        getClusterChildren(t) {
          return this._geoJSONIndex.getChildren(t.clusterId);
        }
        getClusterLeaves(t) {
          return this._geoJSONIndex.getLeaves(t.clusterId, t.limit, t.offset);
        }
      }
      function nt(e, i) {
        return i.cluster
          ? new T(
              (function ({ superclusterOptions: e, clusterProperties: i }) {
                if (!i || !e) return e;
                const r = {},
                  n = {},
                  a = { accumulated: null, zoom: 0 },
                  s = { properties: null },
                  o = Object.keys(i);
                for (const l of o) {
                  const [e, a] = i[l],
                    s = t.cW(a),
                    o = t.cW(
                      'string' == typeof e
                        ? [e, ['accumulated'], ['get', l]]
                        : e
                    );
                  (r[l] = s.value), (n[l] = o.value);
                }
                return (
                  (e.map = (t) => {
                    s.properties = t;
                    const e = {};
                    for (const i of o) e[i] = r[i].evaluate(a, s);
                    return e;
                  }),
                  (e.reduce = (t, e) => {
                    s.properties = e;
                    for (const i of o)
                      (a.accumulated = t[i]), (t[i] = n[i].evaluate(a, s));
                  }),
                  e
                );
              })(i)
            ).load(e.features)
          : (function (t, e) {
              return new et(t, e);
            })(e, i.geojsonVtOptions);
      }
      class at {
        constructor(e) {
          (this.self = e),
            (this.actor = new t.K(e)),
            (this.layerIndexes = {}),
            (this.availableImages = {}),
            (this.workerSources = {}),
            (this.demWorkerSources = {}),
            (this.externalWorkerSourceTypes = {}),
            (this.globalStates = new Map()),
            (this.self.registerWorkerSource = (t, e) => {
              if (this.externalWorkerSourceTypes[t])
                throw new Error(
                  `Worker source with name "${t}" already registered.`
                );
              this.externalWorkerSourceTypes[t] = e;
            }),
            (this.self.addProtocol = t.cD),
            (this.self.removeProtocol = t.cE),
            (this.self.registerRTLTextPlugin = (e) => {
              t.c_.setMethods(e);
            }),
            this.actor.registerMessageHandler('LDT', (t, e) =>
              this._getDEMWorkerSource(t, e.source).loadTile(e)
            ),
            this.actor.registerMessageHandler('RDT', (e, i) =>
              t._(this, void 0, void 0, function* () {
                this._getDEMWorkerSource(e, i.source).removeTile(i);
              })
            ),
            this.actor.registerMessageHandler('GCEZ', (e, i) =>
              t._(this, void 0, void 0, function* () {
                return this._getWorkerSource(
                  e,
                  i.type,
                  i.source
                ).getClusterExpansionZoom(i);
              })
            ),
            this.actor.registerMessageHandler('GCC', (e, i) =>
              t._(this, void 0, void 0, function* () {
                return this._getWorkerSource(
                  e,
                  i.type,
                  i.source
                ).getClusterChildren(i);
              })
            ),
            this.actor.registerMessageHandler('GCL', (e, i) =>
              t._(this, void 0, void 0, function* () {
                return this._getWorkerSource(
                  e,
                  i.type,
                  i.source
                ).getClusterLeaves(i);
              })
            ),
            this.actor.registerMessageHandler('LD', (t, e) =>
              this._getWorkerSource(t, e.type, e.source).loadData(e)
            ),
            this.actor.registerMessageHandler('GD', (t, e) =>
              this._getWorkerSource(t, e.type, e.source).getData()
            ),
            this.actor.registerMessageHandler('LT', (t, e) =>
              this._getWorkerSource(t, e.type, e.source).loadTile(e)
            ),
            this.actor.registerMessageHandler('RT', (t, e) =>
              this._getWorkerSource(t, e.type, e.source).reloadTile(e)
            ),
            this.actor.registerMessageHandler('AT', (t, e) =>
              this._getWorkerSource(t, e.type, e.source).abortTile(e)
            ),
            this.actor.registerMessageHandler('RMT', (t, e) =>
              this._getWorkerSource(t, e.type, e.source).removeTile(e)
            ),
            this.actor.registerMessageHandler('RS', (e, i) =>
              t._(this, void 0, void 0, function* () {
                if (
                  !this.workerSources[e] ||
                  !this.workerSources[e][i.type] ||
                  !this.workerSources[e][i.type][i.source]
                )
                  return;
                const t = this.workerSources[e][i.type][i.source];
                delete this.workerSources[e][i.type][i.source],
                  void 0 !== t.removeSource && t.removeSource(i);
              })
            ),
            this.actor.registerMessageHandler('RM', (e) =>
              t._(this, void 0, void 0, function* () {
                delete this.layerIndexes[e],
                  delete this.availableImages[e],
                  delete this.workerSources[e],
                  delete this.demWorkerSources[e],
                  this.globalStates.delete(e);
              })
            ),
            this.actor.registerMessageHandler('SR', (e, i) =>
              t._(this, void 0, void 0, function* () {
                this.referrer = i;
              })
            ),
            this.actor.registerMessageHandler('SRPS', (t, e) =>
              this._syncRTLPluginState(t, e)
            ),
            this.actor.registerMessageHandler('IS', (e, i) =>
              t._(this, void 0, void 0, function* () {
                this.self.importScripts(i);
              })
            ),
            this.actor.registerMessageHandler('SI', (t, e) =>
              this._setImages(t, e)
            ),
            this.actor.registerMessageHandler('UL', (e, i) =>
              t._(this, void 0, void 0, function* () {
                this._getLayerIndex(e).update(
                  i.layers,
                  i.removedIds,
                  this._getGlobalState(e)
                );
              })
            ),
            this.actor.registerMessageHandler('UGS', (e, i) =>
              t._(this, void 0, void 0, function* () {
                const t = this._getGlobalState(e);
                for (const e in i) t[e] = i[e];
              })
            ),
            this.actor.registerMessageHandler('SL', (e, i) =>
              t._(this, void 0, void 0, function* () {
                this._getLayerIndex(e).replace(i, this._getGlobalState(e));
              })
            );
        }
        _getGlobalState(t) {
          let e = this.globalStates.get(t);
          return e || ((e = {}), this.globalStates.set(t, e)), e;
        }
        _setImages(e, i) {
          return t._(this, void 0, void 0, function* () {
            this.availableImages[e] = i;
            for (const t in this.workerSources[e]) {
              const r = this.workerSources[e][t];
              for (const t in r) r[t].availableImages = i;
            }
          });
        }
        _syncRTLPluginState(e, i) {
          return t._(this, void 0, void 0, function* () {
            return yield t.c_.syncState(i, this.self.importScripts);
          });
        }
        _getAvailableImages(t) {
          let e = this.availableImages[t];
          return e || (e = []), e;
        }
        _getLayerIndex(t) {
          let i = this.layerIndexes[t];
          return i || (i = this.layerIndexes[t] = new e()), i;
        }
        _getWorkerSource(t, e, i) {
          if (
            (this.workerSources[t] || (this.workerSources[t] = {}),
            this.workerSources[t][e] || (this.workerSources[t][e] = {}),
            !this.workerSources[t][e][i])
          ) {
            const r = {
              sendAsync: (e, i) => (
                (e.targetMapId = t), this.actor.sendAsync(e, i)
              ),
            };
            switch (e) {
              case 'vector':
                this.workerSources[t][e][i] = new a(
                  r,
                  this._getLayerIndex(t),
                  this._getAvailableImages(t)
                );
                break;
              case 'geojson':
                this.workerSources[t][e][i] = new rt(
                  r,
                  this._getLayerIndex(t),
                  this._getAvailableImages(t)
                );
                break;
              default:
                this.workerSources[t][e][i] =
                  new this.externalWorkerSourceTypes[e](
                    r,
                    this._getLayerIndex(t),
                    this._getAvailableImages(t)
                  );
            }
          }
          return this.workerSources[t][e][i];
        }
        _getDEMWorkerSource(t, e) {
          return (
            this.demWorkerSources[t] || (this.demWorkerSources[t] = {}),
            this.demWorkerSources[t][e] ||
              (this.demWorkerSources[t][e] = new s()),
            this.demWorkerSources[t][e]
          );
        }
      }
      return t.i(self) && (self.worker = new at(self)), at;
    }),
    i('index', ['exports', './shared'], function (t, e) {
      var i = '5.11.0';
      function r() {
        var t = new e.A(4);
        return (
          e.A != Float32Array && ((t[1] = 0), (t[2] = 0)),
          (t[0] = 1),
          (t[3] = 1),
          t
        );
      }
      let n, a;
      const s = {
          frame(t, i, r) {
            const n = requestAnimationFrame((t) => {
                a(), i(t);
              }),
              { unsubscribe: a } = e.s(
                t.signal,
                'abort',
                () => {
                  a(), cancelAnimationFrame(n), r(e.c());
                },
                !1
              );
          },
          frameAsync(t) {
            return new Promise((e, i) => {
              this.frame(t, e, i);
            });
          },
          getImageData(t, e = 0) {
            return this.getImageCanvasContext(t).getImageData(
              -e,
              -e,
              t.width + 2 * e,
              t.height + 2 * e
            );
          },
          getImageCanvasContext(t) {
            const e = window.document.createElement('canvas'),
              i = e.getContext('2d', { willReadFrequently: !0 });
            if (!i) throw new Error('failed to create canvas 2d context');
            return (
              (e.width = t.width),
              (e.height = t.height),
              i.drawImage(t, 0, 0, t.width, t.height),
              i
            );
          },
          resolveURL: (t) => (
            n || (n = document.createElement('a')), (n.href = t), n.href
          ),
          hardwareConcurrency:
            ('undefined' != typeof navigator &&
              navigator.hardwareConcurrency) ||
            4,
          get prefersReducedMotion() {
            return (
              !!matchMedia &&
              (null == a &&
                (a = matchMedia('(prefers-reduced-motion: reduce)')),
              a.matches)
            );
          },
        },
        o = new (class {
          constructor() {
            (this._realTime =
              'undefined' != typeof performance &&
              performance &&
              performance.now
                ? performance.now.bind(performance)
                : Date.now.bind(Date)),
              (this._frozenAt = null);
          }
          getCurrentTime() {
            return null !== this._frozenAt ? this._frozenAt : this._realTime();
          }
          setNow(t) {
            this._frozenAt = t;
          }
          restoreNow() {
            this._frozenAt = null;
          }
          isFrozen() {
            return null !== this._frozenAt;
          }
        })();
      function l() {
        return o.getCurrentTime();
      }
      class c {
        static testProp(t) {
          if (!c.docStyle) return t[0];
          for (let e = 0; e < t.length; e++)
            if (t[e] in c.docStyle) return t[e];
          return t[0];
        }
        static create(t, e, i) {
          const r = window.document.createElement(t);
          return void 0 !== e && (r.className = e), i && i.appendChild(r), r;
        }
        static createNS(t, e) {
          return window.document.createElementNS(t, e);
        }
        static disableDrag() {
          c.docStyle &&
            c.selectProp &&
            ((c.userSelect = c.docStyle[c.selectProp]),
            (c.docStyle[c.selectProp] = 'none'));
        }
        static enableDrag() {
          c.docStyle &&
            c.selectProp &&
            (c.docStyle[c.selectProp] = c.userSelect);
        }
        static setTransform(t, e) {
          t.style[c.transformProp] = e;
        }
        static addEventListener(t, e, i, r = {}) {
          t.addEventListener(e, i, 'passive' in r ? r : r.capture);
        }
        static removeEventListener(t, e, i, r = {}) {
          t.removeEventListener(e, i, 'passive' in r ? r : r.capture);
        }
        static suppressClickInternal(t) {
          t.preventDefault(),
            t.stopPropagation(),
            window.removeEventListener('click', c.suppressClickInternal, !0);
        }
        static suppressClick() {
          window.addEventListener('click', c.suppressClickInternal, !0),
            window.setTimeout(() => {
              window.removeEventListener('click', c.suppressClickInternal, !0);
            }, 0);
        }
        static getScale(t) {
          const e = t.getBoundingClientRect();
          return {
            x: e.width / t.offsetWidth || 1,
            y: e.height / t.offsetHeight || 1,
            boundingClientRect: e,
          };
        }
        static getPoint(t, i, r) {
          const n = i.boundingClientRect;
          return new e.P(
            (r.clientX - n.left) / i.x - t.clientLeft,
            (r.clientY - n.top) / i.y - t.clientTop
          );
        }
        static mousePos(t, e) {
          const i = c.getScale(t);
          return c.getPoint(t, i, e);
        }
        static touchPos(t, e) {
          const i = [],
            r = c.getScale(t);
          for (let n = 0; n < e.length; n++) i.push(c.getPoint(t, r, e[n]));
          return i;
        }
        static mouseButton(t) {
          return t.button;
        }
        static remove(t) {
          t.parentNode && t.parentNode.removeChild(t);
        }
        static sanitize(t) {
          const e =
              new DOMParser().parseFromString(t, 'text/html').body ||
              document.createElement('body'),
            i = e.querySelectorAll('script');
          for (const r of i) r.remove();
          return c.clean(e), e.innerHTML;
        }
        static isPossiblyDangerous(t, e) {
          const i = e.replace(/\s+/g, '').toLowerCase();
          return (
            !(
              !['src', 'href', 'xlink:href'].includes(t) ||
              (!i.includes('javascript:') && !i.includes('data:'))
            ) ||
            !!t.startsWith('on') ||
            void 0
          );
        }
        static clean(t) {
          const e = t.children;
          for (const i of e) c.removeAttributes(i), c.clean(i);
        }
        static removeAttributes(t) {
          for (const { name: e, value: i } of t.attributes)
            c.isPossiblyDangerous(e, i) && t.removeAttribute(e);
        }
      }
      (c.docStyle =
        'undefined' != typeof window &&
        window.document &&
        window.document.documentElement.style),
        (c.selectProp = c.testProp([
          'userSelect',
          'MozUserSelect',
          'WebkitUserSelect',
          'msUserSelect',
        ])),
        (c.transformProp = c.testProp(['transform', 'WebkitTransform']));
      const h = {
        supported: !1,
        testSupport: function (t) {
          !p && d && (f ? m(t) : (u = t));
        },
      };
      let u,
        d,
        p = !1,
        f = !1;
      function m(t) {
        const e = t.createTexture();
        t.bindTexture(t.TEXTURE_2D, e);
        try {
          if (
            (t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, t.RGBA, t.UNSIGNED_BYTE, d),
            t.isContextLost())
          )
            return;
          h.supported = !0;
        } catch (t) {}
        t.deleteTexture(e), (p = !0);
      }
      var g;
      'undefined' != typeof document &&
        ((d = document.createElement('img')),
        (d.onload = () => {
          u && m(u), (u = null), (f = !0);
        }),
        (d.onerror = () => {
          (p = !0), (u = null);
        }),
        (d.src =
          'data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=')),
        (function (t) {
          let i, r, n, a;
          (t.resetRequestQueue = () => {
            (i = []), (r = 0), (n = 0), (a = {});
          }),
            (t.addThrottleControl = (t) => {
              const e = n++;
              return (a[e] = t), e;
            }),
            (t.removeThrottleControl = (t) => {
              delete a[t], o();
            }),
            (t.getImage = (t, r, n = !0) =>
              new Promise((a, s) => {
                h.supported &&
                  (t.headers || (t.headers = {}),
                  (t.headers.accept = 'image/webp,*/*')),
                  e.e(t, { type: 'image' }),
                  i.push({
                    abortController: r,
                    requestParameters: t,
                    supportImageRefresh: n,
                    state: 'queued',
                    onError: (t) => {
                      s(t);
                    },
                    onSuccess: (t) => {
                      a(t);
                    },
                  }),
                  o();
              }));
          const s = (t) =>
              e._(this, void 0, void 0, function* () {
                t.state = 'running';
                const {
                    requestParameters: i,
                    supportImageRefresh: n,
                    onError: a,
                    onSuccess: s,
                    abortController: c,
                  } = t,
                  h =
                    !1 === n &&
                    !e.i(self) &&
                    !e.g(i.url) &&
                    (!i.headers ||
                      Object.keys(i.headers).reduce(
                        (t, e) => t && 'accept' === e,
                        !0
                      ));
                r++;
                const u = h ? l(i, c) : e.m(i, c);
                try {
                  const i = yield u;
                  delete t.abortController,
                    (t.state = 'completed'),
                    i.data instanceof HTMLImageElement || e.b(i.data)
                      ? s(i)
                      : i.data &&
                        s({
                          data: yield ((d = i.data),
                          'function' == typeof createImageBitmap
                            ? e.f(d)
                            : e.h(d)),
                          cacheControl: i.cacheControl,
                          expires: i.expires,
                        });
                } catch (e) {
                  delete t.abortController, a(e);
                } finally {
                  r--, o();
                }
                var d;
              }),
            o = () => {
              const t = (() => {
                for (const t of Object.keys(a)) if (a[t]()) return !0;
                return !1;
              })()
                ? e.a.MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME
                : e.a.MAX_PARALLEL_IMAGE_REQUESTS;
              for (let e = r; e < t && i.length > 0; e++) {
                const t = i.shift();
                t.abortController.signal.aborted ? e-- : s(t);
              }
            },
            l = (t, i) =>
              new Promise((r, n) => {
                const a = new Image(),
                  s = t.url,
                  o = t.credentials;
                o && 'include' === o
                  ? (a.crossOrigin = 'use-credentials')
                  : ((o && 'same-origin' === o) || !e.d(s)) &&
                    (a.crossOrigin = 'anonymous'),
                  i.signal.addEventListener('abort', () => {
                    (a.src = ''), n(e.c());
                  }),
                  (a.fetchPriority = 'high'),
                  (a.onload = () => {
                    (a.onerror = a.onload = null), r({ data: a });
                  }),
                  (a.onerror = () => {
                    (a.onerror = a.onload = null),
                      i.signal.aborted ||
                        n(
                          new Error(
                            'Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.'
                          )
                        );
                  }),
                  (a.src = s);
              });
        })(g || (g = {})),
        g.resetRequestQueue();
      class _ {
        constructor(t) {
          this._transformRequestFn = null != t ? t : null;
        }
        transformRequest(t, e) {
          return (
            (this._transformRequestFn && this._transformRequestFn(t, e)) || {
              url: t,
            }
          );
        }
        setTransformRequest(t) {
          this._transformRequestFn = t;
        }
      }
      function y(t) {
        const e = [];
        if ('string' == typeof t) e.push({ id: 'default', url: t });
        else if (t && t.length > 0) {
          const i = [];
          for (const { id: r, url: n } of t) {
            const t = `${r}${n}`;
            -1 === i.indexOf(t) && (i.push(t), e.push({ id: r, url: n }));
          }
        }
        return e;
      }
      function v(t, e, i) {
        try {
          const r = new URL(t);
          return (r.pathname += `${e}${i}`), r.toString();
        } catch (e) {
          throw new Error(
            `Invalid sprite URL "${t}", must be absolute. Modify style specification directly or use TransformStyleFunction to correct the issue dynamically`
          );
        }
      }
      function x(t) {
        const { userImage: e } = t;
        return (
          !!(e && e.render && e.render()) &&
          (t.data.replace(new Uint8Array(e.data.buffer)), !0)
        );
      }
      class b extends e.E {
        constructor() {
          super(),
            (this.images = {}),
            (this.updatedImages = {}),
            (this.callbackDispatchedThisFrame = {}),
            (this.loaded = !1),
            (this.requestors = []),
            (this.patterns = {}),
            (this.atlasImage = new e.R({ width: 1, height: 1 })),
            (this.dirty = !0);
        }
        isLoaded() {
          return this.loaded;
        }
        setLoaded(t) {
          if (this.loaded !== t && ((this.loaded = t), t)) {
            for (const { ids: t, promiseResolve: e } of this.requestors)
              e(this._getImagesForIds(t));
            this.requestors = [];
          }
        }
        getImage(t) {
          const i = this.images[t];
          if (i && !i.data && i.spriteData) {
            const t = i.spriteData;
            (i.data = new e.R(
              { width: t.width, height: t.height },
              t.context.getImageData(t.x, t.y, t.width, t.height).data
            )),
              (i.spriteData = null);
          }
          return i;
        }
        addImage(t, e) {
          if (this.images[t])
            throw new Error(
              `Image id ${t} already exist, use updateImage instead`
            );
          this._validate(t, e) && (this.images[t] = e);
        }
        _validate(t, i) {
          let r = !0;
          const n = i.data || i.spriteData;
          return (
            this._validateStretch(i.stretchX, n && n.width) ||
              (this.fire(
                new e.k(new Error(`Image "${t}" has invalid "stretchX" value`))
              ),
              (r = !1)),
            this._validateStretch(i.stretchY, n && n.height) ||
              (this.fire(
                new e.k(new Error(`Image "${t}" has invalid "stretchY" value`))
              ),
              (r = !1)),
            this._validateContent(i.content, i) ||
              (this.fire(
                new e.k(new Error(`Image "${t}" has invalid "content" value`))
              ),
              (r = !1)),
            r
          );
        }
        _validateStretch(t, e) {
          if (!t) return !0;
          let i = 0;
          for (const r of t) {
            if (r[0] < i || r[1] < r[0] || e < r[1]) return !1;
            i = r[1];
          }
          return !0;
        }
        _validateContent(t, e) {
          if (!t) return !0;
          if (4 !== t.length) return !1;
          const i = e.spriteData,
            r = (i && i.width) || e.data.width,
            n = (i && i.height) || e.data.height;
          return !(
            t[0] < 0 ||
            r < t[0] ||
            t[1] < 0 ||
            n < t[1] ||
            t[2] < 0 ||
            r < t[2] ||
            t[3] < 0 ||
            n < t[3] ||
            t[2] < t[0] ||
            t[3] < t[1]
          );
        }
        updateImage(t, e, i = !0) {
          const r = this.getImage(t);
          if (
            i &&
            (r.data.width !== e.data.width || r.data.height !== e.data.height)
          )
            throw new Error(
              `size mismatch between old image (${r.data.width}x${r.data.height}) and new image (${e.data.width}x${e.data.height}).`
            );
          (e.version = r.version + 1),
            (this.images[t] = e),
            (this.updatedImages[t] = !0);
        }
        removeImage(t) {
          const e = this.images[t];
          delete this.images[t],
            delete this.patterns[t],
            e.userImage && e.userImage.onRemove && e.userImage.onRemove();
        }
        listImages() {
          return Object.keys(this.images);
        }
        getImages(t) {
          return new Promise((e, i) => {
            let r = !0;
            if (!this.isLoaded()) for (const n of t) this.images[n] || (r = !1);
            this.isLoaded() || r
              ? e(this._getImagesForIds(t))
              : this.requestors.push({ ids: t, promiseResolve: e });
          });
        }
        _getImagesForIds(t) {
          const i = {};
          for (const r of t) {
            let t = this.getImage(r);
            t ||
              (this.fire(new e.l('styleimagemissing', { id: r })),
              (t = this.getImage(r))),
              t
                ? (i[r] = {
                    data: t.data.clone(),
                    pixelRatio: t.pixelRatio,
                    sdf: t.sdf,
                    version: t.version,
                    stretchX: t.stretchX,
                    stretchY: t.stretchY,
                    content: t.content,
                    textFitWidth: t.textFitWidth,
                    textFitHeight: t.textFitHeight,
                    hasRenderCallback: Boolean(
                      t.userImage && t.userImage.render
                    ),
                  })
                : e.w(
                    `Image "${r}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`
                  );
          }
          return i;
        }
        getPixelSize() {
          const { width: t, height: e } = this.atlasImage;
          return { width: t, height: e };
        }
        getPattern(t) {
          const i = this.patterns[t],
            r = this.getImage(t);
          if (!r) return null;
          if (i && i.position.version === r.version) return i.position;
          if (i) i.position.version = r.version;
          else {
            const i = { w: r.data.width + 2, h: r.data.height + 2, x: 0, y: 0 },
              n = new e.I(i, r);
            this.patterns[t] = { bin: i, position: n };
          }
          return this._updatePatternAtlas(), this.patterns[t].position;
        }
        bind(t) {
          const i = t.gl;
          this.atlasTexture
            ? this.dirty &&
              (this.atlasTexture.update(this.atlasImage), (this.dirty = !1))
            : (this.atlasTexture = new e.T(t, this.atlasImage, i.RGBA)),
            this.atlasTexture.bind(i.LINEAR, i.CLAMP_TO_EDGE);
        }
        _updatePatternAtlas() {
          const t = [];
          for (const e in this.patterns) t.push(this.patterns[e].bin);
          const { w: i, h: r } = e.p(t),
            n = this.atlasImage;
          n.resize({ width: i || 1, height: r || 1 });
          for (const a in this.patterns) {
            const { bin: t } = this.patterns[a],
              i = t.x + 1,
              r = t.y + 1,
              s = this.getImage(a).data,
              o = s.width,
              l = s.height;
            e.R.copy(
              s,
              n,
              { x: 0, y: 0 },
              { x: i, y: r },
              { width: o, height: l }
            ),
              e.R.copy(
                s,
                n,
                { x: 0, y: l - 1 },
                { x: i, y: r - 1 },
                { width: o, height: 1 }
              ),
              e.R.copy(
                s,
                n,
                { x: 0, y: 0 },
                { x: i, y: r + l },
                { width: o, height: 1 }
              ),
              e.R.copy(
                s,
                n,
                { x: o - 1, y: 0 },
                { x: i - 1, y: r },
                { width: 1, height: l }
              ),
              e.R.copy(
                s,
                n,
                { x: 0, y: 0 },
                { x: i + o, y: r },
                { width: 1, height: l }
              );
          }
          this.dirty = !0;
        }
        beginFrame() {
          this.callbackDispatchedThisFrame = {};
        }
        dispatchRenderCallbacks(t) {
          for (const i of t) {
            if (this.callbackDispatchedThisFrame[i]) continue;
            this.callbackDispatchedThisFrame[i] = !0;
            const t = this.getImage(i);
            t || e.w(`Image with ID: "${i}" was not found`),
              x(t) && this.updateImage(i, t);
          }
        }
      }
      const w = 1e20;
      function T(t, e, i, r, n, a, s, o, l) {
        for (let c = e; c < e + r; c++) P(t, i * a + c, a, n, s, o, l);
        for (let c = i; c < i + n; c++) P(t, c * a + e, 1, r, s, o, l);
      }
      function P(t, e, i, r, n, a, s) {
        (a[0] = 0), (s[0] = -w), (s[1] = w), (n[0] = t[e]);
        for (let o = 1, l = 0, c = 0; o < r; o++) {
          n[o] = t[e + o * i];
          const r = o * o;
          do {
            const t = a[l];
            c = (n[o] - n[t] + r - t * t) / (o - t) / 2;
          } while (c <= s[l] && --l > -1);
          l++, (a[l] = o), (s[l] = c), (s[l + 1] = w);
        }
        for (let o = 0, l = 0; o < r; o++) {
          for (; s[l + 1] < o; ) l++;
          const r = a[l],
            c = o - r;
          t[e + o * i] = n[r] + c * c;
        }
      }
      const C = e.v.layout_symbol['text-font'].default.join(',');
      class I {
        constructor(t, e, i) {
          (this.requestManager = t),
            (this.localIdeographFontFamily = e),
            (this.entries = {}),
            (this.lang = i);
        }
        setURL(t) {
          this.url = t;
        }
        getGlyphs(t) {
          return e._(this, void 0, void 0, function* () {
            const e = [];
            for (const n in t)
              for (const i of t[n])
                e.push(this._getAndCacheGlyphsPromise(n, i));
            const i = yield Promise.all(e),
              r = {};
            for (const { stack: t, id: n, glyph: a } of i)
              r[t] || (r[t] = {}),
                (r[t][n] = a && {
                  id: a.id,
                  bitmap: a.bitmap.clone(),
                  metrics: a.metrics,
                });
            return r;
          });
        }
        _getAndCacheGlyphsPromise(t, i) {
          return e._(this, void 0, void 0, function* () {
            let e = this.entries[t];
            e ||
              (e = this.entries[t] = { glyphs: {}, requests: {}, ranges: {} });
            let r = e.glyphs[i];
            return void 0 !== r
              ? { stack: t, id: i, glyph: r }
              : !this.url || this._charUsesLocalIdeographFontFamily(i)
              ? ((r = e.glyphs[i] = this._drawGlyph(e, t, i)),
                { stack: t, id: i, glyph: r })
              : yield this._downloadAndCacheRangePromise(t, i);
          });
        }
        _downloadAndCacheRangePromise(t, i) {
          return e._(this, void 0, void 0, function* () {
            const e = Math.floor(i / 256);
            if (256 * e > 65535)
              throw new Error('glyphs > 65535 not supported');
            const r = this.entries[t];
            if (r.ranges[e]) return { stack: t, id: i, glyph: null };
            if (!r.requests[e]) {
              const i = I.loadGlyphRange(t, e, this.url, this.requestManager);
              r.requests[e] = i;
            }
            try {
              const n = yield r.requests[e];
              for (const t in n) r.glyphs[+t] = n[+t];
              return (
                (r.ranges[e] = !0), { stack: t, id: i, glyph: n[i] || null }
              );
            } catch (n) {
              const s = (r.glyphs[i] = this._drawGlyph(r, t, i));
              return (
                this._warnOnMissingGlyphRange(s, e, i, n),
                { stack: t, id: i, glyph: s }
              );
            }
          });
        }
        _warnOnMissingGlyphRange(t, i, r, n) {
          const a = 256 * i,
            s = a + 255,
            o = r.toString(16).padStart(4, '0').toUpperCase();
          e.w(
            `Unable to load glyph range ${i}, ${a}-${s}. Rendering codepoint U+${o} locally instead. ${n}`
          );
        }
        _charUsesLocalIdeographFontFamily(t) {
          return (
            !!this.localIdeographFontFamily &&
            (/\p{Ideo}|\p{sc=Hang}|\p{sc=Hira}|\p{sc=Kana}/u.test(
              String.fromCodePoint(t)
            ) ||
              e.u['CJK Unified Ideographs'](t) ||
              e.u['Hangul Syllables'](t) ||
              e.u.Hiragana(t) ||
              e.u.Katakana(t) ||
              e.u['CJK Symbols and Punctuation'](t) ||
              e.u['Halfwidth and Fullwidth Forms'](t))
          );
        }
        _drawGlyph(t, i, r) {
          const n =
              i === C &&
              '' !== this.localIdeographFontFamily &&
              this._charUsesLocalIdeographFontFamily(r),
            a = n ? 'ideographTinySDF' : 'tinySDF';
          t[a] ||
            (t[a] = this._createTinySDF(n ? this.localIdeographFontFamily : i));
          const s = t[a].draw(String.fromCharCode(r));
          return {
            id: r,
            bitmap: new e.q(
              { width: s.width || 60, height: s.height || 60 },
              s.data
            ),
            metrics: {
              width: s.glyphWidth / 2 || 24,
              height: s.glyphHeight / 2 || 24,
              left: s.glyphLeft / 2 + 0.5 || 0,
              top: s.glyphTop / 2 - 27.5 || -8,
              advance: s.glyphAdvance / 2 || 24,
              isDoubleResolution: !0,
            },
          };
        }
        _createTinySDF(t) {
          const e = t ? t.split(',') : [];
          e.push('sans-serif');
          const i = e
            .map((t) => (/[-\w]+/.test(t) ? t : `'${CSS.escape(t)}'`))
            .join(',');
          return new I.TinySDF({
            fontSize: 48,
            buffer: 6,
            radius: 16,
            cutoff: 0.25,
            fontFamily: i,
            fontWeight: this._fontWeight(e[0]),
            fontStyle: this._fontStyle(e[0]),
            lang: this.lang,
          });
        }
        _fontStyle(t) {
          return /italic/i.test(t)
            ? 'italic'
            : /oblique/i.test(t)
            ? 'oblique'
            : 'normal';
        }
        _fontWeight(t) {
          const e = {
            'thin': 100,
            'hairline': 100,
            'extra light': 200,
            'ultra light': 200,
            'light': 300,
            'normal': 400,
            'regular': 400,
            'medium': 500,
            'semibold': 600,
            'demibold': 600,
            'bold': 700,
            'extra bold': 800,
            'ultra bold': 800,
            'black': 900,
            'heavy': 900,
            'extra black': 950,
            'ultra black': 950,
          };
          let i;
          for (const [r, n] of Object.entries(e))
            new RegExp(`\\b${r}\\b`, 'i').test(t) && (i = `${n}`);
          return i;
        }
      }
      (I.loadGlyphRange = function (t, i, r, n) {
        return e._(this, void 0, void 0, function* () {
          const a = 256 * i,
            s = a + 255,
            o = n.transformRequest(
              r.replace('{fontstack}', t).replace('{range}', `${a}-${s}`),
              'Glyphs'
            ),
            l = yield e.n(o, new AbortController());
          if (!l || !l.data)
            throw new Error(
              `Could not load glyph range. range: ${i}, ${a}-${s}`
            );
          const c = {};
          for (const t of e.o(l.data)) c[t.id] = t;
          return c;
        });
      }),
        (I.TinySDF = class {
          constructor({
            fontSize: t = 24,
            buffer: e = 3,
            radius: i = 8,
            cutoff: r = 0.25,
            fontFamily: n = 'sans-serif',
            fontWeight: a = 'normal',
            fontStyle: s = 'normal',
            lang: o = null,
          } = {}) {
            (this.buffer = e),
              (this.cutoff = r),
              (this.radius = i),
              (this.lang = o);
            const l = (this.size = t + 4 * e),
              c = this._createCanvas(l),
              h = (this.ctx = c.getContext('2d', { willReadFrequently: !0 }));
            (h.font = `${s} ${a} ${t}px ${n}`),
              (h.textBaseline = 'alphabetic'),
              (h.textAlign = 'left'),
              (h.fillStyle = 'black'),
              (this.gridOuter = new Float64Array(l * l)),
              (this.gridInner = new Float64Array(l * l)),
              (this.f = new Float64Array(l)),
              (this.z = new Float64Array(l + 1)),
              (this.v = new Uint16Array(l));
          }
          _createCanvas(t) {
            const e = document.createElement('canvas');
            return (e.width = e.height = t), e;
          }
          draw(t) {
            const {
                width: e,
                actualBoundingBoxAscent: i,
                actualBoundingBoxDescent: r,
                actualBoundingBoxLeft: n,
                actualBoundingBoxRight: a,
              } = this.ctx.measureText(t),
              s = Math.ceil(i),
              o = Math.max(
                0,
                Math.min(this.size - this.buffer, Math.ceil(a - n))
              ),
              l = Math.min(this.size - this.buffer, s + Math.ceil(r)),
              c = o + 2 * this.buffer,
              h = l + 2 * this.buffer,
              u = Math.max(c * h, 0),
              d = new Uint8ClampedArray(u),
              p = {
                data: d,
                width: c,
                height: h,
                glyphWidth: o,
                glyphHeight: l,
                glyphTop: s,
                glyphLeft: 0,
                glyphAdvance: e,
              };
            if (0 === o || 0 === l) return p;
            const { ctx: f, buffer: m, gridInner: g, gridOuter: _ } = this;
            this.lang && (f.lang = this.lang),
              f.clearRect(m, m, o, l),
              f.fillText(t, m, m + s);
            const y = f.getImageData(m, m, o, l);
            _.fill(w, 0, u), g.fill(0, 0, u);
            for (let v = 0; v < l; v++)
              for (let t = 0; t < o; t++) {
                const e = y.data[4 * (v * o + t) + 3] / 255;
                if (0 === e) continue;
                const i = (v + m) * c + t + m;
                if (1 === e) (_[i] = 0), (g[i] = w);
                else {
                  const t = 0.5 - e;
                  (_[i] = t > 0 ? t * t : 0), (g[i] = t < 0 ? t * t : 0);
                }
              }
            T(_, 0, 0, c, h, c, this.f, this.v, this.z),
              T(g, m, m, o, l, c, this.f, this.v, this.z);
            for (let v = 0; v < u; v++) {
              const t = Math.sqrt(_[v]) - Math.sqrt(g[v]);
              d[v] = Math.round(255 - 255 * (t / this.radius + this.cutoff));
            }
            return p;
          }
        });
      class S {
        constructor() {
          this.specification = e.t.light.position;
        }
        possiblyEvaluate(t, i) {
          return e.C(t.expression.evaluate(i));
        }
        interpolate(t, i, r) {
          return {
            x: e.F.number(t.x, i.x, r),
            y: e.F.number(t.y, i.y, r),
            z: e.F.number(t.z, i.z, r),
          };
        }
      }
      let M;
      class D extends e.E {
        constructor(t) {
          super(),
            (M =
              M ||
              new e.r({
                anchor: new e.D(e.t.light.anchor),
                position: new S(),
                color: new e.D(e.t.light.color),
                intensity: new e.D(e.t.light.intensity),
              })),
            (this._transitionable = new e.x(M, void 0)),
            this.setLight(t),
            (this._transitioning = this._transitionable.untransitioned());
        }
        getLight() {
          return this._transitionable.serialize();
        }
        setLight(t, i = {}) {
          if (!this._validate(e.y, t, i))
            for (const e in t) {
              const i = t[e];
              e.endsWith('-transition')
                ? this._transitionable.setTransition(e.slice(0, -11), i)
                : this._transitionable.setValue(e, i);
            }
        }
        updateTransitions(t) {
          this._transitioning = this._transitionable.transitioned(
            t,
            this._transitioning
          );
        }
        hasTransition() {
          return this._transitioning.hasTransition();
        }
        recalculate(t) {
          this.properties = this._transitioning.possiblyEvaluate(t);
        }
        _validate(t, i, r) {
          return (
            (!r || !1 !== r.validate) &&
            e.z(
              this,
              t.call(e.B, {
                value: i,
                style: { glyphs: !0, sprite: !0 },
                styleSpec: e.t,
              })
            )
          );
        }
      }
      const L = new e.r({
        'sky-color': new e.D(e.t.sky['sky-color']),
        'horizon-color': new e.D(e.t.sky['horizon-color']),
        'fog-color': new e.D(e.t.sky['fog-color']),
        'fog-ground-blend': new e.D(e.t.sky['fog-ground-blend']),
        'horizon-fog-blend': new e.D(e.t.sky['horizon-fog-blend']),
        'sky-horizon-blend': new e.D(e.t.sky['sky-horizon-blend']),
        'atmosphere-blend': new e.D(e.t.sky['atmosphere-blend']),
      });
      class A extends e.E {
        constructor(t) {
          super(),
            (this._transitionable = new e.x(L, void 0)),
            this.setSky(t),
            (this._transitioning = this._transitionable.untransitioned()),
            this.recalculate(new e.G(0));
        }
        setSky(t, i = {}) {
          if (!this._validate(e.H, t, i)) {
            t ||
              (t = {
                'sky-color': 'transparent',
                'horizon-color': 'transparent',
                'fog-color': 'transparent',
                'fog-ground-blend': 1,
                'atmosphere-blend': 0,
              });
            for (const e in t) {
              const i = t[e];
              e.endsWith('-transition')
                ? this._transitionable.setTransition(e.slice(0, -11), i)
                : this._transitionable.setValue(e, i);
            }
          }
        }
        getSky() {
          return this._transitionable.serialize();
        }
        updateTransitions(t) {
          this._transitioning = this._transitionable.transitioned(
            t,
            this._transitioning
          );
        }
        hasTransition() {
          return this._transitioning.hasTransition();
        }
        recalculate(t) {
          this.properties = this._transitioning.possiblyEvaluate(t);
        }
        _validate(t, i, r = {}) {
          return (
            !1 !== (null == r ? void 0 : r.validate) &&
            e.z(
              this,
              t.call(
                e.B,
                e.e({
                  value: i,
                  style: { glyphs: !0, sprite: !0 },
                  styleSpec: e.t,
                })
              )
            )
          );
        }
        calculateFogBlendOpacity(t) {
          return t < 60 ? 0 : t < 70 ? (t - 60) / 10 : 1;
        }
      }
      class E {
        constructor(t, e) {
          (this.width = t),
            (this.height = e),
            (this.nextRow = 0),
            (this.data = new Uint8Array(this.width * this.height)),
            (this.dashEntry = {});
        }
        getDash(t, e) {
          const i = t.join(',') + String(e);
          return (
            this.dashEntry[i] || (this.dashEntry[i] = this.addDash(t, e)),
            this.dashEntry[i]
          );
        }
        getDashRanges(t, e, i) {
          const r = [];
          let n = t.length % 2 == 1 ? -t[t.length - 1] * i : 0,
            a = t[0] * i,
            s = !0;
          r.push({ left: n, right: a, isDash: s, zeroLength: 0 === t[0] });
          let o = t[0];
          for (let l = 1; l < t.length; l++) {
            s = !s;
            const e = t[l];
            (n = o * i),
              (o += e),
              (a = o * i),
              r.push({ left: n, right: a, isDash: s, zeroLength: 0 === e });
          }
          return r;
        }
        addRoundDash(t, e, i) {
          const r = e / 2;
          for (let n = -i; n <= i; n++) {
            const e = this.width * (this.nextRow + i + n);
            let a = 0,
              s = t[a];
            for (let o = 0; o < this.width; o++) {
              o / s.right > 1 && (s = t[++a]);
              const l = Math.abs(o - s.left),
                c = Math.abs(o - s.right),
                h = Math.min(l, c);
              let u;
              const d = (n / i) * (r + 1);
              if (s.isDash) {
                const t = r - Math.abs(d);
                u = Math.sqrt(h * h + t * t);
              } else u = r - Math.sqrt(h * h + d * d);
              this.data[e + o] = Math.max(0, Math.min(255, u + 128));
            }
          }
        }
        addRegularDash(t) {
          for (let s = t.length - 1; s >= 0; --s) {
            const e = t[s],
              i = t[s + 1];
            e.zeroLength
              ? t.splice(s, 1)
              : i &&
                i.isDash === e.isDash &&
                ((i.left = e.left), t.splice(s, 1));
          }
          const e = t[0],
            i = t[t.length - 1];
          e.isDash === i.isDash &&
            ((e.left = i.left - this.width), (i.right = e.right + this.width));
          const r = this.width * this.nextRow;
          let n = 0,
            a = t[n];
          for (let s = 0; s < this.width; s++) {
            s / a.right > 1 && (a = t[++n]);
            const e = Math.abs(s - a.left),
              i = Math.abs(s - a.right),
              o = Math.min(e, i);
            this.data[r + s] = Math.max(
              0,
              Math.min(255, (a.isDash ? o : -o) + 128)
            );
          }
        }
        addDash(t, i) {
          const r = i ? 7 : 0,
            n = 2 * r + 1;
          if (this.nextRow + n > this.height)
            return e.w('LineAtlas out of space'), null;
          let a = 0;
          for (let e = 0; e < t.length; e++) a += t[e];
          if (0 !== a) {
            const e = this.width / a,
              n = this.getDashRanges(t, this.width, e);
            i ? this.addRoundDash(n, e, r) : this.addRegularDash(n);
          }
          const s = { y: this.nextRow + r, height: 2 * r, width: a };
          return (this.nextRow += n), (this.dirty = !0), s;
        }
        bind(t) {
          const e = t.gl;
          this.texture
            ? (e.bindTexture(e.TEXTURE_2D, this.texture),
              this.dirty &&
                ((this.dirty = !1),
                e.texSubImage2D(
                  e.TEXTURE_2D,
                  0,
                  0,
                  0,
                  this.width,
                  this.height,
                  e.ALPHA,
                  e.UNSIGNED_BYTE,
                  this.data
                )))
            : ((this.texture = e.createTexture()),
              e.bindTexture(e.TEXTURE_2D, this.texture),
              e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.REPEAT),
              e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.REPEAT),
              e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.LINEAR),
              e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.LINEAR),
              e.texImage2D(
                e.TEXTURE_2D,
                0,
                e.ALPHA,
                this.width,
                this.height,
                0,
                e.ALPHA,
                e.UNSIGNED_BYTE,
                this.data
              ));
        }
      }
      const R = 'maplibre_preloaded_worker_pool';
      class z {
        constructor() {
          this.active = {};
        }
        acquire(t) {
          if (!this.workers)
            for (this.workers = []; this.workers.length < z.workerCount; )
              this.workers.push(new Worker(e.a.WORKER_URL));
          return (this.active[t] = !0), this.workers.slice();
        }
        release(t) {
          delete this.active[t],
            0 === this.numActive() &&
              (this.workers.forEach((t) => {
                t.terminate();
              }),
              (this.workers = null));
        }
        isPreloaded() {
          return !!this.active[R];
        }
        numActive() {
          return Object.keys(this.active).length;
        }
      }
      const k = Math.floor(s.hardwareConcurrency / 2);
      let O, F;
      function B() {
        return O || (O = new z()), O;
      }
      z.workerCount = e.J(globalThis) ? Math.max(Math.min(k, 3), 1) : 1;
      class N {
        constructor(t, i) {
          (this.workerPool = t),
            (this.actors = []),
            (this.currentActor = 0),
            (this.id = i);
          const r = this.workerPool.acquire(i);
          for (let n = 0; n < r.length; n++) {
            const t = new e.K(r[n], i);
            (t.name = `Worker ${n}`), this.actors.push(t);
          }
          if (!this.actors.length) throw new Error('No actors found');
        }
        broadcast(t, e) {
          const i = [];
          for (const r of this.actors)
            i.push(r.sendAsync({ type: t, data: e }));
          return Promise.all(i);
        }
        getActor() {
          return (
            (this.currentActor = (this.currentActor + 1) % this.actors.length),
            this.actors[this.currentActor]
          );
        }
        remove(t = !0) {
          this.actors.forEach((t) => {
            t.remove();
          }),
            (this.actors = []),
            t && this.workerPool.release(this.id);
        }
        registerMessageHandler(t, e) {
          for (const i of this.actors) i.registerMessageHandler(t, e);
        }
      }
      function V() {
        return (
          F ||
            ((F = new N(B(), e.L)),
            F.registerMessageHandler('GR', (t, i, r) => e.m(i, r))),
          F
        );
      }
      function j(t, i) {
        const r = e.M();
        return (
          e.N(r, r, [1, 1, 0]),
          e.O(r, r, [0.5 * t.width, 0.5 * t.height, 1]),
          t.calculatePosMatrix
            ? e.Q(r, r, t.calculatePosMatrix(i.toUnwrapped()))
            : r
        );
      }
      function U(t, e, i, r, n, a, s) {
        var o;
        const l = (function (t, e, i) {
            if (t)
              for (const r of t) {
                const t = e[r];
                if (t && t.source === i && 'fill-extrusion' === t.type)
                  return !0;
              }
            else
              for (const r in e) {
                const t = e[r];
                if (t.source === i && 'fill-extrusion' === t.type) return !0;
              }
            return !1;
          })(
            null !== (o = null == n ? void 0 : n.layers) && void 0 !== o
              ? o
              : null,
            e,
            t.id
          ),
          c = a.maxPitchScaleFactor(),
          h = t.tilesIn(r, c, l);
        h.sort(G);
        const u = [];
        for (const d of h)
          u.push({
            wrappedTileID: d.tileID.wrapped().key,
            queryResults: d.tile.queryRenderedFeatures(
              e,
              i,
              t.getState(),
              d.queryGeometry,
              d.cameraQueryGeometry,
              d.scale,
              n,
              a,
              c,
              j(a, d.tileID),
              s ? (t, e) => s(d.tileID, t, e) : void 0
            ),
          });
        return (function (t, e) {
          for (const i in t) for (const r of t[i]) Z(r, e);
          return t;
        })(
          (function (t) {
            const e = {},
              i = {};
            for (const r of t) {
              const t = r.queryResults,
                n = r.wrappedTileID,
                a = (i[n] = i[n] || {});
              for (const i in t) {
                const r = t[i],
                  n = (a[i] = a[i] || {}),
                  s = (e[i] = e[i] || []);
                for (const t of r)
                  n[t.featureIndex] || ((n[t.featureIndex] = !0), s.push(t));
              }
            }
            return e;
          })(u),
          t
        );
      }
      function G(t, e) {
        const i = t.tileID,
          r = e.tileID;
        return (
          i.overscaledZ - r.overscaledZ ||
          i.canonical.y - r.canonical.y ||
          i.wrap - r.wrap ||
          i.canonical.x - r.canonical.x
        );
      }
      function Z(t, e) {
        const i = t.feature,
          r = e.getFeatureState(i.layer['source-layer'], i.id);
        (i.source = i.layer.source),
          i.layer['source-layer'] && (i.sourceLayer = i.layer['source-layer']),
          (i.state = r);
      }
      function $(t, i, r) {
        return e._(this, void 0, void 0, function* () {
          let n = t;
          if (
            (t.url
              ? (n = (yield e.j(i.transformRequest(t.url, 'Source'), r)).data)
              : yield s.frameAsync(r),
            !n)
          )
            return null;
          const a = e.S(e.e(n, t), [
            'tiles',
            'minzoom',
            'maxzoom',
            'attribution',
            'bounds',
            'scheme',
            'tileSize',
            'encoding',
          ]);
          return (
            'vector_layers' in n &&
              n.vector_layers &&
              (a.vectorLayerIds = n.vector_layers.map((t) => t.id)),
            a
          );
        });
      }
      class q {
        constructor(t, e) {
          t &&
            (e
              ? this.setSouthWest(t).setNorthEast(e)
              : Array.isArray(t) &&
                (4 === t.length
                  ? this.setSouthWest([t[0], t[1]]).setNorthEast([t[2], t[3]])
                  : this.setSouthWest(t[0]).setNorthEast(t[1])));
        }
        setNorthEast(t) {
          return (
            (this._ne =
              t instanceof e.U ? new e.U(t.lng, t.lat) : e.U.convert(t)),
            this
          );
        }
        setSouthWest(t) {
          return (
            (this._sw =
              t instanceof e.U ? new e.U(t.lng, t.lat) : e.U.convert(t)),
            this
          );
        }
        extend(t) {
          const i = this._sw,
            r = this._ne;
          let n, a;
          if (t instanceof e.U) (n = t), (a = t);
          else {
            if (!(t instanceof q))
              return Array.isArray(t)
                ? 4 === t.length || t.every(Array.isArray)
                  ? this.extend(q.convert(t))
                  : this.extend(e.U.convert(t))
                : t && ('lng' in t || 'lon' in t) && 'lat' in t
                ? this.extend(e.U.convert(t))
                : this;
            if (((n = t._sw), (a = t._ne), !n || !a)) return this;
          }
          return (
            i || r
              ? ((i.lng = Math.min(n.lng, i.lng)),
                (i.lat = Math.min(n.lat, i.lat)),
                (r.lng = Math.max(a.lng, r.lng)),
                (r.lat = Math.max(a.lat, r.lat)))
              : ((this._sw = new e.U(n.lng, n.lat)),
                (this._ne = new e.U(a.lng, a.lat))),
            this
          );
        }
        getCenter() {
          return new e.U(
            (this._sw.lng + this._ne.lng) / 2,
            (this._sw.lat + this._ne.lat) / 2
          );
        }
        getSouthWest() {
          return this._sw;
        }
        getNorthEast() {
          return this._ne;
        }
        getNorthWest() {
          return new e.U(this.getWest(), this.getNorth());
        }
        getSouthEast() {
          return new e.U(this.getEast(), this.getSouth());
        }
        getWest() {
          return this._sw.lng;
        }
        getSouth() {
          return this._sw.lat;
        }
        getEast() {
          return this._ne.lng;
        }
        getNorth() {
          return this._ne.lat;
        }
        toArray() {
          return [this._sw.toArray(), this._ne.toArray()];
        }
        toString() {
          return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
        }
        isEmpty() {
          return !(this._sw && this._ne);
        }
        contains(t) {
          const { lng: i, lat: r } = e.U.convert(t);
          let n = this._sw.lng <= i && i <= this._ne.lng;
          return (
            this._sw.lng > this._ne.lng &&
              (n = this._sw.lng >= i && i >= this._ne.lng),
            this._sw.lat <= r && r <= this._ne.lat && n
          );
        }
        intersects(t) {
          if (
            (t = q.convert(t)).getNorth() < this.getSouth() ||
            t.getSouth() > this.getNorth()
          )
            return !1;
          const i = e.V(this.getWest(), -180, 180),
            r = e.V(this.getEast(), -180, 180),
            n = e.V(t.getWest(), -180, 180),
            a = e.V(t.getEast(), -180, 180),
            s = i > r,
            o = n > a;
          return (
            !(!s || !o) ||
            (s ? a >= i || n <= r : o ? r >= n || i <= a : !(n > r || a < i))
          );
        }
        static convert(t) {
          return t instanceof q ? t : t ? new q(t) : t;
        }
        static fromLngLat(t, i = 0) {
          const r = (360 * i) / 40075017,
            n = r / Math.cos((Math.PI / 180) * t.lat);
          return new q(
            new e.U(t.lng - n, t.lat - r),
            new e.U(t.lng + n, t.lat + r)
          );
        }
        adjustAntiMeridian() {
          const t = new e.U(this._sw.lng, this._sw.lat),
            i = new e.U(this._ne.lng, this._ne.lat);
          return new q(t, t.lng > i.lng ? new e.U(i.lng + 360, i.lat) : i);
        }
      }
      class H {
        constructor(t, e, i) {
          (this.bounds = q.convert(this.validateBounds(t))),
            (this.minzoom = e || 0),
            (this.maxzoom = i || 24);
        }
        validateBounds(t) {
          return Array.isArray(t) && 4 === t.length
            ? [
                Math.max(-180, t[0]),
                Math.max(-90, t[1]),
                Math.min(180, t[2]),
                Math.min(90, t[3]),
              ]
            : [-180, -90, 180, 90];
        }
        contains(t) {
          const i = Math.pow(2, t.z),
            r = Math.floor(e.X(this.bounds.getWest()) * i),
            n = Math.floor(e.W(this.bounds.getNorth()) * i),
            a = Math.ceil(e.X(this.bounds.getEast()) * i),
            s = Math.ceil(e.W(this.bounds.getSouth()) * i);
          return t.x >= r && t.x < a && t.y >= n && t.y < s;
        }
      }
      class W extends e.E {
        constructor(t, i, r, n) {
          if (
            (super(),
            (this.id = t),
            (this.dispatcher = r),
            (this.type = 'vector'),
            (this.minzoom = 0),
            (this.maxzoom = 22),
            (this.scheme = 'xyz'),
            (this.tileSize = 512),
            (this.reparseOverscaled = !0),
            (this.isTileClipped = !0),
            (this._loaded = !1),
            e.e(this, e.S(i, ['url', 'scheme', 'tileSize', 'promoteId'])),
            (this._options = e.e({ type: 'vector' }, i)),
            (this._collectResourceTiming = i.collectResourceTiming),
            512 !== this.tileSize)
          )
            throw new Error('vector tile sources must have a tileSize of 512');
          this.setEventedParent(n);
        }
        load() {
          return e._(this, void 0, void 0, function* () {
            (this._loaded = !1),
              this.fire(new e.l('dataloading', { dataType: 'source' })),
              (this._tileJSONRequest = new AbortController());
            try {
              const t = yield $(
                this._options,
                this.map._requestManager,
                this._tileJSONRequest
              );
              (this._tileJSONRequest = null),
                (this._loaded = !0),
                this.map.style.tileManagers[this.id].clearTiles(),
                t &&
                  (e.e(this, t),
                  t.bounds &&
                    (this.tileBounds = new H(
                      t.bounds,
                      this.minzoom,
                      this.maxzoom
                    )),
                  this.fire(
                    new e.l('data', {
                      dataType: 'source',
                      sourceDataType: 'metadata',
                    })
                  ),
                  this.fire(
                    new e.l('data', {
                      dataType: 'source',
                      sourceDataType: 'content',
                    })
                  ));
            } catch (t) {
              (this._tileJSONRequest = null),
                (this._loaded = !0),
                this.fire(new e.k(t));
            }
          });
        }
        loaded() {
          return this._loaded;
        }
        hasTile(t) {
          return !this.tileBounds || this.tileBounds.contains(t.canonical);
        }
        onAdd(t) {
          (this.map = t), this.load();
        }
        setSourceProperty(t) {
          this._tileJSONRequest && this._tileJSONRequest.abort(),
            t(),
            this.load();
        }
        setTiles(t) {
          return (
            this.setSourceProperty(() => {
              this._options.tiles = t;
            }),
            this
          );
        }
        setUrl(t) {
          return (
            this.setSourceProperty(() => {
              (this.url = t), (this._options.url = t);
            }),
            this
          );
        }
        onRemove() {
          this._tileJSONRequest &&
            (this._tileJSONRequest.abort(), (this._tileJSONRequest = null));
        }
        serialize() {
          return e.e({}, this._options);
        }
        loadTile(t) {
          return e._(this, void 0, void 0, function* () {
            const e = t.tileID.canonical.url(
                this.tiles,
                this.map.getPixelRatio(),
                this.scheme
              ),
              i = {
                request: this.map._requestManager.transformRequest(e, 'Tile'),
                uid: t.uid,
                tileID: t.tileID,
                zoom: t.tileID.overscaledZ,
                tileSize: this.tileSize * t.tileID.overscaleFactor(),
                type: this.type,
                source: this.id,
                pixelRatio: this.map.getPixelRatio(),
                showCollisionBoxes: this.map.showCollisionBoxes,
                promoteId: this.promoteId,
                subdivisionGranularity:
                  this.map.style.projection.subdivisionGranularity,
              };
            i.request.collectResourceTiming = this._collectResourceTiming;
            let r = 'RT';
            if (t.actor && 'expired' !== t.state) {
              if ('loading' === t.state)
                return new Promise((e, i) => {
                  t.reloadPromise = { resolve: e, reject: i };
                });
            } else (t.actor = this.dispatcher.getActor()), (r = 'LT');
            t.abortController = new AbortController();
            try {
              const e = yield t.actor.sendAsync(
                { type: r, data: i },
                t.abortController
              );
              if ((delete t.abortController, t.aborted)) return;
              this._afterTileLoadWorkerResponse(t, e);
            } catch (e) {
              if ((delete t.abortController, t.aborted)) return;
              if (e && 404 !== e.status) throw e;
              this._afterTileLoadWorkerResponse(t, null);
            }
          });
        }
        _afterTileLoadWorkerResponse(t, e) {
          if (
            (e && e.resourceTiming && (t.resourceTiming = e.resourceTiming),
            e && this.map._refreshExpiredTiles && t.setExpiryData(e),
            t.loadVectorData(e, this.map.painter),
            t.reloadPromise)
          ) {
            const e = t.reloadPromise;
            (t.reloadPromise = null),
              this.loadTile(t).then(e.resolve).catch(e.reject);
          }
        }
        abortTile(t) {
          return e._(this, void 0, void 0, function* () {
            t.abortController &&
              (t.abortController.abort(), delete t.abortController),
              t.actor &&
                (yield t.actor.sendAsync({
                  type: 'AT',
                  data: { uid: t.uid, type: this.type, source: this.id },
                }));
          });
        }
        unloadTile(t) {
          return e._(this, void 0, void 0, function* () {
            t.unloadVectorData(),
              t.actor &&
                (yield t.actor.sendAsync({
                  type: 'RMT',
                  data: { uid: t.uid, type: this.type, source: this.id },
                }));
          });
        }
        hasTransition() {
          return !1;
        }
      }
      class X extends e.E {
        constructor(t, i, r, n) {
          super(),
            (this.id = t),
            (this.dispatcher = r),
            this.setEventedParent(n),
            (this.type = 'raster'),
            (this.minzoom = 0),
            (this.maxzoom = 22),
            (this.roundZoom = !0),
            (this.scheme = 'xyz'),
            (this.tileSize = 512),
            (this._loaded = !1),
            (this._options = e.e({ type: 'raster' }, i)),
            e.e(this, e.S(i, ['url', 'scheme', 'tileSize']));
        }
        load() {
          return e._(this, arguments, void 0, function* (t = !1) {
            (this._loaded = !1),
              this.fire(new e.l('dataloading', { dataType: 'source' })),
              (this._tileJSONRequest = new AbortController());
            try {
              const i = yield $(
                this._options,
                this.map._requestManager,
                this._tileJSONRequest
              );
              (this._tileJSONRequest = null),
                (this._loaded = !0),
                i &&
                  (e.e(this, i),
                  i.bounds &&
                    (this.tileBounds = new H(
                      i.bounds,
                      this.minzoom,
                      this.maxzoom
                    )),
                  this.fire(
                    new e.l('data', {
                      dataType: 'source',
                      sourceDataType: 'metadata',
                    })
                  ),
                  this.fire(
                    new e.l('data', {
                      dataType: 'source',
                      sourceDataType: 'content',
                      sourceDataChanged: t,
                    })
                  ));
            } catch (t) {
              (this._tileJSONRequest = null),
                (this._loaded = !0),
                this.fire(new e.k(t));
            }
          });
        }
        loaded() {
          return this._loaded;
        }
        onAdd(t) {
          (this.map = t), this.load();
        }
        onRemove() {
          this._tileJSONRequest &&
            (this._tileJSONRequest.abort(), (this._tileJSONRequest = null));
        }
        setSourceProperty(t) {
          this._tileJSONRequest &&
            (this._tileJSONRequest.abort(), (this._tileJSONRequest = null)),
            t(),
            this.load(!0);
        }
        setTiles(t) {
          return (
            this.setSourceProperty(() => {
              this._options.tiles = t;
            }),
            this
          );
        }
        setUrl(t) {
          return (
            this.setSourceProperty(() => {
              (this.url = t), (this._options.url = t);
            }),
            this
          );
        }
        serialize() {
          return e.e({}, this._options);
        }
        hasTile(t) {
          return !this.tileBounds || this.tileBounds.contains(t.canonical);
        }
        loadTile(t) {
          return e._(this, void 0, void 0, function* () {
            const i = t.tileID.canonical.url(
              this.tiles,
              this.map.getPixelRatio(),
              this.scheme
            );
            t.abortController = new AbortController();
            try {
              const r = yield g.getImage(
                this.map._requestManager.transformRequest(i, 'Tile'),
                t.abortController,
                this.map._refreshExpiredTiles
              );
              if ((delete t.abortController, t.aborted))
                return void (t.state = 'unloaded');
              if (r && r.data) {
                this.map._refreshExpiredTiles &&
                  (r.cacheControl || r.expires) &&
                  t.setExpiryData({
                    cacheControl: r.cacheControl,
                    expires: r.expires,
                  });
                const i = this.map.painter.context,
                  n = i.gl,
                  a = r.data;
                (t.texture = this.map.painter.getTileTexture(a.width)),
                  t.texture
                    ? t.texture.update(a, { useMipmap: !0 })
                    : ((t.texture = new e.T(i, a, n.RGBA, { useMipmap: !0 })),
                      t.texture.bind(
                        n.LINEAR,
                        n.CLAMP_TO_EDGE,
                        n.LINEAR_MIPMAP_NEAREST
                      )),
                  (t.state = 'loaded');
              }
            } catch (e) {
              if ((delete t.abortController, t.aborted)) t.state = 'unloaded';
              else if (e) throw ((t.state = 'errored'), e);
            }
          });
        }
        abortTile(t) {
          return e._(this, void 0, void 0, function* () {
            t.abortController &&
              (t.abortController.abort(), delete t.abortController);
          });
        }
        unloadTile(t) {
          return e._(this, void 0, void 0, function* () {
            t.texture && this.map.painter.saveTileTexture(t.texture);
          });
        }
        hasTransition() {
          return !1;
        }
      }
      class Y extends X {
        constructor(t, i, r, n) {
          super(t, i, r, n),
            (this.type = 'raster-dem'),
            (this.maxzoom = 22),
            (this._options = e.e({ type: 'raster-dem' }, i)),
            (this.encoding = i.encoding || 'mapbox'),
            (this.redFactor = i.redFactor),
            (this.greenFactor = i.greenFactor),
            (this.blueFactor = i.blueFactor),
            (this.baseShift = i.baseShift);
        }
        loadTile(t) {
          return e._(this, void 0, void 0, function* () {
            const i = t.tileID.canonical.url(
                this.tiles,
                this.map.getPixelRatio(),
                this.scheme
              ),
              r = this.map._requestManager.transformRequest(i, 'Tile');
            (t.neighboringTiles = this._getNeighboringTiles(t.tileID)),
              (t.abortController = new AbortController());
            try {
              const i = yield g.getImage(
                r,
                t.abortController,
                this.map._refreshExpiredTiles
              );
              if ((delete t.abortController, t.aborted))
                return void (t.state = 'unloaded');
              if (i && i.data) {
                const r = i.data;
                this.map._refreshExpiredTiles &&
                  (i.cacheControl || i.expires) &&
                  t.setExpiryData({
                    cacheControl: i.cacheControl,
                    expires: i.expires,
                  });
                const n = e.b(r) && e.Y() ? r : yield this.readImageNow(r),
                  a = {
                    type: this.type,
                    uid: t.uid,
                    source: this.id,
                    rawImageData: n,
                    encoding: this.encoding,
                    redFactor: this.redFactor,
                    greenFactor: this.greenFactor,
                    blueFactor: this.blueFactor,
                    baseShift: this.baseShift,
                  };
                if (!t.actor || 'expired' === t.state) {
                  t.actor = this.dispatcher.getActor();
                  const e = yield t.actor.sendAsync({ type: 'LDT', data: a });
                  (t.dem = e),
                    (t.needsHillshadePrepare = !0),
                    (t.needsTerrainPrepare = !0),
                    (t.state = 'loaded');
                }
              }
            } catch (e) {
              if ((delete t.abortController, t.aborted)) t.state = 'unloaded';
              else if (e) throw ((t.state = 'errored'), e);
            }
          });
        }
        readImageNow(t) {
          return e._(this, void 0, void 0, function* () {
            if ('undefined' != typeof VideoFrame && e.Z()) {
              const i = t.width + 2,
                r = t.height + 2;
              try {
                return new e.R(
                  { width: i, height: r },
                  yield e.$(t, -1, -1, i, r)
                );
              } catch (t) {}
            }
            return s.getImageData(t, 1);
          });
        }
        _getNeighboringTiles(t) {
          const i = t.canonical,
            r = Math.pow(2, i.z),
            n = (i.x - 1 + r) % r,
            a = 0 === i.x ? t.wrap - 1 : t.wrap,
            s = (i.x + 1 + r) % r,
            o = i.x + 1 === r ? t.wrap + 1 : t.wrap,
            l = {};
          return (
            (l[new e.a0(t.overscaledZ, a, i.z, n, i.y).key] = {
              backfilled: !1,
            }),
            (l[new e.a0(t.overscaledZ, o, i.z, s, i.y).key] = {
              backfilled: !1,
            }),
            i.y > 0 &&
              ((l[new e.a0(t.overscaledZ, a, i.z, n, i.y - 1).key] = {
                backfilled: !1,
              }),
              (l[new e.a0(t.overscaledZ, t.wrap, i.z, i.x, i.y - 1).key] = {
                backfilled: !1,
              }),
              (l[new e.a0(t.overscaledZ, o, i.z, s, i.y - 1).key] = {
                backfilled: !1,
              })),
            i.y + 1 < r &&
              ((l[new e.a0(t.overscaledZ, a, i.z, n, i.y + 1).key] = {
                backfilled: !1,
              }),
              (l[new e.a0(t.overscaledZ, t.wrap, i.z, i.x, i.y + 1).key] = {
                backfilled: !1,
              }),
              (l[new e.a0(t.overscaledZ, o, i.z, s, i.y + 1).key] = {
                backfilled: !1,
              })),
            l
          );
        }
        unloadTile(t) {
          return e._(this, void 0, void 0, function* () {
            t.demTexture && this.map.painter.saveTileTexture(t.demTexture),
              t.fbo && (t.fbo.destroy(), delete t.fbo),
              t.dem && delete t.dem,
              delete t.neighboringTiles,
              (t.state = 'unloaded'),
              t.actor &&
                (yield t.actor.sendAsync({
                  type: 'RDT',
                  data: { type: this.type, uid: t.uid, source: this.id },
                }));
          });
        }
      }
      function K(t) {
        return 'GeometryCollection' === t.type
          ? t.geometries.map((t) => t.coordinates).flat(1 / 0)
          : t.coordinates.flat(1 / 0);
      }
      function J(t) {
        const e = new q();
        let i;
        switch (t.type) {
          case 'FeatureCollection':
            i = t.features.map((t) => K(t.geometry)).flat(1 / 0);
            break;
          case 'Feature':
            i = K(t.geometry);
            break;
          default:
            i = K(t);
        }
        if (0 == i.length) return e;
        for (let r = 0; r < i.length - 1; r += 2) e.extend([i[r], i[r + 1]]);
        return e;
      }
      class Q extends e.E {
        constructor(t, i, r, n) {
          super(),
            (this.id = t),
            (this.type = 'geojson'),
            (this.minzoom = 0),
            (this.maxzoom = 18),
            (this.tileSize = 512),
            (this.isTileClipped = !0),
            (this.reparseOverscaled = !0),
            (this._removed = !1),
            (this._isUpdatingWorker = !1),
            (this._pendingWorkerUpdate = { data: i.data }),
            (this.actor = r.getActor()),
            this.setEventedParent(n),
            (this._data = i.data),
            (this._options = e.e({}, i)),
            (this._collectResourceTiming = i.collectResourceTiming),
            void 0 !== i.maxzoom && (this.maxzoom = i.maxzoom),
            i.type && (this.type = i.type),
            i.attribution && (this.attribution = i.attribution),
            (this.promoteId = i.promoteId),
            void 0 !== i.clusterMaxZoom &&
              this.maxzoom <= i.clusterMaxZoom &&
              e.w(
                `The maxzoom value "${this.maxzoom}" is expected to be greater than the clusterMaxZoom value "${i.clusterMaxZoom}".`
              ),
            (this.workerOptions = e.e(
              {
                source: this.id,
                cluster: i.cluster || !1,
                geojsonVtOptions: {
                  buffer: this._pixelsToTileUnits(
                    void 0 !== i.buffer ? i.buffer : 128
                  ),
                  tolerance: this._pixelsToTileUnits(
                    void 0 !== i.tolerance ? i.tolerance : 0.375
                  ),
                  extent: e.a3,
                  maxZoom: this.maxzoom,
                  lineMetrics: i.lineMetrics || !1,
                  generateId: i.generateId || !1,
                },
                superclusterOptions: {
                  maxZoom: this._getClusterMaxZoom(i.clusterMaxZoom),
                  minPoints: Math.max(2, i.clusterMinPoints || 2),
                  extent: e.a3,
                  radius: this._pixelsToTileUnits(i.clusterRadius || 50),
                  log: !1,
                  generateId: i.generateId || !1,
                },
                clusterProperties: i.clusterProperties,
                filter: i.filter,
              },
              i.workerOptions
            )),
            'string' == typeof this.promoteId &&
              (this.workerOptions.promoteId = this.promoteId);
        }
        _hasPendingWorkerUpdate() {
          return (
            void 0 !== this._pendingWorkerUpdate.data ||
            void 0 !== this._pendingWorkerUpdate.diff ||
            this._pendingWorkerUpdate.optionsChanged
          );
        }
        _pixelsToTileUnits(t) {
          return t * (e.a3 / this.tileSize);
        }
        _getClusterMaxZoom(t) {
          const i = t ? Math.round(t) : this.maxzoom - 1;
          return (
            Number.isInteger(t) ||
              void 0 === t ||
              e.w(
                `Integer expected for option 'clusterMaxZoom': provided value "${t}" rounded to "${i}"`
              ),
            i
          );
        }
        load() {
          return e._(this, void 0, void 0, function* () {
            yield this._updateWorkerData();
          });
        }
        onAdd(t) {
          (this.map = t), this.load();
        }
        setData(t) {
          return (
            (this._data = t),
            (this._pendingWorkerUpdate = { data: t }),
            this._updateWorkerData(),
            this
          );
        }
        updateData(t) {
          return (
            (this._pendingWorkerUpdate.diff = e.a4(
              this._pendingWorkerUpdate.diff,
              t
            )),
            this._updateWorkerData(),
            this
          );
        }
        getData() {
          return e._(this, void 0, void 0, function* () {
            const t = e.e({ type: this.type }, this.workerOptions);
            return this.actor.sendAsync({ type: 'GD', data: t });
          });
        }
        getBounds() {
          return e._(this, void 0, void 0, function* () {
            return J(yield this.getData());
          });
        }
        setClusterOptions(t) {
          return (
            (this.workerOptions.cluster = t.cluster),
            void 0 !== t.clusterRadius &&
              (this.workerOptions.superclusterOptions.radius =
                this._pixelsToTileUnits(t.clusterRadius)),
            void 0 !== t.clusterMaxZoom &&
              (this.workerOptions.superclusterOptions.maxZoom =
                this._getClusterMaxZoom(t.clusterMaxZoom)),
            (this._pendingWorkerUpdate.optionsChanged = !0),
            this._updateWorkerData(),
            this
          );
        }
        getClusterExpansionZoom(t) {
          return this.actor.sendAsync({
            type: 'GCEZ',
            data: { type: this.type, clusterId: t, source: this.id },
          });
        }
        getClusterChildren(t) {
          return this.actor.sendAsync({
            type: 'GCC',
            data: { type: this.type, clusterId: t, source: this.id },
          });
        }
        getClusterLeaves(t, e, i) {
          return this.actor.sendAsync({
            type: 'GCL',
            data: {
              type: this.type,
              source: this.id,
              clusterId: t,
              limit: e,
              offset: i,
            },
          });
        }
        _updateWorkerData() {
          return e._(this, void 0, void 0, function* () {
            if (this._isUpdatingWorker) return;
            if (!this._hasPendingWorkerUpdate())
              return void e.w(
                `No pending worker updates for GeoJSONSource ${this.id}.`
              );
            const { data: t, diff: i } = this._pendingWorkerUpdate,
              r = e.e({ type: this.type }, this.workerOptions);
            t
              ? ('string' == typeof t
                  ? ((r.request = this.map._requestManager.transformRequest(
                      s.resolveURL(t),
                      'Source'
                    )),
                    (r.request.collectResourceTiming =
                      this._collectResourceTiming))
                  : (r.data = JSON.stringify(t)),
                (this._pendingWorkerUpdate.data = void 0))
              : i &&
                ((r.dataDiff = i), (this._pendingWorkerUpdate.diff = void 0)),
              (this._pendingWorkerUpdate.optionsChanged = void 0),
              (this._isUpdatingWorker = !0),
              this.fire(new e.l('dataloading', { dataType: 'source' }));
            try {
              const t = yield this.actor.sendAsync({ type: 'LD', data: r });
              if (((this._isUpdatingWorker = !1), this._removed || t.abandoned))
                return void this.fire(
                  new e.l('dataabort', { dataType: 'source' })
                );
              this._data = t.data;
              let n = null;
              t.resourceTiming &&
                t.resourceTiming[this.id] &&
                (n = t.resourceTiming[this.id].slice(0));
              const a = { dataType: 'source' };
              this._collectResourceTiming &&
                n &&
                n.length > 0 &&
                e.e(a, { resourceTiming: n }),
                this.fire(
                  new e.l(
                    'data',
                    Object.assign(Object.assign({}, a), {
                      sourceDataType: 'metadata',
                    })
                  )
                ),
                this.fire(
                  new e.l(
                    'data',
                    Object.assign(Object.assign({}, a), {
                      sourceDataType: 'content',
                      shouldReloadTileOptions:
                        this._getShouldReloadTileOptions(i),
                    })
                  )
                );
            } catch (t) {
              if (((this._isUpdatingWorker = !1), this._removed))
                return void this.fire(
                  new e.l('dataabort', { dataType: 'source' })
                );
              this.fire(new e.k(t));
            } finally {
              this._hasPendingWorkerUpdate() && this._updateWorkerData();
            }
          });
        }
        _getShouldReloadTileOptions(t) {
          if (!t || t.removeAll) return;
          const { add: e = [], update: i = [], remove: r = [] } = t || {},
            n = new Set([...i.map((t) => t.id), ...r]);
          return {
            nextBounds: [
              ...i.map((t) => t.newGeometry),
              ...e.map((t) => t.geometry),
            ].map((t) => J(t)),
            prevIds: n,
          };
        }
        shouldReloadTile(t, { nextBounds: i, prevIds: r }) {
          const n = t.latestFeatureIndex.loadVTLayers();
          for (
            let e = 0;
            e < t.latestFeatureIndex.featureIndexArray.length;
            e++
          ) {
            const i = t.latestFeatureIndex.featureIndexArray.get(e),
              a = n._geojsonTileLayer.feature(i.featureIndex);
            if (r.has(a.id)) return !0;
          }
          const { buffer: a, extent: s } = this.workerOptions.geojsonVtOptions,
            o = (function ({ x: t, y: i, z: r }, n = 0) {
              const a = e.a1((t - n) / Math.pow(2, r)),
                s = e.a2((i + 1 + n) / Math.pow(2, r)),
                o = e.a1((t + 1 + n) / Math.pow(2, r)),
                l = e.a2((i - n) / Math.pow(2, r));
              return new q([a, s], [o, l]);
            })(t.tileID.canonical, a / s);
          for (const e of i) if (o.intersects(e)) return !0;
          return !1;
        }
        loaded() {
          return !this._isUpdatingWorker && !this._hasPendingWorkerUpdate();
        }
        loadTile(t) {
          return e._(this, void 0, void 0, function* () {
            const e = t.actor ? 'RT' : 'LT';
            t.actor = this.actor;
            const i = {
              type: this.type,
              uid: t.uid,
              tileID: t.tileID,
              zoom: t.tileID.overscaledZ,
              maxZoom: this.maxzoom,
              tileSize: this.tileSize,
              source: this.id,
              pixelRatio: this.map.getPixelRatio(),
              showCollisionBoxes: this.map.showCollisionBoxes,
              promoteId: this.promoteId,
              subdivisionGranularity:
                this.map.style.projection.subdivisionGranularity,
            };
            t.abortController = new AbortController();
            const r = yield this.actor.sendAsync(
              { type: e, data: i },
              t.abortController
            );
            delete t.abortController,
              t.unloadVectorData(),
              t.aborted || t.loadVectorData(r, this.map.painter, 'RT' === e);
          });
        }
        abortTile(t) {
          return e._(this, void 0, void 0, function* () {
            t.abortController &&
              (t.abortController.abort(), delete t.abortController),
              (t.aborted = !0);
          });
        }
        unloadTile(t) {
          return e._(this, void 0, void 0, function* () {
            t.unloadVectorData(),
              yield this.actor.sendAsync({
                type: 'RMT',
                data: { uid: t.uid, type: this.type, source: this.id },
              });
          });
        }
        onRemove() {
          (this._removed = !0),
            this.actor.sendAsync({
              type: 'RS',
              data: { type: this.type, source: this.id },
            });
        }
        serialize() {
          return e.e({}, this._options, { type: this.type, data: this._data });
        }
        hasTransition() {
          return !1;
        }
      }
      class tt extends e.E {
        constructor(t, e, i, r) {
          super(),
            (this.flippedWindingOrder = !1),
            (this.id = t),
            (this.dispatcher = i),
            (this.coordinates = e.coordinates),
            (this.type = 'image'),
            (this.minzoom = 0),
            (this.maxzoom = 22),
            (this.tileSize = 512),
            (this.tiles = {}),
            (this._loaded = !1),
            this.setEventedParent(r),
            (this.options = e);
        }
        load(t) {
          return e._(this, void 0, void 0, function* () {
            (this._loaded = !1),
              this.fire(new e.l('dataloading', { dataType: 'source' })),
              (this.url = this.options.url),
              (this._request = new AbortController());
            try {
              const e = yield g.getImage(
                this.map._requestManager.transformRequest(this.url, 'Image'),
                this._request
              );
              (this._request = null),
                (this._loaded = !0),
                e &&
                  e.data &&
                  ((this.image = e.data),
                  t && (this.coordinates = t),
                  this._finishLoading());
            } catch (t) {
              (this._request = null),
                (this._loaded = !0),
                this.fire(new e.k(t));
            }
          });
        }
        loaded() {
          return this._loaded;
        }
        updateImage(t) {
          return t.url
            ? (this._request && (this._request.abort(), (this._request = null)),
              (this.options.url = t.url),
              this.load(t.coordinates).finally(() => {
                this.texture = null;
              }),
              this)
            : this;
        }
        _finishLoading() {
          this.map &&
            (this.setCoordinates(this.coordinates),
            this.fire(
              new e.l('data', {
                dataType: 'source',
                sourceDataType: 'metadata',
              })
            ));
        }
        onAdd(t) {
          (this.map = t), this.load();
        }
        onRemove() {
          this._request && (this._request.abort(), (this._request = null));
        }
        setCoordinates(t) {
          this.coordinates = t;
          const i = t.map(e.a5.fromLngLat);
          var r;
          return (
            (this.tileID = (function (t) {
              const i = e.a6.fromPoints(t),
                r = i.width(),
                n = i.height(),
                a = Math.max(r, n),
                s = Math.max(0, Math.floor(-Math.log(a) / Math.LN2)),
                o = Math.pow(2, s);
              return new e.a8(
                s,
                Math.floor(((i.minX + i.maxX) / 2) * o),
                Math.floor(((i.minY + i.maxY) / 2) * o)
              );
            })(i)),
            (this.terrainTileRanges = this._getOverlappingTileRanges(i)),
            (this.minzoom = this.maxzoom = this.tileID.z),
            (this.tileCoords = i.map((t) =>
              this.tileID.getTilePoint(t)._round()
            )),
            (this.flippedWindingOrder =
              ((r = this.tileCoords)[1].x - r[0].x) * (r[2].y - r[0].y) -
                (r[1].y - r[0].y) * (r[2].x - r[0].x) <
              0),
            this.fire(
              new e.l('data', { dataType: 'source', sourceDataType: 'content' })
            ),
            this
          );
        }
        prepare() {
          if (0 === Object.keys(this.tiles).length || !this.image) return;
          const t = this.map.painter.context,
            i = t.gl;
          this.texture ||
            ((this.texture = new e.T(t, this.image, i.RGBA)),
            this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE));
          let r = !1;
          for (const e in this.tiles) {
            const t = this.tiles[e];
            'loaded' !== t.state &&
              ((t.state = 'loaded'), (t.texture = this.texture), (r = !0));
          }
          r &&
            this.fire(
              new e.l('data', {
                dataType: 'source',
                sourceDataType: 'idle',
                sourceId: this.id,
              })
            );
        }
        loadTile(t) {
          return e._(this, void 0, void 0, function* () {
            this.tileID && this.tileID.equals(t.tileID.canonical)
              ? ((this.tiles[String(t.tileID.wrap)] = t), (t.buckets = {}))
              : (t.state = 'errored');
          });
        }
        serialize() {
          return {
            type: 'image',
            url: this.options.url,
            coordinates: this.coordinates,
          };
        }
        hasTransition() {
          return !1;
        }
        _getOverlappingTileRanges(t) {
          const { minX: i, minY: r, maxX: n, maxY: a } = e.a6.fromPoints(t),
            s = {};
          for (let o = 0; o <= e.a7; o++) {
            const t = Math.pow(2, o),
              e = Math.floor(i * t),
              l = Math.floor(r * t),
              c = Math.floor(n * t),
              h = Math.floor(a * t);
            s[o] = { minTileX: e, minTileY: l, maxTileX: c, maxTileY: h };
          }
          return s;
        }
      }
      class et extends tt {
        constructor(t, e, i, r) {
          super(t, e, i, r),
            (this.roundZoom = !0),
            (this.type = 'video'),
            (this.options = e);
        }
        load() {
          return e._(this, void 0, void 0, function* () {
            this._loaded = !1;
            const t = this.options;
            this.urls = [];
            for (const e of t.urls)
              this.urls.push(
                this.map._requestManager.transformRequest(e, 'Source').url
              );
            try {
              const t = yield e.a9(this.urls);
              if (((this._loaded = !0), !t)) return;
              (this.video = t),
                (this.video.loop = !0),
                this.video.addEventListener('playing', () => {
                  this.map.triggerRepaint();
                }),
                this.map && this.video.play(),
                this._finishLoading();
            } catch (t) {
              this.fire(new e.k(t));
            }
          });
        }
        pause() {
          this.video && this.video.pause();
        }
        play() {
          this.video && this.video.play();
        }
        seek(t) {
          if (this.video) {
            const i = this.video.seekable;
            t < i.start(0) || t > i.end(0)
              ? this.fire(
                  new e.k(
                    new e.aa(
                      `sources.${this.id}`,
                      null,
                      `Playback for this video can be set only between the ${i.start(
                        0
                      )} and ${i.end(0)}-second mark.`
                    )
                  )
                )
              : (this.video.currentTime = t);
          }
        }
        getVideo() {
          return this.video;
        }
        onAdd(t) {
          this.map ||
            ((this.map = t),
            this.load(),
            this.video &&
              (this.video.play(), this.setCoordinates(this.coordinates)));
        }
        prepare() {
          if (0 === Object.keys(this.tiles).length || this.video.readyState < 2)
            return;
          const t = this.map.painter.context,
            i = t.gl;
          this.texture
            ? this.video.paused ||
              (this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE),
              i.texSubImage2D(
                i.TEXTURE_2D,
                0,
                0,
                0,
                i.RGBA,
                i.UNSIGNED_BYTE,
                this.video
              ))
            : ((this.texture = new e.T(t, this.video, i.RGBA)),
              this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE));
          let r = !1;
          for (const e in this.tiles) {
            const t = this.tiles[e];
            'loaded' !== t.state &&
              ((t.state = 'loaded'), (t.texture = this.texture), (r = !0));
          }
          r &&
            this.fire(
              new e.l('data', {
                dataType: 'source',
                sourceDataType: 'idle',
                sourceId: this.id,
              })
            );
        }
        serialize() {
          return {
            type: 'video',
            urls: this.urls,
            coordinates: this.coordinates,
          };
        }
        hasTransition() {
          return this.video && !this.video.paused;
        }
      }
      class it extends tt {
        constructor(t, i, r, n) {
          super(t, i, r, n),
            i.coordinates
              ? (Array.isArray(i.coordinates) &&
                  4 === i.coordinates.length &&
                  !i.coordinates.some(
                    (t) =>
                      !Array.isArray(t) ||
                      2 !== t.length ||
                      t.some((t) => 'number' != typeof t)
                  )) ||
                this.fire(
                  new e.k(
                    new e.aa(
                      `sources.${t}`,
                      null,
                      '"coordinates" property must be an array of 4 longitude/latitude array pairs'
                    )
                  )
                )
              : this.fire(
                  new e.k(
                    new e.aa(
                      `sources.${t}`,
                      null,
                      'missing required property "coordinates"'
                    )
                  )
                ),
            i.animate &&
              'boolean' != typeof i.animate &&
              this.fire(
                new e.k(
                  new e.aa(
                    `sources.${t}`,
                    null,
                    'optional "animate" property must be a boolean value'
                  )
                )
              ),
            i.canvas
              ? 'string' == typeof i.canvas ||
                i.canvas instanceof HTMLCanvasElement ||
                this.fire(
                  new e.k(
                    new e.aa(
                      `sources.${t}`,
                      null,
                      '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'
                    )
                  )
                )
              : this.fire(
                  new e.k(
                    new e.aa(
                      `sources.${t}`,
                      null,
                      'missing required property "canvas"'
                    )
                  )
                ),
            (this.options = i),
            (this.animate = void 0 === i.animate || i.animate);
        }
        load() {
          return e._(this, void 0, void 0, function* () {
            (this._loaded = !0),
              this.canvas ||
                (this.canvas =
                  this.options.canvas instanceof HTMLCanvasElement
                    ? this.options.canvas
                    : document.getElementById(this.options.canvas)),
              (this.width = this.canvas.width),
              (this.height = this.canvas.height),
              this._hasInvalidDimensions()
                ? this.fire(
                    new e.k(
                      new Error(
                        'Canvas dimensions cannot be less than or equal to zero.'
                      )
                    )
                  )
                : ((this.play = function () {
                    (this._playing = !0), this.map.triggerRepaint();
                  }),
                  (this.pause = function () {
                    this._playing && (this.prepare(), (this._playing = !1));
                  }),
                  this._finishLoading());
          });
        }
        getCanvas() {
          return this.canvas;
        }
        onAdd(t) {
          (this.map = t),
            this.load(),
            this.canvas && this.animate && this.play();
        }
        onRemove() {
          this.pause();
        }
        prepare() {
          let t = !1;
          if (
            (this.canvas.width !== this.width &&
              ((this.width = this.canvas.width), (t = !0)),
            this.canvas.height !== this.height &&
              ((this.height = this.canvas.height), (t = !0)),
            this._hasInvalidDimensions())
          )
            return;
          if (0 === Object.keys(this.tiles).length) return;
          const i = this.map.painter.context,
            r = i.gl;
          this.texture
            ? (t || this._playing) &&
              this.texture.update(this.canvas, { premultiply: !0 })
            : (this.texture = new e.T(i, this.canvas, r.RGBA, {
                premultiply: !0,
              }));
          let n = !1;
          for (const e in this.tiles) {
            const t = this.tiles[e];
            'loaded' !== t.state &&
              ((t.state = 'loaded'), (t.texture = this.texture), (n = !0));
          }
          n &&
            this.fire(
              new e.l('data', {
                dataType: 'source',
                sourceDataType: 'idle',
                sourceId: this.id,
              })
            );
        }
        serialize() {
          return { type: 'canvas', coordinates: this.coordinates };
        }
        hasTransition() {
          return this._playing;
        }
        _hasInvalidDimensions() {
          for (const t of [this.canvas.width, this.canvas.height])
            if (isNaN(t) || t <= 0) return !0;
          return !1;
        }
      }
      const rt = {},
        nt = (t) => {
          switch (t) {
            case 'geojson':
              return Q;
            case 'image':
              return tt;
            case 'raster':
              return X;
            case 'raster-dem':
              return Y;
            case 'vector':
              return W;
            case 'video':
              return et;
            case 'canvas':
              return it;
          }
          return rt[t];
        },
        at = 'RTLPluginLoaded';
      class st extends e.E {
        constructor() {
          super(...arguments),
            (this.status = 'unavailable'),
            (this.url = null),
            (this.dispatcher = V());
        }
        _syncState(t) {
          return (
            (this.status = t),
            this.dispatcher
              .broadcast('SRPS', { pluginStatus: t, pluginURL: this.url })
              .catch((t) => {
                throw ((this.status = 'error'), t);
              })
          );
        }
        getRTLTextPluginStatus() {
          return this.status;
        }
        clearRTLTextPlugin() {
          (this.status = 'unavailable'), (this.url = null);
        }
        setRTLTextPlugin(t) {
          return e._(this, arguments, void 0, function* (t, e = !1) {
            if (this.url)
              throw new Error(
                'setRTLTextPlugin cannot be called multiple times.'
              );
            if (((this.url = s.resolveURL(t)), !this.url))
              throw new Error(`requested url ${t} is invalid`);
            if ('unavailable' === this.status) {
              if (!e) return this._requestImport();
              (this.status = 'deferred'), this._syncState(this.status);
            } else if ('requested' === this.status) return this._requestImport();
          });
        }
        _requestImport() {
          return e._(this, void 0, void 0, function* () {
            yield this._syncState('loading'),
              (this.status = 'loaded'),
              this.fire(new e.l(at));
          });
        }
        lazyLoad() {
          'unavailable' === this.status
            ? (this.status = 'requested')
            : 'deferred' === this.status && this._requestImport();
        }
      }
      let ot = null;
      function lt() {
        return ot || (ot = new st()), ot;
      }
      var ct, ht;
      !(function (t) {
        (t[(t.Base = 0)] = 'Base'), (t[(t.Parent = 1)] = 'Parent');
      })(ct || (ct = {})),
        (function (t) {
          (t[(t.Departing = 0)] = 'Departing'),
            (t[(t.Incoming = 1)] = 'Incoming');
        })(ht || (ht = {}));
      class ut {
        constructor(t, i) {
          (this.timeAdded = 0),
            (this.fadeEndTime = 0),
            (this.fadeOpacity = 1),
            (this.tileID = t),
            (this.uid = e.ab()),
            (this.uses = 0),
            (this.tileSize = i),
            (this.buckets = {}),
            (this.expirationTime = null),
            (this.queryPadding = 0),
            (this.hasSymbolBuckets = !1),
            (this.hasRTLText = !1),
            (this.dependencies = {}),
            (this.rtt = []),
            (this.rttCoords = {}),
            (this.expiredRequestCount = 0),
            (this.state = 'loading');
        }
        isRenderable(t) {
          return (
            this.hasData() &&
            (!this.fadeEndTime || this.fadeOpacity > 0) &&
            (t || !this.holdingForSymbolFade())
          );
        }
        setCrossFadeLogic({
          fadingRole: t,
          fadingDirection: e,
          fadingParentID: i,
          fadeEndTime: r,
        }) {
          this.resetFadeLogic(),
            (this.fadingRole = t),
            (this.fadingDirection = e),
            (this.fadingParentID = i),
            (this.fadeEndTime = r);
        }
        setSelfFadeLogic(t) {
          this.resetFadeLogic(), (this.selfFading = !0), (this.fadeEndTime = t);
        }
        resetFadeLogic() {
          (this.fadingRole = null),
            (this.fadingDirection = null),
            (this.fadingParentID = null),
            (this.selfFading = !1),
            (this.timeAdded = l()),
            (this.fadeEndTime = 0),
            (this.fadeOpacity = 1);
        }
        wasRequested() {
          return (
            'errored' === this.state ||
            'loaded' === this.state ||
            'reloading' === this.state
          );
        }
        clearTextures(t) {
          this.demTexture && t.saveTileTexture(this.demTexture),
            (this.demTexture = null);
        }
        loadVectorData(t, i, r) {
          if (
            (this.hasData() && this.unloadVectorData(),
            (this.state = 'loaded'),
            t)
          ) {
            t.featureIndex &&
              ((this.latestFeatureIndex = t.featureIndex),
              t.rawTileData
                ? ((this.latestRawTileData = t.rawTileData),
                  (this.latestFeatureIndex.rawTileData = t.rawTileData))
                : this.latestRawTileData &&
                  (this.latestFeatureIndex.rawTileData =
                    this.latestRawTileData)),
              (this.collisionBoxArray = t.collisionBoxArray),
              (this.buckets = (function (t, e) {
                const i = {};
                if (!e) return i;
                for (const r of t) {
                  const t = r.layerIds
                    .map((t) => e.getLayer(t))
                    .filter(Boolean);
                  if (0 !== t.length) {
                    (r.layers = t),
                      r.stateDependentLayerIds &&
                        (r.stateDependentLayers = r.stateDependentLayerIds.map(
                          (e) => t.filter((t) => t.id === e)[0]
                        ));
                    for (const e of t) i[e.id] = r;
                  }
                }
                return i;
              })(t.buckets, null == i ? void 0 : i.style)),
              (this.hasSymbolBuckets = !1);
            for (const t in this.buckets) {
              const i = this.buckets[t];
              if (i instanceof e.ad) {
                if (((this.hasSymbolBuckets = !0), !r)) break;
                i.justReloaded = !0;
              }
            }
            if (((this.hasRTLText = !1), this.hasSymbolBuckets))
              for (const t in this.buckets) {
                const i = this.buckets[t];
                if (i instanceof e.ad && i.hasRTLText) {
                  (this.hasRTLText = !0), lt().lazyLoad();
                  break;
                }
              }
            this.queryPadding = 0;
            for (const t in this.buckets) {
              const e = this.buckets[t];
              this.queryPadding = Math.max(
                this.queryPadding,
                i.style.getLayer(t).queryRadius(e)
              );
            }
            t.imageAtlas && (this.imageAtlas = t.imageAtlas),
              t.glyphAtlasImage && (this.glyphAtlasImage = t.glyphAtlasImage),
              (this.dashPositions = t.dashPositions);
          } else this.collisionBoxArray = new e.ac();
        }
        unloadVectorData() {
          for (const t in this.buckets) this.buckets[t].destroy();
          (this.buckets = {}),
            this.imageAtlasTexture && this.imageAtlasTexture.destroy(),
            this.imageAtlas && (this.imageAtlas = null),
            this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(),
            this.dashPositions && (this.dashPositions = null),
            (this.latestFeatureIndex = null),
            (this.state = 'unloaded');
        }
        getBucket(t) {
          return this.buckets[t.id];
        }
        upload(t) {
          for (const e in this.buckets) {
            const i = this.buckets[e];
            i.uploadPending() && i.upload(t);
          }
          const i = t.gl;
          this.imageAtlas &&
            !this.imageAtlas.uploaded &&
            ((this.imageAtlasTexture = new e.T(
              t,
              this.imageAtlas.image,
              i.RGBA
            )),
            (this.imageAtlas.uploaded = !0)),
            this.glyphAtlasImage &&
              ((this.glyphAtlasTexture = new e.T(
                t,
                this.glyphAtlasImage,
                i.ALPHA
              )),
              (this.glyphAtlasImage = null));
        }
        prepare(t) {
          this.imageAtlas &&
            this.imageAtlas.patchUpdatedImages(t, this.imageAtlasTexture);
        }
        queryRenderedFeatures(t, e, i, r, n, a, s, o, l, c, h) {
          return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData
            ? this.latestFeatureIndex.query(
                {
                  queryGeometry: r,
                  cameraQueryGeometry: n,
                  scale: a,
                  tileSize: this.tileSize,
                  pixelPosMatrix: c,
                  transform: o,
                  params: s,
                  queryPadding: this.queryPadding * l,
                  getElevation: h,
                },
                t,
                e,
                i
              )
            : {};
        }
        querySourceFeatures(t, i) {
          const r = this.latestFeatureIndex;
          if (!r || !r.rawTileData) return;
          const n = r.loadVTLayers(),
            a = i && i.sourceLayer ? i.sourceLayer : '',
            s = n._geojsonTileLayer || n[a];
          if (!s) return;
          const o = e.ae(
              null == i ? void 0 : i.filter,
              null == i ? void 0 : i.globalState
            ),
            { z: l, x: c, y: h } = this.tileID.canonical,
            u = { z: l, x: c, y: h };
          for (let d = 0; d < s.length; d++) {
            const i = s.feature(d);
            if (o.needGeometry) {
              const t = e.af(i, !0);
              if (
                !o.filter(
                  new e.G(this.tileID.overscaledZ),
                  t,
                  this.tileID.canonical
                )
              )
                continue;
            } else if (!o.filter(new e.G(this.tileID.overscaledZ), i)) continue;
            const n = r.getId(i, a),
              p = new e.ag(i, l, c, h, n);
            (p.tile = u), t.push(p);
          }
        }
        hasData() {
          return (
            'loaded' === this.state ||
            'reloading' === this.state ||
            'expired' === this.state
          );
        }
        patternsLoaded() {
          return (
            this.imageAtlas &&
            !!Object.keys(this.imageAtlas.patternPositions).length
          );
        }
        setExpiryData(t) {
          const i = this.expirationTime;
          if (t.cacheControl) {
            const i = e.ah(t.cacheControl);
            i['max-age'] &&
              (this.expirationTime = Date.now() + 1e3 * i['max-age']);
          } else t.expires && (this.expirationTime = new Date(t.expires).getTime());
          if (this.expirationTime) {
            const t = Date.now();
            let e = !1;
            if (this.expirationTime > t) e = !1;
            else if (i)
              if (this.expirationTime < i) e = !0;
              else {
                const r = this.expirationTime - i;
                r ? (this.expirationTime = t + Math.max(r, 3e4)) : (e = !0);
              }
            else e = !0;
            e
              ? (this.expiredRequestCount++, (this.state = 'expired'))
              : (this.expiredRequestCount = 0);
          }
        }
        getExpiryTimeout() {
          if (this.expirationTime)
            return this.expiredRequestCount
              ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31))
              : Math.min(
                  this.expirationTime - new Date().getTime(),
                  Math.pow(2, 31) - 1
                );
        }
        setFeatureState(t, e) {
          if (
            !this.latestFeatureIndex ||
            !this.latestFeatureIndex.rawTileData ||
            0 === Object.keys(t).length
          )
            return;
          const i = this.latestFeatureIndex.loadVTLayers();
          for (const r in this.buckets) {
            if (!e.style.hasLayer(r)) continue;
            const n = this.buckets[r],
              a = n.layers[0].sourceLayer || '_geojsonTileLayer',
              s = i[a],
              o = t[a];
            if (!s || !o || 0 === Object.keys(o).length) continue;
            n.update(
              o,
              s,
              (this.imageAtlas && this.imageAtlas.patternPositions) || {},
              this.dashPositions || {}
            );
            const l = e && e.style && e.style.getLayer(r);
            l &&
              (this.queryPadding = Math.max(
                this.queryPadding,
                l.queryRadius(n)
              ));
          }
        }
        holdingForSymbolFade() {
          return void 0 !== this.symbolFadeHoldUntil;
        }
        symbolFadeFinished() {
          return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < l();
        }
        clearSymbolFadeHold() {
          this.symbolFadeHoldUntil = void 0;
        }
        setSymbolHoldDuration(t) {
          this.symbolFadeHoldUntil = l() + t;
        }
        setDependencies(t, e) {
          const i = {};
          for (const r of e) i[r] = !0;
          this.dependencies[t] = i;
        }
        hasDependency(t, e) {
          for (const i of t) {
            const t = this.dependencies[i];
            if (t) for (const i of e) if (t[i]) return !0;
          }
          return !1;
        }
      }
      class dt {
        constructor(t, e) {
          (this.max = t), (this.onRemove = e), this.reset();
        }
        reset() {
          for (const t in this.data)
            for (const e of this.data[t])
              e.timeout && clearTimeout(e.timeout), this.onRemove(e.value);
          return (this.data = {}), (this.order = []), this;
        }
        add(t, e, i) {
          const r = t.wrapped().key;
          void 0 === this.data[r] && (this.data[r] = []);
          const n = { value: e, timeout: void 0 };
          if (
            (void 0 !== i &&
              (n.timeout = setTimeout(() => {
                this.remove(t, n);
              }, i)),
            this.data[r].push(n),
            this.order.push(r),
            this.order.length > this.max)
          ) {
            const t = this._getAndRemoveByKey(this.order[0]);
            t && this.onRemove(t);
          }
          return this;
        }
        has(t) {
          return t.wrapped().key in this.data;
        }
        getAndRemove(t) {
          return this.has(t) ? this._getAndRemoveByKey(t.wrapped().key) : null;
        }
        _getAndRemoveByKey(t) {
          const e = this.data[t].shift();
          return (
            e.timeout && clearTimeout(e.timeout),
            0 === this.data[t].length && delete this.data[t],
            this.order.splice(this.order.indexOf(t), 1),
            e.value
          );
        }
        getByKey(t) {
          const e = this.data[t];
          return e ? e[0].value : null;
        }
        get(t) {
          return this.has(t) ? this.data[t.wrapped().key][0].value : null;
        }
        remove(t, e) {
          if (!this.has(t)) return this;
          const i = t.wrapped().key,
            r = void 0 === e ? 0 : this.data[i].indexOf(e),
            n = this.data[i][r];
          return (
            this.data[i].splice(r, 1),
            n.timeout && clearTimeout(n.timeout),
            0 === this.data[i].length && delete this.data[i],
            this.onRemove(n.value),
            this.order.splice(this.order.indexOf(i), 1),
            this
          );
        }
        setMaxSize(t) {
          for (this.max = t; this.order.length > this.max; ) {
            const t = this._getAndRemoveByKey(this.order[0]);
            t && this.onRemove(t);
          }
          return this;
        }
        filter(t) {
          const e = [];
          for (const i in this.data)
            for (const r of this.data[i]) t(r.value) || e.push(r);
          for (const i of e) this.remove(i.value.tileID, i);
        }
      }
      class pt {
        constructor() {
          (this.state = {}),
            (this.stateChanges = {}),
            (this.deletedStates = {});
        }
        updateState(t, i, r) {
          const n = String(i);
          if (
            ((this.stateChanges[t] = this.stateChanges[t] || {}),
            (this.stateChanges[t][n] = this.stateChanges[t][n] || {}),
            e.e(this.stateChanges[t][n], r),
            null === this.deletedStates[t])
          ) {
            this.deletedStates[t] = {};
            for (const e in this.state[t])
              e !== n && (this.deletedStates[t][e] = null);
          } else if (
            this.deletedStates[t] &&
            null === this.deletedStates[t][n]
          ) {
            this.deletedStates[t][n] = {};
            for (const e in this.state[t][n])
              r[e] || (this.deletedStates[t][n][e] = null);
          } else
            for (const e in r)
              this.deletedStates[t] &&
                this.deletedStates[t][n] &&
                null === this.deletedStates[t][n][e] &&
                delete this.deletedStates[t][n][e];
        }
        removeFeatureState(t, e, i) {
          if (null === this.deletedStates[t]) return;
          const r = String(e);
          if (
            ((this.deletedStates[t] = this.deletedStates[t] || {}),
            i && void 0 !== e)
          )
            null !== this.deletedStates[t][r] &&
              ((this.deletedStates[t][r] = this.deletedStates[t][r] || {}),
              (this.deletedStates[t][r][i] = null));
          else if (void 0 !== e)
            if (this.stateChanges[t] && this.stateChanges[t][r])
              for (i in ((this.deletedStates[t][r] = {}),
              this.stateChanges[t][r]))
                this.deletedStates[t][r][i] = null;
            else this.deletedStates[t][r] = null;
          else this.deletedStates[t] = null;
        }
        getState(t, i) {
          const r = String(i),
            n = e.e(
              {},
              (this.state[t] || {})[r],
              (this.stateChanges[t] || {})[r]
            );
          if (null === this.deletedStates[t]) return {};
          if (this.deletedStates[t]) {
            const e = this.deletedStates[t][i];
            if (null === e) return {};
            for (const t in e) delete n[t];
          }
          return n;
        }
        initializeTileState(t, e) {
          t.setFeatureState(this.state, e);
        }
        coalesceChanges(t, i) {
          const r = {};
          for (const n in this.stateChanges) {
            this.state[n] = this.state[n] || {};
            const t = {};
            for (const i in this.stateChanges[n])
              this.state[n][i] || (this.state[n][i] = {}),
                e.e(this.state[n][i], this.stateChanges[n][i]),
                (t[i] = this.state[n][i]);
            r[n] = t;
          }
          for (const n in this.deletedStates) {
            this.state[n] = this.state[n] || {};
            const t = {};
            if (null === this.deletedStates[n])
              for (const e in this.state[n])
                (t[e] = {}), (this.state[n][e] = {});
            else
              for (const e in this.deletedStates[n]) {
                if (null === this.deletedStates[n][e]) this.state[n][e] = {};
                else
                  for (const t of Object.keys(this.deletedStates[n][e]))
                    delete this.state[n][e][t];
                t[e] = this.state[n][e];
              }
            (r[n] = r[n] || {}), e.e(r[n], t);
          }
          if (
            ((this.stateChanges = {}),
            (this.deletedStates = {}),
            0 !== Object.keys(r).length)
          )
            for (const e in t) t[e].setFeatureState(r, i);
        }
      }
      const ft = 89.25;
      function mt(t, i) {
        const r = e.ai(i.lat, -e.aj, e.aj);
        return new e.P(e.X(i.lng) * t, e.W(r) * t);
      }
      function gt(t, i) {
        return new e.a5(i.x / t, i.y / t).toLngLat();
      }
      function _t(t) {
        return (
          t.cameraToCenterDistance *
          Math.min(
            0.85 * Math.tan(e.ak(90 - t.pitch)),
            Math.tan(e.ak(ft - t.pitch))
          )
        );
      }
      function yt(t, i) {
        const r = t.canonical,
          n = i / e.al(r.z),
          a = r.x + Math.pow(2, r.z) * t.wrap,
          s = e.am(new Float64Array(16));
        return (
          e.N(s, s, [a * n, r.y * n, 0]), e.O(s, s, [n / e.a3, n / e.a3, 1]), s
        );
      }
      function vt(t, i, r, n, a) {
        const s = e.a5.fromLngLat(t, i),
          o = a * e.an(1, t.lat),
          l = o * Math.cos(e.ak(r)),
          c = Math.sqrt(o * o - l * l),
          h = c * Math.sin(e.ak(-n)),
          u = c * Math.cos(e.ak(-n));
        return new e.a5(s.x + h, s.y + u, s.z + l);
      }
      function xt(t, e, i) {
        const r = e.intersectsFrustum(t);
        if (!i || 0 === r) return r;
        const n = e.intersectsPlane(i);
        return 0 === n ? 0 : 2 === r && 2 === n ? 2 : 1;
      }
      function bt(t, e, i) {
        let r = 0;
        const n = (i - e) / 10;
        for (let a = 0; a < 10; a++)
          r += n * Math.pow(Math.cos(e + ((a + 0.5) / 10) * (i - e)), t);
        return r;
      }
      function wt(t, i) {
        return function (r, n, a, s, o) {
          const l =
              2 *
              ((t - 1) / e.ao(Math.cos(e.ak(ft - o)) / Math.cos(e.ak(ft))) - 1),
            c = Math.acos(a / s),
            h = 2 * bt(l - 1, 0, e.ak(o / 2)),
            u = Math.min(e.ak(ft), c + e.ak(o / 2)),
            d = bt(l - 1, Math.min(u, c - e.ak(o / 2)), u),
            p = Math.atan(n / a),
            f = Math.hypot(n, a);
          let m = r;
          return (
            (m += e.ao(s / f / Math.max(0.5, Math.cos(e.ak(o / 2))))),
            (m += (l * e.ao(Math.cos(p))) / 2),
            (m -= e.ao(Math.max(1, d / h / i)) / 2),
            m
          );
        };
      }
      const Tt = wt(9.314, 3);
      function Pt(t, i) {
        const r = (i.roundZoom ? Math.round : Math.floor)(
          t.zoom + e.ao(t.tileSize / i.tileSize)
        );
        return Math.max(0, r);
      }
      function Ct(t, i) {
        const r = t.getCameraFrustum(),
          n = t.getClippingPlane(),
          a = t.screenPointToMercatorCoordinate(t.getCameraPoint()),
          s = e.a5.fromLngLat(t.center, t.elevation);
        a.z =
          s.z +
          (Math.cos(t.pitchInRadians) * t.cameraToCenterDistance) / t.worldSize;
        const o = t.getCoveringTilesDetailsProvider(),
          l = o.allowVariableZoom(t, i),
          c = Pt(t, i),
          h = i.minzoom || 0,
          u = void 0 !== i.maxzoom ? i.maxzoom : t.maxZoom,
          d = Math.min(Math.max(0, c), u),
          p = Math.pow(2, d),
          f = [p * a.x, p * a.y, 0],
          m = [p * s.x, p * s.y, 0],
          g = Math.hypot(s.x - a.x, s.y - a.y),
          _ = Math.abs(s.z - a.z),
          y = Math.hypot(g, _),
          v = (t) => ({ zoom: 0, x: 0, y: 0, wrap: t, fullyVisible: !1 }),
          x = [],
          b = [];
        if (t.renderWorldCopies && o.allowWorldCopies())
          for (let e = 1; e <= 3; e++) x.push(v(-e)), x.push(v(e));
        for (x.push(v(0)); x.length > 0; ) {
          const p = x.pop(),
            g = p.x,
            v = p.y;
          let w = p.fullyVisible;
          const T = { x: g, y: v, z: p.zoom },
            P = o.getTileBoundingVolume(T, p.wrap, t.elevation, i);
          if (!w) {
            const t = xt(r, P, n);
            if (0 === t) continue;
            w = 2 === t;
          }
          const C = o.distanceToTile2d(a.x, a.y, T, P);
          let I = c;
          l &&
            (I = (i.calculateTileZoom || Tt)(
              t.zoom + e.ao(t.tileSize / i.tileSize),
              C,
              _,
              y,
              t.fov
            )),
            (I = (i.roundZoom ? Math.round : Math.floor)(I)),
            (I = Math.max(0, I));
          const S = Math.min(I, u);
          if (((p.wrap = o.getWrap(s, T, p.wrap)), p.zoom >= S)) {
            if (p.zoom < h) continue;
            const t = d - p.zoom,
              r = f[0] - 0.5 - (g << t),
              n = f[1] - 0.5 - (v << t),
              a = i.reparseOverscaled ? Math.max(p.zoom, I) : p.zoom;
            b.push({
              tileID: new e.a0(p.zoom === u ? a : p.zoom, p.wrap, p.zoom, g, v),
              distanceSq: e.ap([m[0] - 0.5 - g, m[1] - 0.5 - v]),
              tileDistanceToCamera: Math.sqrt(r * r + n * n),
            });
          } else
            for (let t = 0; t < 4; t++)
              x.push({
                zoom: p.zoom + 1,
                x: (g << 1) + (t % 2),
                y: (v << 1) + (t >> 1),
                wrap: p.wrap,
                fullyVisible: w,
              });
        }
        return b
          .sort((t, e) => t.distanceSq - e.distanceSq)
          .map((t) => t.tileID);
      }
      const It = e.a6.fromPoints([new e.P(0, 0), new e.P(e.a3, e.a3)]);
      class St extends e.E {
        constructor(t, e, i) {
          super(),
            (this.id = t),
            (this.dispatcher = i),
            this.on('data', (t) => this._dataHandler(t)),
            this.on('dataloading', () => {
              this._sourceErrored = !1;
            }),
            this.on('error', () => {
              this._sourceErrored = this._source.loaded();
            }),
            (this._source = ((t, e, i, r) => {
              const n = new (nt(e.type))(t, e, i, r);
              if (n.id !== t)
                throw new Error(
                  `Expected Source id to be ${t} instead of ${n.id}`
                );
              return n;
            })(t, e, i, this)),
            (this._tiles = {}),
            (this._cache = new dt(0, (t) => this._unloadTile(t))),
            (this._timers = {}),
            (this._maxTileCacheSize = null),
            (this._maxTileCacheZoomLevels = null),
            (this._rasterFadeDuration = 0),
            (this._maxFadingAncestorLevels = 5),
            (this._state = new pt()),
            (this._didEmitContent = !1),
            (this._updated = !1);
        }
        onAdd(t) {
          (this.map = t),
            (this._maxTileCacheSize = t ? t._maxTileCacheSize : null),
            (this._maxTileCacheZoomLevels = t
              ? t._maxTileCacheZoomLevels
              : null),
            this._source && this._source.onAdd && this._source.onAdd(t);
        }
        onRemove(t) {
          this.clearTiles(),
            this._source && this._source.onRemove && this._source.onRemove(t);
        }
        loaded() {
          if (this._sourceErrored) return !0;
          if (!this._sourceLoaded) return !1;
          if (!this._source.loaded()) return !1;
          if (
            !(
              (void 0 === this.used && void 0 === this.usedForTerrain) ||
              this.used ||
              this.usedForTerrain
            )
          )
            return !0;
          if (!this._updated) return !1;
          for (const t in this._tiles) {
            const e = this._tiles[t];
            if ('loaded' !== e.state && 'errored' !== e.state) return !1;
          }
          return !0;
        }
        getSource() {
          return this._source;
        }
        getState() {
          return this._state;
        }
        pause() {
          this._paused = !0;
        }
        resume() {
          if (!this._paused) return;
          const t = this._shouldReloadOnResume;
          (this._paused = !1),
            (this._shouldReloadOnResume = !1),
            t && this.reload(),
            this.transform && this.update(this.transform, this.terrain);
        }
        _loadTile(t, i, r) {
          return e._(this, void 0, void 0, function* () {
            try {
              yield this._source.loadTile(t), this._tileLoaded(t, i, r);
            } catch (i) {
              (t.state = 'errored'),
                404 !== i.status
                  ? this._source.fire(new e.k(i, { tile: t }))
                  : this.update(this.transform, this.terrain);
            }
          });
        }
        _unloadTile(t) {
          this._source.unloadTile && this._source.unloadTile(t);
        }
        _abortTile(t) {
          this._source.abortTile && this._source.abortTile(t),
            this._source.fire(
              new e.l('dataabort', {
                tile: t,
                coord: t.tileID,
                dataType: 'source',
              })
            );
        }
        serialize() {
          return this._source.serialize();
        }
        prepare(t) {
          this._source.prepare && this._source.prepare(),
            this._state.coalesceChanges(
              this._tiles,
              this.map ? this.map.painter : null
            );
          for (const e in this._tiles) {
            const i = this._tiles[e];
            i.upload(t), i.prepare(this.map.style.imageManager);
          }
        }
        getIds() {
          return Object.values(this._tiles)
            .map((t) => t.tileID)
            .sort(Mt)
            .map((t) => t.key);
        }
        getRenderableIds(t) {
          const i = [];
          for (const e in this._tiles)
            this._isIdRenderable(e, t) && i.push(this._tiles[e]);
          return t
            ? i
                .sort((t, i) => {
                  const r = t.tileID,
                    n = i.tileID,
                    a = new e.P(r.canonical.x, r.canonical.y)._rotate(
                      -this.transform.bearingInRadians
                    ),
                    s = new e.P(n.canonical.x, n.canonical.y)._rotate(
                      -this.transform.bearingInRadians
                    );
                  return (
                    r.overscaledZ - n.overscaledZ || s.y - a.y || s.x - a.x
                  );
                })
                .map((t) => t.tileID.key)
            : i
                .map((t) => t.tileID)
                .sort(Mt)
                .map((t) => t.key);
        }
        hasRenderableParent(t) {
          const e = t.overscaledZ - 1;
          if (e >= this._source.minzoom) {
            const i = this.getLoadedTile(t.scaledTo(e));
            if (i) return this._isIdRenderable(i.tileID.key);
          }
          return !1;
        }
        _isIdRenderable(t, e = !1) {
          var i;
          return null === (i = this._tiles[t]) || void 0 === i
            ? void 0
            : i.isRenderable(e);
        }
        reload(t, e) {
          if (this._paused) this._shouldReloadOnResume = !0;
          else {
            this._cache.reset();
            for (const i in this._tiles)
              (e &&
                this._source.shouldReloadTile &&
                !this._source.shouldReloadTile(this._tiles[i], e)) ||
                (t
                  ? this._reloadTile(i, 'expired')
                  : 'errored' !== this._tiles[i].state &&
                    this._reloadTile(i, 'reloading'));
          }
        }
        _reloadTile(t, i) {
          return e._(this, void 0, void 0, function* () {
            const e = this._tiles[t];
            e &&
              ('loading' !== e.state && (e.state = i),
              yield this._loadTile(e, t, i));
          });
        }
        _tileLoaded(t, i, r) {
          (t.timeAdded = l()),
            t.selfFading &&
              (t.fadeEndTime = t.timeAdded + this._rasterFadeDuration),
            'expired' === r && (t.refreshedUponExpiration = !0),
            this._setTileReloadTimer(i, t),
            'raster-dem' === this.getSource().type &&
              t.dem &&
              this._backfillDEM(t),
            this._state.initializeTileState(
              t,
              this.map ? this.map.painter : null
            ),
            t.aborted ||
              this._source.fire(
                new e.l('data', {
                  dataType: 'source',
                  tile: t,
                  coord: t.tileID,
                })
              );
        }
        _backfillDEM(t) {
          const e = this.getRenderableIds();
          for (let r = 0; r < e.length; r++) {
            const n = e[r];
            if (t.neighboringTiles && t.neighboringTiles[n]) {
              const e = this.getTileByID(n);
              i(t, e), i(e, t);
            }
          }
          function i(t, e) {
            (t.needsHillshadePrepare = !0), (t.needsTerrainPrepare = !0);
            let i = e.tileID.canonical.x - t.tileID.canonical.x;
            const r = e.tileID.canonical.y - t.tileID.canonical.y,
              n = Math.pow(2, t.tileID.canonical.z),
              a = e.tileID.key;
            (0 === i && 0 === r) ||
              Math.abs(r) > 1 ||
              (Math.abs(i) > 1 &&
                (1 === Math.abs(i + n)
                  ? (i += n)
                  : 1 === Math.abs(i - n) && (i -= n)),
              e.dem &&
                t.dem &&
                (t.dem.backfillBorder(e.dem, i, r),
                t.neighboringTiles &&
                  t.neighboringTiles[a] &&
                  (t.neighboringTiles[a].backfilled = !0)));
          }
        }
        getTile(t) {
          return this.getTileByID(t.key);
        }
        getTileByID(t) {
          return this._tiles[t];
        }
        _retainLoadedChildren(t, e) {
          const i = Object.values(t),
            r = this._getLoadedDescendents(i),
            n = {};
          for (const a of i) {
            const t = r[a.key];
            if (!(null == t ? void 0 : t.length)) {
              n[a.key] = a;
              continue;
            }
            const i = a.overscaledZ + St.maxUnderzooming,
              s = t.filter((t) => t.tileID.overscaledZ <= i);
            if (!s.length) {
              n[a.key] = a;
              continue;
            }
            const o = Math.min(...s.map((t) => t.tileID.overscaledZ)),
              l = s
                .filter((t) => t.tileID.overscaledZ === o)
                .map((t) => t.tileID);
            for (const r of l) e[r.key] = r;
            this._areDescendentsComplete(l, o, a.overscaledZ) || (n[a.key] = a);
          }
          return n;
        }
        _getLoadedDescendents(t) {
          var e;
          const i = {};
          for (const r in this._tiles) {
            const n = this._tiles[r];
            if (n.hasData())
              for (const r of t)
                n.tileID.isChildOf(r) &&
                  (i[(e = r.key)] || (i[e] = [])).push(n);
          }
          return i;
        }
        _areDescendentsComplete(t, e, i) {
          return 1 === t.length && t[0].isOverscaled()
            ? t[0].overscaledZ === e
            : Math.pow(4, e - i) === t.length;
        }
        getLoadedTile(t) {
          const e = this._tiles[t.key];
          return (null == e ? void 0 : e.hasData()) ? e : null;
        }
        updateCacheSize(t) {
          const i = Math.ceil(t.width / this._source.tileSize) + 1,
            r = Math.ceil(t.height / this._source.tileSize) + 1,
            n = Math.floor(
              i *
                r *
                (null === this._maxTileCacheZoomLevels
                  ? e.a.MAX_TILE_CACHE_ZOOM_LEVELS
                  : this._maxTileCacheZoomLevels)
            ),
            a =
              'number' == typeof this._maxTileCacheSize
                ? Math.min(this._maxTileCacheSize, n)
                : n;
          this._cache.setMaxSize(a);
        }
        handleWrapJump(t) {
          const e = Math.round(
            (t - (void 0 === this._prevLng ? t : this._prevLng)) / 360
          );
          if (((this._prevLng = t), e)) {
            const t = {};
            for (const i in this._tiles) {
              const r = this._tiles[i];
              (r.tileID = r.tileID.unwrapTo(r.tileID.wrap + e)),
                (t[r.tileID.key] = r);
            }
            (this._tiles = t), this._resetTileReloadTimers();
          }
        }
        update(t, i) {
          if (!this._sourceLoaded || this._paused) return;
          let r;
          (this.transform = t),
            (this.terrain = i),
            this.updateCacheSize(t),
            this.handleWrapJump(this.transform.center.lng),
            this.used || this.usedForTerrain
              ? this._source.tileID
                ? (r = t
                    .getVisibleUnwrappedCoordinates(this._source.tileID)
                    .map(
                      (t) =>
                        new e.a0(
                          t.canonical.z,
                          t.wrap,
                          t.canonical.z,
                          t.canonical.x,
                          t.canonical.y
                        )
                    ))
                : ((r = Ct(t, {
                    tileSize: this.usedForTerrain
                      ? this.tileSize
                      : this._source.tileSize,
                    minzoom: this._source.minzoom,
                    maxzoom: this._source.maxzoom,
                    roundZoom: !this.usedForTerrain && this._source.roundZoom,
                    reparseOverscaled: this._source.reparseOverscaled,
                    terrain: i,
                    calculateTileZoom: this._source.calculateTileZoom,
                  })),
                  this._source.hasTile &&
                    (r = r.filter((t) => this._source.hasTile(t))))
              : (r = []),
            this.usedForTerrain && (r = this._addTerrainIdealTiles(r));
          const n = 0 === r.length && !this._updated && this._didEmitContent;
          (this._updated = !0),
            n &&
              this.fire(
                new e.l('data', {
                  sourceDataType: 'idle',
                  dataType: 'source',
                  sourceId: this.id,
                })
              );
          const a = Pt(t, this._source),
            s = this._updateRetainedTiles(r, a),
            o = Dt(this._source.type);
          o &&
            this._rasterFadeDuration > 0 &&
            !i &&
            this._updateFadingTiles(r, s),
            o ? this._cleanUpRasterTiles(s) : this._cleanUpVectorTiles(s);
        }
        _cleanUpRasterTiles(t) {
          for (const e in this._tiles) t[e] || this._removeTile(e);
        }
        _cleanUpVectorTiles(t) {
          for (const e in this._tiles) {
            const i = this._tiles[e];
            t[e]
              ? i.clearSymbolFadeHold()
              : i.hasSymbolBuckets
              ? i.holdingForSymbolFade()
                ? i.symbolFadeFinished() && this._removeTile(e)
                : i.setSymbolHoldDuration(this.map._fadeDuration)
              : this._removeTile(e);
          }
        }
        _addTerrainIdealTiles(t) {
          const e = [];
          for (const i of t)
            if (i.canonical.z > this._source.minzoom) {
              const t = i.scaledTo(i.canonical.z - 1);
              e.push(t);
              const r = i.scaledTo(
                Math.max(this._source.minzoom, Math.min(i.canonical.z, 5))
              );
              e.push(r);
            }
          return t.concat(e);
        }
        releaseSymbolFadeTiles() {
          for (const t in this._tiles)
            this._tiles[t].holdingForSymbolFade() && this._removeTile(t);
        }
        _updateRetainedTiles(t, e) {
          var i;
          const r = {},
            n = {},
            a = Math.max(e - St.maxOverzooming, this._source.minzoom);
          let s = {};
          for (const o of t) {
            const t = this._addTile(o);
            (r[o.key] = o), t.hasData() || (s[o.key] = o);
          }
          s = this._retainLoadedChildren(s, r);
          for (const o in s) {
            const t = s[o];
            let e = this._tiles[o],
              l = null == e ? void 0 : e.wasRequested();
            for (let s = t.overscaledZ - 1; s >= a; --s) {
              const a = t.scaledTo(s);
              if (n[a.key]) break;
              if (
                ((n[a.key] = !0),
                (e = this.getTile(a)),
                !e && l && (e = this._addTile(a)),
                e)
              ) {
                const t = e.hasData();
                if (
                  ((t ||
                    !(null === (i = this.map) || void 0 === i
                      ? void 0
                      : i.cancelPendingTileRequestsWhileZooming) ||
                    l) &&
                    (r[a.key] = a),
                  (l = e.wasRequested()),
                  t)
                )
                  break;
              }
            }
          }
          return r;
        }
        _updateFadingTiles(t, i) {
          const r = l(),
            n = e.aq(t);
          for (const e of t) {
            const t = this._tiles[e.key];
            (t.fadingDirection !== ht.Departing && 0 !== t.fadeOpacity) ||
              t.resetFadeLogic(),
              this._updateFadingAncestor(t, i, r) ||
                this._updateFadingDescendents(t, i, r) ||
                this._updateFadingEdge(t, n, r) ||
                t.resetFadeLogic();
          }
        }
        _updateFadingAncestor(t, e, i) {
          if (!t.hasData()) return !1;
          const {
            tileID: r,
            fadingRole: n,
            fadingDirection: a,
            fadingParentID: s,
          } = t;
          if (n === ct.Base && a === ht.Incoming && s)
            return (e[s.key] = s), !0;
          const o = Math.max(
            r.overscaledZ - this._maxFadingAncestorLevels,
            this._source.minzoom
          );
          for (let l = r.overscaledZ - 1; l >= o; l--) {
            const n = r.scaledTo(l),
              a = this.getLoadedTile(n);
            if (a)
              return (
                t.setCrossFadeLogic({
                  fadingRole: ct.Base,
                  fadingDirection: ht.Incoming,
                  fadingParentID: a.tileID,
                  fadeEndTime: i + this._rasterFadeDuration,
                }),
                a.setCrossFadeLogic({
                  fadingRole: ct.Parent,
                  fadingDirection: ht.Departing,
                  fadeEndTime: i + this._rasterFadeDuration,
                }),
                (e[n.key] = n),
                !0
              );
          }
          return !1;
        }
        _updateFadingDescendents(t, e, i) {
          if (!t.hasData()) return !1;
          const r = t.tileID.children(this._source.maxzoom);
          let n = this._updateFadingChildren(t, r, e, i);
          if (n) return !0;
          for (const a of r) {
            const r = a.children(this._source.maxzoom);
            this._updateFadingChildren(t, r, e, i) && (n = !0);
          }
          return n;
        }
        _updateFadingChildren(t, e, i, r) {
          if (e[0].overscaledZ >= this._source.maxzoom) return !1;
          let n = !1;
          for (const a of e) {
            const e = this.getLoadedTile(a);
            if (!e) continue;
            const { fadingRole: s, fadingDirection: o, fadingParentID: l } = e;
            (s === ct.Base && o === ht.Departing && l) ||
              (e.setCrossFadeLogic({
                fadingRole: ct.Base,
                fadingDirection: ht.Departing,
                fadingParentID: t.tileID,
                fadeEndTime: r + this._rasterFadeDuration,
              }),
              t.setCrossFadeLogic({
                fadingRole: ct.Parent,
                fadingDirection: ht.Incoming,
                fadeEndTime: r + this._rasterFadeDuration,
              })),
              (i[a.key] = a),
              (n = !0);
          }
          return n;
        }
        _updateFadingEdge(t, e, i) {
          const r = t.tileID;
          return (
            !!t.selfFading ||
            (!t.hasData() &&
              !!e.has(r) &&
              (t.setSelfFadeLogic(i + this._rasterFadeDuration), !0))
          );
        }
        _addTile(t) {
          let i = this._tiles[t.key];
          if (i) return i;
          (i = this._cache.getAndRemove(t)),
            i &&
              (i.resetFadeLogic(),
              this._setTileReloadTimer(t.key, i),
              (i.tileID = t),
              this._state.initializeTileState(
                i,
                this.map ? this.map.painter : null
              ));
          const r = i;
          return (
            i ||
              ((i = new ut(t, this._source.tileSize * t.overscaleFactor())),
              this._loadTile(i, t.key, i.state)),
            i.uses++,
            (this._tiles[t.key] = i),
            r ||
              this._source.fire(
                new e.l('dataloading', {
                  tile: i,
                  coord: i.tileID,
                  dataType: 'source',
                })
              ),
            i
          );
        }
        _setTileReloadTimer(t, e) {
          this._clearTileReloadTimer(t);
          const i = e.getExpiryTimeout();
          i &&
            (this._timers[t] = setTimeout(() => {
              this._reloadTile(t, 'expired'), delete this._timers[t];
            }, i));
        }
        _clearTileReloadTimer(t) {
          const e = this._timers[t];
          e && (clearTimeout(e), delete this._timers[t]);
        }
        _resetTileReloadTimers() {
          for (const t in this._timers)
            clearTimeout(this._timers[t]), delete this._timers[t];
          for (const t in this._tiles)
            this._setTileReloadTimer(t, this._tiles[t]);
        }
        refreshTiles(t) {
          for (const e in this._tiles)
            (this._isIdRenderable(e) || 'errored' == this._tiles[e].state) &&
              t.some((t) => t.equals(this._tiles[e].tileID.canonical)) &&
              this._reloadTile(e, 'expired');
        }
        _removeTile(t) {
          const e = this._tiles[t];
          e &&
            (e.uses--,
            delete this._tiles[t],
            this._clearTileReloadTimer(t),
            e.uses > 0 ||
              (e.hasData() && 'reloading' !== e.state
                ? this._cache.add(e.tileID, e, e.getExpiryTimeout())
                : ((e.aborted = !0), this._abortTile(e), this._unloadTile(e))));
        }
        _dataHandler(t) {
          'source' === t.dataType &&
            ('metadata' !== t.sourceDataType
              ? 'content' === t.sourceDataType &&
                this._sourceLoaded &&
                !this._paused &&
                (this.reload(t.sourceDataChanged, t.shouldReloadTileOptions),
                this.transform && this.update(this.transform, this.terrain),
                (this._didEmitContent = !0))
              : (this._sourceLoaded = !0));
        }
        clearTiles() {
          (this._shouldReloadOnResume = !1), (this._paused = !1);
          for (const t in this._tiles) this._removeTile(t);
          this._cache.reset();
        }
        tilesIn(t, i, r) {
          const n = [],
            a = this.transform;
          if (!a) return n;
          const s = a.getCoveringTilesDetailsProvider().allowWorldCopies(),
            o = r ? a.getCameraQueryGeometry(t) : t,
            l = (t) => a.screenPointToMercatorCoordinate(t, this.terrain),
            c = this.transformBbox(t, l, !s),
            h = this.transformBbox(o, l, !s),
            u = this.getIds(),
            d = e.a6.fromPoints(h);
          for (let p = 0; p < u.length; p++) {
            const t = this._tiles[u[p]];
            if (t.holdingForSymbolFade()) continue;
            const r = s
                ? [t.tileID]
                : [t.tileID.unwrapTo(-1), t.tileID.unwrapTo(0)],
              o = Math.pow(2, a.zoom - t.tileID.overscaledZ),
              l = (i * t.queryPadding * e.a3) / t.tileSize / o;
            for (const i of r) {
              const r = d.map((t) => i.getTilePoint(new e.a5(t.x, t.y)));
              if ((r.expandBy(l), r.intersects(It))) {
                const e = c.map((t) => i.getTilePoint(t)),
                  r = h.map((t) => i.getTilePoint(t));
                n.push({
                  tile: t,
                  tileID: s ? i : i.unwrapTo(0),
                  queryGeometry: e,
                  cameraQueryGeometry: r,
                  scale: o,
                });
              }
            }
          }
          return n;
        }
        transformBbox(t, i, r) {
          let n = t.map(i);
          if (r) {
            const r = e.a6.fromPoints(t);
            r.shrinkBy(0.001 * Math.min(r.width(), r.height()));
            const a = r.map(i);
            e.a6.fromPoints(n).covers(a) ||
              (n = n.map((t) => (t.x > 0.5 ? new e.a5(t.x - 1, t.y, t.z) : t)));
          }
          return n;
        }
        getVisibleCoordinates(t) {
          const e = this.getRenderableIds(t).map((t) => this._tiles[t].tileID);
          return this.transform && this.transform.populateCache(e), e;
        }
        hasTransition() {
          if (this._source.hasTransition()) return !0;
          if (Dt(this._source.type) && this._rasterFadeDuration > 0) {
            const t = l();
            for (const e in this._tiles)
              if (this._tiles[e].fadeEndTime >= t) return !0;
          }
          return !1;
        }
        setRasterFadeDuration(t) {
          this._rasterFadeDuration = t;
        }
        setFeatureState(t, e, i) {
          this._state.updateState((t = t || '_geojsonTileLayer'), e, i);
        }
        removeFeatureState(t, e, i) {
          this._state.removeFeatureState((t = t || '_geojsonTileLayer'), e, i);
        }
        getFeatureState(t, e) {
          return this._state.getState((t = t || '_geojsonTileLayer'), e);
        }
        setDependencies(t, e, i) {
          const r = this._tiles[t];
          r && r.setDependencies(e, i);
        }
        reloadTilesForDependencies(t, e) {
          for (const i in this._tiles)
            this._tiles[i].hasDependency(t, e) &&
              this._reloadTile(i, 'reloading');
          this._cache.filter((i) => !i.hasDependency(t, e));
        }
      }
      function Mt(t, e) {
        const i = Math.abs(2 * t.wrap) - +(t.wrap < 0),
          r = Math.abs(2 * e.wrap) - +(e.wrap < 0);
        return (
          t.overscaledZ - e.overscaledZ ||
          r - i ||
          e.canonical.y - t.canonical.y ||
          e.canonical.x - t.canonical.x
        );
      }
      function Dt(t) {
        return 'raster' === t || 'image' === t || 'video' === t;
      }
      (St.maxOverzooming = 10), (St.maxUnderzooming = 3);
      class Lt {
        constructor(t, e) {
          this.reset(t, e);
        }
        reset(t, e) {
          (this.points = t || []), (this._distances = [0]);
          for (let i = 1; i < this.points.length; i++)
            this._distances[i] =
              this._distances[i - 1] + this.points[i].dist(this.points[i - 1]);
          (this.length = this._distances[this._distances.length - 1]),
            (this.padding = Math.min(e || 0, 0.5 * this.length)),
            (this.paddedLength = this.length - 2 * this.padding);
        }
        lerp(t) {
          if (1 === this.points.length) return this.points[0];
          t = e.ai(t, 0, 1);
          let i = 1,
            r = this._distances[i];
          const n = t * this.paddedLength + this.padding;
          for (; r < n && i < this._distances.length; )
            r = this._distances[++i];
          const a = i - 1,
            s = this._distances[a],
            o = r - s,
            l = o > 0 ? (n - s) / o : 0;
          return this.points[a].mult(1 - l).add(this.points[i].mult(l));
        }
      }
      function At(t, e) {
        let i = !0;
        return (
          'always' === t || ('never' !== t && 'never' !== e) || (i = !1), i
        );
      }
      class Et {
        constructor(t, e, i) {
          const r = (this.boxCells = []),
            n = (this.circleCells = []);
          (this.xCellCount = Math.ceil(t / i)),
            (this.yCellCount = Math.ceil(e / i));
          for (let a = 0; a < this.xCellCount * this.yCellCount; a++)
            r.push([]), n.push([]);
          (this.circleKeys = []),
            (this.boxKeys = []),
            (this.bboxes = []),
            (this.circles = []),
            (this.width = t),
            (this.height = e),
            (this.xScale = this.xCellCount / t),
            (this.yScale = this.yCellCount / e),
            (this.boxUid = 0),
            (this.circleUid = 0);
        }
        keysLength() {
          return this.boxKeys.length + this.circleKeys.length;
        }
        insert(t, e, i, r, n) {
          this._forEachCell(e, i, r, n, this._insertBoxCell, this.boxUid++),
            this.boxKeys.push(t),
            this.bboxes.push(e),
            this.bboxes.push(i),
            this.bboxes.push(r),
            this.bboxes.push(n);
        }
        insertCircle(t, e, i, r) {
          this._forEachCell(
            e - r,
            i - r,
            e + r,
            i + r,
            this._insertCircleCell,
            this.circleUid++
          ),
            this.circleKeys.push(t),
            this.circles.push(e),
            this.circles.push(i),
            this.circles.push(r);
        }
        _insertBoxCell(t, e, i, r, n, a) {
          this.boxCells[n].push(a);
        }
        _insertCircleCell(t, e, i, r, n, a) {
          this.circleCells[n].push(a);
        }
        _query(t, e, i, r, n, a, s) {
          if (i < 0 || t > this.width || r < 0 || e > this.height) return [];
          const o = [];
          if (t <= 0 && e <= 0 && this.width <= i && this.height <= r) {
            if (n) return [{ key: null, x1: t, y1: e, x2: i, y2: r }];
            for (let t = 0; t < this.boxKeys.length; t++)
              o.push({
                key: this.boxKeys[t],
                x1: this.bboxes[4 * t],
                y1: this.bboxes[4 * t + 1],
                x2: this.bboxes[4 * t + 2],
                y2: this.bboxes[4 * t + 3],
              });
            for (let t = 0; t < this.circleKeys.length; t++) {
              const e = this.circles[3 * t],
                i = this.circles[3 * t + 1],
                r = this.circles[3 * t + 2];
              o.push({
                key: this.circleKeys[t],
                x1: e - r,
                y1: i - r,
                x2: e + r,
                y2: i + r,
              });
            }
          } else this._forEachCell(t, e, i, r, this._queryCell, o, { hitTest: n, overlapMode: a, seenUids: { box: {}, circle: {} } }, s);
          return o;
        }
        query(t, e, i, r) {
          return this._query(t, e, i, r, !1, null);
        }
        hitTest(t, e, i, r, n, a) {
          return this._query(t, e, i, r, !0, n, a).length > 0;
        }
        hitTestCircle(t, e, i, r, n) {
          const a = t - i,
            s = t + i,
            o = e - i,
            l = e + i;
          if (s < 0 || a > this.width || l < 0 || o > this.height) return !1;
          const c = [];
          return (
            this._forEachCell(
              a,
              o,
              s,
              l,
              this._queryCellCircle,
              c,
              {
                hitTest: !0,
                overlapMode: r,
                circle: { x: t, y: e, radius: i },
                seenUids: { box: {}, circle: {} },
              },
              n
            ),
            c.length > 0
          );
        }
        _queryCell(t, e, i, r, n, a, s, o) {
          const { seenUids: l, hitTest: c, overlapMode: h } = s,
            u = this.boxCells[n];
          if (null !== u) {
            const n = this.bboxes;
            for (const s of u)
              if (!l.box[s]) {
                l.box[s] = !0;
                const u = 4 * s,
                  d = this.boxKeys[s];
                if (
                  t <= n[u + 2] &&
                  e <= n[u + 3] &&
                  i >= n[u + 0] &&
                  r >= n[u + 1] &&
                  (!o || o(d)) &&
                  (!c || !At(h, d.overlapMode)) &&
                  (a.push({
                    key: d,
                    x1: n[u],
                    y1: n[u + 1],
                    x2: n[u + 2],
                    y2: n[u + 3],
                  }),
                  c)
                )
                  return !0;
              }
          }
          const d = this.circleCells[n];
          if (null !== d) {
            const n = this.circles;
            for (const s of d)
              if (!l.circle[s]) {
                l.circle[s] = !0;
                const u = 3 * s,
                  d = this.circleKeys[s];
                if (
                  this._circleAndRectCollide(
                    n[u],
                    n[u + 1],
                    n[u + 2],
                    t,
                    e,
                    i,
                    r
                  ) &&
                  (!o || o(d)) &&
                  (!c || !At(h, d.overlapMode))
                ) {
                  const t = n[u],
                    e = n[u + 1],
                    i = n[u + 2];
                  if (
                    (a.push({
                      key: d,
                      x1: t - i,
                      y1: e - i,
                      x2: t + i,
                      y2: e + i,
                    }),
                    c)
                  )
                    return !0;
                }
              }
          }
          return !1;
        }
        _queryCellCircle(t, e, i, r, n, a, s, o) {
          const { circle: l, seenUids: c, overlapMode: h } = s,
            u = this.boxCells[n];
          if (null !== u) {
            const t = this.bboxes;
            for (const e of u)
              if (!c.box[e]) {
                c.box[e] = !0;
                const i = 4 * e,
                  r = this.boxKeys[e];
                if (
                  this._circleAndRectCollide(
                    l.x,
                    l.y,
                    l.radius,
                    t[i + 0],
                    t[i + 1],
                    t[i + 2],
                    t[i + 3]
                  ) &&
                  (!o || o(r)) &&
                  !At(h, r.overlapMode)
                )
                  return a.push(!0), !0;
              }
          }
          const d = this.circleCells[n];
          if (null !== d) {
            const t = this.circles;
            for (const e of d)
              if (!c.circle[e]) {
                c.circle[e] = !0;
                const i = 3 * e,
                  r = this.circleKeys[e];
                if (
                  this._circlesCollide(
                    t[i],
                    t[i + 1],
                    t[i + 2],
                    l.x,
                    l.y,
                    l.radius
                  ) &&
                  (!o || o(r)) &&
                  !At(h, r.overlapMode)
                )
                  return a.push(!0), !0;
              }
          }
        }
        _forEachCell(t, e, i, r, n, a, s, o) {
          const l = this._convertToXCellCoord(t),
            c = this._convertToYCellCoord(e),
            h = this._convertToXCellCoord(i),
            u = this._convertToYCellCoord(r);
          for (let d = l; d <= h; d++)
            for (let l = c; l <= u; l++)
              if (n.call(this, t, e, i, r, this.xCellCount * l + d, a, s, o))
                return;
        }
        _convertToXCellCoord(t) {
          return Math.max(
            0,
            Math.min(this.xCellCount - 1, Math.floor(t * this.xScale))
          );
        }
        _convertToYCellCoord(t) {
          return Math.max(
            0,
            Math.min(this.yCellCount - 1, Math.floor(t * this.yScale))
          );
        }
        _circlesCollide(t, e, i, r, n, a) {
          const s = r - t,
            o = n - e,
            l = i + a;
          return l * l > s * s + o * o;
        }
        _circleAndRectCollide(t, e, i, r, n, a, s) {
          const o = (a - r) / 2,
            l = Math.abs(t - (r + o));
          if (l > o + i) return !1;
          const c = (s - n) / 2,
            h = Math.abs(e - (n + c));
          if (h > c + i) return !1;
          if (l <= o || h <= c) return !0;
          const u = l - o,
            d = h - c;
          return u * u + d * d <= i * i;
        }
      }
      function Rt(t, i, n) {
        const a = e.M();
        if (!t) {
          const { vecSouth: t, vecEast: e } = kt(i),
            n = r();
          (n[0] = e[0]),
            (n[1] = e[1]),
            (n[2] = t[0]),
            (n[3] = t[1]),
            (s = n),
            (d = (l = (o = n)[0]) * (u = o[3]) - (h = o[2]) * (c = o[1])) &&
              ((s[0] = u * (d = 1 / d)),
              (s[1] = -c * d),
              (s[2] = -h * d),
              (s[3] = l * d)),
            (a[0] = n[0]),
            (a[1] = n[1]),
            (a[4] = n[2]),
            (a[5] = n[3]);
        }
        var s, o, l, c, h, u, d;
        return e.O(a, a, [1 / n, 1 / n, 1]), a;
      }
      function zt(t, i, r, n) {
        if (t) {
          const t = e.M();
          if (!i) {
            const { vecSouth: e, vecEast: i } = kt(r);
            (t[0] = i[0]), (t[1] = i[1]), (t[4] = e[0]), (t[5] = e[1]);
          }
          return e.O(t, t, [n, n, 1]), t;
        }
        return r.pixelsToClipSpaceMatrix;
      }
      function kt(t) {
        const i = Math.cos(t.rollInRadians),
          r = Math.sin(t.rollInRadians),
          n = Math.cos(t.pitchInRadians),
          a = Math.cos(t.bearingInRadians),
          s = Math.sin(t.bearingInRadians),
          o = e.av();
        (o[0] = -a * n * r - s * i), (o[1] = -s * n * r + a * i);
        const l = e.aw(o);
        l < 1e-9 ? e.ax(o) : e.ay(o, o, 1 / l);
        const c = e.av();
        (c[0] = a * n * i - s * r), (c[1] = s * n * i + a * r);
        const h = e.aw(c);
        return (
          h < 1e-9 ? e.ax(c) : e.ay(c, c, 1 / h), { vecEast: c, vecSouth: o }
        );
      }
      function Ot(t, i, r, n) {
        let a;
        n
          ? ((a = [t, i, n(t, i), 1]), e.aA(a, a, r))
          : ((a = [t, i, 0, 1]), Qt(a, a, r));
        const s = a[3];
        return {
          point: new e.P(a[0] / s, a[1] / s),
          signedDistanceFromCamera: s,
          isOccluded: !1,
        };
      }
      function Ft(t, e) {
        return 0.5 + (t / e) * 0.5;
      }
      function Bt(t, e) {
        return t.x >= -e[0] && t.x <= e[0] && t.y >= -e[1] && t.y <= e[1];
      }
      function Nt(t, i, r, n, a, s, o, l, c, h, u, d, p) {
        const f = r ? t.textSizeData : t.iconSizeData,
          m = e.ar(f, i.transform.zoom),
          g = [(256 / i.width) * 2 + 1, (256 / i.height) * 2 + 1],
          _ = r
            ? t.text.dynamicLayoutVertexArray
            : t.icon.dynamicLayoutVertexArray;
        _.clear();
        const y = t.lineVertexArray,
          v = r ? t.text.placedSymbolArray : t.icon.placedSymbolArray,
          x = i.transform.width / i.transform.height;
        let b = !1;
        for (let w = 0; w < v.length; w++) {
          const r = v.get(w);
          if (r.hidden || (r.writingMode === e.as.vertical && !b)) {
            Jt(r.numGlyphs, _);
            continue;
          }
          b = !1;
          const T = new e.P(r.anchorX, r.anchorY),
            P = {
              getElevation: p,
              pitchedLabelPlaneMatrix: n,
              lineVertexArray: y,
              pitchWithMap: s,
              projectionCache: {
                projections: {},
                offsets: {},
                cachedAnchorPoint: void 0,
                anyProjectionOccluded: !1,
              },
              transform: i.transform,
              tileAnchorPoint: T,
              unwrappedTileID: c,
              width: h,
              height: u,
              translation: d,
            },
            C = Ht(r.anchorX, r.anchorY, P);
          if (!Bt(C.point, g)) {
            Jt(r.numGlyphs, _);
            continue;
          }
          const I = Ft(
              i.transform.cameraToCenterDistance,
              C.signedDistanceFromCamera
            ),
            S = e.at(f, m, r),
            M = s
              ? (S *
                  i.transform.getPitchedTextCorrection(
                    r.anchorX,
                    r.anchorY,
                    c
                  )) /
                I
              : S * I,
            D = Ut({
              projectionContext: P,
              pitchedLabelPlaneMatrixInverse: a,
              symbol: r,
              fontSize: M,
              flip: !1,
              keepUpright: o,
              glyphOffsetArray: t.glyphOffsetArray,
              dynamicLayoutVertexArray: _,
              aspectRatio: x,
              rotateToLine: l,
            });
          (b = D.useVertical),
            (D.notEnoughRoom ||
              b ||
              (D.needsFlipping &&
                Ut({
                  projectionContext: P,
                  pitchedLabelPlaneMatrixInverse: a,
                  symbol: r,
                  fontSize: M,
                  flip: !0,
                  keepUpright: o,
                  glyphOffsetArray: t.glyphOffsetArray,
                  dynamicLayoutVertexArray: _,
                  aspectRatio: x,
                  rotateToLine: l,
                }).notEnoughRoom)) &&
              Jt(r.numGlyphs, _);
        }
        r
          ? t.text.dynamicLayoutVertexBuffer.updateData(_)
          : t.icon.dynamicLayoutVertexBuffer.updateData(_);
      }
      function Vt(t, e, i, r, n, a, s, o) {
        const l = a.glyphStartIndex + a.numGlyphs,
          c = a.lineStartIndex,
          h = a.lineStartIndex + a.lineLength,
          u = e.getoffsetX(a.glyphStartIndex),
          d = e.getoffsetX(l - 1),
          p = Yt(t * u, i, r, n, a.segment, c, h, o, s);
        if (!p) return null;
        const f = Yt(t * d, i, r, n, a.segment, c, h, o, s);
        return f
          ? o.projectionCache.anyProjectionOccluded
            ? null
            : { first: p, last: f }
          : null;
      }
      function jt(t, i, r, n) {
        return t === e.as.horizontal &&
          Math.abs(r.y - i.y) > Math.abs(r.x - i.x) * n
          ? { useVertical: !0 }
          : (t === e.as.vertical ? i.y < r.y : i.x > r.x)
          ? { needsFlipping: !0 }
          : null;
      }
      function Ut(t) {
        const {
            projectionContext: i,
            pitchedLabelPlaneMatrixInverse: r,
            symbol: n,
            fontSize: a,
            flip: s,
            keepUpright: o,
            glyphOffsetArray: l,
            dynamicLayoutVertexArray: c,
            aspectRatio: h,
            rotateToLine: u,
          } = t,
          d = a / 24,
          p = n.lineOffsetX * d,
          f = n.lineOffsetY * d;
        let m;
        if (n.numGlyphs > 1) {
          const t = n.glyphStartIndex + n.numGlyphs,
            e = n.lineStartIndex,
            a = n.lineStartIndex + n.lineLength,
            c = Vt(d, l, p, f, s, n, u, i);
          if (!c) return { notEnoughRoom: !0 };
          const g = qt(c.first.point.x, c.first.point.y, i, r),
            _ = qt(c.last.point.x, c.last.point.y, i, r);
          if (o && !s) {
            const t = jt(n.writingMode, g, _, h);
            if (t) return t;
          }
          m = [c.first];
          for (let r = n.glyphStartIndex + 1; r < t - 1; r++) {
            const t = Yt(d * l.getoffsetX(r), p, f, s, n.segment, e, a, i, u);
            if (!t) return { notEnoughRoom: !0 };
            m.push(t);
          }
          m.push(c.last);
        } else {
          if (o && !s) {
            const t = $t(i.tileAnchorPoint.x, i.tileAnchorPoint.y, i).point,
              a = n.lineStartIndex + n.segment + 1,
              s = new e.P(i.lineVertexArray.getx(a), i.lineVertexArray.gety(a)),
              o = $t(s.x, s.y, i),
              l =
                o.signedDistanceFromCamera > 0
                  ? o.point
                  : Gt(i.tileAnchorPoint, s, t, 1, i),
              c = qt(t.x, t.y, i, r),
              u = qt(l.x, l.y, i, r),
              d = jt(n.writingMode, c, u, h);
            if (d) return d;
          }
          const t = Yt(
            d * l.getoffsetX(n.glyphStartIndex),
            p,
            f,
            s,
            n.segment,
            n.lineStartIndex,
            n.lineStartIndex + n.lineLength,
            i,
            u
          );
          if (!t || i.projectionCache.anyProjectionOccluded)
            return { notEnoughRoom: !0 };
          m = [t];
        }
        for (const g of m) e.az(c, g.point, g.angle);
        return {};
      }
      function Gt(t, e, i, r, n) {
        const a = t.add(t.sub(e)._unit()),
          s = $t(a.x, a.y, n).point,
          o = i.sub(s);
        return i.add(o._mult(r / o.mag()));
      }
      function Zt(t, i, r) {
        const n = i.projectionCache;
        if (n.projections[t]) return n.projections[t];
        const a = new e.P(i.lineVertexArray.getx(t), i.lineVertexArray.gety(t)),
          s = $t(a.x, a.y, i);
        if (s.signedDistanceFromCamera > 0)
          return (
            (n.projections[t] = s.point),
            (n.anyProjectionOccluded = n.anyProjectionOccluded || s.isOccluded),
            s.point
          );
        const o = t - r.direction;
        return Gt(
          0 === r.distanceFromAnchor
            ? i.tileAnchorPoint
            : new e.P(i.lineVertexArray.getx(o), i.lineVertexArray.gety(o)),
          a,
          r.previousVertex,
          r.absOffsetX - r.distanceFromAnchor + 1,
          i
        );
      }
      function $t(t, e, i) {
        const r = t + i.translation[0],
          n = e + i.translation[1];
        let a;
        return (
          i.pitchWithMap
            ? ((a = Ot(r, n, i.pitchedLabelPlaneMatrix, i.getElevation)),
              (a.isOccluded = !1))
            : ((a = i.transform.projectTileCoordinates(
                r,
                n,
                i.unwrappedTileID,
                i.getElevation
              )),
              (a.point.x = (0.5 * a.point.x + 0.5) * i.width),
              (a.point.y = (0.5 * -a.point.y + 0.5) * i.height)),
          a
        );
      }
      function qt(t, i, r, n) {
        if (r.pitchWithMap) {
          const a = [t, i, 0, 1];
          return (
            e.aA(a, a, n),
            r.transform.projectTileCoordinates(
              a[0] / a[3],
              a[1] / a[3],
              r.unwrappedTileID,
              r.getElevation
            ).point
          );
        }
        return { x: (t / r.width) * 2 - 1, y: 1 - (i / r.height) * 2 };
      }
      function Ht(t, e, i) {
        return i.transform.projectTileCoordinates(
          t,
          e,
          i.unwrappedTileID,
          i.getElevation
        );
      }
      function Wt(t, e, i) {
        return t
          ._unit()
          ._perp()
          ._mult(e * i);
      }
      function Xt(t, i, r, n, a, s, o, l, c) {
        if (l.projectionCache.offsets[t]) return l.projectionCache.offsets[t];
        const h = r.add(i);
        if (t + c.direction < n || t + c.direction >= a)
          return (l.projectionCache.offsets[t] = h), h;
        const u = Zt(t + c.direction, l, c),
          d = Wt(u.sub(r), o, c.direction),
          p = r.add(d),
          f = u.add(d);
        return (
          (l.projectionCache.offsets[t] = e.aB(s, h, p, f) || h),
          l.projectionCache.offsets[t]
        );
      }
      function Yt(t, e, i, r, n, a, s, o, l) {
        const c = r ? t - e : t + e;
        let h = c > 0 ? 1 : -1,
          u = 0;
        r && ((h *= -1), (u = Math.PI)), h < 0 && (u += Math.PI);
        let d,
          p = h > 0 ? a + n : a + n + 1;
        o.projectionCache.cachedAnchorPoint
          ? (d = o.projectionCache.cachedAnchorPoint)
          : ((d = $t(o.tileAnchorPoint.x, o.tileAnchorPoint.y, o).point),
            (o.projectionCache.cachedAnchorPoint = d));
        let f,
          m,
          g = d,
          _ = d,
          y = 0,
          v = 0;
        const x = Math.abs(c),
          b = [];
        let w;
        for (; y + v <= x; ) {
          if (((p += h), p < a || p >= s)) return null;
          (y += v), (_ = g), (m = f);
          const t = {
            absOffsetX: x,
            direction: h,
            distanceFromAnchor: y,
            previousVertex: _,
          };
          if (((g = Zt(p, o, t)), 0 === i)) b.push(_), (w = g.sub(_));
          else {
            let e;
            const r = g.sub(_);
            (e =
              0 === r.mag() ? Wt(Zt(p + h, o, t).sub(g), i, h) : Wt(r, i, h)),
              m || (m = _.add(e)),
              (f = Xt(p, e, g, a, s, m, i, o, t)),
              b.push(m),
              (w = f.sub(m));
          }
          v = w.mag();
        }
        const T = w._mult((x - y) / v)._add(m || _),
          P = u + Math.atan2(g.y - _.y, g.x - _.x);
        return b.push(T), { point: T, angle: l ? P : 0, path: b };
      }
      const Kt = new Float32Array([
        -1 / 0,
        -1 / 0,
        0,
        -1 / 0,
        -1 / 0,
        0,
        -1 / 0,
        -1 / 0,
        0,
        -1 / 0,
        -1 / 0,
        0,
      ]);
      function Jt(t, e) {
        for (let i = 0; i < t; i++) {
          const t = e.length;
          e.resize(t + 4), e.float32.set(Kt, 3 * t);
        }
      }
      function Qt(t, e, i) {
        const r = e[0],
          n = e[1];
        return (
          (t[0] = i[0] * r + i[4] * n + i[12]),
          (t[1] = i[1] * r + i[5] * n + i[13]),
          (t[3] = i[3] * r + i[7] * n + i[15]),
          t
        );
      }
      const te = 100;
      class ee {
        constructor(
          t,
          e = new Et(t.width + 200, t.height + 200, 25),
          i = new Et(t.width + 200, t.height + 200, 25)
        ) {
          (this.transform = t),
            (this.grid = e),
            (this.ignoredGrid = i),
            (this.pitchFactor =
              Math.cos((t.pitch * Math.PI) / 180) * t.cameraToCenterDistance),
            (this.screenRightBoundary = t.width + te),
            (this.screenBottomBoundary = t.height + te),
            (this.gridRightBoundary = t.width + 200),
            (this.gridBottomBoundary = t.height + 200),
            (this.perspectiveRatioCutoff = 0.6);
        }
        placeCollisionBox(t, e, i, r, n, a, s, o, l, c, h, u) {
          const d = this.projectAndGetPerspectiveRatio(
              t.anchorPointX + o[0],
              t.anchorPointY + o[1],
              n,
              c,
              u
            ),
            p = i * d.perspectiveRatio;
          let f;
          if (a || s)
            f = this._projectCollisionBox(t, p, r, n, a, s, o, d, c, h, u);
          else {
            const e = d.x + (h ? h.x * p : 0),
              i = d.y + (h ? h.y * p : 0);
            f = {
              allPointsOccluded: !1,
              box: [e + t.x1 * p, i + t.y1 * p, e + t.x2 * p, i + t.y2 * p],
            };
          }
          const [m, g, _, y] = f.box,
            v = a ? f.allPointsOccluded : d.isOccluded;
          let x = v;
          return (
            x || (x = d.perspectiveRatio < this.perspectiveRatioCutoff),
            x || (x = !this.isInsideGrid(m, g, _, y)),
            x || ('always' !== e && this.grid.hitTest(m, g, _, y, e, l))
              ? { box: [m, g, _, y], placeable: !1, offscreen: !1, occluded: v }
              : {
                  box: [m, g, _, y],
                  placeable: !0,
                  offscreen: this.isOffscreen(m, g, _, y),
                  occluded: v,
                }
          );
        }
        placeCollisionCircles(t, i, r, n, a, s, o, l, c, h, u, d, p, f) {
          const m = [],
            g = new e.P(i.anchorX, i.anchorY),
            _ = this.getPerspectiveRatio(g.x, g.y, s, f),
            y =
              (c
                ? (a *
                    this.transform.getPitchedTextCorrection(
                      i.anchorX,
                      i.anchorY,
                      s
                    )) /
                  _
                : a * _) / e.aF,
            v = {
              getElevation: f,
              pitchedLabelPlaneMatrix: o,
              lineVertexArray: r,
              pitchWithMap: c,
              projectionCache: {
                projections: {},
                offsets: {},
                cachedAnchorPoint: void 0,
                anyProjectionOccluded: !1,
              },
              transform: this.transform,
              tileAnchorPoint: g,
              unwrappedTileID: s,
              width: this.transform.width,
              height: this.transform.height,
              translation: p,
            },
            x = Vt(y, n, i.lineOffsetX * y, i.lineOffsetY * y, !1, i, !1, v);
          let b = !1,
            w = !1,
            T = !0;
          if (x) {
            const i = 0.5 * u * _ + d,
              r = new e.P(-100, -100),
              n = new e.P(this.screenRightBoundary, this.screenBottomBoundary),
              a = new Lt(),
              s = x.first,
              o = x.last;
            let p = [];
            for (let t = s.path.length - 1; t >= 1; t--) p.push(s.path[t]);
            for (let t = 1; t < o.path.length; t++) p.push(o.path[t]);
            const f = 2.5 * i;
            if (c) {
              const t = this.projectPathToScreenSpace(p, v);
              p = t.some((t) => t.signedDistanceFromCamera <= 0)
                ? []
                : t.map((t) => t.point);
            }
            let g = [];
            if (p.length > 0) {
              const t = p[0].clone(),
                i = p[0].clone();
              for (let e = 1; e < p.length; e++)
                (t.x = Math.min(t.x, p[e].x)),
                  (t.y = Math.min(t.y, p[e].y)),
                  (i.x = Math.max(i.x, p[e].x)),
                  (i.y = Math.max(i.y, p[e].y));
              g =
                t.x >= r.x && i.x <= n.x && t.y >= r.y && i.y <= n.y
                  ? [p]
                  : i.x < r.x || t.x > n.x || i.y < r.y || t.y > n.y
                  ? []
                  : e.aC([p], r.x, r.y, n.x, n.y);
            }
            for (const e of g) {
              a.reset(e, 0.25 * i);
              let r = 0;
              r = a.length <= 0.5 * i ? 1 : Math.ceil(a.paddedLength / f) + 1;
              for (let e = 0; e < r; e++) {
                const n = e / Math.max(r - 1, 1),
                  s = a.lerp(n),
                  o = s.x + te,
                  c = s.y + te;
                m.push(o, c, i, 0);
                const u = o - i,
                  d = c - i,
                  p = o + i,
                  f = c + i;
                if (
                  ((T = T && this.isOffscreen(u, d, p, f)),
                  (w = w || this.isInsideGrid(u, d, p, f)),
                  'always' !== t &&
                    this.grid.hitTestCircle(o, c, i, t, h) &&
                    ((b = !0), !l))
                )
                  return { circles: [], offscreen: !1, collisionDetected: b };
              }
            }
          }
          return {
            circles:
              (!l && b) || !w || _ < this.perspectiveRatioCutoff ? [] : m,
            offscreen: T,
            collisionDetected: b,
          };
        }
        projectPathToScreenSpace(t, i) {
          const r = (function (t, i) {
            const r = e.M();
            return (
              e.au(r, i.pitchedLabelPlaneMatrix),
              t.map((t) => {
                const e = Ot(t.x, t.y, r, i.getElevation),
                  n = i.transform.projectTileCoordinates(
                    e.point.x,
                    e.point.y,
                    i.unwrappedTileID,
                    i.getElevation
                  );
                return (
                  (n.point.x = (0.5 * n.point.x + 0.5) * i.width),
                  (n.point.y = (0.5 * -n.point.y + 0.5) * i.height),
                  n
                );
              })
            );
          })(t, i);
          return (function (t) {
            let e = 0,
              i = 0,
              r = 0,
              n = 0;
            for (let a = 0; a < t.length; a++)
              t[a].isOccluded
                ? ((r = a + 1), (n = 0))
                : (n++, n > i && ((i = n), (e = r)));
            return t.slice(e, e + i);
          })(r);
        }
        queryRenderedSymbols(t) {
          if (
            0 === t.length ||
            (0 === this.grid.keysLength() &&
              0 === this.ignoredGrid.keysLength())
          )
            return {};
          const i = [],
            r = new e.a6();
          for (const u of t) {
            const t = new e.P(u.x + te, u.y + te);
            r.extend(t), i.push(t);
          }
          const { minX: n, minY: a, maxX: s, maxY: o } = r,
            l = this.grid
              .query(n, a, s, o)
              .concat(this.ignoredGrid.query(n, a, s, o)),
            c = {},
            h = {};
          for (const u of l) {
            const t = u.key;
            if (
              (void 0 === c[t.bucketInstanceId] && (c[t.bucketInstanceId] = {}),
              c[t.bucketInstanceId][t.featureIndex])
            )
              continue;
            const r = [
              new e.P(u.x1, u.y1),
              new e.P(u.x2, u.y1),
              new e.P(u.x2, u.y2),
              new e.P(u.x1, u.y2),
            ];
            e.aD(i, r) &&
              ((c[t.bucketInstanceId][t.featureIndex] = !0),
              void 0 === h[t.bucketInstanceId] && (h[t.bucketInstanceId] = []),
              h[t.bucketInstanceId].push(t.featureIndex));
          }
          return h;
        }
        insertCollisionBox(t, e, i, r, n, a) {
          (i ? this.ignoredGrid : this.grid).insert(
            {
              bucketInstanceId: r,
              featureIndex: n,
              collisionGroupID: a,
              overlapMode: e,
            },
            t[0],
            t[1],
            t[2],
            t[3]
          );
        }
        insertCollisionCircles(t, e, i, r, n, a) {
          const s = i ? this.ignoredGrid : this.grid,
            o = {
              bucketInstanceId: r,
              featureIndex: n,
              collisionGroupID: a,
              overlapMode: e,
            };
          for (let l = 0; l < t.length; l += 4)
            s.insertCircle(o, t[l], t[l + 1], t[l + 2]);
        }
        projectAndGetPerspectiveRatio(t, i, r, n, a) {
          if (a) {
            let r;
            n
              ? ((r = [t, i, n(t, i), 1]), e.aA(r, r, a))
              : ((r = [t, i, 0, 1]), Qt(r, r, a));
            const s = r[3];
            return {
              x: ((r[0] / s + 1) / 2) * this.transform.width + te,
              y: ((-r[1] / s + 1) / 2) * this.transform.height + te,
              perspectiveRatio:
                0.5 + (this.transform.cameraToCenterDistance / s) * 0.5,
              isOccluded: !1,
              signedDistanceFromCamera: s,
            };
          }
          {
            const e = this.transform.projectTileCoordinates(t, i, r, n);
            return {
              x: ((e.point.x + 1) / 2) * this.transform.width + te,
              y: ((1 - e.point.y) / 2) * this.transform.height + te,
              perspectiveRatio:
                0.5 +
                (this.transform.cameraToCenterDistance /
                  e.signedDistanceFromCamera) *
                  0.5,
              isOccluded: e.isOccluded,
              signedDistanceFromCamera: e.signedDistanceFromCamera,
            };
          }
        }
        getPerspectiveRatio(t, e, i, r) {
          const n = this.transform.projectTileCoordinates(t, e, i, r);
          return (
            0.5 +
            (this.transform.cameraToCenterDistance /
              n.signedDistanceFromCamera) *
              0.5
          );
        }
        isOffscreen(t, e, i, r) {
          return (
            i < te ||
            t >= this.screenRightBoundary ||
            r < te ||
            e > this.screenBottomBoundary
          );
        }
        isInsideGrid(t, e, i, r) {
          return (
            i >= 0 &&
            t < this.gridRightBoundary &&
            r >= 0 &&
            e < this.gridBottomBoundary
          );
        }
        getViewportMatrix() {
          const t = e.am([]);
          return e.N(t, t, [-100, -100, 0]), t;
        }
        _projectCollisionBox(t, i, r, n, a, s, o, l, c, h, u) {
          let d = 1,
            p = 0,
            f = 0,
            m = 1;
          const g = t.anchorPointX + o[0],
            _ = t.anchorPointY + o[1];
          if (s && !a) {
            const t = this.projectAndGetPerspectiveRatio(g + 1, _, n, c, u),
              e = t.x - l.x,
              i = Math.atan((t.y - l.y) / e) + (e < 0 ? Math.PI : 0),
              r = Math.sin(i),
              a = Math.cos(i);
            (d = a), (p = r), (f = -r), (m = a);
          } else if (!s && a) {
            const t = kt(this.transform);
            (d = t.vecEast[0]),
              (p = t.vecEast[1]),
              (f = t.vecSouth[0]),
              (m = t.vecSouth[1]);
          }
          let y = l.x,
            v = l.y,
            x = i;
          a &&
            ((y = g),
            (v = _),
            (x = Math.pow(2, -(this.transform.zoom - r.overscaledZ))),
            (x *= this.transform.getPitchedTextCorrection(g, _, n)),
            h ||
              (x *= e.ai(
                0.5 +
                  (l.signedDistanceFromCamera /
                    this.transform.cameraToCenterDistance) *
                    0.5,
                0,
                4
              ))),
            h &&
              ((y += d * h.x * x + f * h.y * x),
              (v += p * h.x * x + m * h.y * x));
          const b = t.x1 * x,
            w = t.x2 * x,
            T = (b + w) / 2,
            P = t.y1 * x,
            C = t.y2 * x,
            I = (P + C) / 2,
            S = [
              { offsetX: b, offsetY: P },
              { offsetX: T, offsetY: P },
              { offsetX: w, offsetY: P },
              { offsetX: w, offsetY: I },
              { offsetX: w, offsetY: C },
              { offsetX: T, offsetY: C },
              { offsetX: b, offsetY: C },
              { offsetX: b, offsetY: I },
            ];
          let M = [];
          for (const { offsetX: L, offsetY: A } of S)
            M.push(new e.P(y + d * L + f * A, v + p * L + m * A));
          let D = !1;
          if (a) {
            const t = M.map((t) =>
              this.projectAndGetPerspectiveRatio(t.x, t.y, n, c, u)
            );
            (D = t.some((t) => !t.isOccluded)),
              (M = t.map((t) => new e.P(t.x, t.y)));
          } else D = !0;
          return { box: e.aE(M), allPointsOccluded: !D };
        }
      }
      class ie {
        constructor(t, e, i, r) {
          (this.opacity = t
            ? Math.max(0, Math.min(1, t.opacity + (t.placed ? e : -e)))
            : r && i
            ? 1
            : 0),
            (this.placed = i);
        }
        isHidden() {
          return 0 === this.opacity && !this.placed;
        }
      }
      class re {
        constructor(t, e, i, r, n) {
          (this.text = new ie(t ? t.text : null, e, i, n)),
            (this.icon = new ie(t ? t.icon : null, e, r, n));
        }
        isHidden() {
          return this.text.isHidden() && this.icon.isHidden();
        }
      }
      class ne {
        constructor(t, e, i) {
          (this.text = t), (this.icon = e), (this.skipFade = i);
        }
      }
      class ae {
        constructor(t, e, i, r, n) {
          (this.bucketInstanceId = t),
            (this.featureIndex = e),
            (this.sourceLayerIndex = i),
            (this.bucketIndex = r),
            (this.tileID = n);
        }
      }
      class se {
        constructor(t) {
          (this.crossSourceCollisions = t),
            (this.maxGroupID = 0),
            (this.collisionGroups = {});
        }
        get(t) {
          if (this.crossSourceCollisions) return { ID: 0, predicate: null };
          if (!this.collisionGroups[t]) {
            const e = ++this.maxGroupID;
            this.collisionGroups[t] = {
              ID: e,
              predicate: (t) => t.collisionGroupID === e,
            };
          }
          return this.collisionGroups[t];
        }
      }
      function oe(t, i, r, n, a) {
        const { horizontalAlign: s, verticalAlign: o } = e.aL(t);
        return new e.P(-(s - 0.5) * i + n[0] * a, -(o - 0.5) * r + n[1] * a);
      }
      class le {
        constructor(t, e, i, r, n) {
          (this.transform = t.clone()),
            (this.terrain = e),
            (this.collisionIndex = new ee(this.transform)),
            (this.placements = {}),
            (this.opacities = {}),
            (this.variableOffsets = {}),
            (this.stale = !1),
            (this.commitTime = 0),
            (this.fadeDuration = i),
            (this.retainedQueryData = {}),
            (this.collisionGroups = new se(r)),
            (this.collisionCircleArrays = {}),
            (this.collisionBoxArrays = new Map()),
            (this.prevPlacement = n),
            n && (n.prevPlacement = void 0),
            (this.placedOrientations = {});
        }
        _getTerrainElevationFunc(t) {
          const e = this.terrain;
          return e ? (i, r) => e.getElevation(t, i, r) : null;
        }
        getBucketParts(t, i, r, n) {
          const a = r.getBucket(i),
            s = r.latestFeatureIndex;
          if (!a || !s || i.id !== a.layerIds[0]) return;
          const o = r.collisionBoxArray,
            l = a.layers[0].layout,
            c = a.layers[0].paint,
            h = Math.pow(2, this.transform.zoom - r.tileID.overscaledZ),
            u = r.tileSize / e.a3,
            d = r.tileID.toUnwrapped(),
            p = 'map' === l.get('text-rotation-alignment'),
            f = e.aG(r, 1, this.transform.zoom),
            m = e.aH(
              this.collisionIndex.transform,
              r,
              c.get('text-translate'),
              c.get('text-translate-anchor')
            ),
            g = e.aH(
              this.collisionIndex.transform,
              r,
              c.get('icon-translate'),
              c.get('icon-translate-anchor')
            ),
            _ = Rt(p, this.transform, f);
          this.retainedQueryData[a.bucketInstanceId] = new ae(
            a.bucketInstanceId,
            s,
            a.sourceLayerIndex,
            a.index,
            r.tileID
          );
          const y = {
            bucket: a,
            layout: l,
            translationText: m,
            translationIcon: g,
            unwrappedTileID: d,
            pitchedLabelPlaneMatrix: _,
            scale: h,
            textPixelRatio: u,
            holdingForFade: r.holdingForSymbolFade(),
            collisionBoxArray: o,
            partiallyEvaluatedTextSize: e.ar(
              a.textSizeData,
              this.transform.zoom
            ),
            collisionGroup: this.collisionGroups.get(a.sourceID),
          };
          if (n)
            for (const e of a.sortKeyRanges) {
              const {
                sortKey: i,
                symbolInstanceStart: r,
                symbolInstanceEnd: n,
              } = e;
              t.push({
                sortKey: i,
                symbolInstanceStart: r,
                symbolInstanceEnd: n,
                parameters: y,
              });
            }
          else
            t.push({
              symbolInstanceStart: 0,
              symbolInstanceEnd: a.symbolInstances.length,
              parameters: y,
            });
        }
        attemptAnchorPlacement(
          t,
          i,
          r,
          n,
          a,
          s,
          o,
          l,
          c,
          h,
          u,
          d,
          p,
          f,
          m,
          g,
          _,
          y,
          v,
          x
        ) {
          const b = e.aI[t.textAnchor],
            w = [t.textOffset0, t.textOffset1],
            T = oe(b, r, n, w, a),
            P = this.collisionIndex.placeCollisionBox(
              i,
              d,
              l,
              c,
              h,
              o,
              s,
              g,
              u.predicate,
              v,
              T,
              x
            );
          if (
            (!y ||
              this.collisionIndex.placeCollisionBox(
                y,
                d,
                l,
                c,
                h,
                o,
                s,
                _,
                u.predicate,
                v,
                T,
                x
              ).placeable) &&
            P.placeable
          ) {
            let t;
            if (
              (this.prevPlacement &&
                this.prevPlacement.variableOffsets[p.crossTileID] &&
                this.prevPlacement.placements[p.crossTileID] &&
                this.prevPlacement.placements[p.crossTileID].text &&
                (t = this.prevPlacement.variableOffsets[p.crossTileID].anchor),
              0 === p.crossTileID)
            )
              throw new Error("symbolInstance.crossTileID can't be 0");
            return (
              (this.variableOffsets[p.crossTileID] = {
                textOffset: w,
                width: r,
                height: n,
                anchor: b,
                textBoxScale: a,
                prevAnchor: t,
              }),
              this.markUsedJustification(f, b, p, m),
              f.allowVerticalPlacement &&
                (this.markUsedOrientation(f, m, p),
                (this.placedOrientations[p.crossTileID] = m)),
              { shift: T, placedGlyphBoxes: P }
            );
          }
        }
        placeLayerBucketPart(t, i, r) {
          const {
              bucket: n,
              layout: a,
              translationText: s,
              translationIcon: o,
              unwrappedTileID: l,
              pitchedLabelPlaneMatrix: c,
              textPixelRatio: h,
              holdingForFade: u,
              collisionBoxArray: d,
              partiallyEvaluatedTextSize: p,
              collisionGroup: f,
            } = t.parameters,
            m = a.get('text-optional'),
            g = a.get('icon-optional'),
            _ = e.aJ(a, 'text-overlap', 'text-allow-overlap'),
            y = 'always' === _,
            v = e.aJ(a, 'icon-overlap', 'icon-allow-overlap'),
            x = 'always' === v,
            b = 'map' === a.get('text-rotation-alignment'),
            w = 'map' === a.get('text-pitch-alignment'),
            T = 'none' !== a.get('icon-text-fit'),
            P = 'viewport-y' === a.get('symbol-z-order'),
            C = y && (x || !n.hasIconData() || g),
            I = x && (y || !n.hasTextData() || m);
          !n.collisionArrays && d && n.deserializeCollisionBoxes(d);
          const S = this.retainedQueryData[n.bucketInstanceId].tileID,
            M = this._getTerrainElevationFunc(S),
            D = this.transform.getFastPathSimpleProjectionMatrix(S),
            L = (t, d, x) => {
              var P, L;
              if (i[t.crossTileID]) return;
              if (u)
                return void (this.placements[t.crossTileID] = new ne(
                  !1,
                  !1,
                  !1
                ));
              let A = !1,
                E = !1,
                R = !0,
                z = null,
                k = { box: null, placeable: !1, offscreen: null, occluded: !1 },
                O = { placeable: !1 },
                F = null,
                B = null,
                N = null,
                V = 0,
                j = 0,
                U = 0;
              d.textFeatureIndex
                ? (V = d.textFeatureIndex)
                : t.useRuntimeCollisionCircles && (V = t.featureIndex),
                d.verticalTextFeatureIndex && (j = d.verticalTextFeatureIndex);
              const G = d.textBox;
              if (G) {
                const i = (i) => {
                    let r = e.as.horizontal;
                    if (n.allowVerticalPlacement && !i && this.prevPlacement) {
                      const e =
                        this.prevPlacement.placedOrientations[t.crossTileID];
                      e &&
                        ((this.placedOrientations[t.crossTileID] = e),
                        (r = e),
                        this.markUsedOrientation(n, r, t));
                    }
                    return r;
                  },
                  a = (i, r) => {
                    if (
                      n.allowVerticalPlacement &&
                      t.numVerticalGlyphVertices > 0 &&
                      d.verticalTextBox
                    ) {
                      for (const t of n.writingModes)
                        if (
                          (t === e.as.vertical
                            ? ((k = r()), (O = k))
                            : (k = i()),
                          k && k.placeable)
                        )
                          break;
                    } else k = i();
                  },
                  c = t.textAnchorOffsetStartIndex,
                  u = t.textAnchorOffsetEndIndex;
                if (u === c) {
                  const r = (e, i) => {
                    const r = this.collisionIndex.placeCollisionBox(
                      e,
                      _,
                      h,
                      S,
                      l,
                      w,
                      b,
                      s,
                      f.predicate,
                      M,
                      void 0,
                      D
                    );
                    return (
                      r &&
                        r.placeable &&
                        (this.markUsedOrientation(n, i, t),
                        (this.placedOrientations[t.crossTileID] = i)),
                      r
                    );
                  };
                  a(
                    () => r(G, e.as.horizontal),
                    () => {
                      const i = d.verticalTextBox;
                      return n.allowVerticalPlacement &&
                        t.numVerticalGlyphVertices > 0 &&
                        i
                        ? r(i, e.as.vertical)
                        : { box: null, offscreen: null };
                    }
                  ),
                    i(k && k.placeable);
                } else {
                  let p =
                    e.aI[
                      null ===
                        (L =
                          null === (P = this.prevPlacement) || void 0 === P
                            ? void 0
                            : P.variableOffsets[t.crossTileID]) || void 0 === L
                        ? void 0
                        : L.anchor
                    ];
                  const m = (e, i, a) => {
                    const d = e.x2 - e.x1,
                      m = e.y2 - e.y1,
                      g = t.textBoxScale,
                      y = T && 'never' === v ? i : null;
                    let x = null,
                      P = 'never' === _ ? 1 : 2,
                      C = 'never';
                    p && P++;
                    for (let r = 0; r < P; r++) {
                      for (let i = c; i < u; i++) {
                        const r = n.textAnchorOffsets.get(i);
                        if (p && r.textAnchor !== p) continue;
                        const c = this.attemptAnchorPlacement(
                          r,
                          e,
                          d,
                          m,
                          g,
                          b,
                          w,
                          h,
                          S,
                          l,
                          f,
                          C,
                          t,
                          n,
                          a,
                          s,
                          o,
                          y,
                          M
                        );
                        if (c && ((x = c.placedGlyphBoxes), x && x.placeable))
                          return (A = !0), (z = c.shift), x;
                      }
                      p ? (p = null) : (C = _);
                    }
                    return (
                      r &&
                        !x &&
                        (x = {
                          box: this.collisionIndex.placeCollisionBox(
                            G,
                            'always',
                            h,
                            S,
                            l,
                            w,
                            b,
                            s,
                            f.predicate,
                            M,
                            void 0,
                            D
                          ).box,
                          offscreen: !1,
                          placeable: !1,
                          occluded: !1,
                        }),
                      x
                    );
                  };
                  a(
                    () => m(G, d.iconBox, e.as.horizontal),
                    () => {
                      const i = d.verticalTextBox;
                      return n.allowVerticalPlacement &&
                        (!k || !k.placeable) &&
                        t.numVerticalGlyphVertices > 0 &&
                        i
                        ? m(i, d.verticalIconBox, e.as.vertical)
                        : { box: null, occluded: !0, offscreen: null };
                    }
                  ),
                    k && ((A = k.placeable), (R = k.offscreen));
                  const g = i(k && k.placeable);
                  if (!A && this.prevPlacement) {
                    const e = this.prevPlacement.variableOffsets[t.crossTileID];
                    e &&
                      ((this.variableOffsets[t.crossTileID] = e),
                      this.markUsedJustification(n, e.anchor, t, g));
                  }
                }
              }
              if (
                ((F = k),
                (A = F && F.placeable),
                (R = F && F.offscreen),
                t.useRuntimeCollisionCircles &&
                  t.centerJustifiedTextSymbolIndex >= 0)
              ) {
                const i = n.text.placedSymbolArray.get(
                    t.centerJustifiedTextSymbolIndex
                  ),
                  o = e.at(n.textSizeData, p, i),
                  h = a.get('text-padding');
                (B = this.collisionIndex.placeCollisionCircles(
                  _,
                  i,
                  n.lineVertexArray,
                  n.glyphOffsetArray,
                  o,
                  l,
                  c,
                  r,
                  w,
                  f.predicate,
                  t.collisionCircleDiameter,
                  h,
                  s,
                  M
                )),
                  B.circles.length &&
                    B.collisionDetected &&
                    !r &&
                    e.w(
                      'Collisions detected, but collision boxes are not shown'
                    ),
                  (A = y || (B.circles.length > 0 && !B.collisionDetected)),
                  (R = R && B.offscreen);
              }
              if ((d.iconFeatureIndex && (U = d.iconFeatureIndex), d.iconBox)) {
                const t = (t) =>
                  this.collisionIndex.placeCollisionBox(
                    t,
                    v,
                    h,
                    S,
                    l,
                    w,
                    b,
                    o,
                    f.predicate,
                    M,
                    T && z ? z : void 0,
                    D
                  );
                O && O.placeable && d.verticalIconBox
                  ? ((N = t(d.verticalIconBox)), (E = N.placeable))
                  : ((N = t(d.iconBox)), (E = N.placeable)),
                  (R = R && N.offscreen);
              }
              const Z =
                  m ||
                  (0 === t.numHorizontalGlyphVertices &&
                    0 === t.numVerticalGlyphVertices),
                $ = g || 0 === t.numIconVertices;
              Z || $
                ? $
                  ? Z || (E = E && A)
                  : (A = E && A)
                : (E = A = E && A);
              const q = E && N.placeable;
              if (
                (A &&
                  F.placeable &&
                  this.collisionIndex.insertCollisionBox(
                    F.box,
                    _,
                    a.get('text-ignore-placement'),
                    n.bucketInstanceId,
                    O && O.placeable && j ? j : V,
                    f.ID
                  ),
                q &&
                  this.collisionIndex.insertCollisionBox(
                    N.box,
                    v,
                    a.get('icon-ignore-placement'),
                    n.bucketInstanceId,
                    U,
                    f.ID
                  ),
                B &&
                  A &&
                  this.collisionIndex.insertCollisionCircles(
                    B.circles,
                    _,
                    a.get('text-ignore-placement'),
                    n.bucketInstanceId,
                    V,
                    f.ID
                  ),
                r && this.storeCollisionData(n.bucketInstanceId, x, d, F, N, B),
                0 === t.crossTileID)
              )
                throw new Error("symbolInstance.crossTileID can't be 0");
              if (0 === n.bucketInstanceId)
                throw new Error("bucket.bucketInstanceId can't be 0");
              (this.placements[t.crossTileID] = new ne(
                (A || C) && !(null == F ? void 0 : F.occluded),
                (E || I) && !(null == N ? void 0 : N.occluded),
                R || n.justReloaded
              )),
                (i[t.crossTileID] = !0);
            };
          if (P) {
            if (0 !== t.symbolInstanceStart)
              throw new Error('bucket.bucketInstanceId should be 0');
            const e = n.getSortedSymbolIndexes(
              -this.transform.bearingInRadians
            );
            for (let t = e.length - 1; t >= 0; --t) {
              const i = e[t];
              L(n.symbolInstances.get(i), n.collisionArrays[i], i);
            }
          } else for (let e = t.symbolInstanceStart; e < t.symbolInstanceEnd; e++) L(n.symbolInstances.get(e), n.collisionArrays[e], e);
          n.justReloaded = !1;
        }
        storeCollisionData(t, e, i, r, n, a) {
          if (i.textBox || i.iconBox) {
            let a, s;
            this.collisionBoxArrays.has(t)
              ? (a = this.collisionBoxArrays.get(t))
              : ((a = new Map()), this.collisionBoxArrays.set(t, a)),
              a.has(e)
                ? (s = a.get(e))
                : ((s = { text: null, icon: null }), a.set(e, s)),
              i.textBox && (s.text = r.box),
              i.iconBox && (s.icon = n.box);
          }
          if (a) {
            let e = this.collisionCircleArrays[t];
            void 0 === e && (e = this.collisionCircleArrays[t] = []);
            for (let t = 0; t < a.circles.length; t += 4)
              e.push(a.circles[t + 0] - te),
                e.push(a.circles[t + 1] - te),
                e.push(a.circles[t + 2]),
                e.push(a.collisionDetected ? 1 : 0);
          }
        }
        markUsedJustification(t, i, r, n) {
          let a;
          a =
            n === e.as.vertical
              ? r.verticalPlacedTextSymbolIndex
              : {
                  left: r.leftJustifiedTextSymbolIndex,
                  center: r.centerJustifiedTextSymbolIndex,
                  right: r.rightJustifiedTextSymbolIndex,
                }[e.aK(i)];
          const s = [
            r.leftJustifiedTextSymbolIndex,
            r.centerJustifiedTextSymbolIndex,
            r.rightJustifiedTextSymbolIndex,
            r.verticalPlacedTextSymbolIndex,
          ];
          for (const e of s)
            e >= 0 &&
              (t.text.placedSymbolArray.get(e).crossTileID =
                a >= 0 && e !== a ? 0 : r.crossTileID);
        }
        markUsedOrientation(t, i, r) {
          const n = i === e.as.horizontal || i === e.as.horizontalOnly ? i : 0,
            a = i === e.as.vertical ? i : 0,
            s = [
              r.leftJustifiedTextSymbolIndex,
              r.centerJustifiedTextSymbolIndex,
              r.rightJustifiedTextSymbolIndex,
            ];
          for (const e of s)
            t.text.placedSymbolArray.get(e).placedOrientation = n;
          r.verticalPlacedTextSymbolIndex &&
            (t.text.placedSymbolArray.get(
              r.verticalPlacedTextSymbolIndex
            ).placedOrientation = a);
        }
        commit(t) {
          (this.commitTime = t),
            (this.zoomAtLastRecencyCheck = this.transform.zoom);
          const e = this.prevPlacement;
          let i = !1;
          this.prevZoomAdjustment = e
            ? e.zoomAdjustment(this.transform.zoom)
            : 0;
          const r = e ? e.symbolFadeChange(t) : 1,
            n = e ? e.opacities : {},
            a = e ? e.variableOffsets : {},
            s = e ? e.placedOrientations : {};
          for (const o in this.placements) {
            const t = this.placements[o],
              e = n[o];
            e
              ? ((this.opacities[o] = new re(e, r, t.text, t.icon)),
                (i = i || t.text !== e.text.placed || t.icon !== e.icon.placed))
              : ((this.opacities[o] = new re(
                  null,
                  r,
                  t.text,
                  t.icon,
                  t.skipFade
                )),
                (i = i || t.text || t.icon));
          }
          for (const o in n) {
            const t = n[o];
            if (!this.opacities[o]) {
              const e = new re(t, r, !1, !1);
              e.isHidden() ||
                ((this.opacities[o] = e),
                (i = i || t.text.placed || t.icon.placed));
            }
          }
          for (const o in a)
            this.variableOffsets[o] ||
              !this.opacities[o] ||
              this.opacities[o].isHidden() ||
              (this.variableOffsets[o] = a[o]);
          for (const o in s)
            this.placedOrientations[o] ||
              !this.opacities[o] ||
              this.opacities[o].isHidden() ||
              (this.placedOrientations[o] = s[o]);
          if (e && void 0 === e.lastPlacementChangeTime)
            throw new Error(
              'Last placement time for previous placement is not defined'
            );
          i
            ? (this.lastPlacementChangeTime = t)
            : 'number' != typeof this.lastPlacementChangeTime &&
              (this.lastPlacementChangeTime = e
                ? e.lastPlacementChangeTime
                : t);
        }
        updateLayerOpacities(t, e) {
          const i = {};
          for (const r of e) {
            const e = r.getBucket(t);
            e &&
              r.latestFeatureIndex &&
              t.id === e.layerIds[0] &&
              this.updateBucketOpacities(e, r.tileID, i, r.collisionBoxArray);
          }
        }
        updateBucketOpacities(t, i, r, n) {
          t.hasTextData() &&
            (t.text.opacityVertexArray.clear(),
            (t.text.hasVisibleVertices = !1)),
            t.hasIconData() &&
              (t.icon.opacityVertexArray.clear(),
              (t.icon.hasVisibleVertices = !1)),
            t.hasIconCollisionBoxData() &&
              t.iconCollisionBox.collisionVertexArray.clear(),
            t.hasTextCollisionBoxData() &&
              t.textCollisionBox.collisionVertexArray.clear();
          const a = t.layers[0],
            s = a.layout,
            o = new re(null, 0, !1, !1, !0),
            l = s.get('text-allow-overlap'),
            c = s.get('icon-allow-overlap'),
            h =
              a._unevaluatedLayout.hasValue('text-variable-anchor') ||
              a._unevaluatedLayout.hasValue('text-variable-anchor-offset'),
            u = 'map' === s.get('text-rotation-alignment'),
            d = 'map' === s.get('text-pitch-alignment'),
            p = 'none' !== s.get('icon-text-fit'),
            f = new re(
              null,
              0,
              l && (c || !t.hasIconData() || s.get('icon-optional')),
              c && (l || !t.hasTextData() || s.get('text-optional')),
              !0
            );
          !t.collisionArrays &&
            n &&
            (t.hasIconCollisionBoxData() || t.hasTextCollisionBoxData()) &&
            t.deserializeCollisionBoxes(n);
          const m = (t, e, i) => {
              for (let r = 0; r < e / 4; r++)
                t.opacityVertexArray.emplaceBack(i);
              t.hasVisibleVertices = t.hasVisibleVertices || i !== ye;
            },
            g = this.collisionBoxArrays.get(t.bucketInstanceId);
          for (let _ = 0; _ < t.symbolInstances.length; _++) {
            const i = t.symbolInstances.get(_),
              {
                numHorizontalGlyphVertices: n,
                numVerticalGlyphVertices: a,
                crossTileID: s,
              } = i;
            let l = this.opacities[s];
            r[s] ? (l = o) : l || ((l = f), (this.opacities[s] = l)),
              (r[s] = !0);
            const c = i.numIconVertices > 0,
              y = this.placedOrientations[i.crossTileID],
              v = y === e.as.vertical,
              x = y === e.as.horizontal || y === e.as.horizontalOnly;
            if (n > 0 || a > 0) {
              const e = _e(l.text);
              m(t.text, n, v ? ye : e), m(t.text, a, x ? ye : e);
              const r = l.text.isHidden();
              [
                i.rightJustifiedTextSymbolIndex,
                i.centerJustifiedTextSymbolIndex,
                i.leftJustifiedTextSymbolIndex,
              ].forEach((e) => {
                e >= 0 &&
                  (t.text.placedSymbolArray.get(e).hidden = r || v ? 1 : 0);
              }),
                i.verticalPlacedTextSymbolIndex >= 0 &&
                  (t.text.placedSymbolArray.get(
                    i.verticalPlacedTextSymbolIndex
                  ).hidden = r || x ? 1 : 0);
              const s = this.variableOffsets[i.crossTileID];
              s && this.markUsedJustification(t, s.anchor, i, y);
              const o = this.placedOrientations[i.crossTileID];
              o &&
                (this.markUsedJustification(t, 'left', i, o),
                this.markUsedOrientation(t, o, i));
            }
            if (c) {
              const e = _e(l.icon),
                r = !(p && i.verticalPlacedIconSymbolIndex && v);
              i.placedIconSymbolIndex >= 0 &&
                (m(t.icon, i.numIconVertices, r ? e : ye),
                (t.icon.placedSymbolArray.get(i.placedIconSymbolIndex).hidden =
                  l.icon.isHidden())),
                i.verticalPlacedIconSymbolIndex >= 0 &&
                  (m(t.icon, i.numVerticalIconVertices, r ? ye : e),
                  (t.icon.placedSymbolArray.get(
                    i.verticalPlacedIconSymbolIndex
                  ).hidden = l.icon.isHidden()));
            }
            const b = g && g.has(_) ? g.get(_) : { text: null, icon: null };
            if (t.hasIconCollisionBoxData() || t.hasTextCollisionBoxData()) {
              const i = t.collisionArrays[_];
              if (i) {
                let r = new e.P(0, 0);
                if (i.textBox || i.verticalTextBox) {
                  let e = !0;
                  if (h) {
                    const t = this.variableOffsets[s];
                    t
                      ? ((r = oe(
                          t.anchor,
                          t.width,
                          t.height,
                          t.textOffset,
                          t.textBoxScale
                        )),
                        u &&
                          r._rotate(
                            d
                              ? -this.transform.bearingInRadians
                              : this.transform.bearingInRadians
                          ))
                      : (e = !1);
                  }
                  if (i.textBox || i.verticalTextBox) {
                    let n;
                    i.textBox && (n = v),
                      i.verticalTextBox && (n = x),
                      ce(
                        t.textCollisionBox.collisionVertexArray,
                        l.text.placed,
                        !e || n,
                        b.text,
                        r.x,
                        r.y
                      );
                  }
                }
                if (i.iconBox || i.verticalIconBox) {
                  const e = Boolean(!x && i.verticalIconBox);
                  let n;
                  i.iconBox && (n = e),
                    i.verticalIconBox && (n = !e),
                    ce(
                      t.iconCollisionBox.collisionVertexArray,
                      l.icon.placed,
                      n,
                      b.icon,
                      p ? r.x : 0,
                      p ? r.y : 0
                    );
                }
              }
            }
          }
          if (
            (t.sortFeatures(-this.transform.bearingInRadians),
            this.retainedQueryData[t.bucketInstanceId] &&
              (this.retainedQueryData[t.bucketInstanceId].featureSortOrder =
                t.featureSortOrder),
            t.hasTextData() &&
              t.text.opacityVertexBuffer &&
              t.text.opacityVertexBuffer.updateData(t.text.opacityVertexArray),
            t.hasIconData() &&
              t.icon.opacityVertexBuffer &&
              t.icon.opacityVertexBuffer.updateData(t.icon.opacityVertexArray),
            t.hasIconCollisionBoxData() &&
              t.iconCollisionBox.collisionVertexBuffer &&
              t.iconCollisionBox.collisionVertexBuffer.updateData(
                t.iconCollisionBox.collisionVertexArray
              ),
            t.hasTextCollisionBoxData() &&
              t.textCollisionBox.collisionVertexBuffer &&
              t.textCollisionBox.collisionVertexBuffer.updateData(
                t.textCollisionBox.collisionVertexArray
              ),
            t.text.opacityVertexArray.length !==
              t.text.layoutVertexArray.length / 4)
          )
            throw new Error(
              `bucket.text.opacityVertexArray.length (= ${t.text.opacityVertexArray.length}) !== bucket.text.layoutVertexArray.length (= ${t.text.layoutVertexArray.length}) / 4`
            );
          if (
            t.icon.opacityVertexArray.length !==
            t.icon.layoutVertexArray.length / 4
          )
            throw new Error(
              `bucket.icon.opacityVertexArray.length (= ${t.icon.opacityVertexArray.length}) !== bucket.icon.layoutVertexArray.length (= ${t.icon.layoutVertexArray.length}) / 4`
            );
          t.bucketInstanceId in this.collisionCircleArrays &&
            ((t.collisionCircleArray =
              this.collisionCircleArrays[t.bucketInstanceId]),
            delete this.collisionCircleArrays[t.bucketInstanceId]);
        }
        symbolFadeChange(t) {
          return 0 === this.fadeDuration
            ? 1
            : (t - this.commitTime) / this.fadeDuration +
                this.prevZoomAdjustment;
        }
        zoomAdjustment(t) {
          return Math.max(0, (this.transform.zoom - t) / 1.5);
        }
        hasTransitions(t) {
          return (
            this.stale || t - this.lastPlacementChangeTime < this.fadeDuration
          );
        }
        stillRecent(t, e) {
          const i =
            this.zoomAtLastRecencyCheck === e ? 1 - this.zoomAdjustment(e) : 1;
          return (
            (this.zoomAtLastRecencyCheck = e),
            this.commitTime + this.fadeDuration * i > t
          );
        }
        setStale() {
          this.stale = !0;
        }
      }
      function ce(t, e, i, r, n, a) {
        (r && 0 !== r.length) || (r = [0, 0, 0, 0]);
        const s = r[0] - te,
          o = r[1] - te,
          l = r[2] - te,
          c = r[3] - te;
        t.emplaceBack(e ? 1 : 0, i ? 1 : 0, n || 0, a || 0, s, o),
          t.emplaceBack(e ? 1 : 0, i ? 1 : 0, n || 0, a || 0, l, o),
          t.emplaceBack(e ? 1 : 0, i ? 1 : 0, n || 0, a || 0, l, c),
          t.emplaceBack(e ? 1 : 0, i ? 1 : 0, n || 0, a || 0, s, c);
      }
      const he = Math.pow(2, 25),
        ue = Math.pow(2, 24),
        de = Math.pow(2, 17),
        pe = Math.pow(2, 16),
        fe = Math.pow(2, 9),
        me = Math.pow(2, 8),
        ge = Math.pow(2, 1);
      function _e(t) {
        if (0 === t.opacity && !t.placed) return 0;
        if (1 === t.opacity && t.placed) return 4294967295;
        const e = t.placed ? 1 : 0,
          i = Math.floor(127 * t.opacity);
        return i * he + e * ue + i * de + e * pe + i * fe + e * me + i * ge + e;
      }
      const ye = 0;
      class ve {
        constructor(t) {
          (this._sortAcrossTiles =
            'viewport-y' !== t.layout.get('symbol-z-order') &&
            !t.layout.get('symbol-sort-key').isConstant()),
            (this._currentTileIndex = 0),
            (this._currentPartIndex = 0),
            (this._seenCrossTileIDs = {}),
            (this._bucketParts = []);
        }
        continuePlacement(t, e, i, r, n) {
          const a = this._bucketParts;
          for (; this._currentTileIndex < t.length; )
            if (
              (e.getBucketParts(
                a,
                r,
                t[this._currentTileIndex],
                this._sortAcrossTiles
              ),
              this._currentTileIndex++,
              n())
            )
              return !0;
          for (
            this._sortAcrossTiles &&
            ((this._sortAcrossTiles = !1),
            a.sort((t, e) => t.sortKey - e.sortKey));
            this._currentPartIndex < a.length;

          )
            if (
              (e.placeLayerBucketPart(
                a[this._currentPartIndex],
                this._seenCrossTileIDs,
                i
              ),
              this._currentPartIndex++,
              n())
            )
              return !0;
          return !1;
        }
      }
      class xe {
        constructor(t, e, i, r, n, a, s, o) {
          (this.placement = new le(t, e, a, s, o)),
            (this._currentPlacementIndex = i.length - 1),
            (this._forceFullPlacement = r),
            (this._showCollisionBoxes = n),
            (this._done = !1);
        }
        isDone() {
          return this._done;
        }
        continuePlacement(t, e, i) {
          const r = l(),
            n = () => !this._forceFullPlacement && l() - r > 2;
          for (; this._currentPlacementIndex >= 0; ) {
            const r = e[t[this._currentPlacementIndex]],
              a = this.placement.collisionIndex.transform.zoom;
            if (
              'symbol' === r.type &&
              (!r.minzoom || r.minzoom <= a) &&
              (!r.maxzoom || r.maxzoom > a)
            ) {
              if (
                (this._inProgressLayer || (this._inProgressLayer = new ve(r)),
                this._inProgressLayer.continuePlacement(
                  i[r.source],
                  this.placement,
                  this._showCollisionBoxes,
                  r,
                  n
                ))
              )
                return;
              delete this._inProgressLayer;
            }
            this._currentPlacementIndex--;
          }
          this._done = !0;
        }
        commit(t) {
          return this.placement.commit(t), this.placement;
        }
      }
      const be = 512 / e.a3 / 2;
      class we {
        constructor(t, i, r) {
          (this.tileID = t),
            (this.bucketInstanceId = r),
            (this._symbolsByKey = {});
          const n = new Map();
          for (let e = 0; e < i.length; e++) {
            const t = i.get(e),
              r = t.key,
              a = n.get(r);
            a ? a.push(t) : n.set(r, [t]);
          }
          for (const [a, s] of n) {
            const t = {
              positions: s.map((t) => ({
                x: Math.floor(t.anchorX * be),
                y: Math.floor(t.anchorY * be),
              })),
              crossTileIDs: s.map((t) => t.crossTileID),
            };
            if (t.positions.length > 128) {
              const i = new e.aM(t.positions.length, 16, Uint16Array);
              for (const { x: e, y: r } of t.positions) i.add(e, r);
              i.finish(), delete t.positions, (t.index = i);
            }
            this._symbolsByKey[a] = t;
          }
        }
        getScaledCoordinates(t, i) {
          const { x: r, y: n, z: a } = this.tileID.canonical,
            { x: s, y: o, z: l } = i.canonical,
            c = be / Math.pow(2, l - a),
            h = (o * e.a3 + t.anchorY) * c,
            u = n * e.a3 * be;
          return {
            x: Math.floor((s * e.a3 + t.anchorX) * c - r * e.a3 * be),
            y: Math.floor(h - u),
          };
        }
        findMatches(t, e, i) {
          const r =
            this.tileID.canonical.z < e.canonical.z
              ? 1
              : Math.pow(2, this.tileID.canonical.z - e.canonical.z);
          for (let n = 0; n < t.length; n++) {
            const a = t.get(n);
            if (a.crossTileID) continue;
            const s = this._symbolsByKey[a.key];
            if (!s) continue;
            const o = this.getScaledCoordinates(a, e);
            if (s.index) {
              const t = s.index
                .range(o.x - r, o.y - r, o.x + r, o.y + r)
                .sort();
              for (const e of t) {
                const t = s.crossTileIDs[e];
                if (!i[t]) {
                  (i[t] = !0), (a.crossTileID = t);
                  break;
                }
              }
            } else if (s.positions)
              for (let t = 0; t < s.positions.length; t++) {
                const e = s.positions[t],
                  n = s.crossTileIDs[t];
                if (
                  Math.abs(e.x - o.x) <= r &&
                  Math.abs(e.y - o.y) <= r &&
                  !i[n]
                ) {
                  (i[n] = !0), (a.crossTileID = n);
                  break;
                }
              }
          }
        }
        getCrossTileIDsLists() {
          return Object.values(this._symbolsByKey).map(
            ({ crossTileIDs: t }) => t
          );
        }
      }
      class Te {
        constructor() {
          this.maxCrossTileID = 0;
        }
        generate() {
          return ++this.maxCrossTileID;
        }
      }
      class Pe {
        constructor() {
          (this.indexes = {}), (this.usedCrossTileIDs = {}), (this.lng = 0);
        }
        handleWrapJump(t) {
          const e = Math.round((t - this.lng) / 360);
          if (0 !== e)
            for (const i in this.indexes) {
              const t = this.indexes[i],
                r = {};
              for (const i in t) {
                const n = t[i];
                (n.tileID = n.tileID.unwrapTo(n.tileID.wrap + e)),
                  (r[n.tileID.key] = n);
              }
              this.indexes[i] = r;
            }
          this.lng = t;
        }
        addBucket(t, e, i) {
          if (
            this.indexes[t.overscaledZ] &&
            this.indexes[t.overscaledZ][t.key]
          ) {
            if (
              this.indexes[t.overscaledZ][t.key].bucketInstanceId ===
              e.bucketInstanceId
            )
              return !1;
            this.removeBucketCrossTileIDs(
              t.overscaledZ,
              this.indexes[t.overscaledZ][t.key]
            );
          }
          for (let n = 0; n < e.symbolInstances.length; n++)
            e.symbolInstances.get(n).crossTileID = 0;
          this.usedCrossTileIDs[t.overscaledZ] ||
            (this.usedCrossTileIDs[t.overscaledZ] = {});
          const r = this.usedCrossTileIDs[t.overscaledZ];
          for (const n in this.indexes) {
            const i = this.indexes[n];
            if (Number(n) > t.overscaledZ)
              for (const n in i) {
                const a = i[n];
                a.tileID.isChildOf(t) && a.findMatches(e.symbolInstances, t, r);
              }
            else {
              const a = i[t.scaledTo(Number(n)).key];
              a && a.findMatches(e.symbolInstances, t, r);
            }
          }
          for (let n = 0; n < e.symbolInstances.length; n++) {
            const t = e.symbolInstances.get(n);
            t.crossTileID ||
              ((t.crossTileID = i.generate()), (r[t.crossTileID] = !0));
          }
          return (
            void 0 === this.indexes[t.overscaledZ] &&
              (this.indexes[t.overscaledZ] = {}),
            (this.indexes[t.overscaledZ][t.key] = new we(
              t,
              e.symbolInstances,
              e.bucketInstanceId
            )),
            !0
          );
        }
        removeBucketCrossTileIDs(t, e) {
          for (const i of e.getCrossTileIDsLists())
            for (const e of i) delete this.usedCrossTileIDs[t][e];
        }
        removeStaleBuckets(t) {
          let e = !1;
          for (const i in this.indexes) {
            const r = this.indexes[i];
            for (const n in r)
              t[r[n].bucketInstanceId] ||
                (this.removeBucketCrossTileIDs(i, r[n]), delete r[n], (e = !0));
          }
          return e;
        }
      }
      class Ce {
        constructor() {
          (this.layerIndexes = {}),
            (this.crossTileIDs = new Te()),
            (this.maxBucketInstanceId = 0),
            (this.bucketsInCurrentPlacement = {});
        }
        addLayer(t, e, i) {
          let r = this.layerIndexes[t.id];
          void 0 === r && (r = this.layerIndexes[t.id] = new Pe());
          let n = !1;
          const a = {};
          r.handleWrapJump(i);
          for (const s of e) {
            const e = s.getBucket(t);
            e &&
              t.id === e.layerIds[0] &&
              (e.bucketInstanceId ||
                (e.bucketInstanceId = ++this.maxBucketInstanceId),
              r.addBucket(s.tileID, e, this.crossTileIDs) && (n = !0),
              (a[e.bucketInstanceId] = !0));
          }
          return r.removeStaleBuckets(a) && (n = !0), n;
        }
        pruneUnusedLayers(t) {
          const e = {};
          t.forEach((t) => {
            e[t] = !0;
          });
          for (const i in this.layerIndexes)
            e[i] || delete this.layerIndexes[i];
        }
      }
      var Ie = 'void main() {fragColor=vec4(1.0);}';
      const Se = {
        prelude: Me(
          '#ifdef GL_ES\nprecision mediump float;\n#else\n#if !defined(lowp)\n#define lowp\n#endif\n#if !defined(mediump)\n#define mediump\n#endif\n#if !defined(highp)\n#define highp\n#endif\n#endif\nout highp vec4 fragColor;',
          '#ifdef GL_ES\nprecision highp float;\n#else\n#if !defined(lowp)\n#define lowp\n#endif\n#if !defined(mediump)\n#define mediump\n#endif\n#if !defined(highp)\n#define highp\n#endif\n#endif\nvec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\n);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}mat3 rotationMatrixFromAxisAngle(vec3 u,float angle) {float c=cos(angle);float s=sin(angle);float c2=1.0-c;return mat3(u.x*u.x*c2+      c,u.x*u.y*c2-u.z*s,u.x*u.z*c2+u.y*s,u.y*u.x*c2+u.z*s,u.y*u.y*c2+    c,u.y*u.z*c2-u.x*s,u.z*u.x*c2-u.y*s,u.z*u.y*c2+u.x*s,u.z*u.z*c2+    c\n);}\n#ifdef TERRAIN3D\nuniform sampler2D u_terrain;uniform float u_terrain_dim;uniform mat4 u_terrain_matrix;uniform vec4 u_terrain_unpack;uniform float u_terrain_exaggeration;uniform highp sampler2D u_depth;\n#endif\nconst highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitShifts=vec4(1.)/bitSh;highp float unpack(highp vec4 color) {return dot(color,bitShifts);}highp float depthOpacity(vec3 frag) {\n#ifdef TERRAIN3D\nhighp float d=unpack(texture(u_depth,frag.xy*0.5+0.5))+0.0001-frag.z;return 1.0-max(0.0,min(1.0,-d*500.0));\n#else\nreturn 1.0;\n#endif\n}float calculate_visibility(vec4 pos) {\n#ifdef TERRAIN3D\nvec3 frag=pos.xyz/pos.w;highp float d=depthOpacity(frag);if (d > 0.95) return 1.0;return (d+depthOpacity(frag+vec3(0.0,0.01,0.0)))/2.0;\n#else\nreturn 1.0;\n#endif\n}float ele(vec2 pos) {\n#ifdef TERRAIN3D\nvec4 rgb=(texture(u_terrain,pos)*255.0)*u_terrain_unpack;return rgb.r+rgb.g+rgb.b-u_terrain_unpack.a;\n#else\nreturn 0.0;\n#endif\n}float get_elevation(vec2 pos) {\n#ifdef TERRAIN3D\n#ifdef GLOBE\nif ((pos.y <-32767.5) || (pos.y > 32766.5)) {return 0.0;}\n#endif\nvec2 coord=(u_terrain_matrix*vec4(pos,0.0,1.0)).xy*u_terrain_dim+1.0;vec2 f=fract(coord);vec2 c=(floor(coord)+0.5)/(u_terrain_dim+2.0);float d=1.0/(u_terrain_dim+2.0);float tl=ele(c);float tr=ele(c+vec2(d,0.0));float bl=ele(c+vec2(0.0,d));float br=ele(c+vec2(d,d));float elevation=mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);return elevation*u_terrain_exaggeration;\n#else\nreturn 0.0;\n#endif\n}const float PI=3.141592653589793;uniform mat4 u_projection_matrix;'
        ),
        projectionMercator: Me(
          '',
          'float projectLineThickness(float tileY) {return 1.0;}float projectCircleRadius(float tileY) {return 1.0;}vec4 projectTile(vec2 p) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);return result;}vec4 projectTile(vec2 p,vec2 rawPos) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);if (rawPos.y <-32767.5 || rawPos.y > 32766.5) {result.z=-10000000.0;}return result;}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_projection_matrix*vec4(posInTile,elevation,1.0);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {return projectTileWithElevation(posInTile,elevation);}'
        ),
        projectionGlobe: Me(
          '',
          '#define GLOBE_RADIUS 6371008.8\nuniform highp vec4 u_projection_tile_mercator_coords;uniform highp vec4 u_projection_clipping_plane;uniform highp float u_projection_transition;uniform mat4 u_projection_fallback_matrix;vec3 globeRotateVector(vec3 vec,vec2 angles) {vec3 axisRight=vec3(vec.z,0.0,-vec.x);vec3 axisUp=cross(axisRight,vec);axisRight=normalize(axisRight);axisUp=normalize(axisUp);vec2 t=tan(angles);return normalize(vec+axisRight*t.x+axisUp*t.y);}mat3 globeGetRotationMatrix(vec3 spherePos) {vec3 axisRight=vec3(spherePos.z,0.0,-spherePos.x);vec3 axisDown=cross(axisRight,spherePos);axisRight=normalize(axisRight);axisDown=normalize(axisDown);return mat3(axisRight,axisDown,spherePos\n);}float circumferenceRatioAtTileY(float tileY) {float mercator_pos_y=u_projection_tile_mercator_coords.y+u_projection_tile_mercator_coords.w*tileY;float spherical_y=2.0*atan(exp(PI-(mercator_pos_y*PI*2.0)))-PI*0.5;return cos(spherical_y);}float projectLineThickness(float tileY) {float thickness=1.0/circumferenceRatioAtTileY(tileY); \nif (u_projection_transition < 0.999) {return mix(1.0,thickness,u_projection_transition);} else {return thickness;}}vec3 projectToSphere(vec2 translatedPos,vec2 rawPos) {vec2 mercator_pos=u_projection_tile_mercator_coords.xy+u_projection_tile_mercator_coords.zw*translatedPos;vec2 spherical;spherical.x=mercator_pos.x*PI*2.0+PI;spherical.y=2.0*atan(exp(PI-(mercator_pos.y*PI*2.0)))-PI*0.5;float len=cos(spherical.y);vec3 pos=vec3(sin(spherical.x)*len,sin(spherical.y),cos(spherical.x)*len\n);if (rawPos.y <-32767.5) {pos=vec3(0.0,1.0,0.0);}if (rawPos.y > 32766.5) {pos=vec3(0.0,-1.0,0.0);}return pos;}vec3 projectToSphere(vec2 posInTile) {return projectToSphere(posInTile,vec2(0.0,0.0));}float globeComputeClippingZ(vec3 spherePos) {return (1.0-(dot(spherePos,u_projection_clipping_plane.xyz)+u_projection_clipping_plane.w));}vec4 interpolateProjection(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);globePosition.z=globeComputeClippingZ(elevatedPos)*globePosition.w;if (u_projection_transition > 0.999) {return globePosition;}vec4 flatPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);const float z_globeness_threshold=0.2;vec4 result=globePosition;result.z=mix(0.0,globePosition.z,clamp((u_projection_transition-z_globeness_threshold)/(1.0-z_globeness_threshold),0.0,1.0));result.xyw=mix(flatPosition.xyw,globePosition.xyw,u_projection_transition);if ((posInTile.y <-32767.5) || (posInTile.y > 32766.5)) {result=globePosition;const float poles_hidden_anim_percentage=0.02;result.z=mix(globePosition.z,100.0,pow(max((1.0-u_projection_transition)/poles_hidden_anim_percentage,0.0),8.0));}return result;}vec4 interpolateProjectionFor3D(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);if (u_projection_transition > 0.999) {return globePosition;}vec4 fallbackPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);return mix(fallbackPosition,globePosition,u_projection_transition);}vec4 projectTile(vec2 posInTile) {return interpolateProjection(posInTile,projectToSphere(posInTile),0.0);}vec4 projectTile(vec2 posInTile,vec2 rawPos) {return interpolateProjection(posInTile,projectToSphere(posInTile,rawPos),0.0);}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return interpolateProjection(posInTile,projectToSphere(posInTile),elevation);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {vec3 spherePos=projectToSphere(posInTile,posInTile);return interpolateProjectionFor3D(posInTile,spherePos,elevation);}'
        ),
        background: Me(
          'uniform vec4 u_color;uniform float u_opacity;void main() {fragColor=u_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}',
          'in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}'
        ),
        backgroundPattern: Me(
          'uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_mix)*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}',
          'uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;void main() {gl_Position=projectTile(a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}'
        ),
        circle: Me(
          'in vec3 v_data;in float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=v_data.xy;float extrude_length=length(extrude);float antialiased_blur=v_data.z;float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));fragColor=v_visibility*opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);const float epsilon=0.5/255.0;if (fragColor.r < epsilon && fragColor.g < epsilon && fragColor.b < epsilon && fragColor.a < epsilon) {discard;}\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}',
          'uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform highp float u_globe_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;uniform vec2 u_translate;in vec2 a_pos;out vec3 v_data;out float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main(void) {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 pos_raw=a_pos+32768.0;vec2 extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);vec2 circle_center=floor(pos_raw/8.0)+u_translate;float ele=get_elevation(circle_center);v_visibility=calculate_visibility(projectTileWithElevation(circle_center,ele));if (u_pitch_with_map) {\n#ifdef GLOBE\nvec3 center_vector=projectToSphere(circle_center);\n#endif\nfloat angle_scale=u_globe_extrude_scale;vec2 corner_position=circle_center;if (u_scale_with_map) {angle_scale*=(radius+stroke_width);corner_position+=extrude*u_extrude_scale*(radius+stroke_width);} else {\n#ifdef GLOBE\nvec4 projected_center=interpolateProjection(circle_center,center_vector,ele);\n#else\nvec4 projected_center=projectTileWithElevation(circle_center,ele);\n#endif\ncorner_position+=extrude*u_extrude_scale*(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);angle_scale*=(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);}\n#ifdef GLOBE\nvec2 angles=extrude*angle_scale;vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(corner_position,corner_vector,ele);\n#else\ngl_Position=projectTileWithElevation(corner_position,ele);\n#endif\n} else {gl_Position=projectTileWithElevation(circle_center,ele);if (gl_Position.z/gl_Position.w > 1.0) {gl_Position.xy=vec2(10000.0);}if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}float antialiasblur=-max(1.0/u_device_pixel_ratio/(radius+stroke_width),blur);v_data=vec3(extrude.x,extrude.y,antialiasblur);}'
        ),
        clippingMask: Me(
          Ie,
          'in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}'
        ),
        heatmap: Me(
          'uniform highp float u_intensity;in vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#define GAUSS_COEF 0.3989422804014327\nvoid main() {\n#pragma mapbox: initialize highp float weight\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);fragColor=vec4(val,1.0,1.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}',
          'uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;uniform highp float u_globe_extrude_scale;in vec2 a_pos;out vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#pragma mapbox: define mediump float radius\nconst highp float ZERO=1.0/255.0/16.0;\n#define GAUSS_COEF 0.3989422804014327\nvoid main(void) {\n#pragma mapbox: initialize highp float weight\n#pragma mapbox: initialize mediump float radius\nvec2 pos_raw=a_pos+32768.0;vec2 unscaled_extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 circle_center=floor(pos_raw/8.0);\n#ifdef GLOBE\nvec2 angles=v_extrude*radius*u_globe_extrude_scale;vec3 center_vector=projectToSphere(circle_center);vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(circle_center+extrude,corner_vector,0.0);\n#else\ngl_Position=projectTileFor3D(circle_center+extrude,get_elevation(circle_center));\n#endif\n}'
        ),
        heatmapTexture: Me(
          'uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;in vec2 v_pos;void main() {float t=texture(u_image,v_pos).r;vec4 color=texture(u_color_ramp,vec2(t,0.5));fragColor=color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(0.0);\n#endif\n}',
          'uniform mat4 u_matrix;uniform vec2 u_world;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}'
        ),
        collisionBox: Me(
          'in float v_placed;in float v_notUsed;void main() {float alpha=0.5;fragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {fragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {fragColor*=.1;}}',
          'in vec2 a_anchor_pos;in vec2 a_placed;in vec2 a_box_real;uniform vec2 u_pixel_extrude_scale;out float v_placed;out float v_notUsed;void main() {gl_Position=projectTileWithElevation(a_anchor_pos,get_elevation(a_anchor_pos));gl_Position.xy=((a_box_real+0.5)*u_pixel_extrude_scale*2.0-1.0)*vec2(1.0,-1.0)*gl_Position.w;if (gl_Position.z/gl_Position.w < 1.1) {gl_Position.z=0.5;}v_placed=a_placed.x;v_notUsed=a_placed.y;}'
        ),
        collisionCircle: Me(
          'in float v_radius;in vec2 v_extrude;in float v_collision;void main() {float alpha=0.5;float stroke_radius=0.9;float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);fragColor=color*alpha*opacity_t;}',
          'in vec2 a_pos;in float a_radius;in vec2 a_flags;uniform vec2 u_viewport_size;out float v_radius;out vec2 v_extrude;out float v_collision;void main() {float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_collision=collision;gl_Position=vec4((a_pos/u_viewport_size*2.0-1.0)*vec2(1.0,-1.0),0.0,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}'
        ),
        colorRelief: Me(
          '#ifdef GL_ES\nprecision highp float;\n#endif\nuniform sampler2D u_image;uniform vec4 u_unpack;uniform sampler2D u_elevation_stops;uniform sampler2D u_color_stops;uniform int u_color_ramp_size;uniform float u_opacity;in vec2 v_pos;float getElevation(vec2 coord) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack);}float getElevationStop(int stop) {float x=(float(stop)+0.5)/float(u_color_ramp_size);vec4 data=texture(u_elevation_stops,vec2(x,0))*255.0;data.a=-1.0;return dot(data,u_unpack);}void main() {float el=getElevation(v_pos);int r=(u_color_ramp_size-1);int l=0;float el_l=getElevationStop(l);float el_r=getElevationStop(r);while(r-l > 1){int m=(r+l)/2;float el_m=getElevationStop(m);if(el < el_m){r=m;el_r=el_m;}else\n{l=m;el_l=el_m;}}float x=(float(l)+(el-el_l)/(el_r-el_l)+0.5)/float(u_color_ramp_size);fragColor=u_opacity*texture(u_color_stops,vec2(x,0));\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}',
          'uniform vec2 u_dimension;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_pos/8192.0)*scale+epsilon;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}'
        ),
        debug: Me(
          'uniform highp vec4 u_color;uniform sampler2D u_overlay;in vec2 v_uv;void main() {vec4 overlay_color=texture(u_overlay,v_uv);fragColor=mix(u_color,overlay_color,overlay_color.a);}',
          'in vec2 a_pos;out vec2 v_uv;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=projectTileWithElevation(a_pos*u_overlay_scale,get_elevation(a_pos));}'
        ),
        depth: Me(
          Ie,
          'in vec2 a_pos;void main() {\n#ifdef GLOBE\ngl_Position=projectTileFor3D(a_pos,0.0);\n#else\ngl_Position=u_projection_matrix*vec4(a_pos,0.0,1.0);\n#endif\n}'
        ),
        fill: Me(
          '#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\nfragColor=color*opacity;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}',
          'uniform vec2 u_fill_translate;in vec2 a_pos;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=projectTile(a_pos+u_fill_translate,a_pos);}'
        ),
        fillOutline: Me(
          'in vec2 v_pos;\n#ifdef GLOBE\nin float v_depth;\n#endif\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=outline_color*(alpha*opacity);\n#ifdef GLOBE\nif (v_depth > 1.0) {discard;}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}',
          'uniform vec2 u_world;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos;\n#ifdef GLOBE\nout float v_depth;\n#endif\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef GLOBE\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n}'
        ),
        fillOutlinePattern: Me(
          'uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;in vec2 v_pos_a;in vec2 v_pos_b;in vec2 v_pos;\n#ifdef GLOBE\nin float v_depth;\n#endif\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=mix(color1,color2,u_fade)*alpha*opacity;\n#ifdef GLOBE\nif (v_depth > 1.0) {discard;}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}',
          'uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;out vec2 v_pos;\n#ifdef GLOBE\nout float v_depth;\n#endif\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef GLOBE\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n}'
        ),
        fillPattern: Me(
          '#ifdef GL_ES\nprecision highp float;\n#endif\nuniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_fade)*opacity;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}',
          'uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}'
        ),
        fillExtrusion: Me(
          'in vec4 v_color;void main() {fragColor=v_color;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}',
          'uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;in vec2 a_pos;in vec4 a_normal_ed;\n#ifdef TERRAIN3D\nin vec2 a_centroid;\n#endif\nout vec4 v_color;\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp vec4 color\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp vec4 color\nvec3 normal=a_normal_ed.xyz;\n#ifdef TERRAIN3D\nfloat height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);\n#else\nfloat height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;\n#endif\nbase=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;\n#ifdef GLOBE\nvec3 spherePos=projectToSphere(posInTile,a_pos);gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);\n#else\ngl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);\n#endif\nfloat colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;vec3 normalForLighting=normal/16384.0;float directional=clamp(dot(normalForLighting,u_lightpos),0.0,1.0);\n#ifdef GLOBE\nmat3 rotMatrix=globeGetRotationMatrix(spherePos);normalForLighting=rotMatrix*normalForLighting;directional=mix(directional,clamp(dot(normalForLighting,u_lightpos_globe),0.0,1.0),u_projection_transition);\n#endif\ndirectional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}'
        ),
        fillExtrusionPattern: Me(
          'uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;in vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);fragColor=mixedColor*v_lighting;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}',
          'uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;in vec2 a_pos;in vec4 a_normal_ed;\n#ifdef TERRAIN3D\nin vec2 a_centroid;\n#endif\n#ifdef GLOBE\nout vec3 v_sphere_pos;\n#endif\nout vec2 v_pos_a;out vec2 v_pos_b;out vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;\n#ifdef TERRAIN3D\nfloat height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);\n#else\nfloat height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;\n#endif\nbase=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;\n#ifdef GLOBE\nvec3 spherePos=projectToSphere(posInTile,a_pos);vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);v_sphere_pos=elevatedPos;gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);\n#else\ngl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);\n#endif\nvec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0\n? a_pos\n: vec2(edgedistance,elevation*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}'
        ),
        hillshadePrepare: Me(
          '#ifdef GL_ES\nprecision highp float;\n#endif\nuniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack);}void main() {vec2 epsilon=1.0/u_dimension;float tileSize=u_dimension.x-2.0;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))*tileSize/pow(2.0,exaggeration+(28.2562-u_zoom));fragColor=clamp(vec4(deriv.x/8.0+0.5,deriv.y/8.0+0.5,1.0,1.0),0.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}',
          'uniform mat4 u_matrix;uniform vec2 u_dimension;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}'
        ),
        hillshade: Me(
          'uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_latrange;uniform float u_exaggeration;uniform vec4 u_accent;uniform int u_method;uniform float u_altitudes[NUM_ILLUMINATION_SOURCES];uniform float u_azimuths[NUM_ILLUMINATION_SOURCES];uniform vec4 u_shadows[NUM_ILLUMINATION_SOURCES];uniform vec4 u_highlights[NUM_ILLUMINATION_SOURCES];\n#define PI 3.141592653589793\n#define STANDARD 0\n#define COMBINED 1\n#define IGOR 2\n#define MULTIDIRECTIONAL 3\n#define BASIC 4\nfloat get_aspect(vec2 deriv){return deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);}void igor_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float aspect=get_aspect(deriv);float azimuth=u_azimuths[0]+PI;float slope_stength=atan(length(deriv))*2.0/PI;float aspect_strength=1.0-abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);float shadow_strength=slope_stength*aspect_strength;float highlight_strength=slope_stength*(1.0-aspect_strength);fragColor=u_shadows[0]*shadow_strength+u_highlights[0]*highlight_strength;}void standard_hillshade(vec2 deriv){float azimuth=u_azimuths[0]+PI;float slope=atan(0.625*length(deriv));float aspect=get_aspect(deriv);float intensity=u_exaggeration;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadows[0],u_highlights[0],shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);fragColor=accent_color*(1.0-shade_color.a)+shade_color;}void basic_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor=u_highlights[0]*(2.0*shade-1.0);}else\n{fragColor=u_shadows[0]*(1.0-2.0*shade);}}void multidirectional_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;fragColor=vec4(0,0,0,0);for(int i=0; i < NUM_ILLUMINATION_SOURCES; i++){float cos_alt=cos(u_altitudes[i]);float sin_alt=sin(u_altitudes[i]);float cos_az=-cos(u_azimuths[i]);float sin_az=-sin(u_azimuths[i]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor+=u_highlights[i]*(2.0*shade-1.0)/float(NUM_ILLUMINATION_SOURCES);}else\n{fragColor+=u_shadows[i]*(1.0-2.0*shade)/float(NUM_ILLUMINATION_SOURCES);}}}void combined_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=acos((sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv)));cang=clamp(cang,0.0,PI/2.0);float shade=cang*atan(length(deriv))*4.0/PI/PI;float highlight=(PI/2.0-cang)*atan(length(deriv))*4.0/PI/PI;fragColor=u_shadows[0]*shade+u_highlights[0]*highlight;}void main() {vec4 pixel=texture(u_image,v_pos);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));vec2 deriv=((pixel.rg*8.0)-4.0)/scaleFactor;if (u_method==BASIC) {basic_hillshade(deriv);} else if (u_method==COMBINED) {combined_hillshade(deriv);} else if (u_method==IGOR) {igor_hillshade(deriv);} else if (u_method==MULTIDIRECTIONAL) {multidirectional_hillshade(deriv);} else if (u_method==STANDARD) {standard_hillshade(deriv);} else {standard_hillshade(deriv);}\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}',
          'uniform mat4 u_matrix;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);v_pos=a_pos/8192.0;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}'
        ),
        line: Me(
          'uniform lowp float u_device_pixel_ratio;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;\n#ifdef GLOBE\nin float v_depth;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);fragColor=color*(alpha*opacity);\n#ifdef GLOBE\nif (v_depth > 1.0) {discard;}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}',
          '\n#define scale 0.015873016\nin vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp float v_linesofar;\n#ifdef GLOBE\nout float v_depth;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;\n#ifdef GLOBE\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_width2=vec2(outset,inset);}'
        ),
        lineGradient: Me(
          'uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;in highp vec2 v_uv;\n#ifdef GLOBE\nin float v_depth;\n#endif\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture(u_image,v_uv);fragColor=color*(alpha*opacity);\n#ifdef GLOBE\nif (v_depth > 1.0) {discard;}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}',
          '\n#define scale 0.015873016\nin vec2 a_pos_normal;in vec4 a_data;in float a_uv_x;in float a_split_index;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec2 v_uv;\n#ifdef GLOBE\nout float v_depth;\n#endif\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;\n#ifdef GLOBE\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_width2=vec2(outset,inset);}'
        ),
        linePattern: Me(
          '#ifdef GL_ES\nprecision highp float;\n#endif\nuniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;in vec2 v_normal;in vec2 v_width2;in float v_linesofar;in float v_gamma_scale;in float v_width;\n#ifdef GLOBE\nin float v_depth;\n#endif\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture(u_image,pos_a),texture(u_image,pos_b),u_fade);fragColor=color*alpha*opacity;\n#ifdef GLOBE\nif (v_depth > 1.0) {discard;}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}',
          '\n#define scale 0.015873016\n#define LINE_DISTANCE_SCALE 2.0\nin vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_linesofar;out float v_gamma_scale;out float v_width;\n#ifdef GLOBE\nout float v_depth;\n#endif\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;\n#ifdef GLOBE\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}'
        ),
        lineSDF: Me(
          'uniform lowp float u_device_pixel_ratio;uniform lowp float u_lineatlas_width;uniform sampler2D u_image;uniform float u_mix;in vec2 v_normal;in vec2 v_width2;in vec2 v_tex_a;in vec2 v_tex_b;in float v_gamma_scale;\n#ifdef GLOBE\nin float v_depth;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define mediump vec4 dasharray_from\n#pragma mapbox: define mediump vec4 dasharray_to\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 dasharray_from\n#pragma mapbox: initialize mediump vec4 dasharray_to\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture(u_image,v_tex_a).a;float sdfdist_b=texture(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);float sdfgamma=(u_lineatlas_width/256.0/u_device_pixel_ratio)/min(dasharray_from.w,dasharray_to.w);alpha*=smoothstep(0.5-sdfgamma/floorwidth,0.5+sdfgamma/floorwidth,sdfdist);fragColor=color*(alpha*opacity);\n#ifdef GLOBE\nif (v_depth > 1.0) {discard;}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}',
          '\n#define scale 0.015873016\n#define LINE_DISTANCE_SCALE 2.0\nin vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_tileratio;uniform float u_crossfade_from;uniform float u_crossfade_to;uniform float u_lineatlas_height;out vec2 v_normal;out vec2 v_width2;out vec2 v_tex_a;out vec2 v_tex_b;out float v_gamma_scale;\n#ifdef GLOBE\nout float v_depth;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define mediump vec4 dasharray_from\n#pragma mapbox: define mediump vec4 dasharray_to\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 dasharray_from\n#pragma mapbox: initialize mediump vec4 dasharray_to\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;\n#ifdef GLOBE\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nfloat u_patternscale_a_x=u_tileratio/dasharray_from.w/u_crossfade_from;float u_patternscale_a_y=-dasharray_from.z/2.0/u_lineatlas_height;float u_patternscale_b_x=u_tileratio/dasharray_to.w/u_crossfade_to;float u_patternscale_b_y=-dasharray_to.z/2.0/u_lineatlas_height;v_tex_a=vec2(a_linesofar*u_patternscale_a_x/floorwidth,normal.y*u_patternscale_a_y+(float(dasharray_from.y)+0.5)/u_lineatlas_height);v_tex_b=vec2(a_linesofar*u_patternscale_b_x/floorwidth,normal.y*u_patternscale_b_y+(float(dasharray_to.y)+0.5)/u_lineatlas_height);v_width2=vec2(outset,inset);}'
        ),
        lineGradientSDF: Me(
          'uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform sampler2D u_image_dash;uniform float u_mix;uniform lowp float u_lineatlas_width;in vec2 v_normal;in vec2 v_width2;in vec2 v_tex_a;in vec2 v_tex_b;in float v_gamma_scale;in highp vec2 v_uv;\n#ifdef GLOBE\nin float v_depth;\n#endif\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define mediump vec4 dasharray_from\n#pragma mapbox: define mediump vec4 dasharray_to\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 dasharray_from\n#pragma mapbox: initialize mediump vec4 dasharray_to\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture(u_image,v_uv);float sdfdist_a=texture(u_image_dash,v_tex_a).a;float sdfdist_b=texture(u_image_dash,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);float sdfgamma=(u_lineatlas_width/256.0)/min(dasharray_from.w,dasharray_to.w);float dash_alpha=smoothstep(0.5-sdfgamma/floorwidth,0.5+sdfgamma/floorwidth,sdfdist);fragColor=color*(alpha*dash_alpha*opacity);\n#ifdef GLOBE\nif (v_depth > 1.0) {discard;}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}',
          '\n#define scale 0.015873016\n#define LINE_DISTANCE_SCALE 2.0\nin vec2 a_pos_normal;in vec4 a_data;in float a_uv_x;in float a_split_index;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;uniform float u_tileratio;uniform float u_crossfade_from;uniform float u_crossfade_to;uniform float u_lineatlas_height;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec2 v_uv;out vec2 v_tex_a;out vec2 v_tex_b;\n#ifdef GLOBE\nout float v_depth;\n#endif\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define mediump vec4 dasharray_from\n#pragma mapbox: define mediump vec4 dasharray_to\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 dasharray_from\n#pragma mapbox: initialize mediump vec4 dasharray_to\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;float texel_height=1.0/u_image_height;float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;\n#ifdef GLOBE\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nfloat u_patternscale_a_x=u_tileratio/dasharray_from.w/u_crossfade_from;float u_patternscale_a_y=-dasharray_from.z/2.0/u_lineatlas_height;float u_patternscale_b_x=u_tileratio/dasharray_to.w/u_crossfade_to;float u_patternscale_b_y=-dasharray_to.z/2.0/u_lineatlas_height;v_tex_a=vec2(a_linesofar*u_patternscale_a_x/floorwidth,normal.y*u_patternscale_a_y+(float(dasharray_from.y)+0.5)/u_lineatlas_height);v_tex_b=vec2(a_linesofar*u_patternscale_b_x/floorwidth,normal.y*u_patternscale_b_y+(float(dasharray_to.y)+0.5)/u_lineatlas_height);v_width2=vec2(outset,inset);}'
        ),
        raster: Me(
          'uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;in vec2 v_pos0;in vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture(u_image0,v_pos0);vec4 color1=texture(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);fragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}',
          'uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;uniform vec4 u_coords_top;uniform vec4 u_coords_bottom;in vec2 a_pos;out vec2 v_pos0;out vec2 v_pos1;void main() {vec2 fractionalPos=a_pos/8192.0;vec2 position=mix(mix(u_coords_top.xy,u_coords_top.zw,fractionalPos.x),mix(u_coords_bottom.xy,u_coords_bottom.zw,fractionalPos.x),fractionalPos.y);gl_Position=projectTile(position,position);v_pos0=((fractionalPos-0.5)/u_buffer_scale)+0.5;\n#ifdef GLOBE\nif (a_pos.y <-32767.5) {v_pos0.y=0.0;}if (a_pos.y > 32766.5) {v_pos0.y=1.0;}\n#endif\nv_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}'
        ),
        symbolIcon: Me(
          'uniform sampler2D u_texture;in vec2 v_tex;in float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nlowp float alpha=opacity*v_fade_opacity;fragColor=texture(u_texture,v_tex)*alpha;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}',
          'in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_tex;out float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;\n#ifdef GLOBE\nif(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}\n#endif\nvec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}gl_Position=finalPos;v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float visibility=calculate_visibility(projectedPoint);v_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));}'
        ),
        symbolSDF: Me(
          '#define SDF_PX 8.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;in vec2 v_data0;in vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float inner_edge=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);inner_edge=inner_edge+gamma*gamma_scale;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(inner_edge-gamma_scaled,inner_edge+gamma_scaled,dist);if (u_is_halo) {lowp float halo_edge=(6.0-halo_width/fontScale)/SDF_PX;alpha=min(smoothstep(halo_edge-gamma_scaled,halo_edge+gamma_scaled,dist),1.0-alpha);}fragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}',
          'in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_data0;out vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;\n#ifdef GLOBE\nif(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}\n#endif\nvec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}'
        ),
        symbolTextAndIcon: Me(
          '#define SDF_PX 8.0\n#define SDF 1.0\n#define ICON 0.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;in vec4 v_data0;in vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;fragColor=texture(u_texture_icon,tex_icon)*alpha;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\nreturn;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);fragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}',
          'in vec4 a_pos_offset;in vec4 a_data;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec4 v_data0;out vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;\n#ifdef GLOBE\nif(u_pitch_with_map && !u_is_along_line) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}\n#endif\nvec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}'
        ),
        terrain: Me(
          'uniform sampler2D u_texture;uniform vec4 u_fog_color;uniform vec4 u_horizon_color;uniform float u_fog_ground_blend;uniform float u_fog_ground_blend_opacity;uniform float u_horizon_fog_blend;uniform bool u_is_globe_mode;in vec2 v_texture_pos;in float v_fog_depth;const float gamma=2.2;vec4 gammaToLinear(vec4 color) {return pow(color,vec4(gamma));}vec4 linearToGamma(vec4 color) {return pow(color,vec4(1.0/gamma));}void main() {vec4 surface_color=texture(u_texture,vec2(v_texture_pos.x,1.0-v_texture_pos.y));if (!u_is_globe_mode && v_fog_depth > u_fog_ground_blend) {vec4 surface_color_linear=gammaToLinear(surface_color);float blend_color=smoothstep(0.0,1.0,max((v_fog_depth-u_horizon_fog_blend)/(1.0-u_horizon_fog_blend),0.0));vec4 fog_horizon_color_linear=mix(gammaToLinear(u_fog_color),gammaToLinear(u_horizon_color),blend_color);float factor_fog=max(v_fog_depth-u_fog_ground_blend,0.0)/(1.0-u_fog_ground_blend);fragColor=linearToGamma(mix(surface_color_linear,fog_horizon_color_linear,pow(factor_fog,2.0)*u_fog_ground_blend_opacity));} else {fragColor=surface_color;}}',
          'in vec3 a_pos3d;uniform mat4 u_fog_matrix;uniform float u_ele_delta;out vec2 v_texture_pos;out float v_fog_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,get_elevation(a_pos3d.xy)-ele_delta);vec4 pos=u_fog_matrix*vec4(a_pos3d.xy,ele,1.0);v_fog_depth=pos.z/pos.w*0.5+0.5;}'
        ),
        terrainDepth: Me(
          'in float v_depth;const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitMsk=vec4(0.,vec3(1./256.0));highp vec4 pack(highp float value) {highp vec4 comp=fract(value*bitSh);comp-=comp.xxyz*bitMsk;return comp;}void main() {fragColor=pack(v_depth);}',
          'in vec3 a_pos3d;uniform float u_ele_delta;out float v_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);v_depth=gl_Position.z/gl_Position.w;}'
        ),
        terrainCoords: Me(
          'precision mediump float;uniform sampler2D u_texture;uniform float u_terrain_coords_id;in vec2 v_texture_pos;void main() {vec4 rgba=texture(u_texture,v_texture_pos);fragColor=vec4(rgba.r,rgba.g,rgba.b,u_terrain_coords_id);}',
          'in vec3 a_pos3d;uniform float u_ele_delta;out vec2 v_texture_pos;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);}'
        ),
        projectionErrorMeasurement: Me(
          'in vec4 v_output_error_encoded;void main() {fragColor=v_output_error_encoded;}',
          'in vec2 a_pos;uniform highp float u_input;uniform highp float u_output_expected;out vec4 v_output_error_encoded;void main() {float real_output=2.0*atan(exp(PI-(u_input*PI*2.0)))-PI*0.5;float error=real_output-u_output_expected;float abs_error=abs(error)*128.0;v_output_error_encoded.x=min(floor(abs_error*256.0),255.0)/255.0;abs_error-=v_output_error_encoded.x;v_output_error_encoded.y=min(floor(abs_error*65536.0),255.0)/255.0;abs_error-=v_output_error_encoded.x/255.0;v_output_error_encoded.z=min(floor(abs_error*16777216.0),255.0)/255.0;v_output_error_encoded.w=error >=0.0 ? 1.0 : 0.0;gl_Position=vec4(a_pos,0.0,1.0);}'
        ),
        atmosphere: Me(
          'in vec3 view_direction;uniform vec3 u_sun_pos;uniform vec3 u_globe_position;uniform float u_globe_radius;uniform float u_atmosphere_blend;/**Shader use from https:*Made some change to adapt to MapLibre Globe geometry*/const float PI=3.141592653589793;const int iSteps=5;const int jSteps=3;/*radius of the planet*/const float EARTH_RADIUS=6371e3;/*radius of the atmosphere*/const float ATMOS_RADIUS=6471e3;vec2 rsi(vec3 r0,vec3 rd,float sr) {float a=dot(rd,rd);float b=2.0*dot(rd,r0);float c=dot(r0,r0)-(sr*sr);float d=(b*b)-4.0*a*c;if (d < 0.0) return vec2(1e5,-1e5);return vec2((-b-sqrt(d))/(2.0*a),(-b+sqrt(d))/(2.0*a));}vec4 atmosphere(vec3 r,vec3 r0,vec3 pSun,float iSun,float rPlanet,float rAtmos,vec3 kRlh,float kMie,float shRlh,float shMie,float g) {pSun=normalize(pSun);r=normalize(r);vec2 p=rsi(r0,r,rAtmos);if (p.x > p.y) {return vec4(0.0,0.0,0.0,1.0);}if (p.x < 0.0) {p.x=0.0;}vec3 pos=r0+r*p.x;vec2 p2=rsi(r0,r,rPlanet);if (p2.x <=p2.y && p2.x > 0.0) {p.y=min(p.y,p2.x);}float iStepSize=(p.y-p.x)/float(iSteps);float iTime=p.x+iStepSize*0.5;vec3 totalRlh=vec3(0,0,0);vec3 totalMie=vec3(0,0,0);float iOdRlh=0.0;float iOdMie=0.0;float mu=dot(r,pSun);float mumu=mu*mu;float gg=g*g;float pRlh=3.0/(16.0*PI)*(1.0+mumu);float pMie=3.0/(8.0*PI)*((1.0-gg)*(mumu+1.0))/(pow(1.0+gg-2.0*mu*g,1.5)*(2.0+gg));for (int i=0; i < iSteps; i++) {vec3 iPos=r0+r*iTime;float iHeight=length(iPos)-rPlanet;float odStepRlh=exp(-iHeight/shRlh)*iStepSize;float odStepMie=exp(-iHeight/shMie)*iStepSize;iOdRlh+=odStepRlh;iOdMie+=odStepMie;float jStepSize=rsi(iPos,pSun,rAtmos).y/float(jSteps);float jTime=jStepSize*0.5;float jOdRlh=0.0;float jOdMie=0.0;for (int j=0; j < jSteps; j++) {vec3 jPos=iPos+pSun*jTime;float jHeight=length(jPos)-rPlanet;jOdRlh+=exp(-jHeight/shRlh)*jStepSize;jOdMie+=exp(-jHeight/shMie)*jStepSize;jTime+=jStepSize;}vec3 attn=exp(-(kMie*(iOdMie+jOdMie)+kRlh*(iOdRlh+jOdRlh)));totalRlh+=odStepRlh*attn;totalMie+=odStepMie*attn;iTime+=iStepSize;}float opacity=exp(-(length(kRlh)*length(totalRlh)+kMie*length(totalMie)));vec3 color=iSun*(pRlh*kRlh*totalRlh+pMie*kMie*totalMie);return vec4(color,opacity);}void main() {vec3 scale_camera_pos=-u_globe_position*EARTH_RADIUS/u_globe_radius;vec4 color=atmosphere(normalize(view_direction),scale_camera_pos,u_sun_pos,22.0,EARTH_RADIUS,ATMOS_RADIUS,vec3(5.5e-6,13.0e-6,22.4e-6),21e-6,8e3,1.2e3,0.758\n);color.rgb=1.0-exp(-1.0*color.rgb);color=pow(color,vec4(1.0/2.2));fragColor=vec4(color.rgb,1.0-color.a)*u_atmosphere_blend;}',
          'in vec2 a_pos;uniform mat4 u_inv_proj_matrix;out vec3 view_direction;void main() {view_direction=(u_inv_proj_matrix*vec4(a_pos,0.0,1.0)).xyz;gl_Position=vec4(a_pos,0.0,1.0);}'
        ),
        sky: Me(
          'uniform vec4 u_sky_color;uniform vec4 u_horizon_color;uniform vec2 u_horizon;uniform vec2 u_horizon_normal;uniform float u_sky_horizon_blend;uniform float u_sky_blend;void main() {float x=gl_FragCoord.x;float y=gl_FragCoord.y;float blend=(y-u_horizon.y)*u_horizon_normal.y+(x-u_horizon.x)*u_horizon_normal.x;if (blend > 0.0) {if (blend < u_sky_horizon_blend) {fragColor=mix(u_sky_color,u_horizon_color,pow(1.0-blend/u_sky_horizon_blend,2.0));} else {fragColor=u_sky_color;}}fragColor=mix(fragColor,vec4(vec3(0.0),0.0),u_sky_blend);}',
          'in vec2 a_pos;void main() {gl_Position=vec4(a_pos,1.0,1.0);}'
        ),
      };
      function Me(t, e) {
        const i = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g,
          r = e.match(/in ([\w]+) ([\w]+)/g),
          n = t.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g),
          a = e.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g),
          s = a ? a.concat(n) : n,
          o = {};
        return {
          fragmentSource: (t = t.replace(
            i,
            (t, e, i, r, n) => (
              (o[n] = !0),
              'define' === e
                ? `\n#ifndef HAS_UNIFORM_u_${n}\nin ${i} ${r} ${n};\n#else\nuniform ${i} ${r} u_${n};\n#endif\n`
                : `\n#ifdef HAS_UNIFORM_u_${n}\n    ${i} ${r} ${n} = u_${n};\n#endif\n`
            )
          )),
          vertexSource: (e = e.replace(i, (t, e, i, r, n) => {
            const a = 'float' === r ? 'vec2' : 'vec4',
              s = n.match(/color/) ? 'color' : a;
            return o[n]
              ? 'define' === e
                ? `\n#ifndef HAS_UNIFORM_u_${n}\nuniform lowp float u_${n}_t;\nin ${i} ${a} a_${n};\nout ${i} ${r} ${n};\n#else\nuniform ${i} ${r} u_${n};\n#endif\n`
                : 'vec4' === s
                ? `\n#ifndef HAS_UNIFORM_u_${n}\n    ${n} = a_${n};\n#else\n    ${i} ${r} ${n} = u_${n};\n#endif\n`
                : `\n#ifndef HAS_UNIFORM_u_${n}\n    ${n} = unpack_mix_${s}(a_${n}, u_${n}_t);\n#else\n    ${i} ${r} ${n} = u_${n};\n#endif\n`
              : 'define' === e
              ? `\n#ifndef HAS_UNIFORM_u_${n}\nuniform lowp float u_${n}_t;\nin ${i} ${a} a_${n};\n#else\nuniform ${i} ${r} u_${n};\n#endif\n`
              : 'vec4' === s
              ? `\n#ifndef HAS_UNIFORM_u_${n}\n    ${i} ${r} ${n} = a_${n};\n#else\n    ${i} ${r} ${n} = u_${n};\n#endif\n`
              : `\n#ifndef HAS_UNIFORM_u_${n}\n    ${i} ${r} ${n} = unpack_mix_${s}(a_${n}, u_${n}_t);\n#else\n    ${i} ${r} ${n} = u_${n};\n#endif\n`;
          })),
          staticAttributes: r,
          staticUniforms: s,
        };
      }
      class De {
        constructor(t, e, i) {
          (this.vertexBuffer = t), (this.indexBuffer = e), (this.segments = i);
        }
        destroy() {
          this.vertexBuffer.destroy(),
            this.indexBuffer.destroy(),
            this.segments.destroy(),
            (this.vertexBuffer = null),
            (this.indexBuffer = null),
            (this.segments = null);
        }
      }
      var Le = e.aN([{ name: 'a_pos', type: 'Int16', components: 2 }]);
      const Ae = '#define PROJECTION_MERCATOR',
        Ee = 'mercator';
      class Re {
        constructor() {
          this._cachedMesh = null;
        }
        get name() {
          return 'mercator';
        }
        get useSubdivision() {
          return !1;
        }
        get shaderVariantName() {
          return Ee;
        }
        get shaderDefine() {
          return Ae;
        }
        get shaderPreludeCode() {
          return Se.projectionMercator;
        }
        get vertexShaderPreludeCode() {
          return Se.projectionMercator.vertexSource;
        }
        get subdivisionGranularity() {
          return e.aO.noSubdivision;
        }
        get useGlobeControls() {
          return !1;
        }
        get transitionState() {
          return 0;
        }
        get latitudeErrorCorrectionRadians() {
          return 0;
        }
        destroy() {}
        updateGPUdependent(t) {}
        getMeshFromTileID(t, i, r, n, a) {
          if (this._cachedMesh) return this._cachedMesh;
          const s = new e.aP();
          s.emplaceBack(0, 0),
            s.emplaceBack(e.a3, 0),
            s.emplaceBack(0, e.a3),
            s.emplaceBack(e.a3, e.a3);
          const o = t.createVertexBuffer(s, Le.members),
            l = e.aQ.simpleSegment(0, 0, 4, 2),
            c = new e.aR();
          c.emplaceBack(1, 0, 2), c.emplaceBack(1, 2, 3);
          const h = t.createIndexBuffer(c);
          return (this._cachedMesh = new De(o, h, l)), this._cachedMesh;
        }
        recalculate() {}
        hasTransition() {
          return !1;
        }
        setErrorQueryLatitudeDegrees(t) {}
      }
      class ze {
        constructor(t = 0, e = 0, i = 0, r = 0) {
          if (
            isNaN(t) ||
            t < 0 ||
            isNaN(e) ||
            e < 0 ||
            isNaN(i) ||
            i < 0 ||
            isNaN(r) ||
            r < 0
          )
            throw new Error(
              'Invalid value for edge-insets, top, bottom, left and right must all be numbers'
            );
          (this.top = t), (this.bottom = e), (this.left = i), (this.right = r);
        }
        interpolate(t, i, r) {
          return (
            null != i.top &&
              null != t.top &&
              (this.top = e.F.number(t.top, i.top, r)),
            null != i.bottom &&
              null != t.bottom &&
              (this.bottom = e.F.number(t.bottom, i.bottom, r)),
            null != i.left &&
              null != t.left &&
              (this.left = e.F.number(t.left, i.left, r)),
            null != i.right &&
              null != t.right &&
              (this.right = e.F.number(t.right, i.right, r)),
            this
          );
        }
        getCenter(t, i) {
          const r = e.ai((this.left + t - this.right) / 2, 0, t),
            n = e.ai((this.top + i - this.bottom) / 2, 0, i);
          return new e.P(r, n);
        }
        equals(t) {
          return (
            this.top === t.top &&
            this.bottom === t.bottom &&
            this.left === t.left &&
            this.right === t.right
          );
        }
        clone() {
          return new ze(this.top, this.bottom, this.left, this.right);
        }
        toJSON() {
          return {
            top: this.top,
            bottom: this.bottom,
            left: this.left,
            right: this.right,
          };
        }
      }
      function ke(t, e) {
        if (!t.renderWorldCopies || t.lngRange) return;
        const i = e.lng - t.center.lng;
        e.lng += i > 180 ? -360 : i < -180 ? 360 : 0;
      }
      function Oe(t) {
        return Math.max(0, Math.floor(t));
      }
      class Fe {
        constructor(t, i) {
          var r;
          (this._callbacks = t),
            (this._tileSize = 512),
            (this._renderWorldCopies =
              void 0 === (null == i ? void 0 : i.renderWorldCopies) ||
              !!(null == i ? void 0 : i.renderWorldCopies)),
            (this._minZoom = (null == i ? void 0 : i.minZoom) || 0),
            (this._maxZoom = (null == i ? void 0 : i.maxZoom) || 22),
            (this._minPitch =
              null == (null == i ? void 0 : i.minPitch)
                ? 0
                : null == i
                ? void 0
                : i.minPitch),
            (this._maxPitch =
              null == (null == i ? void 0 : i.maxPitch)
                ? 60
                : null == i
                ? void 0
                : i.maxPitch),
            (this._constrain =
              null !== (r = null == i ? void 0 : i.constrain) && void 0 !== r
                ? r
                : this._callbacks.constrain),
            this.setMaxBounds(),
            (this._width = 0),
            (this._height = 0),
            (this._center = new e.U(0, 0)),
            (this._elevation = 0),
            (this._zoom = 0),
            (this._tileZoom = Oe(this._zoom)),
            (this._scale = e.al(this._zoom)),
            (this._bearingInRadians = 0),
            (this._fovInRadians = 0.6435011087932844),
            (this._pitchInRadians = 0),
            (this._rollInRadians = 0),
            (this._unmodified = !0),
            (this._edgeInsets = new ze()),
            (this._minElevationForCurrentTile = 0),
            (this._autoCalculateNearFarZ = !0);
        }
        apply(t, i, r) {
          (this._latRange = t.latRange),
            (this._lngRange = t.lngRange),
            (this._width = t.width),
            (this._height = t.height),
            (this._center = t.center),
            (this._elevation = t.elevation),
            (this._minElevationForCurrentTile = t.minElevationForCurrentTile),
            (this._zoom = t.zoom),
            (this._tileZoom = Oe(this._zoom)),
            (this._scale = e.al(this._zoom)),
            (this._bearingInRadians = t.bearingInRadians),
            (this._fovInRadians = t.fovInRadians),
            (this._pitchInRadians = t.pitchInRadians),
            (this._rollInRadians = t.rollInRadians),
            (this._unmodified = t.unmodified),
            (this._edgeInsets = new ze(
              t.padding.top,
              t.padding.bottom,
              t.padding.left,
              t.padding.right
            )),
            (this._minZoom = t.minZoom),
            (this._maxZoom = t.maxZoom),
            (this._minPitch = t.minPitch),
            (this._maxPitch = t.maxPitch),
            (this._renderWorldCopies = t.renderWorldCopies),
            (this._cameraToCenterDistance = t.cameraToCenterDistance),
            (this._nearZ = t.nearZ),
            (this._farZ = t.farZ),
            (this._autoCalculateNearFarZ = !r && t.autoCalculateNearFarZ),
            i && this.constrainInternal(),
            this._calcMatrices();
        }
        get pixelsToClipSpaceMatrix() {
          return this._pixelsToClipSpaceMatrix;
        }
        get clipSpaceToPixelsMatrix() {
          return this._clipSpaceToPixelsMatrix;
        }
        get minElevationForCurrentTile() {
          return this._minElevationForCurrentTile;
        }
        setMinElevationForCurrentTile(t) {
          this._minElevationForCurrentTile = t;
        }
        get tileSize() {
          return this._tileSize;
        }
        get tileZoom() {
          return this._tileZoom;
        }
        get scale() {
          return this._scale;
        }
        get width() {
          return this._width;
        }
        get height() {
          return this._height;
        }
        get bearingInRadians() {
          return this._bearingInRadians;
        }
        get lngRange() {
          return this._lngRange;
        }
        get latRange() {
          return this._latRange;
        }
        get pixelsToGLUnits() {
          return this._pixelsToGLUnits;
        }
        get minZoom() {
          return this._minZoom;
        }
        setMinZoom(t) {
          this._minZoom !== t &&
            ((this._minZoom = t),
            this.setZoom(this.constrain(this._center, this.zoom).zoom));
        }
        get maxZoom() {
          return this._maxZoom;
        }
        setMaxZoom(t) {
          this._maxZoom !== t &&
            ((this._maxZoom = t),
            this.setZoom(this.constrain(this._center, this.zoom).zoom));
        }
        get minPitch() {
          return this._minPitch;
        }
        setMinPitch(t) {
          this._minPitch !== t &&
            ((this._minPitch = t), this.setPitch(Math.max(this.pitch, t)));
        }
        get maxPitch() {
          return this._maxPitch;
        }
        setMaxPitch(t) {
          this._maxPitch !== t &&
            ((this._maxPitch = t), this.setPitch(Math.min(this.pitch, t)));
        }
        get renderWorldCopies() {
          return this._renderWorldCopies;
        }
        setRenderWorldCopies(t) {
          void 0 === t ? (t = !0) : null === t && (t = !1),
            (this._renderWorldCopies = t);
        }
        get constrain() {
          return this._constrain;
        }
        setConstrain(t) {
          t || (t = this._callbacks.constrain),
            (this._constrain = t),
            this.constrainInternal(),
            this._calcMatrices();
        }
        get worldSize() {
          return this._tileSize * this._scale;
        }
        get centerOffset() {
          return this.centerPoint._sub(this.size._div(2));
        }
        get size() {
          return new e.P(this._width, this._height);
        }
        get bearing() {
          return (this._bearingInRadians / Math.PI) * 180;
        }
        setBearing(t) {
          const i = (e.V(t, -180, 180) * Math.PI) / 180;
          var n, a, s, o, l, c, h, u, d;
          this._bearingInRadians !== i &&
            ((this._unmodified = !1),
            (this._bearingInRadians = i),
            this._calcMatrices(),
            (this._rotationMatrix = r()),
            (n = this._rotationMatrix),
            (s = -this._bearingInRadians),
            (o = (a = this._rotationMatrix)[0]),
            (l = a[1]),
            (c = a[2]),
            (h = a[3]),
            (u = Math.sin(s)),
            (d = Math.cos(s)),
            (n[0] = o * d + c * u),
            (n[1] = l * d + h * u),
            (n[2] = o * -u + c * d),
            (n[3] = l * -u + h * d));
        }
        get rotationMatrix() {
          return this._rotationMatrix;
        }
        get pitchInRadians() {
          return this._pitchInRadians;
        }
        get pitch() {
          return (this._pitchInRadians / Math.PI) * 180;
        }
        setPitch(t) {
          const i = (e.ai(t, this.minPitch, this.maxPitch) / 180) * Math.PI;
          this._pitchInRadians !== i &&
            ((this._unmodified = !1),
            (this._pitchInRadians = i),
            this._calcMatrices());
        }
        get rollInRadians() {
          return this._rollInRadians;
        }
        get roll() {
          return (this._rollInRadians / Math.PI) * 180;
        }
        setRoll(t) {
          const e = (t / 180) * Math.PI;
          this._rollInRadians !== e &&
            ((this._unmodified = !1),
            (this._rollInRadians = e),
            this._calcMatrices());
        }
        get fovInRadians() {
          return this._fovInRadians;
        }
        get fov() {
          return e.aS(this._fovInRadians);
        }
        setFov(t) {
          (t = e.ai(t, 0.1, 150)),
            this.fov !== t &&
              ((this._unmodified = !1),
              (this._fovInRadians = e.ak(t)),
              this._calcMatrices());
        }
        get zoom() {
          return this._zoom;
        }
        setZoom(t) {
          const i = this.constrain(this._center, t).zoom;
          this._zoom !== i &&
            ((this._unmodified = !1),
            (this._zoom = i),
            (this._tileZoom = Math.max(0, Math.floor(i))),
            (this._scale = e.al(i)),
            this.constrainInternal(),
            this._calcMatrices());
        }
        get center() {
          return this._center;
        }
        setCenter(t) {
          (t.lat === this._center.lat && t.lng === this._center.lng) ||
            ((this._unmodified = !1),
            (this._center = t),
            this.constrainInternal(),
            this._calcMatrices());
        }
        get elevation() {
          return this._elevation;
        }
        setElevation(t) {
          t !== this._elevation &&
            ((this._elevation = t),
            this.constrainInternal(),
            this._calcMatrices());
        }
        get padding() {
          return this._edgeInsets.toJSON();
        }
        setPadding(t) {
          this._edgeInsets.equals(t) ||
            ((this._unmodified = !1),
            this._edgeInsets.interpolate(this._edgeInsets, t, 1),
            this._calcMatrices());
        }
        get centerPoint() {
          return this._edgeInsets.getCenter(this._width, this._height);
        }
        get pixelsPerMeter() {
          return this._pixelPerMeter;
        }
        get unmodified() {
          return this._unmodified;
        }
        get cameraToCenterDistance() {
          return this._cameraToCenterDistance;
        }
        get nearZ() {
          return this._nearZ;
        }
        get farZ() {
          return this._farZ;
        }
        get autoCalculateNearFarZ() {
          return this._autoCalculateNearFarZ;
        }
        overrideNearFarZ(t, e) {
          (this._autoCalculateNearFarZ = !1),
            (this._nearZ = t),
            (this._farZ = e),
            this._calcMatrices();
        }
        clearNearFarZOverride() {
          (this._autoCalculateNearFarZ = !0), this._calcMatrices();
        }
        isPaddingEqual(t) {
          return this._edgeInsets.equals(t);
        }
        interpolatePadding(t, e, i) {
          (this._unmodified = !1),
            this._edgeInsets.interpolate(t, e, i),
            this.constrainInternal(),
            this._calcMatrices();
        }
        resize(t, e, i = !0) {
          (this._width = t),
            (this._height = e),
            i && this.constrainInternal(),
            this._calcMatrices();
        }
        getMaxBounds() {
          return this._latRange &&
            2 === this._latRange.length &&
            this._lngRange &&
            2 === this._lngRange.length
            ? new q(
                [this._lngRange[0], this._latRange[0]],
                [this._lngRange[1], this._latRange[1]]
              )
            : null;
        }
        setMaxBounds(t) {
          t
            ? ((this._lngRange = [t.getWest(), t.getEast()]),
              (this._latRange = [t.getSouth(), t.getNorth()]),
              this.constrainInternal())
            : ((this._lngRange = null), (this._latRange = [-e.aj, e.aj]));
        }
        getCameraQueryGeometry(t, i) {
          if (1 === i.length) return [i[0], t];
          {
            const {
              minX: r,
              minY: n,
              maxX: a,
              maxY: s,
            } = e.a6.fromPoints(i).extend(t);
            return [
              new e.P(r, n),
              new e.P(a, n),
              new e.P(a, s),
              new e.P(r, s),
              new e.P(r, n),
            ];
          }
        }
        constrainInternal() {
          if (
            !this.center ||
            !this._width ||
            !this._height ||
            this._constraining
          )
            return;
          this._constraining = !0;
          const t = this._unmodified,
            { center: e, zoom: i } = this.constrain(this.center, this.zoom);
          this.setCenter(e),
            this.setZoom(i),
            (this._unmodified = t),
            (this._constraining = !1);
        }
        _calcMatrices() {
          if (this._width && this._height) {
            this._pixelsToGLUnits = [2 / this._width, -2 / this._height];
            let t = e.am(new Float64Array(16));
            e.O(t, t, [this._width / 2, -this._height / 2, 1]),
              e.N(t, t, [1, -1, 0]),
              (this._clipSpaceToPixelsMatrix = t),
              (t = e.am(new Float64Array(16))),
              e.O(t, t, [1, -1, 1]),
              e.N(t, t, [-1, -1, 0]),
              e.O(t, t, [2 / this._width, 2 / this._height, 1]),
              (this._pixelsToClipSpaceMatrix = t),
              (this._cameraToCenterDistance =
                (0.5 / Math.tan(this.fovInRadians / 2)) * this._height);
          }
          this._callbacks.calcMatrices();
        }
        calculateCenterFromCameraLngLatAlt(t, i, r, n) {
          const a = void 0 !== r ? r : this.bearing,
            s = (n = void 0 !== n ? n : this.pitch),
            o = e.a5.fromLngLat(t, i),
            l = -Math.cos(e.ak(s)),
            c = Math.sin(e.ak(s)),
            h = c * Math.sin(e.ak(a)),
            u = -c * Math.cos(e.ak(a));
          let d = this.elevation;
          const p = i - d;
          let f;
          l * p >= 0 || Math.abs(l) < 0.1
            ? ((f = 1e4), (d = i + f * l))
            : (f = -p / l);
          let m,
            g,
            _ = e.aT(1, o.y),
            y = 0;
          do {
            if (((y += 1), y > 10)) break;
            (g = f / _),
              (m = new e.a5(o.x + h * g, o.y + u * g)),
              (_ = 1 / m.meterInMercatorCoordinateUnits());
          } while (Math.abs(f - g * _) > 1e-12);
          return {
            center: m.toLngLat(),
            elevation: d,
            zoom: e.ao(
              this.height /
                2 /
                Math.tan(this.fovInRadians / 2) /
                g /
                this.tileSize
            ),
          };
        }
        recalculateZoomAndCenter(t) {
          if (this.elevation - t == 0) return;
          const i = e.an(1, this.center.lat) * this.worldSize,
            r = this.cameraToCenterDistance / i,
            n = e.a5.fromLngLat(this.center, this.elevation),
            a = vt(this.center, this.elevation, this.pitch, this.bearing, r);
          this._elevation = t;
          const s = this.calculateCenterFromCameraLngLatAlt(
            a.toLngLat(),
            e.aT(a.z, n.y),
            this.bearing,
            this.pitch
          );
          (this._elevation = s.elevation),
            (this._center = s.center),
            this.setZoom(s.zoom);
        }
        getCameraPoint() {
          const t =
            Math.tan(this.pitchInRadians) * (this.cameraToCenterDistance || 1);
          return this.centerPoint.add(
            new e.P(
              t * Math.sin(this.rollInRadians),
              t * Math.cos(this.rollInRadians)
            )
          );
        }
        getCameraAltitude() {
          return (
            (Math.cos(this.pitchInRadians) * this._cameraToCenterDistance) /
              this._pixelPerMeter +
            this.elevation
          );
        }
        getCameraLngLat() {
          const t = e.an(1, this.center.lat) * this.worldSize;
          return vt(
            this.center,
            this.elevation,
            this.pitch,
            this.bearing,
            this.cameraToCenterDistance / t
          ).toLngLat();
        }
        getMercatorTileCoordinates(t) {
          if (!t) return [0, 0, 1, 1];
          const i =
            t.canonical.z >= 0
              ? 1 << t.canonical.z
              : Math.pow(2, t.canonical.z);
          return [
            t.canonical.x / i,
            t.canonical.y / i,
            1 / i / e.a3,
            1 / i / e.a3,
          ];
        }
      }
      class Be {
        constructor(t, i) {
          (this.min = t),
            (this.max = i),
            (this.center = e.aU([], e.aV([], this.min, this.max), 0.5));
        }
        quadrant(t) {
          const i = [t % 2 == 0, t < 2],
            r = e.aW(this.min),
            n = e.aW(this.max);
          for (let e = 0; e < i.length; e++)
            (r[e] = i[e] ? this.min[e] : this.center[e]),
              (n[e] = i[e] ? this.center[e] : this.max[e]);
          return (n[2] = this.max[2]), new Be(r, n);
        }
        distanceX(t) {
          return Math.max(Math.min(this.max[0], t[0]), this.min[0]) - t[0];
        }
        distanceY(t) {
          return Math.max(Math.min(this.max[1], t[1]), this.min[1]) - t[1];
        }
        intersectsFrustum(t) {
          let e = !0;
          for (let i = 0; i < t.planes.length; i++) {
            const r = this.intersectsPlane(t.planes[i]);
            if (0 === r) return 0;
            1 === r && (e = !1);
          }
          return e
            ? 2
            : t.aabb.min[0] > this.max[0] ||
              t.aabb.min[1] > this.max[1] ||
              t.aabb.min[2] > this.max[2] ||
              t.aabb.max[0] < this.min[0] ||
              t.aabb.max[1] < this.min[1] ||
              t.aabb.max[2] < this.min[2]
            ? 0
            : 1;
        }
        intersectsPlane(t) {
          let e = t[3],
            i = t[3];
          for (let r = 0; r < 3; r++)
            t[r] > 0
              ? ((e += t[r] * this.min[r]), (i += t[r] * this.max[r]))
              : ((i += t[r] * this.min[r]), (e += t[r] * this.max[r]));
          return e >= 0 ? 2 : i < 0 ? 0 : 1;
        }
      }
      class Ne {
        distanceToTile2d(t, e, i, r) {
          const n = r.distanceX([t, e]),
            a = r.distanceY([t, e]);
          return Math.hypot(n, a);
        }
        getWrap(t, e, i) {
          return i;
        }
        getTileBoundingVolume(t, i, r, n) {
          var a, s;
          let o = 0,
            l = 0;
          if (null == n ? void 0 : n.terrain) {
            const c = new e.a0(t.z, i, t.z, t.x, t.y),
              h = n.terrain.getMinMaxElevation(c);
            (o =
              null !== (a = h.minElevation) && void 0 !== a
                ? a
                : Math.min(0, r)),
              (l =
                null !== (s = h.maxElevation) && void 0 !== s
                  ? s
                  : Math.max(0, r));
          }
          const c = 1 << t.z;
          return new Be(
            [i + t.x / c, t.y / c, o],
            [i + (t.x + 1) / c, (t.y + 1) / c, l]
          );
        }
        allowVariableZoom(t, i) {
          const r =
              (t.fov *
                (Math.abs(Math.cos(t.rollInRadians)) * t.height +
                  Math.abs(Math.sin(t.rollInRadians)) * t.width)) /
              t.height,
            n = e.ai(78.5 - r / 2, 0, 60);
          return !!i.terrain || t.pitch > n;
        }
        allowWorldCopies() {
          return !0;
        }
        prepareNextFrame() {}
      }
      class Ve {
        constructor(t, e, i) {
          (this.points = t), (this.planes = e), (this.aabb = i);
        }
        static fromInvProjectionMatrix(t, i = 1, r = 0, n, a) {
          const s = a
              ? [
                  [6, 5, 4],
                  [0, 1, 2],
                  [0, 3, 7],
                  [2, 1, 5],
                  [3, 2, 6],
                  [0, 4, 5],
                ]
              : [
                  [0, 1, 2],
                  [6, 5, 4],
                  [0, 3, 7],
                  [2, 1, 5],
                  [3, 2, 6],
                  [0, 4, 5],
                ],
            o = Math.pow(2, r),
            l = [
              [-1, 1, -1, 1],
              [1, 1, -1, 1],
              [1, -1, -1, 1],
              [-1, -1, -1, 1],
              [-1, 1, 1, 1],
              [1, 1, 1, 1],
              [1, -1, 1, 1],
              [-1, -1, 1, 1],
            ].map((r) =>
              (function (t, i, r, n) {
                const a = e.aA([], t, i),
                  s = (1 / a[3] / r) * n;
                return e.a$(a, a, [s, s, 1 / a[3], s]);
              })(r, t, i, o)
            );
          n &&
            (function (t, i, r, n) {
              const a = n ? 4 : 0,
                s = n ? 0 : 4;
              let o = 0;
              const l = [],
                c = [];
              for (let d = 0; d < 4; d++) {
                const i = e.aX([], t[d + s], t[d + a]),
                  r = e.b0(i);
                e.aU(i, i, 1 / r), l.push(r), c.push(i);
              }
              for (let d = 0; d < 4; d++) {
                const i = e.b1(t[d + a], c[d], r);
                o = null !== i && i >= 0 ? Math.max(o, i) : Math.max(o, l[d]);
              }
              const h = (function (t, i) {
                  const r = e.aX([], t[i[0]], t[i[1]]),
                    n = e.aX([], t[i[2]], t[i[1]]),
                    a = [0, 0, 0, 0];
                  return e.aY(a, e.aZ([], r, n)), (a[3] = -e.a_(a, t[i[0]])), a;
                })(t, i),
                u = (function (t, i) {
                  const r = e.b2(t),
                    n = e.b3([], t, 1 / r),
                    a = e.aX([], i, e.aU([], n, e.a_(i, n))),
                    s = e.b2(a);
                  if (s > 0) {
                    const t = Math.sqrt(1 - n[3] * n[3]),
                      r = e.aU([], n, -n[3]),
                      o = e.aV([], r, e.aU([], a, t / s));
                    return e.b4(i, o);
                  }
                  return null;
                })(r, h);
              if (null !== u) {
                const t = u / e.a_(c[0], h);
                o = Math.min(o, t);
              }
              for (let e = 0; e < 4; e++) {
                const i = Math.min(o, l[e]);
                t[e + s] = [
                  t[e + a][0] + c[e][0] * i,
                  t[e + a][1] + c[e][1] * i,
                  t[e + a][2] + c[e][2] * i,
                  1,
                ];
              }
            })(l, s[0], n, a);
          const c = s.map((t) => {
              const i = e.aX([], l[t[0]], l[t[1]]),
                r = e.aX([], l[t[2]], l[t[1]]),
                n = e.aY([], e.aZ([], i, r)),
                a = -e.a_(n, l[t[1]]);
              return n.concat(a);
            }),
            h = [
              Number.POSITIVE_INFINITY,
              Number.POSITIVE_INFINITY,
              Number.POSITIVE_INFINITY,
            ],
            u = [
              Number.NEGATIVE_INFINITY,
              Number.NEGATIVE_INFINITY,
              Number.NEGATIVE_INFINITY,
            ];
          for (const e of l)
            for (let t = 0; t < 3; t++)
              (h[t] = Math.min(h[t], e[t])), (u[t] = Math.max(u[t], e[t]));
          return new Ve(l, c, new Be(h, u));
        }
      }
      class je {
        get pixelsToClipSpaceMatrix() {
          return this._helper.pixelsToClipSpaceMatrix;
        }
        get clipSpaceToPixelsMatrix() {
          return this._helper.clipSpaceToPixelsMatrix;
        }
        get pixelsToGLUnits() {
          return this._helper.pixelsToGLUnits;
        }
        get centerOffset() {
          return this._helper.centerOffset;
        }
        get size() {
          return this._helper.size;
        }
        get rotationMatrix() {
          return this._helper.rotationMatrix;
        }
        get centerPoint() {
          return this._helper.centerPoint;
        }
        get pixelsPerMeter() {
          return this._helper.pixelsPerMeter;
        }
        setMinZoom(t) {
          this._helper.setMinZoom(t);
        }
        setMaxZoom(t) {
          this._helper.setMaxZoom(t);
        }
        setMinPitch(t) {
          this._helper.setMinPitch(t);
        }
        setMaxPitch(t) {
          this._helper.setMaxPitch(t);
        }
        setRenderWorldCopies(t) {
          this._helper.setRenderWorldCopies(t);
        }
        setBearing(t) {
          this._helper.setBearing(t);
        }
        setPitch(t) {
          this._helper.setPitch(t);
        }
        setRoll(t) {
          this._helper.setRoll(t);
        }
        setFov(t) {
          this._helper.setFov(t);
        }
        setZoom(t) {
          this._helper.setZoom(t);
        }
        setCenter(t) {
          this._helper.setCenter(t);
        }
        setElevation(t) {
          this._helper.setElevation(t);
        }
        setMinElevationForCurrentTile(t) {
          this._helper.setMinElevationForCurrentTile(t);
        }
        setPadding(t) {
          this._helper.setPadding(t);
        }
        interpolatePadding(t, e, i) {
          return this._helper.interpolatePadding(t, e, i);
        }
        isPaddingEqual(t) {
          return this._helper.isPaddingEqual(t);
        }
        resize(t, e, i = !0) {
          this._helper.resize(t, e, i);
        }
        getMaxBounds() {
          return this._helper.getMaxBounds();
        }
        setMaxBounds(t) {
          this._helper.setMaxBounds(t);
        }
        setConstrain(t) {
          this._helper.setConstrain(t);
        }
        overrideNearFarZ(t, e) {
          this._helper.overrideNearFarZ(t, e);
        }
        clearNearFarZOverride() {
          this._helper.clearNearFarZOverride();
        }
        getCameraQueryGeometry(t) {
          return this._helper.getCameraQueryGeometry(this.getCameraPoint(), t);
        }
        get tileSize() {
          return this._helper.tileSize;
        }
        get tileZoom() {
          return this._helper.tileZoom;
        }
        get scale() {
          return this._helper.scale;
        }
        get worldSize() {
          return this._helper.worldSize;
        }
        get width() {
          return this._helper.width;
        }
        get height() {
          return this._helper.height;
        }
        get lngRange() {
          return this._helper.lngRange;
        }
        get latRange() {
          return this._helper.latRange;
        }
        get minZoom() {
          return this._helper.minZoom;
        }
        get maxZoom() {
          return this._helper.maxZoom;
        }
        get zoom() {
          return this._helper.zoom;
        }
        get center() {
          return this._helper.center;
        }
        get minPitch() {
          return this._helper.minPitch;
        }
        get maxPitch() {
          return this._helper.maxPitch;
        }
        get pitch() {
          return this._helper.pitch;
        }
        get pitchInRadians() {
          return this._helper.pitchInRadians;
        }
        get roll() {
          return this._helper.roll;
        }
        get rollInRadians() {
          return this._helper.rollInRadians;
        }
        get bearing() {
          return this._helper.bearing;
        }
        get bearingInRadians() {
          return this._helper.bearingInRadians;
        }
        get fov() {
          return this._helper.fov;
        }
        get fovInRadians() {
          return this._helper.fovInRadians;
        }
        get elevation() {
          return this._helper.elevation;
        }
        get minElevationForCurrentTile() {
          return this._helper.minElevationForCurrentTile;
        }
        get padding() {
          return this._helper.padding;
        }
        get unmodified() {
          return this._helper.unmodified;
        }
        get renderWorldCopies() {
          return this._helper.renderWorldCopies;
        }
        get cameraToCenterDistance() {
          return this._helper.cameraToCenterDistance;
        }
        get constrain() {
          return this._helper.constrain;
        }
        get nearZ() {
          return this._helper.nearZ;
        }
        get farZ() {
          return this._helper.farZ;
        }
        get autoCalculateNearFarZ() {
          return this._helper.autoCalculateNearFarZ;
        }
        setTransitionState(t, e) {}
        constructor(t) {
          (this._posMatrixCache = new Map()),
            (this._alignedPosMatrixCache = new Map()),
            (this._fogMatrixCacheF32 = new Map()),
            (this.defaultConstrain = (t, i) => {
              i = e.ai(+i, this.minZoom, this.maxZoom);
              const r = { center: new e.U(t.lng, t.lat), zoom: i };
              let n = this._helper._lngRange;
              if (!this._helper._renderWorldCopies && null === n) {
                const t = 180 - 1e-10;
                n = [-t, t];
              }
              const a = this.tileSize * e.al(r.zoom);
              let s = 0,
                o = a,
                l = 0,
                c = a,
                h = 0,
                u = 0;
              const { x: d, y: p } = this.size;
              if (this._helper._latRange) {
                const t = this._helper._latRange;
                (s = e.W(t[1]) * a),
                  (o = e.W(t[0]) * a),
                  o - s < p && (h = p / (o - s));
              }
              n &&
                ((l = e.V(e.X(n[0]) * a, 0, a)),
                (c = e.V(e.X(n[1]) * a, 0, a)),
                c < l && (c += a),
                c - l < d && (u = d / (c - l)));
              const { x: f, y: m } = mt(a, t);
              let g, _;
              const y = Math.max(u || 0, h || 0);
              if (y) {
                const t = new e.P(u ? (c + l) / 2 : f, h ? (o + s) / 2 : m);
                return (r.center = gt(a, t).wrap()), (r.zoom += e.ao(y)), r;
              }
              if (this._helper._latRange) {
                const t = p / 2;
                m - t < s && (_ = s + t), m + t > o && (_ = o - t);
              }
              if (n) {
                const t = (l + c) / 2;
                let i = f;
                this._helper._renderWorldCopies &&
                  (i = e.V(f, t - a / 2, t + a / 2));
                const r = d / 2;
                i - r < l && (g = l + r), i + r > c && (g = c - r);
              }
              if (void 0 !== g || void 0 !== _) {
                const t = new e.P(null != g ? g : f, null != _ ? _ : m);
                r.center = gt(a, t).wrap();
              }
              return r;
            }),
            (this._helper = new Fe(
              {
                calcMatrices: () => {
                  this._calcMatrices();
                },
                constrain: (t, e) => this.defaultConstrain(t, e),
              },
              t
            )),
            (this._coveringTilesDetailsProvider = new Ne());
        }
        clone() {
          const t = new je();
          return t.apply(this), t;
        }
        apply(t, e, i) {
          this._helper.apply(t, e, i);
        }
        get cameraPosition() {
          return this._cameraPosition;
        }
        get projectionMatrix() {
          return this._projectionMatrix;
        }
        get modelViewProjectionMatrix() {
          return this._viewProjMatrix;
        }
        get inverseProjectionMatrix() {
          return this._invProjMatrix;
        }
        get mercatorMatrix() {
          return this._mercatorMatrix;
        }
        getVisibleUnwrappedCoordinates(t) {
          const i = [new e.b5(0, t)];
          if (this._helper._renderWorldCopies) {
            const r = this.screenPointToMercatorCoordinate(new e.P(0, 0)),
              n = this.screenPointToMercatorCoordinate(
                new e.P(this._helper._width, 0)
              ),
              a = this.screenPointToMercatorCoordinate(
                new e.P(this._helper._width, this._helper._height)
              ),
              s = this.screenPointToMercatorCoordinate(
                new e.P(0, this._helper._height)
              ),
              o = Math.floor(Math.min(r.x, n.x, a.x, s.x)),
              l = Math.floor(Math.max(r.x, n.x, a.x, s.x)),
              c = 1;
            for (let h = o - c; h <= l + c; h++)
              0 !== h && i.push(new e.b5(h, t));
          }
          return i;
        }
        getCameraFrustum() {
          return Ve.fromInvProjectionMatrix(
            this._invViewProjMatrix,
            this.worldSize
          );
        }
        getClippingPlane() {
          return null;
        }
        getCoveringTilesDetailsProvider() {
          return this._coveringTilesDetailsProvider;
        }
        recalculateZoomAndCenter(t) {
          const e = this.screenPointToLocation(this.centerPoint, t),
            i = t ? t.getElevationForLngLatZoom(e, this._helper._tileZoom) : 0;
          this._helper.recalculateZoomAndCenter(i);
        }
        setLocationAtPoint(t, i) {
          const r = e.an(this.elevation, this.center.lat),
            n = this.screenPointToMercatorCoordinateAtZ(i, r),
            a = this.screenPointToMercatorCoordinateAtZ(this.centerPoint, r),
            s = e.a5.fromLngLat(t),
            o = new e.a5(s.x - (n.x - a.x), s.y - (n.y - a.y));
          this.setCenter(null == o ? void 0 : o.toLngLat()),
            this._helper._renderWorldCopies &&
              this.setCenter(this.center.wrap());
        }
        locationToScreenPoint(t, i) {
          return i
            ? this.coordinatePoint(
                e.a5.fromLngLat(t),
                i.getElevationForLngLatZoom(t, this._helper._tileZoom),
                this._pixelMatrix3D
              )
            : this.coordinatePoint(e.a5.fromLngLat(t));
        }
        screenPointToLocation(t, e) {
          var i;
          return null === (i = this.screenPointToMercatorCoordinate(t, e)) ||
            void 0 === i
            ? void 0
            : i.toLngLat();
        }
        screenPointToMercatorCoordinate(t, e) {
          if (e) {
            const i = e.pointCoordinate(t);
            if (null != i) return i;
          }
          return this.screenPointToMercatorCoordinateAtZ(t);
        }
        screenPointToMercatorCoordinateAtZ(t, i) {
          const r = i || 0,
            n = [t.x, t.y, 0, 1],
            a = [t.x, t.y, 1, 1];
          e.aA(n, n, this._pixelMatrixInverse),
            e.aA(a, a, this._pixelMatrixInverse);
          const s = n[3],
            o = a[3],
            l = n[1] / s,
            c = a[1] / o,
            h = n[2] / s,
            u = a[2] / o,
            d = h === u ? 0 : (r - h) / (u - h);
          return new e.a5(
            e.F.number(n[0] / s, a[0] / o, d) / this.worldSize,
            e.F.number(l, c, d) / this.worldSize,
            r
          );
        }
        coordinatePoint(t, i = 0, r = this._pixelMatrix) {
          const n = [t.x * this.worldSize, t.y * this.worldSize, i, 1];
          return e.aA(n, n, r), new e.P(n[0] / n[3], n[1] / n[3]);
        }
        getBounds() {
          const t = Math.max(0, this._helper._height / 2 - _t(this));
          return new q()
            .extend(this.screenPointToLocation(new e.P(0, t)))
            .extend(this.screenPointToLocation(new e.P(this._helper._width, t)))
            .extend(
              this.screenPointToLocation(
                new e.P(this._helper._width, this._helper._height)
              )
            )
            .extend(
              this.screenPointToLocation(new e.P(0, this._helper._height))
            );
        }
        isPointOnMapSurface(t, e) {
          return e
            ? null != e.pointCoordinate(t)
            : t.y > this.height / 2 - _t(this);
        }
        calculatePosMatrix(t, i = !1, r) {
          var n;
          const a =
              null !== (n = t.key) && void 0 !== n
                ? n
                : e.b6(
                    t.wrap,
                    t.canonical.z,
                    t.canonical.z,
                    t.canonical.x,
                    t.canonical.y
                  ),
            s = i ? this._alignedPosMatrixCache : this._posMatrixCache;
          if (s.has(a)) {
            const t = s.get(a);
            return r ? t.f32 : t.f64;
          }
          const o = yt(t, this.worldSize);
          e.Q(o, i ? this._alignedProjMatrix : this._viewProjMatrix, o);
          const l = { f64: o, f32: new Float32Array(o) };
          return s.set(a, l), r ? l.f32 : l.f64;
        }
        calculateFogMatrix(t) {
          const i = t.key,
            r = this._fogMatrixCacheF32;
          if (r.has(i)) return r.get(i);
          const n = yt(t, this.worldSize);
          return (
            e.Q(n, this._fogMatrix, n), r.set(i, new Float32Array(n)), r.get(i)
          );
        }
        calculateCenterFromCameraLngLatAlt(t, e, i, r) {
          return this._helper.calculateCenterFromCameraLngLatAlt(t, e, i, r);
        }
        _calculateNearFarZIfNeeded(t, i, r) {
          if (!this._helper.autoCalculateNearFarZ) return;
          const n = Math.min(
              this.elevation,
              this.minElevationForCurrentTile,
              this.getCameraAltitude() - 100
            ),
            a = t - (n * this._helper._pixelPerMeter) / Math.cos(i),
            s = n < 0 ? a : t,
            o = Math.PI / 2 + this.pitchInRadians,
            l =
              ((e.ak(this.fov) *
                (Math.abs(Math.cos(e.ak(this.roll))) * this.height +
                  Math.abs(Math.sin(e.ak(this.roll))) * this.width)) /
                this.height) *
              (0.5 + r.y / this.height),
            c =
              (Math.sin(l) * s) /
              Math.sin(e.ai(Math.PI - o - l, 0.01, Math.PI - 0.01)),
            h = _t(this),
            u = Math.atan(h / this._helper.cameraToCenterDistance),
            d = e.ak(0.75),
            p = u > d ? 2 * u * (0.5 + r.y / (2 * h)) : d,
            f =
              (Math.sin(p) * s) /
              Math.sin(e.ai(Math.PI - o - p, 0.01, Math.PI - 0.01)),
            m = Math.min(c, f);
          (this._helper._farZ = 1.01 * (Math.cos(Math.PI / 2 - i) * m + s)),
            (this._helper._nearZ = this._helper._height / 50);
        }
        _calcMatrices() {
          if (!this._helper._height) return;
          const t = this.centerOffset,
            i = mt(this.worldSize, this.center),
            r = i.x,
            n = i.y;
          this._helper._pixelPerMeter =
            e.an(1, this.center.lat) * this.worldSize;
          const a = e.ak(Math.min(this.pitch, ft)),
            s = Math.max(
              this._helper.cameraToCenterDistance / 2,
              this._helper.cameraToCenterDistance +
                (this._helper._elevation * this._helper._pixelPerMeter) /
                  Math.cos(a)
            );
          let o;
          this._calculateNearFarZIfNeeded(s, a, t),
            (o = new Float64Array(16)),
            e.b7(
              o,
              this.fovInRadians,
              this._helper._width / this._helper._height,
              this._helper._nearZ,
              this._helper._farZ
            ),
            (this._invProjMatrix = new Float64Array(16)),
            e.au(this._invProjMatrix, o),
            (o[8] = (2 * -t.x) / this._helper._width),
            (o[9] = (2 * t.y) / this._helper._height),
            (this._projectionMatrix = e.b8(o)),
            e.O(o, o, [1, -1, 1]),
            e.N(o, o, [0, 0, -this._helper.cameraToCenterDistance]),
            e.b9(o, o, -this.rollInRadians),
            e.ba(o, o, this.pitchInRadians),
            e.b9(o, o, -this.bearingInRadians),
            e.N(o, o, [-r, -n, 0]),
            (this._mercatorMatrix = e.O([], o, [
              this.worldSize,
              this.worldSize,
              this.worldSize,
            ])),
            e.O(o, o, [1, 1, this._helper._pixelPerMeter]),
            (this._pixelMatrix = e.Q(
              new Float64Array(16),
              this.clipSpaceToPixelsMatrix,
              o
            )),
            e.N(o, o, [0, 0, -this.elevation]),
            (this._viewProjMatrix = o),
            (this._invViewProjMatrix = e.au([], o));
          const l = [0, 0, -1, 1];
          e.aA(l, l, this._invViewProjMatrix),
            (this._cameraPosition = [l[0] / l[3], l[1] / l[3], l[2] / l[3]]),
            (this._fogMatrix = new Float64Array(16)),
            e.b7(
              this._fogMatrix,
              this.fovInRadians,
              this.width / this.height,
              s,
              this._helper._farZ
            ),
            (this._fogMatrix[8] = (2 * -t.x) / this.width),
            (this._fogMatrix[9] = (2 * t.y) / this.height),
            e.O(this._fogMatrix, this._fogMatrix, [1, -1, 1]),
            e.N(this._fogMatrix, this._fogMatrix, [
              0,
              0,
              -this.cameraToCenterDistance,
            ]),
            e.b9(this._fogMatrix, this._fogMatrix, -this.rollInRadians),
            e.ba(this._fogMatrix, this._fogMatrix, this.pitchInRadians),
            e.b9(this._fogMatrix, this._fogMatrix, -this.bearingInRadians),
            e.N(this._fogMatrix, this._fogMatrix, [-r, -n, 0]),
            e.O(this._fogMatrix, this._fogMatrix, [
              1,
              1,
              this._helper._pixelPerMeter,
            ]),
            e.N(this._fogMatrix, this._fogMatrix, [0, 0, -this.elevation]),
            (this._pixelMatrix3D = e.Q(
              new Float64Array(16),
              this.clipSpaceToPixelsMatrix,
              o
            ));
          const c = (this._helper._width % 2) / 2,
            h = (this._helper._height % 2) / 2,
            u = Math.cos(this.bearingInRadians),
            d = Math.sin(-this.bearingInRadians),
            p = r - Math.round(r) + u * c + d * h,
            f = n - Math.round(n) + u * h + d * c,
            m = new Float64Array(o);
          if (
            (e.N(m, m, [p > 0.5 ? p - 1 : p, f > 0.5 ? f - 1 : f, 0]),
            (this._alignedProjMatrix = m),
            (o = e.au(new Float64Array(16), this._pixelMatrix)),
            !o)
          )
            throw new Error('failed to invert matrix');
          (this._pixelMatrixInverse = o), this._clearMatrixCaches();
        }
        _clearMatrixCaches() {
          this._posMatrixCache.clear(),
            this._alignedPosMatrixCache.clear(),
            this._fogMatrixCacheF32.clear();
        }
        maxPitchScaleFactor() {
          if (!this._pixelMatrixInverse) return 1;
          const t = this.screenPointToMercatorCoordinate(new e.P(0, 0)),
            i = [t.x * this.worldSize, t.y * this.worldSize, 0, 1];
          return (
            e.aA(i, i, this._pixelMatrix)[3] /
            this._helper.cameraToCenterDistance
          );
        }
        getCameraPoint() {
          return this._helper.getCameraPoint();
        }
        getCameraAltitude() {
          return this._helper.getCameraAltitude();
        }
        getCameraLngLat() {
          const t = e.an(1, this.center.lat) * this.worldSize;
          return vt(
            this.center,
            this.elevation,
            this.pitch,
            this.bearing,
            this._helper.cameraToCenterDistance / t
          ).toLngLat();
        }
        lngLatToCameraDepth(t, i) {
          const r = e.a5.fromLngLat(t),
            n = [r.x * this.worldSize, r.y * this.worldSize, i, 1];
          return e.aA(n, n, this._viewProjMatrix), n[2] / n[3];
        }
        getProjectionData(t) {
          const { overscaledTileID: i, aligned: r, applyTerrainMatrix: n } = t,
            a = this._helper.getMercatorTileCoordinates(i),
            s = i ? this.calculatePosMatrix(i, r, !0) : null;
          let o;
          return (
            (o =
              i && i.terrainRttPosMatrix32f && n
                ? i.terrainRttPosMatrix32f
                : s || e.bb()),
            {
              mainMatrix: o,
              tileMercatorCoords: a,
              clippingPlane: [0, 0, 0, 0],
              projectionTransition: 0,
              fallbackMatrix: o,
            }
          );
        }
        isLocationOccluded(t) {
          return !1;
        }
        getPixelScale() {
          return 1;
        }
        getCircleRadiusCorrection() {
          return 1;
        }
        getPitchedTextCorrection(t, e, i) {
          return 1;
        }
        transformLightDirection(t) {
          return e.aW(t);
        }
        getRayDirectionFromPixel(t) {
          throw new Error('Not implemented.');
        }
        projectTileCoordinates(t, i, r, n) {
          const a = this.calculatePosMatrix(r);
          let s;
          n
            ? ((s = [t, i, n(t, i), 1]), e.aA(s, s, a))
            : ((s = [t, i, 0, 1]), Qt(s, s, a));
          const o = s[3];
          return {
            point: new e.P(s[0] / o, s[1] / o),
            signedDistanceFromCamera: o,
            isOccluded: !1,
          };
        }
        populateCache(t) {
          for (const e of t) this.calculatePosMatrix(e);
        }
        getMatrixForModel(t, i) {
          const r = e.a5.fromLngLat(t, i),
            n = r.meterInMercatorCoordinateUnits(),
            a = e.bc();
          return (
            e.N(a, a, [r.x, r.y, r.z]),
            e.b9(a, a, Math.PI),
            e.ba(a, a, Math.PI / 2),
            e.O(a, a, [-n, n, n]),
            a
          );
        }
        getProjectionDataForCustomLayer(t = !0) {
          const i = new e.a0(0, 0, 0, 0, 0),
            r = this.getProjectionData({
              overscaledTileID: i,
              applyGlobeMatrix: t,
            }),
            n = yt(i, this.worldSize);
          e.Q(n, this._viewProjMatrix, n),
            (r.tileMercatorCoords = [0, 0, 1, 1]);
          const a = [e.a3, e.a3, this.worldSize / this._helper.pixelsPerMeter],
            s = e.bd();
          return e.O(s, n, a), (r.fallbackMatrix = s), (r.mainMatrix = s), r;
        }
        getFastPathSimpleProjectionMatrix(t) {
          return this.calculatePosMatrix(t);
        }
      }
      function Ue() {
        e.w(
          'Map cannot fit within canvas with the given bounds, padding, and/or offset.'
        );
      }
      function Ge(t) {
        if (t.useSlerp)
          if (t.k < 1) {
            const i = e.be(
                t.startEulerAngles.roll,
                t.startEulerAngles.pitch,
                t.startEulerAngles.bearing
              ),
              r = e.be(
                t.endEulerAngles.roll,
                t.endEulerAngles.pitch,
                t.endEulerAngles.bearing
              ),
              n = new Float64Array(4);
            e.bf(n, i, r, t.k);
            const a = e.bg(n);
            t.tr.setRoll(a.roll),
              t.tr.setPitch(a.pitch),
              t.tr.setBearing(a.bearing);
          } else
            t.tr.setRoll(t.endEulerAngles.roll),
              t.tr.setPitch(t.endEulerAngles.pitch),
              t.tr.setBearing(t.endEulerAngles.bearing);
        else
          t.tr.setRoll(
            e.F.number(t.startEulerAngles.roll, t.endEulerAngles.roll, t.k)
          ),
            t.tr.setPitch(
              e.F.number(t.startEulerAngles.pitch, t.endEulerAngles.pitch, t.k)
            ),
            t.tr.setBearing(
              e.F.number(
                t.startEulerAngles.bearing,
                t.endEulerAngles.bearing,
                t.k
              )
            );
      }
      function Ze(t, i, r, n, a) {
        const s = a.padding,
          o = mt(a.worldSize, r.getNorthWest()),
          l = mt(a.worldSize, r.getNorthEast()),
          c = mt(a.worldSize, r.getSouthEast()),
          h = mt(a.worldSize, r.getSouthWest()),
          u = e.ak(-n),
          d = o.rotate(u),
          p = l.rotate(u),
          f = c.rotate(u),
          m = h.rotate(u),
          g = new e.P(
            Math.max(d.x, p.x, m.x, f.x),
            Math.max(d.y, p.y, m.y, f.y)
          ),
          _ = new e.P(
            Math.min(d.x, p.x, m.x, f.x),
            Math.min(d.y, p.y, m.y, f.y)
          ),
          y = g.sub(_),
          v = (a.width - (s.left + s.right + i.left + i.right)) / y.x,
          x = (a.height - (s.top + s.bottom + i.top + i.bottom)) / y.y;
        if (x < 0 || v < 0) return void Ue();
        const b = Math.min(e.ao(a.scale * Math.min(v, x)), t.maxZoom),
          w = e.P.convert(t.offset),
          T = new e.P((i.left - i.right) / 2, (i.top - i.bottom) / 2).rotate(
            e.ak(n)
          ),
          P = w.add(T).mult(a.scale / e.al(b));
        return {
          center: gt(a.worldSize, o.add(c).div(2).sub(P)),
          zoom: b,
          bearing: n,
        };
      }
      class $e {
        get useGlobeControls() {
          return !1;
        }
        handlePanInertia(t, e) {
          const i = t.mag(),
            r = Math.abs(_t(e));
          return {
            easingOffset: t.mult(Math.min((0.75 * r) / i, 1)),
            easingCenter: e.center,
          };
        }
        handleMapControlsRollPitchBearingZoom(t, e) {
          t.bearingDelta && e.setBearing(e.bearing + t.bearingDelta),
            t.pitchDelta && e.setPitch(e.pitch + t.pitchDelta),
            t.rollDelta && e.setRoll(e.roll + t.rollDelta),
            t.zoomDelta && e.setZoom(e.zoom + t.zoomDelta);
        }
        handleMapControlsPan(t, e, i) {
          t.around.distSqr(e.centerPoint) < 0.01 ||
            e.setLocationAtPoint(i, t.around);
        }
        cameraForBoxAndBearing(t, e, i, r, n) {
          return Ze(t, e, i, r, n);
        }
        handleJumpToCenterZoom(t, i) {
          t.zoom !== (void 0 !== i.zoom ? +i.zoom : t.zoom) &&
            t.setZoom(+i.zoom),
            void 0 !== i.center && t.setCenter(e.U.convert(i.center));
        }
        handleEaseTo(t, i) {
          const r = t.zoom,
            n = t.padding,
            a = { roll: t.roll, pitch: t.pitch, bearing: t.bearing },
            s = {
              roll: void 0 === i.roll ? t.roll : i.roll,
              pitch: void 0 === i.pitch ? t.pitch : i.pitch,
              bearing: void 0 === i.bearing ? t.bearing : i.bearing,
            },
            o = void 0 !== i.zoom,
            l = !t.isPaddingEqual(i.padding);
          let c = !1;
          const h = o ? +i.zoom : t.zoom;
          let u = t.centerPoint.add(i.offsetAsPoint);
          const d = t.screenPointToLocation(u),
            { center: p, zoom: f } = t.constrain(
              e.U.convert(i.center || d),
              null != h ? h : r
            );
          ke(t, p);
          const m = mt(t.worldSize, d),
            g = mt(t.worldSize, p).sub(m),
            _ = e.al(f - r);
          return (
            (c = f !== r),
            {
              easeFunc: (o) => {
                if (
                  (c && t.setZoom(e.F.number(r, f, o)),
                  e.bh(a, s) ||
                    Ge({
                      startEulerAngles: a,
                      endEulerAngles: s,
                      tr: t,
                      k: o,
                      useSlerp: a.roll != s.roll,
                    }),
                  l &&
                    (t.interpolatePadding(n, i.padding, o),
                    (u = t.centerPoint.add(i.offsetAsPoint))),
                  i.around)
                )
                  t.setLocationAtPoint(i.around, i.aroundPoint);
                else {
                  const i = e.al(t.zoom - r),
                    n = f > r ? Math.min(2, _) : Math.max(0.5, _),
                    a = Math.pow(n, 1 - o),
                    s = gt(t.worldSize, m.add(g.mult(o * a)).mult(i));
                  t.setLocationAtPoint(t.renderWorldCopies ? s.wrap() : s, u);
                }
              },
              isZooming: c,
              elevationCenter: p,
            }
          );
        }
        handleFlyTo(t, i) {
          const r = void 0 !== i.zoom,
            n = t.zoom,
            a = t.constrain(
              e.U.convert(i.center || i.locationAtOffset),
              r ? +i.zoom : n
            ),
            s = a.center,
            o = a.zoom;
          ke(t, s);
          const l = mt(t.worldSize, i.locationAtOffset),
            c = mt(t.worldSize, s).sub(l),
            h = c.mag(),
            u = e.al(o - n);
          let d;
          if (void 0 !== i.minZoom) {
            const r = Math.min(+i.minZoom, n, o),
              a = t.constrain(s, r).zoom;
            d = e.al(a - n);
          }
          return {
            easeFunc: (i, r, a, h) => {
              t.setZoom(1 === i ? o : n + e.ao(r));
              const u = 1 === i ? s : gt(t.worldSize, l.add(c.mult(a)).mult(r));
              t.setLocationAtPoint(t.renderWorldCopies ? u.wrap() : u, h);
            },
            scaleOfZoom: u,
            targetCenter: s,
            scaleOfMinZoom: d,
            pixelPathLength: h,
          };
        }
      }
      class qe {
        constructor(t, e, i) {
          (this.blendFunction = t), (this.blendColor = e), (this.mask = i);
        }
      }
      (qe.Replace = [1, 0]),
        (qe.disabled = new qe(qe.Replace, e.bi.transparent, [!1, !1, !1, !1])),
        (qe.unblended = new qe(qe.Replace, e.bi.transparent, [!0, !0, !0, !0])),
        (qe.alphaBlended = new qe([1, 771], e.bi.transparent, [
          !0,
          !0,
          !0,
          !0,
        ]));
      const He = 2305;
      class We {
        constructor(t, e, i) {
          (this.enable = t), (this.mode = e), (this.frontFace = i);
        }
      }
      (We.disabled = new We(!1, 1029, He)),
        (We.backCCW = new We(!0, 1029, He)),
        (We.frontCCW = new We(!0, 1028, He));
      class Xe {
        constructor(t, e, i) {
          (this.func = t), (this.mask = e), (this.range = i);
        }
      }
      (Xe.ReadOnly = !1),
        (Xe.ReadWrite = !0),
        (Xe.disabled = new Xe(519, Xe.ReadOnly, [0, 1]));
      const Ye = 7680;
      class Ke {
        constructor(t, e, i, r, n, a) {
          (this.test = t),
            (this.ref = e),
            (this.mask = i),
            (this.fail = r),
            (this.depthFail = n),
            (this.pass = a);
        }
      }
      Ke.disabled = new Ke({ func: 519, mask: 0 }, 0, 0, Ye, Ye, Ye);
      const Je = new WeakMap();
      function Qe(t) {
        var e;
        if (Je.has(t)) return Je.get(t);
        {
          const i =
            null === (e = t.getParameter(t.VERSION)) || void 0 === e
              ? void 0
              : e.startsWith('WebGL 2.0');
          return Je.set(t, i), i;
        }
      }
      class ti {
        get awaitingQuery() {
          return !!this._readbackQueue;
        }
        constructor(t) {
          (this._readbackWaitFrames = 4),
            (this._measureWaitFrames = 6),
            (this._texWidth = 1),
            (this._texHeight = 1),
            (this._measuredError = 0),
            (this._updateCount = 0),
            (this._lastReadbackFrame = -1e3),
            (this._readbackQueue = null),
            (this._cachedRenderContext = t);
          const i = t.context,
            r = i.gl;
          (this._texFormat = r.RGBA), (this._texType = r.UNSIGNED_BYTE);
          const n = new e.aP();
          n.emplaceBack(-1, -1), n.emplaceBack(2, -1), n.emplaceBack(-1, 2);
          const a = new e.aR();
          a.emplaceBack(0, 1, 2),
            (this._fullscreenTriangle = new De(
              i.createVertexBuffer(n, Le.members),
              i.createIndexBuffer(a),
              e.aQ.simpleSegment(0, 0, n.length, a.length)
            )),
            (this._resultBuffer = new Uint8Array(4)),
            i.activeTexture.set(r.TEXTURE1);
          const s = r.createTexture();
          r.bindTexture(r.TEXTURE_2D, s),
            r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_S, r.CLAMP_TO_EDGE),
            r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_T, r.CLAMP_TO_EDGE),
            r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MIN_FILTER, r.NEAREST),
            r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MAG_FILTER, r.NEAREST),
            r.texImage2D(
              r.TEXTURE_2D,
              0,
              this._texFormat,
              this._texWidth,
              this._texHeight,
              0,
              this._texFormat,
              this._texType,
              null
            ),
            (this._fbo = i.createFramebuffer(
              this._texWidth,
              this._texHeight,
              !1,
              !1
            )),
            this._fbo.colorAttachment.set(s),
            Qe(r) &&
              ((this._pbo = r.createBuffer()),
              r.bindBuffer(r.PIXEL_PACK_BUFFER, this._pbo),
              r.bufferData(r.PIXEL_PACK_BUFFER, 4, r.STREAM_READ),
              r.bindBuffer(r.PIXEL_PACK_BUFFER, null));
        }
        destroy() {
          const t = this._cachedRenderContext.context.gl;
          this._fullscreenTriangle.destroy(),
            this._fbo.destroy(),
            t.deleteBuffer(this._pbo),
            (this._fullscreenTriangle = null),
            (this._fbo = null),
            (this._pbo = null),
            (this._resultBuffer = null);
        }
        updateErrorLoop(t, e) {
          const i = this._updateCount;
          return (
            this._readbackQueue
              ? i >=
                  this._readbackQueue.frameNumberIssued +
                    this._readbackWaitFrames && this._tryReadback()
              : i >= this._lastReadbackFrame + this._measureWaitFrames &&
                this._renderErrorTexture(t, e),
            this._updateCount++,
            this._measuredError
          );
        }
        _bindFramebuffer() {
          const t = this._cachedRenderContext.context,
            e = t.gl;
          t.activeTexture.set(e.TEXTURE1),
            e.bindTexture(e.TEXTURE_2D, this._fbo.colorAttachment.get()),
            t.bindFramebuffer.set(this._fbo.framebuffer);
        }
        _renderErrorTexture(t, i) {
          const r = this._cachedRenderContext.context,
            n = r.gl;
          if (
            (this._bindFramebuffer(),
            r.viewport.set([0, 0, this._texWidth, this._texHeight]),
            r.clear({ color: e.bi.transparent }),
            this._cachedRenderContext
              .useProgram('projectionErrorMeasurement')
              .draw(
                r,
                n.TRIANGLES,
                Xe.disabled,
                Ke.disabled,
                qe.unblended,
                We.disabled,
                ((t, e) => ({ u_input: t, u_output_expected: e }))(t, i),
                null,
                null,
                '$clipping',
                this._fullscreenTriangle.vertexBuffer,
                this._fullscreenTriangle.indexBuffer,
                this._fullscreenTriangle.segments
              ),
            this._pbo && Qe(n))
          ) {
            n.bindBuffer(n.PIXEL_PACK_BUFFER, this._pbo),
              n.readBuffer(n.COLOR_ATTACHMENT0),
              n.readPixels(
                0,
                0,
                this._texWidth,
                this._texHeight,
                this._texFormat,
                this._texType,
                0
              ),
              n.bindBuffer(n.PIXEL_PACK_BUFFER, null);
            const t = n.fenceSync(n.SYNC_GPU_COMMANDS_COMPLETE, 0);
            n.flush(),
              (this._readbackQueue = {
                frameNumberIssued: this._updateCount,
                sync: t,
              });
          } else this._readbackQueue = { frameNumberIssued: this._updateCount, sync: null };
        }
        _tryReadback() {
          const t = this._cachedRenderContext.context.gl;
          if (this._pbo && this._readbackQueue && Qe(t)) {
            const i = t.clientWaitSync(this._readbackQueue.sync, 0, 0);
            if (i === t.WAIT_FAILED)
              return (
                e.w('WebGL2 clientWaitSync failed.'),
                (this._readbackQueue = null),
                void (this._lastReadbackFrame = this._updateCount)
              );
            if (i === t.TIMEOUT_EXPIRED) return;
            t.bindBuffer(t.PIXEL_PACK_BUFFER, this._pbo),
              t.getBufferSubData(
                t.PIXEL_PACK_BUFFER,
                0,
                this._resultBuffer,
                0,
                4
              ),
              t.bindBuffer(t.PIXEL_PACK_BUFFER, null);
          } else this._bindFramebuffer(), t.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, this._resultBuffer);
          (this._readbackQueue = null),
            (this._measuredError = ti._parseRGBA8float(this._resultBuffer)),
            (this._lastReadbackFrame = this._updateCount);
        }
        static _parseRGBA8float(t) {
          let e = 0;
          return (
            (e += t[0] / 256),
            (e += t[1] / 65536),
            (e += t[2] / 16777216),
            t[3] < 127 && (e = -e),
            e / 128
          );
        }
      }
      const ei = e.a3 / 128;
      function ii(t, i) {
        const r = void 0 !== t.granularity ? Math.max(t.granularity, 1) : 1,
          n = r + (t.generateBorders ? 2 : 0),
          a =
            r +
            (t.extendToNorthPole || t.generateBorders ? 1 : 0) +
            (t.extendToSouthPole || t.generateBorders ? 1 : 0),
          s = n + 1,
          o = a + 1,
          l = t.generateBorders ? -1 : 0,
          c = t.generateBorders || t.extendToNorthPole ? -1 : 0,
          h = r + (t.generateBorders ? 1 : 0),
          u = r + (t.generateBorders || t.extendToSouthPole ? 1 : 0),
          d = s * o,
          p = n * a * 6,
          f = s * o > 65536;
        if (f && '16bit' === i)
          throw new Error(
            'Granularity is too large and meshes would not fit inside 16 bit vertex indices.'
          );
        const m = f || '32bit' === i,
          g = new Int16Array(2 * d);
        let _ = 0;
        for (let x = c; x <= u; x++)
          for (let i = l; i <= h; i++) {
            let n = (i / r) * e.a3;
            -1 === i && (n = -ei), i === r + 1 && (n = e.a3 + ei);
            let a = (x / r) * e.a3;
            -1 === x && (a = t.extendToNorthPole ? e.bk : -ei),
              x === r + 1 && (a = t.extendToSouthPole ? e.bl : e.a3 + ei),
              (g[_++] = n),
              (g[_++] = a);
          }
        const y = m ? new Uint32Array(p) : new Uint16Array(p);
        let v = 0;
        for (let e = 0; e < a; e++)
          for (let t = 0; t < n; t++) {
            const i = t + 1 + e * s,
              r = t + (e + 1) * s,
              n = t + 1 + (e + 1) * s;
            (y[v++] = t + e * s),
              (y[v++] = r),
              (y[v++] = i),
              (y[v++] = i),
              (y[v++] = r),
              (y[v++] = n);
          }
        return {
          vertices: g.buffer.slice(0),
          indices: y.buffer.slice(0),
          uses32bitIndices: m,
        };
      }
      const ri = new e.aO({
        fill: new e.bm(128, 2),
        line: new e.bm(512, 0),
        tile: new e.bm(128, 32),
        stencil: new e.bm(128, 1),
        circle: 3,
      });
      class ni {
        constructor() {
          (this._tileMeshCache = {}),
            (this._errorCorrectionUsable = 0),
            (this._errorMeasurementLastValue = 0),
            (this._errorCorrectionPreviousValue = 0),
            (this._errorMeasurementLastChangeTime = -1e3);
        }
        get name() {
          return 'vertical-perspective';
        }
        get transitionState() {
          return 1;
        }
        get useSubdivision() {
          return !0;
        }
        get shaderVariantName() {
          return 'globe';
        }
        get shaderDefine() {
          return '#define GLOBE';
        }
        get shaderPreludeCode() {
          return Se.projectionGlobe;
        }
        get vertexShaderPreludeCode() {
          return Se.projectionMercator.vertexSource;
        }
        get subdivisionGranularity() {
          return ri;
        }
        get useGlobeControls() {
          return !0;
        }
        get latitudeErrorCorrectionRadians() {
          return this._errorCorrectionUsable;
        }
        destroy() {
          this._errorMeasurement && this._errorMeasurement.destroy();
        }
        updateGPUdependent(t) {
          this._errorMeasurement || (this._errorMeasurement = new ti(t));
          const i = e.W(this._errorQueryLatitudeDegrees),
            r =
              2 * Math.atan(Math.exp(Math.PI - i * Math.PI * 2)) -
              0.5 * Math.PI,
            n = this._errorMeasurement.updateErrorLoop(i, r),
            a = l();
          n !== this._errorMeasurementLastValue &&
            ((this._errorCorrectionPreviousValue = this._errorCorrectionUsable),
            (this._errorMeasurementLastValue = n),
            (this._errorMeasurementLastChangeTime = a));
          const s = Math.min(
            Math.max((a - this._errorMeasurementLastChangeTime) / 1e3 / 0.5, 0),
            1
          );
          this._errorCorrectionUsable = e.bn(
            this._errorCorrectionPreviousValue,
            -this._errorMeasurementLastValue,
            e.bo(s)
          );
        }
        _getMeshKey(t) {
          return `${t.granularity.toString(
            36
          )}_${t.generateBorders ? 'b' : ''}${t.extendToNorthPole ? 'n' : ''}${t.extendToSouthPole ? 's' : ''}`;
        }
        getMeshFromTileID(t, e, i, r, n) {
          const a = (
            'stencil' === n ? ri.stencil : ri.tile
          ).getGranularityForZoomLevel(e.z);
          return this._getMesh(t, {
            granularity: a,
            generateBorders: i,
            extendToNorthPole: 0 === e.y && r,
            extendToSouthPole: e.y === (1 << e.z) - 1 && r,
          });
        }
        _getMesh(t, i) {
          const r = this._getMeshKey(i);
          if (r in this._tileMeshCache) return this._tileMeshCache[r];
          const n = (function (t, i) {
            const r = ii(i, '16bit'),
              n = e.aP.deserialize({
                arrayBuffer: r.vertices,
                length: r.vertices.byteLength / 2 / 2,
              }),
              a = e.aR.deserialize({
                arrayBuffer: r.indices,
                length: r.indices.byteLength / 2 / 3,
              });
            return new De(
              t.createVertexBuffer(n, Le.members),
              t.createIndexBuffer(a),
              e.aQ.simpleSegment(0, 0, n.length, a.length)
            );
          })(t, i);
          return (this._tileMeshCache[r] = n), n;
        }
        recalculate(t) {}
        hasTransition() {
          const t = l();
          let e = !1;
          return (
            (e = e || (t - this._errorMeasurementLastChangeTime) / 1e3 < 0.7),
            (e =
              e ||
              (this._errorMeasurement && this._errorMeasurement.awaitingQuery)),
            e
          );
        }
        setErrorQueryLatitudeDegrees(t) {
          this._errorQueryLatitudeDegrees = t;
        }
      }
      const ai = new e.r({ type: new e.D(e.t.projection.type) });
      class si extends e.E {
        constructor(t) {
          super(),
            (this._transitionable = new e.x(ai, void 0)),
            this.setProjection(t),
            (this._transitioning = this._transitionable.untransitioned()),
            this.recalculate(new e.G(0)),
            (this._mercatorProjection = new Re()),
            (this._verticalPerspectiveProjection = new ni());
        }
        get transitionState() {
          const t = this.properties.get('type');
          if ('string' == typeof t && 'mercator' === t) return 0;
          if ('string' == typeof t && 'vertical-perspective' === t) return 1;
          if (t instanceof e.bp) {
            if ('vertical-perspective' === t.from && 'mercator' === t.to)
              return 1 - t.transition;
            if ('mercator' === t.from && 'vertical-perspective' === t.to)
              return t.transition;
          }
          return 1;
        }
        get useGlobeRendering() {
          return this.transitionState > 0;
        }
        get latitudeErrorCorrectionRadians() {
          return this
            ._verticalPerspectiveProjection.latitudeErrorCorrectionRadians;
        }
        get currentProjection() {
          return this.useGlobeRendering
            ? this._verticalPerspectiveProjection
            : this._mercatorProjection;
        }
        get name() {
          return 'globe';
        }
        get useSubdivision() {
          return this.currentProjection.useSubdivision;
        }
        get shaderVariantName() {
          return this.currentProjection.shaderVariantName;
        }
        get shaderDefine() {
          return this.currentProjection.shaderDefine;
        }
        get shaderPreludeCode() {
          return this.currentProjection.shaderPreludeCode;
        }
        get vertexShaderPreludeCode() {
          return this.currentProjection.vertexShaderPreludeCode;
        }
        get subdivisionGranularity() {
          return this.currentProjection.subdivisionGranularity;
        }
        get useGlobeControls() {
          return this.transitionState > 0;
        }
        destroy() {
          this._mercatorProjection.destroy(),
            this._verticalPerspectiveProjection.destroy();
        }
        updateGPUdependent(t) {
          this._mercatorProjection.updateGPUdependent(t),
            this._verticalPerspectiveProjection.updateGPUdependent(t);
        }
        getMeshFromTileID(t, e, i, r, n) {
          return this.currentProjection.getMeshFromTileID(t, e, i, r, n);
        }
        setProjection(t) {
          this._transitionable.setValue(
            'type',
            (null == t ? void 0 : t.type) || 'mercator'
          );
        }
        updateTransitions(t) {
          this._transitioning = this._transitionable.transitioned(
            t,
            this._transitioning
          );
        }
        hasTransition() {
          return (
            this._transitioning.hasTransition() ||
            this.currentProjection.hasTransition()
          );
        }
        recalculate(t) {
          this.properties = this._transitioning.possiblyEvaluate(t);
        }
        setErrorQueryLatitudeDegrees(t) {
          this._verticalPerspectiveProjection.setErrorQueryLatitudeDegrees(t),
            this._mercatorProjection.setErrorQueryLatitudeDegrees(t);
        }
      }
      function oi(t) {
        const e = hi(t.worldSize, t.center.lat);
        return 2 * Math.PI * e;
      }
      function li(t, i, r, n, a) {
        const s = 1 / (1 << a),
          o = (i / e.a3) * s + n * s,
          l = e.br(
            ((t / e.a3) * s + r * s) * Math.PI * 2 + Math.PI,
            2 * Math.PI
          ),
          c =
            2 * Math.atan(Math.exp(Math.PI - o * Math.PI * 2)) - 0.5 * Math.PI,
          h = Math.cos(c),
          u = new Float64Array(3);
        return (
          (u[0] = Math.sin(l) * h),
          (u[1] = Math.sin(c)),
          (u[2] = Math.cos(l) * h),
          u
        );
      }
      function ci(t) {
        return (function (t, e) {
          const i = Math.cos(e),
            r = new Float64Array(3);
          return (
            (r[0] = Math.sin(t) * i),
            (r[1] = Math.sin(e)),
            (r[2] = Math.cos(t) * i),
            r
          );
        })((t.lng * Math.PI) / 180, (t.lat * Math.PI) / 180);
      }
      function hi(t, e) {
        return t / (2 * Math.PI) / Math.cos((e * Math.PI) / 180);
      }
      function ui(t) {
        const i = (Math.asin(t[1]) / Math.PI) * 180,
          r = Math.sqrt(t[0] * t[0] + t[2] * t[2]);
        if (r > 1e-6) {
          const n = t[0] / r,
            a = Math.acos(t[2] / r),
            s = ((n > 0 ? a : -a) / Math.PI) * 180;
          return new e.U(e.V(s, -180, 180), i);
        }
        return new e.U(0, i);
      }
      function di(t) {
        return Math.cos((t * Math.PI) / 180);
      }
      function pi(t, i) {
        const r = di(t),
          n = di(i);
        return e.ao(n / r);
      }
      function fi(t, i) {
        const r = t.rotate(i.bearingInRadians),
          n = i.zoom + pi(i.center.lat, 0),
          a = e.bn(
            1 / di(i.center.lat),
            1 / di(Math.min(Math.abs(i.center.lat), 60)),
            e.bq(n, 7, 3, 0, 1)
          ),
          s =
            360 / oi({ worldSize: i.worldSize, center: { lat: i.center.lat } });
        return new e.U(
          i.center.lng - r.x * s * a,
          e.ai(i.center.lat + r.y * s, -e.aj, e.aj)
        );
      }
      function mi(t) {
        const e = 0.5 * t,
          i = Math.sin(e),
          r = Math.cos(e);
        return Math.log(i + r) - Math.log(r - i);
      }
      function gi(t, i, r, n) {
        const a = t.lat + r * n;
        if (Math.abs(r) > 1) {
          const s =
              ((Math.sign(t.lat + r) !== Math.sign(t.lat)
                ? -Math.abs(t.lat)
                : Math.abs(t.lat)) *
                Math.PI) /
              180,
            o = (Math.abs(t.lat + r) * Math.PI) / 180,
            l = mi(s + n * (o - s)),
            c = mi(s),
            h = mi(o);
          return new e.U(t.lng + i * ((l - c) / (h - c)), a);
        }
        return new e.U(t.lng + i * n, a);
      }
      class _i {
        constructor(t) {
          (this._cachePrevious = new Map()),
            (this._cache = new Map()),
            (this._hadAnyChanges = !1),
            (this._boundingVolumeFactory = t);
        }
        swapBuffers() {
          if (!this._hadAnyChanges) return;
          const t = this._cachePrevious;
          (this._cachePrevious = this._cache),
            (this._cache = t),
            this._cache.clear(),
            (this._hadAnyChanges = !1);
        }
        getTileBoundingVolume(t, e, i, r) {
          const n = `${t.z}_${t.x}_${t.y}_${
              (null == r ? void 0 : r.terrain) ? 't' : ''
            }`,
            a = this._cache.get(n);
          if (a) return a;
          const s = this._cachePrevious.get(n);
          if (s) return this._cache.set(n, s), s;
          const o = this._boundingVolumeFactory(t, e, i, r);
          return this._cache.set(n, o), (this._hadAnyChanges = !0), o;
        }
      }
      class yi {
        constructor(t, e, i, r) {
          (this.min = i), (this.max = r), (this.points = t), (this.planes = e);
        }
        static fromAabb(t, e) {
          const i = [];
          for (let r = 0; r < 8; r++)
            i.push([
              1 & ~r ? t[0] : e[0],
              1 == ((r >> 1) & 1) ? e[1] : t[1],
              1 == ((r >> 2) & 1) ? e[2] : t[2],
            ]);
          return new yi(
            i,
            [
              [-1, 0, 0, e[0]],
              [1, 0, 0, -t[0]],
              [0, -1, 0, e[1]],
              [0, 1, 0, -t[1]],
              [0, 0, -1, e[2]],
              [0, 0, 1, -t[2]],
            ],
            t,
            e
          );
        }
        static fromCenterSizeAngles(t, i, r) {
          const n = e.bu([], r[0], r[1], r[2]),
            a = e.bv([], [i[0], 0, 0], n),
            s = e.bv([], [0, i[1], 0], n),
            o = e.bv([], [0, 0, i[2]], n),
            l = [...t],
            c = [...t];
          for (let e = 0; e < 8; e++)
            for (let i = 0; i < 3; i++) {
              const r =
                t[i] +
                a[i] * (1 & ~e ? -1 : 1) +
                s[i] * (1 == ((e >> 1) & 1) ? 1 : -1) +
                o[i] * (1 == ((e >> 2) & 1) ? 1 : -1);
              (l[i] = Math.min(l[i], r)), (c[i] = Math.max(c[i], r));
            }
          const h = [];
          for (let u = 0; u < 8; u++) {
            const i = [...t];
            e.aV(i, i, e.aU([], a, 1 & ~u ? -1 : 1)),
              e.aV(i, i, e.aU([], s, 1 == ((u >> 1) & 1) ? 1 : -1)),
              e.aV(i, i, e.aU([], o, 1 == ((u >> 2) & 1) ? 1 : -1)),
              h.push(i);
          }
          return new yi(
            h,
            [
              [...a, -e.a_(a, h[0])],
              [...s, -e.a_(s, h[0])],
              [...o, -e.a_(o, h[0])],
              [-a[0], -a[1], -a[2], -e.a_(a, h[7])],
              [-s[0], -s[1], -s[2], -e.a_(s, h[7])],
              [-o[0], -o[1], -o[2], -e.a_(o, h[7])],
            ],
            l,
            c
          );
        }
        intersectsFrustum(t) {
          let e = !0;
          const i = this.points.length,
            r = this.planes.length,
            n = t.planes.length,
            a = t.points.length;
          for (let s = 0; s < n; s++) {
            const r = t.planes[s];
            let n = 0;
            for (let t = 0; t < i; t++) {
              const e = this.points[t];
              r[0] * e[0] + r[1] * e[1] + r[2] * e[2] + r[3] >= 0 && n++;
            }
            if (0 === n) return 0;
            n < i && (e = !1);
          }
          if (e) return 2;
          for (let s = 0; s < r; s++) {
            const e = this.planes[s];
            let i = 0;
            for (let r = 0; r < a; r++) {
              const n = t.points[r];
              e[0] * n[0] + e[1] * n[1] + e[2] * n[2] + e[3] >= 0 && i++;
            }
            if (0 === i) return 0;
          }
          return 1;
        }
        intersectsPlane(t) {
          const e = this.points.length;
          let i = 0;
          for (let r = 0; r < e; r++) {
            const e = this.points[r];
            t[0] * e[0] + t[1] * e[1] + t[2] * e[2] + t[3] >= 0 && i++;
          }
          return i === e ? 2 : 0 === i ? 0 : 1;
        }
      }
      function vi(t, e, i) {
        const r = t - e;
        return r < 0 ? -r : Math.max(0, r - i);
      }
      function xi(t, e, i, r, n) {
        const a = t - i;
        let s;
        return (
          (s =
            a < 0
              ? Math.min(-a, 1 + a - n)
              : a > 1
              ? Math.min(Math.max(a - n, 0), 1 - a)
              : 0),
          Math.max(s, vi(e, r, n))
        );
      }
      class bi {
        constructor() {
          this._boundingVolumeCache = new _i(this._computeTileBoundingVolume);
        }
        prepareNextFrame() {
          this._boundingVolumeCache.swapBuffers();
        }
        distanceToTile2d(t, e, i, r) {
          const n = 1 << i.z,
            a = 1 / n,
            s = i.x / n,
            o = i.y / n;
          let l = 2;
          return (
            (l = Math.min(l, xi(t, e, s, o, a))),
            (l = Math.min(l, xi(t, e, s + 0.5, -o - a, a))),
            (l = Math.min(l, xi(t, e, s + 0.5, 2 - o - a, a))),
            l
          );
        }
        getWrap(t, e, i) {
          const r = 1 << e.z,
            n = 1 / r,
            a = e.x / r,
            s = vi(t.x, a, n),
            o = vi(t.x, a - 1, n),
            l = vi(t.x, a + 1, n),
            c = Math.min(s, o, l);
          return c === l ? 1 : c === o ? -1 : 0;
        }
        allowVariableZoom(t, e) {
          return Pt(t, e) > 4;
        }
        allowWorldCopies() {
          return !1;
        }
        getTileBoundingVolume(t, e, i, r) {
          return this._boundingVolumeCache.getTileBoundingVolume(t, e, i, r);
        }
        _computeTileBoundingVolume(t, i, r, n) {
          var a, s;
          let o = 0,
            l = 0;
          if (null == n ? void 0 : n.terrain) {
            const c = new e.a0(t.z, i, t.z, t.x, t.y),
              h = n.terrain.getMinMaxElevation(c);
            (o =
              null !== (a = h.minElevation) && void 0 !== a
                ? a
                : Math.min(0, r)),
              (l =
                null !== (s = h.maxElevation) && void 0 !== s
                  ? s
                  : Math.max(0, r));
          }
          if (((o /= e.bx), (l /= e.bx), (o += 1), (l += 1), t.z <= 0))
            return yi.fromAabb([-l, -l, -l], [l, l, l]);
          if (1 === t.z)
            return yi.fromAabb(
              [0 === t.x ? -l : 0, 0 === t.y ? 0 : -l, -l],
              [0 === t.x ? 0 : l, 0 === t.y ? l : 0, l]
            );
          {
            const i = [
                li(0, 0, t.x, t.y, t.z),
                li(e.a3, 0, t.x, t.y, t.z),
                li(e.a3, e.a3, t.x, t.y, t.z),
                li(0, e.a3, t.x, t.y, t.z),
              ],
              r = [];
            for (const t of i) r.push(e.aU([], t, l));
            if (l !== o) for (const t of i) r.push(e.aU([], t, o));
            0 === t.y && r.push([0, 1, 0]),
              t.y === (1 << t.z) - 1 && r.push([0, -1, 0]);
            const n = [1, 1, 1],
              a = [-1, -1, -1];
            for (const t of r)
              for (let e = 0; e < 3; e++)
                (n[e] = Math.min(n[e], t[e])), (a[e] = Math.max(a[e], t[e]));
            const s = li(e.a3 / 2, e.a3 / 2, t.x, t.y, t.z),
              c = e.aZ([], [0, 1, 0], s);
            e.aY(c, c);
            const h = e.aZ([], s, c);
            e.aY(h, h);
            const u = e.aZ([], i[2], i[1]);
            e.aY(u, u);
            const d = e.aZ([], i[0], i[3]);
            e.aY(d, d),
              r.push(e.aU([], s, l)),
              t.y >= (1 << t.z) / 2 &&
                r.push(e.aU([], li(e.a3 / 2, 0, t.x, t.y, t.z), l)),
              t.y < (1 << t.z) / 2 &&
                r.push(e.aU([], li(e.a3 / 2, e.a3, t.x, t.y, t.z), l));
            const p = wi(s, r),
              f = wi(h, r),
              m = [-s[0], -s[1], -s[2], p.max],
              g = [s[0], s[1], s[2], -p.min],
              _ = [-h[0], -h[1], -h[2], f.max],
              y = [h[0], h[1], h[2], -f.min],
              v = [...u, 0],
              x = [...d, 0],
              b = [];
            return (
              0 === t.y
                ? b.push(e.bw(x, v, m), e.bw(x, v, g))
                : b.push(
                    e.bw(_, v, m),
                    e.bw(_, v, g),
                    e.bw(_, x, m),
                    e.bw(_, x, g)
                  ),
              t.y === (1 << t.z) - 1
                ? b.push(e.bw(x, v, m), e.bw(x, v, g))
                : b.push(
                    e.bw(y, v, m),
                    e.bw(y, v, g),
                    e.bw(y, x, m),
                    e.bw(y, x, g)
                  ),
              new yi(b, [m, g, _, y, v, x], n, a)
            );
          }
        }
      }
      function wi(t, i) {
        let r = 1 / 0,
          n = -1 / 0;
        for (const a of i) {
          const i = e.a_(t, a);
          (r = Math.min(r, i)), (n = Math.max(n, i));
        }
        return { min: r, max: n };
      }
      class Ti {
        get pixelsToClipSpaceMatrix() {
          return this._helper.pixelsToClipSpaceMatrix;
        }
        get clipSpaceToPixelsMatrix() {
          return this._helper.clipSpaceToPixelsMatrix;
        }
        get pixelsToGLUnits() {
          return this._helper.pixelsToGLUnits;
        }
        get centerOffset() {
          return this._helper.centerOffset;
        }
        get size() {
          return this._helper.size;
        }
        get rotationMatrix() {
          return this._helper.rotationMatrix;
        }
        get centerPoint() {
          return this._helper.centerPoint;
        }
        get pixelsPerMeter() {
          return this._helper.pixelsPerMeter;
        }
        setMinZoom(t) {
          this._helper.setMinZoom(t);
        }
        setMaxZoom(t) {
          this._helper.setMaxZoom(t);
        }
        setMinPitch(t) {
          this._helper.setMinPitch(t);
        }
        setMaxPitch(t) {
          this._helper.setMaxPitch(t);
        }
        setRenderWorldCopies(t) {
          this._helper.setRenderWorldCopies(t);
        }
        setBearing(t) {
          this._helper.setBearing(t);
        }
        setPitch(t) {
          this._helper.setPitch(t);
        }
        setRoll(t) {
          this._helper.setRoll(t);
        }
        setFov(t) {
          this._helper.setFov(t);
        }
        setZoom(t) {
          this._helper.setZoom(t);
        }
        setCenter(t) {
          this._helper.setCenter(t);
        }
        setElevation(t) {
          this._helper.setElevation(t);
        }
        setMinElevationForCurrentTile(t) {
          this._helper.setMinElevationForCurrentTile(t);
        }
        setPadding(t) {
          this._helper.setPadding(t);
        }
        interpolatePadding(t, e, i) {
          return this._helper.interpolatePadding(t, e, i);
        }
        isPaddingEqual(t) {
          return this._helper.isPaddingEqual(t);
        }
        resize(t, e) {
          this._helper.resize(t, e);
        }
        getMaxBounds() {
          return this._helper.getMaxBounds();
        }
        setMaxBounds(t) {
          this._helper.setMaxBounds(t);
        }
        setConstrain(t) {
          this._helper.setConstrain(t);
        }
        overrideNearFarZ(t, e) {
          this._helper.overrideNearFarZ(t, e);
        }
        clearNearFarZOverride() {
          this._helper.clearNearFarZOverride();
        }
        getCameraQueryGeometry(t) {
          return this._helper.getCameraQueryGeometry(this.getCameraPoint(), t);
        }
        get tileSize() {
          return this._helper.tileSize;
        }
        get tileZoom() {
          return this._helper.tileZoom;
        }
        get scale() {
          return this._helper.scale;
        }
        get worldSize() {
          return this._helper.worldSize;
        }
        get width() {
          return this._helper.width;
        }
        get height() {
          return this._helper.height;
        }
        get lngRange() {
          return this._helper.lngRange;
        }
        get latRange() {
          return this._helper.latRange;
        }
        get minZoom() {
          return this._helper.minZoom;
        }
        get maxZoom() {
          return this._helper.maxZoom;
        }
        get zoom() {
          return this._helper.zoom;
        }
        get center() {
          return this._helper.center;
        }
        get minPitch() {
          return this._helper.minPitch;
        }
        get maxPitch() {
          return this._helper.maxPitch;
        }
        get pitch() {
          return this._helper.pitch;
        }
        get pitchInRadians() {
          return this._helper.pitchInRadians;
        }
        get roll() {
          return this._helper.roll;
        }
        get rollInRadians() {
          return this._helper.rollInRadians;
        }
        get bearing() {
          return this._helper.bearing;
        }
        get bearingInRadians() {
          return this._helper.bearingInRadians;
        }
        get fov() {
          return this._helper.fov;
        }
        get fovInRadians() {
          return this._helper.fovInRadians;
        }
        get elevation() {
          return this._helper.elevation;
        }
        get minElevationForCurrentTile() {
          return this._helper.minElevationForCurrentTile;
        }
        get padding() {
          return this._helper.padding;
        }
        get unmodified() {
          return this._helper.unmodified;
        }
        get renderWorldCopies() {
          return this._helper.renderWorldCopies;
        }
        get constrain() {
          return this._helper.constrain;
        }
        get nearZ() {
          return this._helper.nearZ;
        }
        get farZ() {
          return this._helper.farZ;
        }
        get autoCalculateNearFarZ() {
          return this._helper.autoCalculateNearFarZ;
        }
        setTransitionState(t) {}
        constructor(t) {
          (this._cachedClippingPlane = e.by()),
            (this._projectionMatrix = e.bc()),
            (this._globeViewProjMatrix32f = e.bb()),
            (this._globeViewProjMatrixNoCorrection = e.bc()),
            (this._globeViewProjMatrixNoCorrectionInverted = e.bc()),
            (this._globeProjMatrixInverted = e.bc()),
            (this._cameraPosition = e.bs()),
            (this._globeLatitudeErrorCorrectionRadians = 0),
            (this.defaultConstrain = (t, i) => {
              const r = e.ai(t.lat, -e.aj, e.aj),
                n = e.ai(+i, this.minZoom + pi(0, r), this.maxZoom);
              return { center: new e.U(t.lng, r), zoom: n };
            }),
            (this._helper = new Fe(
              {
                calcMatrices: () => {
                  this._calcMatrices();
                },
                constrain: (t, e) => this.defaultConstrain(t, e),
              },
              t
            )),
            (this._coveringTilesDetailsProvider = new bi());
        }
        clone() {
          const t = new Ti();
          return t.apply(this), t;
        }
        apply(t, e) {
          (this._globeLatitudeErrorCorrectionRadians = e || 0),
            this._helper.apply(t);
        }
        get projectionMatrix() {
          return this._projectionMatrix;
        }
        get modelViewProjectionMatrix() {
          return this._globeViewProjMatrixNoCorrection;
        }
        get inverseProjectionMatrix() {
          return this._globeProjMatrixInverted;
        }
        get cameraPosition() {
          const t = e.bs();
          return (
            (t[0] = this._cameraPosition[0]),
            (t[1] = this._cameraPosition[1]),
            (t[2] = this._cameraPosition[2]),
            t
          );
        }
        get cameraToCenterDistance() {
          return this._helper.cameraToCenterDistance;
        }
        getProjectionData(t) {
          const { overscaledTileID: e, applyGlobeMatrix: i } = t,
            r = this._helper.getMercatorTileCoordinates(e);
          return {
            mainMatrix: this._globeViewProjMatrix32f,
            tileMercatorCoords: r,
            clippingPlane: this._cachedClippingPlane,
            projectionTransition: i ? 1 : 0,
            fallbackMatrix: this._globeViewProjMatrix32f,
          };
        }
        _computeClippingPlane(t) {
          const i = this.pitchInRadians,
            r = this.cameraToCenterDistance / t,
            n = Math.sin(i) * r,
            a = Math.cos(i) * r + 1,
            s = (1 / Math.sqrt(n * n + a * a)) * 1;
          let o = -n,
            l = a;
          const c = Math.sqrt(o * o + l * l);
          (o /= c), (l /= c);
          const h = [0, o, l];
          e.bz(h, h, [0, 0, 0], -this.bearingInRadians),
            e.bA(h, h, [0, 0, 0], (-1 * this.center.lat * Math.PI) / 180),
            e.bB(h, h, [0, 0, 0], (this.center.lng * Math.PI) / 180);
          const u = 1 / e.b0(h);
          return e.aU(h, h, u), [...h, -s * u];
        }
        isLocationOccluded(t) {
          return !this.isSurfacePointVisible(ci(t));
        }
        transformLightDirection(t) {
          const i = (this._helper._center.lng * Math.PI) / 180,
            r = (this._helper._center.lat * Math.PI) / 180,
            n = Math.cos(r),
            a = [Math.sin(i) * n, Math.sin(r), Math.cos(i) * n],
            s = [a[2], 0, -a[0]],
            o = [0, 0, 0];
          e.aZ(o, s, a), e.aY(s, s), e.aY(o, o);
          const l = [0, 0, 0];
          return (
            e.aY(l, [
              s[0] * t[0] + o[0] * t[1] + a[0] * t[2],
              s[1] * t[0] + o[1] * t[1] + a[1] * t[2],
              s[2] * t[0] + o[2] * t[1] + a[2] * t[2],
            ]),
            l
          );
        }
        getPixelScale() {
          return 1 / Math.cos((this._helper._center.lat * Math.PI) / 180);
        }
        getCircleRadiusCorrection() {
          return Math.cos((this._helper._center.lat * Math.PI) / 180);
        }
        getPitchedTextCorrection(t, i, r) {
          const n = (function (t, i, r) {
              const n = 1 / (1 << r.z);
              return new e.a5(
                (t / e.a3) * n + r.x * n,
                (i / e.a3) * n + r.y * n
              );
            })(t, i, r.canonical),
            a =
              ((s = n.y),
              [
                e.br(n.x * Math.PI * 2 + Math.PI, 2 * Math.PI),
                2 * Math.atan(Math.exp(Math.PI - s * Math.PI * 2)) -
                  0.5 * Math.PI,
              ]);
          var s;
          return this.getCircleRadiusCorrection() / Math.cos(a[1]);
        }
        projectTileCoordinates(t, i, r, n) {
          const a = r.canonical,
            s = li(t, i, a.x, a.y, a.z),
            o = 1 + (n ? n(t, i) : 0) / e.bx,
            l = [s[0] * o, s[1] * o, s[2] * o, 1];
          e.aA(l, l, this._globeViewProjMatrixNoCorrection);
          const c = this._cachedClippingPlane,
            h = c[0] * s[0] + c[1] * s[1] + c[2] * s[2] + c[3] < 0;
          return {
            point: new e.P(l[0] / l[3], l[1] / l[3]),
            signedDistanceFromCamera: l[3],
            isOccluded: h,
          };
        }
        _calcMatrices() {
          if (!this._helper._width || !this._helper._height) return;
          const t = hi(this.worldSize, this.center.lat),
            i = e.bd(),
            r = e.bd();
          this._helper.autoCalculateNearFarZ &&
            ((this._helper._nearZ = 0.5),
            (this._helper._farZ = this.cameraToCenterDistance + 2 * t)),
            e.b7(
              i,
              this.fovInRadians,
              this.width / this.height,
              this._helper._nearZ,
              this._helper._farZ
            );
          const n = this.centerOffset;
          (i[8] = (2 * -n.x) / this._helper._width),
            (i[9] = (2 * n.y) / this._helper._height),
            (this._projectionMatrix = e.b8(i)),
            (this._globeProjMatrixInverted = e.bd()),
            e.au(this._globeProjMatrixInverted, i),
            e.N(i, i, [0, 0, -this.cameraToCenterDistance]),
            e.b9(i, i, this.rollInRadians),
            e.ba(i, i, -this.pitchInRadians),
            e.b9(i, i, this.bearingInRadians),
            e.N(i, i, [0, 0, -t]);
          const a = e.bs();
          (a[0] = t),
            (a[1] = t),
            (a[2] = t),
            e.ba(r, i, (this.center.lat * Math.PI) / 180),
            e.bC(r, r, (-this.center.lng * Math.PI) / 180),
            e.O(r, r, a),
            (this._globeViewProjMatrixNoCorrection = r),
            e.ba(
              i,
              i,
              (this.center.lat * Math.PI) / 180 -
                this._globeLatitudeErrorCorrectionRadians
            ),
            e.bC(i, i, (-this.center.lng * Math.PI) / 180),
            e.O(i, i, a),
            (this._globeViewProjMatrix32f = new Float32Array(i)),
            (this._globeViewProjMatrixNoCorrectionInverted = e.bd()),
            e.au(this._globeViewProjMatrixNoCorrectionInverted, r);
          const s = e.bs();
          (this._cameraPosition = e.bs()),
            (this._cameraPosition[2] = this.cameraToCenterDistance / t),
            e.bz(
              this._cameraPosition,
              this._cameraPosition,
              s,
              -this.rollInRadians
            ),
            e.bA(
              this._cameraPosition,
              this._cameraPosition,
              s,
              this.pitchInRadians
            ),
            e.bz(
              this._cameraPosition,
              this._cameraPosition,
              s,
              -this.bearingInRadians
            ),
            e.aV(this._cameraPosition, this._cameraPosition, [0, 0, 1]),
            e.bA(
              this._cameraPosition,
              this._cameraPosition,
              s,
              (-this.center.lat * Math.PI) / 180
            ),
            e.bB(
              this._cameraPosition,
              this._cameraPosition,
              s,
              (this.center.lng * Math.PI) / 180
            ),
            (this._cachedClippingPlane = this._computeClippingPlane(t));
          const o = e.b8(this._globeViewProjMatrixNoCorrectionInverted);
          e.O(o, o, [1, 1, -1]),
            (this._cachedFrustum = Ve.fromInvProjectionMatrix(
              o,
              1,
              0,
              this._cachedClippingPlane,
              !0
            ));
        }
        calculateFogMatrix(t) {
          e.w('calculateFogMatrix is not supported on globe projection.');
          const i = e.bd();
          return e.am(i), i;
        }
        getVisibleUnwrappedCoordinates(t) {
          return [new e.b5(0, t)];
        }
        getCameraFrustum() {
          return this._cachedFrustum;
        }
        getClippingPlane() {
          return this._cachedClippingPlane;
        }
        getCoveringTilesDetailsProvider() {
          return this._coveringTilesDetailsProvider;
        }
        recalculateZoomAndCenter(t) {
          t &&
            e.w(
              'terrain is not fully supported on vertical perspective projection.'
            ),
            this._helper.recalculateZoomAndCenter(0);
        }
        maxPitchScaleFactor() {
          return 1;
        }
        getCameraPoint() {
          return this._helper.getCameraPoint();
        }
        getCameraAltitude() {
          return this._helper.getCameraAltitude();
        }
        getCameraLngLat() {
          return this._helper.getCameraLngLat();
        }
        lngLatToCameraDepth(t, i) {
          if (!this._globeViewProjMatrixNoCorrection) return 1;
          const r = ci(t);
          e.aU(r, r, 1 + i / e.bx);
          const n = e.by();
          return (
            e.aA(
              n,
              [r[0], r[1], r[2], 1],
              this._globeViewProjMatrixNoCorrection
            ),
            n[2] / n[3]
          );
        }
        populateCache(t) {}
        getBounds() {
          const t = 0.5 * this.width,
            i = 0.5 * this.height,
            r = [
              new e.P(0, 0),
              new e.P(t, 0),
              new e.P(this.width, 0),
              new e.P(this.width, i),
              new e.P(this.width, this.height),
              new e.P(t, this.height),
              new e.P(0, this.height),
              new e.P(0, i),
            ],
            n = [];
          for (const e of r) n.push(this.unprojectScreenPoint(e));
          let a = 0,
            s = 0,
            o = 0,
            l = 0;
          const c = this.center;
          for (const u of n) {
            const t = e.bD(c.lng, u.lng),
              i = e.bD(c.lat, u.lat);
            t < s && (s = t),
              t > a && (a = t),
              i < l && (l = i),
              i > o && (o = i);
          }
          const h = [c.lng + s, c.lat + l, c.lng + a, c.lat + o];
          return (
            this.isSurfacePointOnScreen([0, 1, 0]) &&
              ((h[3] = 90), (h[0] = -180), (h[2] = 180)),
            this.isSurfacePointOnScreen([0, -1, 0]) &&
              ((h[1] = -90), (h[0] = -180), (h[2] = 180)),
            new q(h)
          );
        }
        calculateCenterFromCameraLngLatAlt(t, e, i, r) {
          return this._helper.calculateCenterFromCameraLngLatAlt(t, e, i, r);
        }
        setLocationAtPoint(t, i) {
          const r = ci(this.unprojectScreenPoint(i)),
            n = ci(t),
            a = e.bs();
          e.bE(a);
          const s = e.bs();
          e.bB(s, r, a, (-this.center.lng * Math.PI) / 180),
            e.bA(s, s, a, (this.center.lat * Math.PI) / 180);
          const o = n[0] * n[0] + n[2] * n[2],
            l = s[0] * s[0];
          if (o < l) return;
          const c = Math.sqrt(o - l),
            h = -c,
            u = e.bF(n[0], n[2], s[0], c),
            d = e.bF(n[0], n[2], s[0], h),
            p = e.bs();
          e.bB(p, n, a, -u);
          const f = e.bF(p[1], p[2], s[1], s[2]),
            m = e.bs();
          e.bB(m, n, a, -d);
          const g = e.bF(m[1], m[2], s[1], s[2]),
            _ = 0.5 * Math.PI,
            y = f >= -_ && f <= _,
            v = g >= -_ && g <= _;
          let x, b;
          if (y && v) {
            const t = (this.center.lng * Math.PI) / 180,
              i = (this.center.lat * Math.PI) / 180;
            e.bG(u, t) + e.bG(f, i) < e.bG(d, t) + e.bG(g, i)
              ? ((x = u), (b = f))
              : ((x = d), (b = g));
          } else if (y) (x = u), (b = f);
          else {
            if (!v) return;
            (x = d), (b = g);
          }
          const w = (x / Math.PI) * 180,
            T = (b / Math.PI) * 180,
            P = this.center.lat;
          this.setCenter(new e.U(w, e.ai(T, -90, 90))),
            this.setZoom(this.zoom + pi(P, this.center.lat));
        }
        locationToScreenPoint(t, i) {
          const r = ci(t);
          if (i) {
            const n = i.getElevationForLngLatZoom(t, this._helper._tileZoom);
            e.aU(r, r, 1 + n / e.bx);
          }
          return this._projectSurfacePointToScreen(r);
        }
        _projectSurfacePointToScreen(t) {
          const i = e.by();
          return (
            e.aA(i, [...t, 1], this._globeViewProjMatrixNoCorrection),
            (i[0] /= i[3]),
            (i[1] /= i[3]),
            new e.P(
              (0.5 * i[0] + 0.5) * this.width,
              (0.5 * -i[1] + 0.5) * this.height
            )
          );
        }
        screenPointToMercatorCoordinate(t, i) {
          if (i) {
            const e = i.pointCoordinate(t);
            if (e) return e;
          }
          return e.a5.fromLngLat(this.unprojectScreenPoint(t));
        }
        screenPointToLocation(t, e) {
          var i;
          return null === (i = this.screenPointToMercatorCoordinate(t, e)) ||
            void 0 === i
            ? void 0
            : i.toLngLat();
        }
        isPointOnMapSurface(t, e) {
          const i = this._cameraPosition,
            r = this.getRayDirectionFromPixel(t);
          return !!this.rayPlanetIntersection(i, r);
        }
        getRayDirectionFromPixel(t) {
          const i = e.by();
          (i[0] = (t.x / this.width) * 2 - 1),
            (i[1] = -1 * ((t.y / this.height) * 2 - 1)),
            (i[2] = 1),
            (i[3] = 1),
            e.aA(i, i, this._globeViewProjMatrixNoCorrectionInverted),
            (i[0] /= i[3]),
            (i[1] /= i[3]),
            (i[2] /= i[3]);
          const r = e.bs();
          (r[0] = i[0] - this._cameraPosition[0]),
            (r[1] = i[1] - this._cameraPosition[1]),
            (r[2] = i[2] - this._cameraPosition[2]);
          const n = e.bs();
          return e.aY(n, r), n;
        }
        isSurfacePointVisible(t) {
          const e = this._cachedClippingPlane;
          return e[0] * t[0] + e[1] * t[1] + e[2] * t[2] + e[3] >= 0;
        }
        isSurfacePointOnScreen(t) {
          if (!this.isSurfacePointVisible(t)) return !1;
          const i = e.by();
          return (
            e.aA(i, [...t, 1], this._globeViewProjMatrixNoCorrection),
            (i[0] /= i[3]),
            (i[1] /= i[3]),
            (i[2] /= i[3]),
            i[0] > -1 &&
              i[0] < 1 &&
              i[1] > -1 &&
              i[1] < 1 &&
              i[2] > -1 &&
              i[2] < 1
          );
        }
        rayPlanetIntersection(t, i) {
          const r = e.a_(t, i),
            n = e.bs(),
            a = e.bs();
          e.aU(a, i, r), e.aX(n, t, a);
          const s = 1 - e.a_(n, n);
          if (s < 0) return null;
          const o = e.a_(t, t) - 1,
            l = -r + (r < 0 ? 1 : -1) * Math.sqrt(s),
            c = o / l,
            h = l;
          return { tMin: Math.min(c, h), tMax: Math.max(c, h) };
        }
        unprojectScreenPoint(t) {
          const i = this._cameraPosition,
            r = this.getRayDirectionFromPixel(t),
            n = this.rayPlanetIntersection(i, r);
          if (n) {
            const t = e.bs();
            e.aV(t, i, [r[0] * n.tMin, r[1] * n.tMin, r[2] * n.tMin]);
            const a = e.bs();
            return e.aY(a, t), ui(a);
          }
          const a = this._cachedClippingPlane,
            s = a[0] * r[0] + a[1] * r[1] + a[2] * r[2],
            o = -e.b4(a, i) / s,
            l = e.bs();
          if (o > 0) e.aV(l, i, [r[0] * o, r[1] * o, r[2] * o]);
          else {
            const t = e.bs();
            e.aV(t, i, [2 * r[0], 2 * r[1], 2 * r[2]]);
            const n = e.b4(this._cachedClippingPlane, t);
            e.aX(l, t, [
              this._cachedClippingPlane[0] * n,
              this._cachedClippingPlane[1] * n,
              this._cachedClippingPlane[2] * n,
            ]);
          }
          const c = (function (t) {
            const i = e.bs();
            return (
              (i[0] = t[0] * -t[3]),
              (i[1] = t[1] * -t[3]),
              (i[2] = t[2] * -t[3]),
              { center: i, radius: Math.sqrt(1 - t[3] * t[3]) }
            );
          })(a);
          return ui(
            (function (t, i, r) {
              const n = e.bs();
              e.aX(n, r, t);
              const a = e.bs();
              return e.bt(a, t, n, i / e.b2(n)), a;
            })(c.center, c.radius, l)
          );
        }
        getMatrixForModel(t, i) {
          const r = e.U.convert(t),
            n = 1 / e.bx,
            a = e.bc();
          return (
            e.bC(a, a, (r.lng / 180) * Math.PI),
            e.ba(a, a, (-r.lat / 180) * Math.PI),
            e.N(a, a, [0, 0, 1 + i / e.bx]),
            e.ba(a, a, 0.5 * Math.PI),
            e.O(a, a, [n, n, n]),
            a
          );
        }
        getProjectionDataForCustomLayer(t = !0) {
          const i = this.getProjectionData({
            overscaledTileID: new e.a0(0, 0, 0, 0, 0),
            applyGlobeMatrix: t,
          });
          return (i.tileMercatorCoords = [0, 0, 1, 1]), i;
        }
        getFastPathSimpleProjectionMatrix(t) {}
      }
      class Pi {
        get pixelsToClipSpaceMatrix() {
          return this._helper.pixelsToClipSpaceMatrix;
        }
        get clipSpaceToPixelsMatrix() {
          return this._helper.clipSpaceToPixelsMatrix;
        }
        get pixelsToGLUnits() {
          return this._helper.pixelsToGLUnits;
        }
        get centerOffset() {
          return this._helper.centerOffset;
        }
        get size() {
          return this._helper.size;
        }
        get rotationMatrix() {
          return this._helper.rotationMatrix;
        }
        get centerPoint() {
          return this._helper.centerPoint;
        }
        get pixelsPerMeter() {
          return this._helper.pixelsPerMeter;
        }
        setMinZoom(t) {
          this._helper.setMinZoom(t);
        }
        setMaxZoom(t) {
          this._helper.setMaxZoom(t);
        }
        setMinPitch(t) {
          this._helper.setMinPitch(t);
        }
        setMaxPitch(t) {
          this._helper.setMaxPitch(t);
        }
        setRenderWorldCopies(t) {
          this._helper.setRenderWorldCopies(t);
        }
        setBearing(t) {
          this._helper.setBearing(t);
        }
        setPitch(t) {
          this._helper.setPitch(t);
        }
        setRoll(t) {
          this._helper.setRoll(t);
        }
        setFov(t) {
          this._helper.setFov(t);
        }
        setZoom(t) {
          this._helper.setZoom(t);
        }
        setCenter(t) {
          this._helper.setCenter(t);
        }
        setElevation(t) {
          this._helper.setElevation(t);
        }
        setMinElevationForCurrentTile(t) {
          this._helper.setMinElevationForCurrentTile(t);
        }
        setPadding(t) {
          this._helper.setPadding(t);
        }
        interpolatePadding(t, e, i) {
          return this._helper.interpolatePadding(t, e, i);
        }
        isPaddingEqual(t) {
          return this._helper.isPaddingEqual(t);
        }
        resize(t, e, i = !0) {
          this._helper.resize(t, e, i);
        }
        getMaxBounds() {
          return this._helper.getMaxBounds();
        }
        setMaxBounds(t) {
          this._helper.setMaxBounds(t);
        }
        setConstrain(t) {
          this._helper.setConstrain(t);
        }
        overrideNearFarZ(t, e) {
          this._helper.overrideNearFarZ(t, e);
        }
        clearNearFarZOverride() {
          this._helper.clearNearFarZOverride();
        }
        getCameraQueryGeometry(t) {
          return this._helper.getCameraQueryGeometry(this.getCameraPoint(), t);
        }
        get tileSize() {
          return this._helper.tileSize;
        }
        get tileZoom() {
          return this._helper.tileZoom;
        }
        get scale() {
          return this._helper.scale;
        }
        get worldSize() {
          return this._helper.worldSize;
        }
        get width() {
          return this._helper.width;
        }
        get height() {
          return this._helper.height;
        }
        get lngRange() {
          return this._helper.lngRange;
        }
        get latRange() {
          return this._helper.latRange;
        }
        get minZoom() {
          return this._helper.minZoom;
        }
        get maxZoom() {
          return this._helper.maxZoom;
        }
        get zoom() {
          return this._helper.zoom;
        }
        get center() {
          return this._helper.center;
        }
        get minPitch() {
          return this._helper.minPitch;
        }
        get maxPitch() {
          return this._helper.maxPitch;
        }
        get pitch() {
          return this._helper.pitch;
        }
        get pitchInRadians() {
          return this._helper.pitchInRadians;
        }
        get roll() {
          return this._helper.roll;
        }
        get rollInRadians() {
          return this._helper.rollInRadians;
        }
        get bearing() {
          return this._helper.bearing;
        }
        get bearingInRadians() {
          return this._helper.bearingInRadians;
        }
        get fov() {
          return this._helper.fov;
        }
        get fovInRadians() {
          return this._helper.fovInRadians;
        }
        get elevation() {
          return this._helper.elevation;
        }
        get minElevationForCurrentTile() {
          return this._helper.minElevationForCurrentTile;
        }
        get padding() {
          return this._helper.padding;
        }
        get unmodified() {
          return this._helper.unmodified;
        }
        get renderWorldCopies() {
          return this._helper.renderWorldCopies;
        }
        get cameraToCenterDistance() {
          return this._helper.cameraToCenterDistance;
        }
        get constrain() {
          return this._helper.constrain;
        }
        get nearZ() {
          return this._helper.nearZ;
        }
        get farZ() {
          return this._helper.farZ;
        }
        get autoCalculateNearFarZ() {
          return this._helper.autoCalculateNearFarZ;
        }
        get isGlobeRendering() {
          return this._globeness > 0;
        }
        setTransitionState(t, e) {
          (this._globeness = t),
            (this._globeLatitudeErrorCorrectionRadians = e),
            this._calcMatrices(),
            this._verticalPerspectiveTransform
              .getCoveringTilesDetailsProvider()
              .prepareNextFrame(),
            this._mercatorTransform
              .getCoveringTilesDetailsProvider()
              .prepareNextFrame();
        }
        get currentTransform() {
          return this.isGlobeRendering
            ? this._verticalPerspectiveTransform
            : this._mercatorTransform;
        }
        constructor(t) {
          (this._globeLatitudeErrorCorrectionRadians = 0),
            (this._globeness = 1),
            (this.defaultConstrain = (t, e) =>
              this.currentTransform.defaultConstrain(t, e)),
            (this._helper = new Fe(
              {
                calcMatrices: () => {
                  this._calcMatrices();
                },
                constrain: (t, e) => this.defaultConstrain(t, e),
              },
              t
            )),
            (this._globeness = 1),
            (this._mercatorTransform = new je()),
            (this._verticalPerspectiveTransform = new Ti());
        }
        clone() {
          const t = new Pi();
          return (
            (t._globeness = this._globeness),
            (t._globeLatitudeErrorCorrectionRadians =
              this._globeLatitudeErrorCorrectionRadians),
            t.apply(this),
            t
          );
        }
        apply(t) {
          this._helper.apply(t),
            this._mercatorTransform.apply(this),
            this._verticalPerspectiveTransform.apply(
              this,
              this._globeLatitudeErrorCorrectionRadians
            );
        }
        get projectionMatrix() {
          return this.currentTransform.projectionMatrix;
        }
        get modelViewProjectionMatrix() {
          return this.currentTransform.modelViewProjectionMatrix;
        }
        get inverseProjectionMatrix() {
          return this.currentTransform.inverseProjectionMatrix;
        }
        get cameraPosition() {
          return this.currentTransform.cameraPosition;
        }
        getProjectionData(t) {
          const e = this._mercatorTransform.getProjectionData(t),
            i = this._verticalPerspectiveTransform.getProjectionData(t);
          return {
            mainMatrix: this.isGlobeRendering ? i.mainMatrix : e.mainMatrix,
            clippingPlane: i.clippingPlane,
            tileMercatorCoords: i.tileMercatorCoords,
            projectionTransition: t.applyGlobeMatrix ? this._globeness : 0,
            fallbackMatrix: e.fallbackMatrix,
          };
        }
        isLocationOccluded(t) {
          return this.currentTransform.isLocationOccluded(t);
        }
        transformLightDirection(t) {
          return this.currentTransform.transformLightDirection(t);
        }
        getPixelScale() {
          return e.bn(
            this._mercatorTransform.getPixelScale(),
            this._verticalPerspectiveTransform.getPixelScale(),
            this._globeness
          );
        }
        getCircleRadiusCorrection() {
          return e.bn(
            this._mercatorTransform.getCircleRadiusCorrection(),
            this._verticalPerspectiveTransform.getCircleRadiusCorrection(),
            this._globeness
          );
        }
        getPitchedTextCorrection(t, i, r) {
          const n = this._mercatorTransform.getPitchedTextCorrection(t, i, r),
            a = this._verticalPerspectiveTransform.getPitchedTextCorrection(
              t,
              i,
              r
            );
          return e.bn(n, a, this._globeness);
        }
        projectTileCoordinates(t, e, i, r) {
          return this.currentTransform.projectTileCoordinates(t, e, i, r);
        }
        _calcMatrices() {
          this._helper._width &&
            this._helper._height &&
            (this._verticalPerspectiveTransform.apply(
              this,
              this._globeLatitudeErrorCorrectionRadians
            ),
            (this._helper._nearZ = this._verticalPerspectiveTransform.nearZ),
            (this._helper._farZ = this._verticalPerspectiveTransform.farZ),
            this._mercatorTransform.apply(this, !0, this.isGlobeRendering),
            (this._helper._nearZ = this._mercatorTransform.nearZ),
            (this._helper._farZ = this._mercatorTransform.farZ));
        }
        calculateFogMatrix(t) {
          return this.currentTransform.calculateFogMatrix(t);
        }
        getVisibleUnwrappedCoordinates(t) {
          return this.currentTransform.getVisibleUnwrappedCoordinates(t);
        }
        getCameraFrustum() {
          return this.currentTransform.getCameraFrustum();
        }
        getClippingPlane() {
          return this.currentTransform.getClippingPlane();
        }
        getCoveringTilesDetailsProvider() {
          return this.currentTransform.getCoveringTilesDetailsProvider();
        }
        recalculateZoomAndCenter(t) {
          this._mercatorTransform.recalculateZoomAndCenter(t),
            this._verticalPerspectiveTransform.recalculateZoomAndCenter(t);
        }
        maxPitchScaleFactor() {
          return this._mercatorTransform.maxPitchScaleFactor();
        }
        getCameraPoint() {
          return this._helper.getCameraPoint();
        }
        getCameraAltitude() {
          return this._helper.getCameraAltitude();
        }
        getCameraLngLat() {
          return this._helper.getCameraLngLat();
        }
        lngLatToCameraDepth(t, e) {
          return this.currentTransform.lngLatToCameraDepth(t, e);
        }
        populateCache(t) {
          this._mercatorTransform.populateCache(t),
            this._verticalPerspectiveTransform.populateCache(t);
        }
        getBounds() {
          return this.currentTransform.getBounds();
        }
        calculateCenterFromCameraLngLatAlt(t, e, i, r) {
          return this._helper.calculateCenterFromCameraLngLatAlt(t, e, i, r);
        }
        setLocationAtPoint(t, e) {
          if (!this.isGlobeRendering)
            return (
              this._mercatorTransform.setLocationAtPoint(t, e),
              void this.apply(this._mercatorTransform)
            );
          this._verticalPerspectiveTransform.setLocationAtPoint(t, e),
            this.apply(this._verticalPerspectiveTransform);
        }
        locationToScreenPoint(t, e) {
          return this.currentTransform.locationToScreenPoint(t, e);
        }
        screenPointToMercatorCoordinate(t, e) {
          return this.currentTransform.screenPointToMercatorCoordinate(t, e);
        }
        screenPointToLocation(t, e) {
          return this.currentTransform.screenPointToLocation(t, e);
        }
        isPointOnMapSurface(t, e) {
          return this.currentTransform.isPointOnMapSurface(t, e);
        }
        getRayDirectionFromPixel(t) {
          return this._verticalPerspectiveTransform.getRayDirectionFromPixel(t);
        }
        getMatrixForModel(t, e) {
          return this.currentTransform.getMatrixForModel(t, e);
        }
        getProjectionDataForCustomLayer(t = !0) {
          const e = this._mercatorTransform.getProjectionDataForCustomLayer(t);
          if (!this.isGlobeRendering) return e;
          const i =
            this._verticalPerspectiveTransform.getProjectionDataForCustomLayer(
              t
            );
          return (i.fallbackMatrix = e.mainMatrix), i;
        }
        getFastPathSimpleProjectionMatrix(t) {
          return this.currentTransform.getFastPathSimpleProjectionMatrix(t);
        }
      }
      class Ci {
        get useGlobeControls() {
          return !0;
        }
        handlePanInertia(t, i) {
          const r = fi(t, i);
          return (
            Math.abs(r.lng - i.center.lng) > 180 &&
              (r.lng = i.center.lng + 179.5 * Math.sign(r.lng - i.center.lng)),
            { easingCenter: r, easingOffset: new e.P(0, 0) }
          );
        }
        handleMapControlsRollPitchBearingZoom(t, i) {
          const r = t.around,
            n = i.screenPointToLocation(r);
          t.bearingDelta && i.setBearing(i.bearing + t.bearingDelta),
            t.pitchDelta && i.setPitch(i.pitch + t.pitchDelta),
            t.rollDelta && i.setRoll(i.roll + t.rollDelta);
          const a = i.zoom;
          t.zoomDelta && i.setZoom(i.zoom + t.zoomDelta);
          const s = i.zoom - a;
          if (0 === s) return;
          const o = e.bD(i.center.lng, n.lng),
            l = o / (Math.abs(o / 180) + 1),
            c = e.bD(i.center.lat, n.lat),
            h = i.getRayDirectionFromPixel(r),
            u = i.cameraPosition,
            d = -1 * e.a_(u, h),
            p = e.bs();
          e.aV(p, u, [h[0] * d, h[1] * d, h[2] * d]);
          const f = e.b0(p) - 1,
            m = Math.exp(0.5 * -Math.max(f - 0.3, 0)),
            g = hi(i.worldSize, i.center.lat) / Math.min(i.width, i.height),
            _ = e.bq(g, 0.9, 0.5, 1, 0.25),
            y = (1 - e.al(-s)) * Math.min(m, _),
            v = i.center.lat,
            x = i.zoom,
            b = new e.U(
              i.center.lng + l * y,
              e.ai(i.center.lat + c * y, -e.aj, e.aj)
            );
          i.setLocationAtPoint(n, r);
          const w = i.center,
            T = e.bq(Math.abs(o), 45, 85, 0, 1),
            P = e.bq(g, 0.75, 0.35, 0, 1),
            C = Math.pow(Math.max(T, P), 0.25),
            I = e.bD(w.lng, b.lng),
            S = e.bD(w.lat, b.lat);
          i.setCenter(new e.U(w.lng + I * C, w.lat + S * C).wrap()),
            i.setZoom(x + pi(v, i.center.lat));
        }
        handleMapControlsPan(t, e, i) {
          if (!t.panDelta) return;
          const r = e.center.lat,
            n = e.zoom;
          e.setCenter(fi(t.panDelta, e).wrap()),
            e.setZoom(n + pi(r, e.center.lat));
        }
        cameraForBoxAndBearing(t, i, r, n, a) {
          const s = Ze(t, i, r, n, a),
            o = (i.left / a.width) * 2 - 1,
            l = ((a.width - i.right) / a.width) * 2 - 1,
            c = (i.top / a.height) * -2 + 1,
            h = ((a.height - i.bottom) / a.height) * -2 + 1,
            u = e.bD(r.getWest(), r.getEast()) < 0,
            d = u ? r.getEast() : r.getWest(),
            p = u ? r.getWest() : r.getEast(),
            f = Math.max(r.getNorth(), r.getSouth()),
            m = Math.min(r.getNorth(), r.getSouth()),
            g = d + 0.5 * e.bD(d, p),
            _ = f + 0.5 * e.bD(f, m),
            y = a.clone();
          y.setCenter(s.center),
            y.setBearing(s.bearing),
            y.setPitch(0),
            y.setRoll(0),
            y.setZoom(s.zoom);
          const v = y.modelViewProjectionMatrix,
            x = [
              ci(r.getNorthWest()),
              ci(r.getNorthEast()),
              ci(r.getSouthWest()),
              ci(r.getSouthEast()),
              ci(new e.U(p, _)),
              ci(new e.U(d, _)),
              ci(new e.U(g, f)),
              ci(new e.U(g, m)),
            ],
            b = ci(s.center);
          let w = Number.POSITIVE_INFINITY;
          for (const e of x)
            o < 0 &&
              (w = Ci.getLesserNonNegativeNonNull(
                w,
                Ci.solveVectorScale(e, b, v, 'x', o)
              )),
              l > 0 &&
                (w = Ci.getLesserNonNegativeNonNull(
                  w,
                  Ci.solveVectorScale(e, b, v, 'x', l)
                )),
              c > 0 &&
                (w = Ci.getLesserNonNegativeNonNull(
                  w,
                  Ci.solveVectorScale(e, b, v, 'y', c)
                )),
              h < 0 &&
                (w = Ci.getLesserNonNegativeNonNull(
                  w,
                  Ci.solveVectorScale(e, b, v, 'y', h)
                ));
          if (Number.isFinite(w) && 0 !== w)
            return (s.zoom = y.zoom + e.ao(w)), s;
          Ue();
        }
        handleJumpToCenterZoom(t, i) {
          const r = t.center.lat,
            n = t.constrain(
              i.center ? e.U.convert(i.center) : t.center,
              t.zoom
            ).center;
          t.setCenter(n.wrap());
          const a = void 0 !== i.zoom ? +i.zoom : t.zoom + pi(r, n.lat);
          t.zoom !== a && t.setZoom(a);
        }
        handleEaseTo(t, i) {
          const r = t.zoom,
            n = t.center,
            a = t.padding,
            s = { roll: t.roll, pitch: t.pitch, bearing: t.bearing },
            o = {
              roll: void 0 === i.roll ? t.roll : i.roll,
              pitch: void 0 === i.pitch ? t.pitch : i.pitch,
              bearing: void 0 === i.bearing ? t.bearing : i.bearing,
            },
            l = void 0 !== i.zoom,
            c = !t.isPaddingEqual(i.padding);
          let h = !1;
          const u = i.center ? e.U.convert(i.center) : n,
            d = t.constrain(u, r).center;
          ke(t, d);
          const p = t.clone();
          p.setCenter(d),
            p.setZoom(l ? +i.zoom : r + pi(n.lat, u.lat)),
            p.setBearing(i.bearing);
          const f = new e.P(
            e.ai(t.centerPoint.x + i.offsetAsPoint.x, 0, t.width),
            e.ai(t.centerPoint.y + i.offsetAsPoint.y, 0, t.height)
          );
          p.setLocationAtPoint(d, f);
          const m = (i.offset && i.offsetAsPoint.mag()) > 0 ? p.center : d,
            g = l ? +i.zoom : r + pi(n.lat, m.lat),
            _ = r + pi(n.lat, 0),
            y = g + pi(m.lat, 0),
            v = e.bD(n.lng, m.lng),
            x = e.bD(n.lat, m.lat),
            b = e.al(y - _);
          return (
            (h = g !== r),
            {
              easeFunc: (r) => {
                if (
                  (e.bh(s, o) ||
                    Ge({
                      startEulerAngles: s,
                      endEulerAngles: o,
                      tr: t,
                      k: r,
                      useSlerp: s.roll != o.roll,
                    }),
                  c && t.interpolatePadding(a, i.padding, r),
                  i.around)
                )
                  e.w(
                    'Easing around a point is not supported under globe projection.'
                  ),
                    t.setLocationAtPoint(i.around, i.aroundPoint);
                else {
                  const e = y > _ ? Math.min(2, b) : Math.max(0.5, b),
                    i = Math.pow(e, 1 - r),
                    a = gi(n, v, x, r * i);
                  t.setCenter(a.wrap());
                }
                if (h) {
                  const i = e.F.number(_, y, r) + pi(0, t.center.lat);
                  t.setZoom(i);
                }
              },
              isZooming: h,
              elevationCenter: m,
            }
          );
        }
        handleFlyTo(t, i) {
          const r = void 0 !== i.zoom,
            n = t.center,
            a = t.zoom,
            s = t.padding,
            o = !t.isPaddingEqual(i.padding),
            l = t.constrain(
              e.U.convert(i.center || i.locationAtOffset),
              a
            ).center,
            c = r ? +i.zoom : t.zoom + pi(t.center.lat, l.lat),
            h = t.clone();
          h.setCenter(l), h.setZoom(c), h.setBearing(i.bearing);
          const u = new e.P(
            e.ai(t.centerPoint.x + i.offsetAsPoint.x, 0, t.width),
            e.ai(t.centerPoint.y + i.offsetAsPoint.y, 0, t.height)
          );
          h.setLocationAtPoint(l, u);
          const d = h.center;
          ke(t, d);
          const p = (function (t, i, r) {
              const n = ci(i),
                a = ci(r),
                s = e.a_(n, a),
                o = Math.acos(s),
                l = oi(t);
              return (o / (2 * Math.PI)) * l;
            })(t, n, d),
            f = a + pi(n.lat, 0),
            m = c + pi(d.lat, 0),
            g = e.al(m - f);
          let _;
          if ('number' == typeof i.minZoom) {
            const r = +i.minZoom + pi(d.lat, 0),
              n = Math.min(r, f, m) + pi(0, d.lat),
              a = t.constrain(d, n).zoom + pi(d.lat, 0);
            _ = e.al(a - f);
          }
          const y = e.bD(n.lng, d.lng),
            v = e.bD(n.lat, d.lat);
          return {
            easeFunc: (r, a, l, h) => {
              const u = gi(n, y, v, l);
              o && t.interpolatePadding(s, i.padding, r);
              const p = 1 === r ? d : u;
              t.setCenter(p.wrap());
              const m = f + e.ao(a);
              t.setZoom(1 === r ? c : m + pi(0, p.lat));
            },
            scaleOfZoom: g,
            targetCenter: d,
            scaleOfMinZoom: _,
            pixelPathLength: p,
          };
        }
        static solveVectorScale(t, e, i, r, n) {
          const a =
              'x' === r ? [i[0], i[4], i[8], i[12]] : [i[1], i[5], i[9], i[13]],
            s = [i[3], i[7], i[11], i[15]],
            o = t[0] * a[0] + t[1] * a[1] + t[2] * a[2],
            l = t[0] * s[0] + t[1] * s[1] + t[2] * s[2],
            c = e[0] * a[0] + e[1] * a[1] + e[2] * a[2],
            h = e[0] * s[0] + e[1] * s[1] + e[2] * s[2];
          return c + n * l === o + n * h ||
            s[3] * (o - c) + a[3] * (h - l) + o * h == c * l
            ? null
            : (c + a[3] - n * h - n * s[3]) / (c - o - n * h + n * l);
        }
        static getLesserNonNegativeNonNull(t, e) {
          return null !== e && e >= 0 && e < t ? e : t;
        }
      }
      class Ii {
        constructor(t) {
          (this._globe = t),
            (this._mercatorCameraHelper = new $e()),
            (this._verticalPerspectiveCameraHelper = new Ci());
        }
        get useGlobeControls() {
          return this._globe.useGlobeRendering;
        }
        get currentHelper() {
          return this.useGlobeControls
            ? this._verticalPerspectiveCameraHelper
            : this._mercatorCameraHelper;
        }
        handlePanInertia(t, e) {
          return this.currentHelper.handlePanInertia(t, e);
        }
        handleMapControlsRollPitchBearingZoom(t, e) {
          return this.currentHelper.handleMapControlsRollPitchBearingZoom(t, e);
        }
        handleMapControlsPan(t, e, i) {
          this.currentHelper.handleMapControlsPan(t, e, i);
        }
        cameraForBoxAndBearing(t, e, i, r, n) {
          return this.currentHelper.cameraForBoxAndBearing(t, e, i, r, n);
        }
        handleJumpToCenterZoom(t, e) {
          this.currentHelper.handleJumpToCenterZoom(t, e);
        }
        handleEaseTo(t, e) {
          return this.currentHelper.handleEaseTo(t, e);
        }
        handleFlyTo(t, e) {
          return this.currentHelper.handleFlyTo(t, e);
        }
      }
      const Si = (t, i) =>
          e.z(t, i && i.filter((t) => 'source.canvas' !== t.identifier)),
        Mi = e.bH();
      class Di extends e.E {
        constructor(t, i = {}) {
          var r, n;
          super(),
            (this._rtlPluginLoaded = () => {
              for (const t in this.tileManagers) {
                const e = this.tileManagers[t].getSource().type;
                ('vector' !== e && 'geojson' !== e) ||
                  this.tileManagers[t].reload();
              }
            }),
            (this.map = t),
            (this.dispatcher = new N(B(), t._getMapId())),
            this.dispatcher.registerMessageHandler('GG', (t, e) =>
              this.getGlyphs(t, e)
            ),
            this.dispatcher.registerMessageHandler('GI', (t, e) =>
              this.getImages(t, e)
            ),
            this.dispatcher.registerMessageHandler('GDA', (t, e) =>
              this.getDashes(t, e)
            ),
            (this.imageManager = new b()),
            this.imageManager.setEventedParent(this);
          const a =
            (null === (r = t._container) || void 0 === r ? void 0 : r.lang) ||
            ('undefined' != typeof document &&
              (null === (n = document.documentElement) || void 0 === n
                ? void 0
                : n.lang)) ||
            void 0;
          (this.glyphManager = new I(
            t._requestManager,
            i.localIdeographFontFamily,
            a
          )),
            (this.lineAtlas = new E(256, 512)),
            (this.crossTileSymbolIndex = new Ce()),
            (this._spritesImagesIds = {}),
            (this._layers = {}),
            (this._order = []),
            (this.tileManagers = {}),
            (this.zoomHistory = new e.bI()),
            (this._loaded = !1),
            (this._availableImages = []),
            (this._globalState = {}),
            this._resetUpdates(),
            this.dispatcher.broadcast('SR', e.bJ()),
            lt().on(at, this._rtlPluginLoaded),
            this.on('data', (t) => {
              if ('source' !== t.dataType || 'metadata' !== t.sourceDataType)
                return;
              const e = this.tileManagers[t.sourceId];
              if (!e) return;
              const i = e.getSource();
              if (i && i.vectorLayerIds)
                for (const r in this._layers) {
                  const t = this._layers[r];
                  t.source === i.id && this._validateLayer(t);
                }
            });
        }
        setGlobalStateProperty(t, i) {
          var r, n, a;
          this._checkLoaded();
          const s =
            null === i
              ? null !==
                  (a =
                    null ===
                      (n =
                        null === (r = this.stylesheet.state) || void 0 === r
                          ? void 0
                          : r[t]) || void 0 === n
                      ? void 0
                      : n.default) && void 0 !== a
                ? a
                : null
              : i;
          if (e.bK(s, this._globalState[t])) return this;
          (this._globalState[t] = s), this._applyGlobalStateChanges([t]);
        }
        getGlobalState() {
          return this._globalState;
        }
        setGlobalState(t) {
          this._checkLoaded();
          const i = [];
          for (const r in t)
            !e.bK(this._globalState[r], t[r].default) &&
              (i.push(r), (this._globalState[r] = t[r].default));
          this._applyGlobalStateChanges(i);
        }
        _applyGlobalStateChanges(t) {
          if (0 === t.length) return;
          const e = new Set(),
            i = {};
          for (const r of t) {
            i[r] = this._globalState[r];
            for (const t in this._layers) {
              const i = this._layers[t],
                n = i.getLayoutAffectingGlobalStateRefs(),
                a = i.getPaintAffectingGlobalStateRefs();
              if ((n.has(r) && e.add(i.source), a.has(r)))
                for (const { name: t, value: e } of a.get(r))
                  this._updatePaintProperty(i, t, e);
            }
          }
          this.dispatcher.broadcast('UGS', i);
          for (const r in this.tileManagers)
            e.has(r) && (this._reloadSource(r), (this._changed = !0));
        }
        loadURL(t, i = {}, r) {
          this.fire(new e.l('dataloading', { dataType: 'style' })),
            (i.validate = 'boolean' != typeof i.validate || i.validate);
          const n = this.map._requestManager.transformRequest(t, 'Style');
          this._loadStyleRequest = new AbortController();
          const a = this._loadStyleRequest;
          e.j(n, this._loadStyleRequest)
            .then((t) => {
              (this._loadStyleRequest = null), this._load(t.data, i, r);
            })
            .catch((t) => {
              (this._loadStyleRequest = null),
                t && !a.signal.aborted && this.fire(new e.k(t));
            });
        }
        loadJSON(t, i = {}, r) {
          this.fire(new e.l('dataloading', { dataType: 'style' })),
            (this._frameRequest = new AbortController()),
            s
              .frameAsync(this._frameRequest)
              .then(() => {
                (this._frameRequest = null),
                  (i.validate = !1 !== i.validate),
                  this._load(t, i, r);
              })
              .catch(() => {});
        }
        loadEmpty() {
          this.fire(new e.l('dataloading', { dataType: 'style' })),
            this._load(Mi, { validate: !1 });
        }
        _load(t, i, r) {
          var n, a;
          let s = i.transformStyle ? i.transformStyle(r, t) : t;
          if (!i.validate || !Si(this, e.B(s))) {
            (s = Object.assign({}, s)),
              (this._loaded = !0),
              (this.stylesheet = s);
            for (const t in s.sources)
              this.addSource(t, s.sources[t], { validate: !1 });
            s.sprite
              ? this._loadSprite(s.sprite)
              : this.imageManager.setLoaded(!0),
              this.glyphManager.setURL(s.glyphs),
              this._createLayers(),
              (this.light = new D(this.stylesheet.light)),
              this._setProjectionInternal(
                (null === (n = this.stylesheet.projection) || void 0 === n
                  ? void 0
                  : n.type) || 'mercator'
              ),
              (this.sky = new A(this.stylesheet.sky)),
              this.map.setTerrain(
                null !== (a = this.stylesheet.terrain) && void 0 !== a
                  ? a
                  : null
              ),
              this.fire(new e.l('data', { dataType: 'style' })),
              this.fire(new e.l('style.load'));
          }
        }
        _createLayers() {
          var t, i, r;
          const n = e.bL(this.stylesheet.layers);
          this.setGlobalState(
            null !== (t = this.stylesheet.state) && void 0 !== t ? t : null
          ),
            this.dispatcher.broadcast('SL', n),
            (this._order = n.map((t) => t.id)),
            (this._layers = {}),
            (this._serializedLayers = null);
          for (const a of n) {
            const t = e.bM(a, this._globalState);
            if (
              (t.setEventedParent(this, { layer: { id: a.id } }),
              (this._layers[a.id] = t),
              e.bN(t) && this.tileManagers[t.source])
            ) {
              const e =
                null !==
                  (r =
                    null === (i = a.paint) || void 0 === i
                      ? void 0
                      : i['raster-fade-duration']) && void 0 !== r
                  ? r
                  : t.paint.get('raster-fade-duration');
              this.tileManagers[t.source].setRasterFadeDuration(e);
            }
          }
        }
        _loadSprite(t, i = !1, r) {
          let n;
          this.imageManager.setLoaded(!1),
            (this._spriteRequest = new AbortController()),
            (function (t, i, r, n) {
              return e._(this, void 0, void 0, function* () {
                const a = y(t),
                  o = r > 1 ? '@2x' : '',
                  l = {},
                  c = {};
                for (const { id: t, url: r } of a) {
                  const a = i.transformRequest(v(r, o, '.json'), 'SpriteJSON');
                  l[t] = e.j(a, n);
                  const s = i.transformRequest(v(r, o, '.png'), 'SpriteImage');
                  c[t] = g.getImage(s, n);
                }
                return (
                  yield Promise.all([...Object.values(l), ...Object.values(c)]),
                  (function (t, i) {
                    return e._(this, void 0, void 0, function* () {
                      const e = {};
                      for (const r in t) {
                        e[r] = {};
                        const n = s.getImageCanvasContext((yield i[r]).data),
                          a = (yield t[r]).data;
                        for (const t in a) {
                          const {
                            width: i,
                            height: s,
                            x: o,
                            y: l,
                            sdf: c,
                            pixelRatio: h,
                            stretchX: u,
                            stretchY: d,
                            content: p,
                            textFitWidth: f,
                            textFitHeight: m,
                          } = a[t];
                          e[r][t] = {
                            data: null,
                            pixelRatio: h,
                            sdf: c,
                            stretchX: u,
                            stretchY: d,
                            content: p,
                            textFitWidth: f,
                            textFitHeight: m,
                            spriteData: {
                              width: i,
                              height: s,
                              x: o,
                              y: l,
                              context: n,
                            },
                          };
                        }
                      }
                      return e;
                    });
                  })(l, c)
                );
              });
            })(
              t,
              this.map._requestManager,
              this.map.getPixelRatio(),
              this._spriteRequest
            )
              .then((t) => {
                if (((this._spriteRequest = null), t))
                  for (const e in t) {
                    this._spritesImagesIds[e] = [];
                    const r = this._spritesImagesIds[e]
                      ? this._spritesImagesIds[e].filter((e) => !(e in t))
                      : [];
                    for (const t of r)
                      this.imageManager.removeImage(t),
                        (this._changedImages[t] = !0);
                    for (const n in t[e]) {
                      const r = 'default' === e ? n : `${e}:${n}`;
                      this._spritesImagesIds[e].push(r),
                        r in this.imageManager.images
                          ? this.imageManager.updateImage(r, t[e][n], !1)
                          : this.imageManager.addImage(r, t[e][n]),
                        i && (this._changedImages[r] = !0);
                    }
                  }
              })
              .catch((t) => {
                (this._spriteRequest = null), (n = t), this.fire(new e.k(n));
              })
              .finally(() => {
                this.imageManager.setLoaded(!0),
                  (this._availableImages = this.imageManager.listImages()),
                  i && (this._changed = !0),
                  this.dispatcher.broadcast('SI', this._availableImages),
                  this.fire(new e.l('data', { dataType: 'style' })),
                  r && r(n);
              });
        }
        _unloadSprite() {
          for (const t of Object.values(this._spritesImagesIds).flat())
            this.imageManager.removeImage(t), (this._changedImages[t] = !0);
          (this._spritesImagesIds = {}),
            (this._availableImages = this.imageManager.listImages()),
            (this._changed = !0),
            this.dispatcher.broadcast('SI', this._availableImages),
            this.fire(new e.l('data', { dataType: 'style' }));
        }
        _validateLayer(t) {
          const i = this.tileManagers[t.source];
          if (!i) return;
          const r = t.sourceLayer;
          if (!r) return;
          const n = i.getSource();
          ('geojson' === n.type ||
            (n.vectorLayerIds && -1 === n.vectorLayerIds.indexOf(r))) &&
            this.fire(
              new e.k(
                new Error(
                  `Source layer "${r}" does not exist on source "${n.id}" as specified by style layer "${t.id}".`
                )
              )
            );
        }
        loaded() {
          if (!this._loaded) return !1;
          if (Object.keys(this._updatedSources).length) return !1;
          for (const t in this.tileManagers)
            if (!this.tileManagers[t].loaded()) return !1;
          return !!this.imageManager.isLoaded();
        }
        _serializeByIds(t, i = !1) {
          const r = this._serializedAllLayers();
          if (!t || 0 === t.length) return Object.values(i ? e.bO(r) : r);
          const n = [];
          for (const a of t)
            if (r[a]) {
              const t = i ? e.bO(r[a]) : r[a];
              n.push(t);
            }
          return n;
        }
        _serializedAllLayers() {
          let t = this._serializedLayers;
          if (t) return t;
          t = this._serializedLayers = {};
          const e = Object.keys(this._layers);
          for (const i of e) {
            const e = this._layers[i];
            'custom' !== e.type && (t[i] = e.serialize());
          }
          return t;
        }
        hasTransitions() {
          var t, e, i;
          if (
            null === (t = this.light) || void 0 === t
              ? void 0
              : t.hasTransition()
          )
            return !0;
          if (
            null === (e = this.sky) || void 0 === e ? void 0 : e.hasTransition()
          )
            return !0;
          if (
            null === (i = this.projection) || void 0 === i
              ? void 0
              : i.hasTransition()
          )
            return !0;
          for (const r in this.tileManagers)
            if (this.tileManagers[r].hasTransition()) return !0;
          for (const r in this._layers)
            if (this._layers[r].hasTransition()) return !0;
          return !1;
        }
        _checkLoaded() {
          if (!this._loaded) throw new Error('Style is not done loading.');
        }
        update(t) {
          if (!this._loaded) return;
          const i = this._changed;
          if (i) {
            const e = Object.keys(this._updatedLayers),
              i = Object.keys(this._removedLayers);
            (e.length || i.length) && this._updateWorkerLayers(e, i);
            for (const t in this._updatedSources) {
              const e = this._updatedSources[t];
              if ('reload' === e) this._reloadSource(t);
              else {
                if ('clear' !== e) throw new Error(`Invalid action ${e}`);
                this._clearSource(t);
              }
            }
            this._updateTilesForChangedImages(),
              this._updateTilesForChangedGlyphs();
            for (const r in this._updatedPaintProps)
              this._layers[r].updateTransitions(t);
            this.light.updateTransitions(t),
              this.sky.updateTransitions(t),
              this._resetUpdates();
          }
          const r = {};
          for (const e in this.tileManagers) {
            const t = this.tileManagers[e];
            (r[e] = t.used), (t.used = !1);
          }
          for (const e of this._order) {
            const i = this._layers[e];
            i.recalculate(t, this._availableImages),
              !i.isHidden(t.zoom) &&
                i.source &&
                (this.tileManagers[i.source].used = !0);
          }
          for (const n in r) {
            const t = this.tileManagers[n];
            !!r[n] != !!t.used &&
              t.fire(
                new e.l('data', {
                  sourceDataType: 'visibility',
                  dataType: 'source',
                  sourceId: n,
                })
              );
          }
          this.light.recalculate(t),
            this.sky.recalculate(t),
            this.projection.recalculate(t),
            (this.z = t.zoom),
            i && this.fire(new e.l('data', { dataType: 'style' }));
        }
        _updateTilesForChangedImages() {
          const t = Object.keys(this._changedImages);
          if (t.length) {
            for (const e in this.tileManagers)
              this.tileManagers[e].reloadTilesForDependencies(
                ['icons', 'patterns'],
                t
              );
            this._changedImages = {};
          }
        }
        _updateTilesForChangedGlyphs() {
          if (this._glyphsDidChange) {
            for (const t in this.tileManagers)
              this.tileManagers[t].reloadTilesForDependencies(['glyphs'], ['']);
            this._glyphsDidChange = !1;
          }
        }
        _updateWorkerLayers(t, e) {
          this.dispatcher.broadcast('UL', {
            layers: this._serializeByIds(t, !1),
            removedIds: e,
          });
        }
        _resetUpdates() {
          (this._changed = !1),
            (this._updatedLayers = {}),
            (this._removedLayers = {}),
            (this._updatedSources = {}),
            (this._updatedPaintProps = {}),
            (this._changedImages = {}),
            (this._glyphsDidChange = !1);
        }
        setState(t, i = {}) {
          var r;
          this._checkLoaded();
          const n = this.serialize();
          if (
            ((t = i.transformStyle ? i.transformStyle(n, t) : t),
            (null === (r = i.validate) || void 0 === r || r) &&
              Si(this, e.B(t)))
          )
            return !1;
          (t = e.bO(t)).layers = e.bL(t.layers);
          const a = e.bP(n, t),
            s = this._getOperationsToPerform(a);
          if (s.unimplemented.length > 0)
            throw new Error(`Unimplemented: ${s.unimplemented.join(', ')}.`);
          if (0 === s.operations.length) return !1;
          for (const e of s.operations) e();
          return (this.stylesheet = t), (this._serializedLayers = null), !0;
        }
        _getOperationsToPerform(t) {
          const e = [],
            i = [];
          for (const r of t)
            switch (r.command) {
              case 'setCenter':
              case 'setZoom':
              case 'setBearing':
              case 'setPitch':
              case 'setRoll':
                continue;
              case 'addLayer':
                e.push(() => this.addLayer.apply(this, r.args));
                break;
              case 'removeLayer':
                e.push(() => this.removeLayer.apply(this, r.args));
                break;
              case 'setPaintProperty':
                e.push(() => this.setPaintProperty.apply(this, r.args));
                break;
              case 'setLayoutProperty':
                e.push(() => this.setLayoutProperty.apply(this, r.args));
                break;
              case 'setFilter':
                e.push(() => this.setFilter.apply(this, r.args));
                break;
              case 'addSource':
                e.push(() => this.addSource.apply(this, r.args));
                break;
              case 'removeSource':
                e.push(() => this.removeSource.apply(this, r.args));
                break;
              case 'setLayerZoomRange':
                e.push(() => this.setLayerZoomRange.apply(this, r.args));
                break;
              case 'setLight':
                e.push(() => this.setLight.apply(this, r.args));
                break;
              case 'setGeoJSONSourceData':
                e.push(() => this.setGeoJSONSourceData.apply(this, r.args));
                break;
              case 'setGlyphs':
                e.push(() => this.setGlyphs.apply(this, r.args));
                break;
              case 'setSprite':
                e.push(() => this.setSprite.apply(this, r.args));
                break;
              case 'setTerrain':
                e.push(() => this.map.setTerrain.apply(this, r.args));
                break;
              case 'setSky':
                e.push(() => this.setSky.apply(this, r.args));
                break;
              case 'setProjection':
                this.setProjection.apply(this, r.args);
                break;
              case 'setGlobalState':
                e.push(() => this.setGlobalState.apply(this, r.args));
                break;
              case 'setTransition':
                e.push(() => {});
                break;
              default:
                i.push(r.command);
            }
          return { operations: e, unimplemented: i };
        }
        addImage(t, i) {
          if (this.getImage(t))
            return this.fire(
              new e.k(new Error(`An image named "${t}" already exists.`))
            );
          this.imageManager.addImage(t, i), this._afterImageUpdated(t);
        }
        updateImage(t, e) {
          this.imageManager.updateImage(t, e);
        }
        getImage(t) {
          return this.imageManager.getImage(t);
        }
        removeImage(t) {
          if (!this.getImage(t))
            return this.fire(
              new e.k(new Error(`An image named "${t}" does not exist.`))
            );
          this.imageManager.removeImage(t), this._afterImageUpdated(t);
        }
        _afterImageUpdated(t) {
          (this._availableImages = this.imageManager.listImages()),
            (this._changedImages[t] = !0),
            (this._changed = !0),
            this.dispatcher.broadcast('SI', this._availableImages),
            this.fire(new e.l('data', { dataType: 'style' }));
        }
        listImages() {
          return this._checkLoaded(), this.imageManager.listImages();
        }
        addSource(t, i, r = {}) {
          if ((this._checkLoaded(), void 0 !== this.tileManagers[t]))
            throw new Error(`Source "${t}" already exists.`);
          if (!i.type)
            throw new Error(
              `The type property must be defined, but only the following properties were given: ${Object.keys(
                i
              ).join(', ')}.`
            );
          if (
            ['vector', 'raster', 'geojson', 'video', 'image'].indexOf(i.type) >=
              0 &&
            this._validate(e.B.source, `sources.${t}`, i, null, r)
          )
            return;
          this.map &&
            this.map._collectResourceTiming &&
            (i.collectResourceTiming = !0);
          const n = (this.tileManagers[t] = new St(t, i, this.dispatcher));
          (n.style = this),
            n.setEventedParent(this, () => ({
              isSourceLoaded: n.loaded(),
              source: n.serialize(),
              sourceId: t,
            })),
            n.onAdd(this.map),
            (this._changed = !0);
        }
        removeSource(t) {
          if ((this._checkLoaded(), void 0 === this.tileManagers[t]))
            throw new Error('There is no source with this ID');
          for (const r in this._layers)
            if (this._layers[r].source === t)
              return this.fire(
                new e.k(
                  new Error(
                    `Source "${t}" cannot be removed while layer "${r}" is using it.`
                  )
                )
              );
          const i = this.tileManagers[t];
          delete this.tileManagers[t],
            delete this._updatedSources[t],
            i.fire(
              new e.l('data', {
                sourceDataType: 'metadata',
                dataType: 'source',
                sourceId: t,
              })
            ),
            i.setEventedParent(null),
            i.onRemove(this.map),
            (this._changed = !0);
        }
        setGeoJSONSourceData(t, e) {
          if ((this._checkLoaded(), void 0 === this.tileManagers[t]))
            throw new Error(`There is no source with this ID=${t}`);
          const i = this.tileManagers[t].getSource();
          if ('geojson' !== i.type)
            throw new Error(
              `geojsonSource.type is ${i.type}, which is !== 'geojson`
            );
          i.setData(e), (this._changed = !0);
        }
        getSource(t) {
          return this.tileManagers[t] && this.tileManagers[t].getSource();
        }
        addLayer(t, i, r = {}) {
          this._checkLoaded();
          const n = t.id;
          if (this.getLayer(n))
            return void this.fire(
              new e.k(new Error(`Layer "${n}" already exists on this map.`))
            );
          let a;
          if ('custom' === t.type) {
            if (Si(this, e.bQ(t))) return;
            a = e.bM(t, this._globalState);
          } else {
            if (
              ('source' in t &&
                'object' == typeof t.source &&
                (this.addSource(n, t.source),
                (t = e.bO(t)),
                (t = e.e(t, { source: n }))),
              this._validate(
                e.B.layer,
                `layers.${n}`,
                t,
                { arrayIndex: -1 },
                r
              ))
            )
              return;
            (a = e.bM(t, this._globalState)),
              this._validateLayer(a),
              a.setEventedParent(this, { layer: { id: n } });
          }
          const s = i ? this._order.indexOf(i) : this._order.length;
          if (i && -1 === s)
            this.fire(
              new e.k(
                new Error(
                  `Cannot add layer "${n}" before non-existing layer "${i}".`
                )
              )
            );
          else {
            if (
              (this._order.splice(s, 0, n),
              (this._layerOrderChanged = !0),
              (this._layers[n] = a),
              this._removedLayers[n] && a.source && 'custom' !== a.type)
            ) {
              const t = this._removedLayers[n];
              delete this._removedLayers[n],
                t.type !== a.type
                  ? (this._updatedSources[a.source] = 'clear')
                  : ((this._updatedSources[a.source] = 'reload'),
                    this.tileManagers[a.source].pause());
            }
            this._updateLayer(a), a.onAdd && a.onAdd(this.map);
          }
        }
        moveLayer(t, i) {
          if ((this._checkLoaded(), (this._changed = !0), !this._layers[t]))
            return void this.fire(
              new e.k(
                new Error(
                  `The layer '${t}' does not exist in the map's style and cannot be moved.`
                )
              )
            );
          if (t === i) return;
          const r = this._order.indexOf(t);
          this._order.splice(r, 1);
          const n = i ? this._order.indexOf(i) : this._order.length;
          i && -1 === n
            ? this.fire(
                new e.k(
                  new Error(
                    `Cannot move layer "${t}" before non-existing layer "${i}".`
                  )
                )
              )
            : (this._order.splice(n, 0, t), (this._layerOrderChanged = !0));
        }
        removeLayer(t) {
          this._checkLoaded();
          const i = this._layers[t];
          if (!i)
            return void this.fire(
              new e.k(new Error(`Cannot remove non-existing layer "${t}".`))
            );
          i.setEventedParent(null);
          const r = this._order.indexOf(t);
          this._order.splice(r, 1),
            (this._layerOrderChanged = !0),
            (this._changed = !0),
            (this._removedLayers[t] = i),
            delete this._layers[t],
            this._serializedLayers && delete this._serializedLayers[t],
            delete this._updatedLayers[t],
            delete this._updatedPaintProps[t],
            i.onRemove && i.onRemove(this.map);
        }
        getLayer(t) {
          return this._layers[t];
        }
        getLayersOrder() {
          return [...this._order];
        }
        hasLayer(t) {
          return t in this._layers;
        }
        setLayerZoomRange(t, i, r) {
          this._checkLoaded();
          const n = this.getLayer(t);
          n
            ? (n.minzoom === i && n.maxzoom === r) ||
              (null != i && (n.minzoom = i),
              null != r && (n.maxzoom = r),
              this._updateLayer(n))
            : this.fire(
                new e.k(
                  new Error(
                    `Cannot set the zoom range of non-existing layer "${t}".`
                  )
                )
              );
        }
        setFilter(t, i, r = {}) {
          this._checkLoaded();
          const n = this.getLayer(t);
          if (n) {
            if (!e.bK(n.filter, i))
              return null == i
                ? (n.setFilter(void 0), void this._updateLayer(n))
                : void (
                    this._validate(
                      e.B.filter,
                      `layers.${n.id}.filter`,
                      i,
                      null,
                      r
                    ) || (n.setFilter(e.bO(i)), this._updateLayer(n))
                  );
          } else this.fire(new e.k(new Error(`Cannot filter non-existing layer "${t}".`)));
        }
        getFilter(t) {
          return e.bO(this.getLayer(t).filter);
        }
        setLayoutProperty(t, i, r, n = {}) {
          this._checkLoaded();
          const a = this.getLayer(t);
          a
            ? e.bK(a.getLayoutProperty(i), r) ||
              (a.setLayoutProperty(i, r, n), this._updateLayer(a))
            : this.fire(
                new e.k(new Error(`Cannot style non-existing layer "${t}".`))
              );
        }
        getLayoutProperty(t, i) {
          const r = this.getLayer(t);
          if (r) return r.getLayoutProperty(i);
          this.fire(
            new e.k(new Error(`Cannot get style of non-existing layer "${t}".`))
          );
        }
        setPaintProperty(t, i, r, n = {}) {
          this._checkLoaded();
          const a = this.getLayer(t);
          a
            ? e.bK(a.getPaintProperty(i), r) ||
              this._updatePaintProperty(a, i, r, n)
            : this.fire(
                new e.k(new Error(`Cannot style non-existing layer "${t}".`))
              );
        }
        _updatePaintProperty(t, i, r, n = {}) {
          t.setPaintProperty(i, r, n) && this._updateLayer(t),
            e.bN(t) &&
              'raster-fade-duration' === i &&
              this.tileManagers[t.source].setRasterFadeDuration(r),
            (this._changed = !0),
            (this._updatedPaintProps[t.id] = !0),
            (this._serializedLayers = null);
        }
        getPaintProperty(t, e) {
          return this.getLayer(t).getPaintProperty(e);
        }
        setFeatureState(t, i) {
          this._checkLoaded();
          const r = t.source,
            n = t.sourceLayer,
            a = this.tileManagers[r];
          if (void 0 === a)
            return void this.fire(
              new e.k(
                new Error(
                  `The source '${r}' does not exist in the map's style.`
                )
              )
            );
          const s = a.getSource().type;
          'geojson' === s && n
            ? this.fire(
                new e.k(
                  new Error(
                    'GeoJSON sources cannot have a sourceLayer parameter.'
                  )
                )
              )
            : 'vector' !== s || n
            ? (void 0 === t.id &&
                this.fire(
                  new e.k(
                    new Error('The feature id parameter must be provided.')
                  )
                ),
              a.setFeatureState(n, t.id, i))
            : this.fire(
                new e.k(
                  new Error(
                    'The sourceLayer parameter must be provided for vector source types.'
                  )
                )
              );
        }
        removeFeatureState(t, i) {
          this._checkLoaded();
          const r = t.source,
            n = this.tileManagers[r];
          if (void 0 === n)
            return void this.fire(
              new e.k(
                new Error(
                  `The source '${r}' does not exist in the map's style.`
                )
              )
            );
          const a = n.getSource().type,
            s = 'vector' === a ? t.sourceLayer : void 0;
          'vector' !== a || s
            ? i && 'string' != typeof t.id && 'number' != typeof t.id
              ? this.fire(
                  new e.k(
                    new Error(
                      'A feature id is required to remove its specific state property.'
                    )
                  )
                )
              : n.removeFeatureState(s, t.id, i)
            : this.fire(
                new e.k(
                  new Error(
                    'The sourceLayer parameter must be provided for vector source types.'
                  )
                )
              );
        }
        getFeatureState(t) {
          this._checkLoaded();
          const i = t.source,
            r = t.sourceLayer,
            n = this.tileManagers[i];
          if (void 0 !== n)
            return 'vector' !== n.getSource().type || r
              ? (void 0 === t.id &&
                  this.fire(
                    new e.k(
                      new Error('The feature id parameter must be provided.')
                    )
                  ),
                n.getFeatureState(r, t.id))
              : void this.fire(
                  new e.k(
                    new Error(
                      'The sourceLayer parameter must be provided for vector source types.'
                    )
                  )
                );
          this.fire(
            new e.k(
              new Error(`The source '${i}' does not exist in the map's style.`)
            )
          );
        }
        getTransition() {
          return e.e(
            { duration: 300, delay: 0 },
            this.stylesheet && this.stylesheet.transition
          );
        }
        serialize() {
          if (!this._loaded) return;
          const t = e.bR(this.tileManagers, (t) => t.serialize()),
            i = this._serializeByIds(this._order, !0),
            r = this.map.getTerrain() || void 0,
            n = this.stylesheet;
          return e.bS(
            {
              version: n.version,
              name: n.name,
              metadata: n.metadata,
              light: n.light,
              sky: n.sky,
              center: n.center,
              zoom: n.zoom,
              bearing: n.bearing,
              pitch: n.pitch,
              sprite: n.sprite,
              glyphs: n.glyphs,
              transition: n.transition,
              projection: n.projection,
              sources: t,
              layers: i,
              terrain: r,
            },
            (t) => void 0 !== t
          );
        }
        _updateLayer(t) {
          (this._updatedLayers[t.id] = !0),
            t.source &&
              !this._updatedSources[t.source] &&
              'raster' !== this.tileManagers[t.source].getSource().type &&
              ((this._updatedSources[t.source] = 'reload'),
              this.tileManagers[t.source].pause()),
            (this._serializedLayers = null),
            (this._changed = !0);
        }
        _flattenAndSortRenderedFeatures(t) {
          const e = (t) => 'fill-extrusion' === this._layers[t].type,
            i = {},
            r = [];
          for (let a = this._order.length - 1; a >= 0; a--) {
            const n = this._order[a];
            if (e(n)) {
              i[n] = a;
              for (const e of t) {
                const t = e[n];
                if (t) for (const e of t) r.push(e);
              }
            }
          }
          r.sort((t, e) => e.intersectionZ - t.intersectionZ);
          const n = [];
          for (let a = this._order.length - 1; a >= 0; a--) {
            const s = this._order[a];
            if (e(s))
              for (let t = r.length - 1; t >= 0; t--) {
                const e = r[t].feature;
                if (i[e.layer.id] < a) break;
                n.push(e), r.pop();
              }
            else
              for (const e of t) {
                const t = e[s];
                if (t) for (const e of t) n.push(e.feature);
              }
          }
          return n;
        }
        queryRenderedFeatures(t, i, r) {
          i &&
            i.filter &&
            this._validate(
              e.B.filter,
              'queryRenderedFeatures.filter',
              i.filter,
              null,
              i
            );
          const n = {};
          if (i && i.layers) {
            if (!(Array.isArray(i.layers) || i.layers instanceof Set))
              return (
                this.fire(
                  new e.k(
                    new Error(
                      'parameters.layers must be an Array or a Set of strings'
                    )
                  )
                ),
                []
              );
            for (const t of i.layers) {
              const i = this._layers[t];
              if (!i)
                return (
                  this.fire(
                    new e.k(
                      new Error(
                        `The layer '${t}' does not exist in the map's style and cannot be queried for features.`
                      )
                    )
                  ),
                  []
                );
              n[i.source] = !0;
            }
          }
          const a = [];
          i.availableImages = this._availableImages;
          const s = this._serializedAllLayers(),
            o =
              i.layers instanceof Set
                ? i.layers
                : Array.isArray(i.layers)
                ? new Set(i.layers)
                : null,
            l = Object.assign(Object.assign({}, i), {
              layers: o,
              globalState: this._globalState,
            });
          for (const e in this.tileManagers)
            (i.layers && !n[e]) ||
              a.push(
                U(
                  this.tileManagers[e],
                  this._layers,
                  s,
                  t,
                  l,
                  r,
                  this.map.terrain
                    ? (t, e, i) => this.map.terrain.getElevation(t, e, i)
                    : void 0
                )
              );
          return (
            this.placement &&
              a.push(
                (function (t, e, i, r, n, a, s) {
                  const o = {},
                    l = a.queryRenderedSymbols(r),
                    c = [];
                  for (const h of Object.keys(l).map(Number)) c.push(s[h]);
                  c.sort(G);
                  for (const h of c) {
                    const i = h.featureIndex.lookupSymbolFeatures(
                      l[h.bucketInstanceId],
                      e,
                      h.bucketIndex,
                      h.sourceLayerIndex,
                      { filterSpec: n.filter, globalState: n.globalState },
                      n.layers,
                      n.availableImages,
                      t
                    );
                    for (const t in i) {
                      const e = (o[t] = o[t] || []),
                        r = i[t];
                      r.sort((t, e) => {
                        const i = h.featureSortOrder;
                        if (i) {
                          const r = i.indexOf(t.featureIndex);
                          return i.indexOf(e.featureIndex) - r;
                        }
                        return e.featureIndex - t.featureIndex;
                      });
                      for (const t of r) e.push(t);
                    }
                  }
                  return (function (t, e, i) {
                    for (const r in t)
                      for (const n of t[r]) Z(n, i[e[r].source]);
                    return t;
                  })(o, t, i);
                })(
                  this._layers,
                  s,
                  this.tileManagers,
                  t,
                  l,
                  this.placement.collisionIndex,
                  this.placement.retainedQueryData
                )
              ),
            this._flattenAndSortRenderedFeatures(a)
          );
        }
        querySourceFeatures(t, i) {
          (null == i ? void 0 : i.filter) &&
            this._validate(
              e.B.filter,
              'querySourceFeatures.filter',
              i.filter,
              null,
              i
            );
          const r = this.tileManagers[t];
          return r
            ? (function (t, e) {
                const i = t.getRenderableIds().map((e) => t.getTileByID(e)),
                  r = [],
                  n = {};
                for (let a = 0; a < i.length; a++) {
                  const t = i[a],
                    s = t.tileID.canonical.key;
                  n[s] || ((n[s] = !0), t.querySourceFeatures(r, e));
                }
                return r;
              })(
                r,
                i
                  ? Object.assign(Object.assign({}, i), {
                      globalState: this._globalState,
                    })
                  : { globalState: this._globalState }
              )
            : [];
        }
        getLight() {
          return this.light.getLight();
        }
        setLight(t, i = {}) {
          this._checkLoaded();
          const r = this.light.getLight();
          let n = !1;
          for (const s in t)
            if (!e.bK(t[s], r[s])) {
              n = !0;
              break;
            }
          if (!n) return;
          const a = {
            now: l(),
            transition: e.e(
              { duration: 300, delay: 0 },
              this.stylesheet.transition
            ),
          };
          this.light.setLight(t, i), this.light.updateTransitions(a);
        }
        getProjection() {
          var t;
          return null === (t = this.stylesheet) || void 0 === t
            ? void 0
            : t.projection;
        }
        setProjection(t) {
          if ((this._checkLoaded(), this.projection)) {
            if (this.projection.name === t.type) return;
            this.projection.destroy(), delete this.projection;
          }
          (this.stylesheet.projection = t), this._setProjectionInternal(t.type);
        }
        getSky() {
          var t;
          return null === (t = this.stylesheet) || void 0 === t
            ? void 0
            : t.sky;
        }
        setSky(t, i = {}) {
          this._checkLoaded();
          const r = this.getSky();
          let n = !1;
          if (!t && !r) return;
          if (t && !r) n = !0;
          else if (!t && r) n = !0;
          else
            for (const s in t)
              if (!e.bK(t[s], r[s])) {
                n = !0;
                break;
              }
          if (!n) return;
          const a = {
            now: l(),
            transition: e.e(
              { duration: 300, delay: 0 },
              this.stylesheet.transition
            ),
          };
          (this.stylesheet.sky = t),
            this.sky.setSky(t, i),
            this.sky.updateTransitions(a);
        }
        _setProjectionInternal(t) {
          const i = (function (t, i) {
            const r = { constrain: i };
            if (Array.isArray(t)) {
              const e = new si({ type: t });
              return {
                projection: e,
                transform: new Pi(r),
                cameraHelper: new Ii(e),
              };
            }
            switch (t) {
              case 'mercator':
                return {
                  projection: new Re(),
                  transform: new je(r),
                  cameraHelper: new $e(),
                };
              case 'globe': {
                const t = new si({
                  type: [
                    'interpolate',
                    ['linear'],
                    ['zoom'],
                    11,
                    'vertical-perspective',
                    12,
                    'mercator',
                  ],
                });
                return {
                  projection: t,
                  transform: new Pi(r),
                  cameraHelper: new Ii(t),
                };
              }
              case 'vertical-perspective':
                return {
                  projection: new ni(),
                  transform: new Ti(r),
                  cameraHelper: new Ci(),
                };
              default:
                return (
                  e.w(
                    `Unknown projection name: ${t}. Falling back to mercator projection.`
                  ),
                  {
                    projection: new Re(),
                    transform: new je(r),
                    cameraHelper: new $e(),
                  }
                );
            }
          })(t, this.map.transformConstrain);
          (this.projection = i.projection),
            this.map.migrateProjection(i.transform, i.cameraHelper);
          for (const e in this.tileManagers) this.tileManagers[e].reload();
        }
        _validate(t, i, r, n, a = {}) {
          return (
            (!a || !1 !== a.validate) &&
            Si(
              this,
              t.call(
                e.B,
                e.e(
                  { key: i, style: this.serialize(), value: r, styleSpec: e.t },
                  n
                )
              )
            )
          );
        }
        _remove(t = !0) {
          this._frameRequest &&
            (this._frameRequest.abort(), (this._frameRequest = null)),
            this._loadStyleRequest &&
              (this._loadStyleRequest.abort(), (this._loadStyleRequest = null)),
            this._spriteRequest &&
              (this._spriteRequest.abort(), (this._spriteRequest = null)),
            lt().off(at, this._rtlPluginLoaded);
          for (const e in this._layers) this._layers[e].setEventedParent(null);
          for (const e in this.tileManagers) {
            const t = this.tileManagers[e];
            t.setEventedParent(null), t.onRemove(this.map);
          }
          this.imageManager.setEventedParent(null),
            this.setEventedParent(null),
            t && this.dispatcher.broadcast('RM', void 0),
            this.dispatcher.remove(t);
        }
        _clearSource(t) {
          this.tileManagers[t].clearTiles();
        }
        _reloadSource(t) {
          this.tileManagers[t].resume(), this.tileManagers[t].reload();
        }
        _updateSources(t) {
          for (const e in this.tileManagers)
            this.tileManagers[e].update(t, this.map.terrain);
        }
        _generateCollisionBoxes() {
          for (const t in this.tileManagers) this._reloadSource(t);
        }
        _updatePlacement(t, e, i, r, n = !1) {
          let a = !1,
            s = !1;
          const o = {};
          for (const l of this._order) {
            const e = this._layers[l];
            if ('symbol' !== e.type) continue;
            if (!o[e.source]) {
              const t = this.tileManagers[e.source];
              o[e.source] = t
                .getRenderableIds(!0)
                .map((e) => t.getTileByID(e))
                .sort(
                  (t, e) =>
                    e.tileID.overscaledZ - t.tileID.overscaledZ ||
                    (t.tileID.isLessThan(e.tileID) ? -1 : 1)
                );
            }
            const i = this.crossTileSymbolIndex.addLayer(
              e,
              o[e.source],
              t.center.lng
            );
            a = a || i;
          }
          if (
            (this.crossTileSymbolIndex.pruneUnusedLayers(this._order),
            ((n = n || this._layerOrderChanged || 0 === i) ||
              !this.pauseablePlacement ||
              (this.pauseablePlacement.isDone() &&
                !this.placement.stillRecent(l(), t.zoom))) &&
              ((this.pauseablePlacement = new xe(
                t,
                this.map.terrain,
                this._order,
                n,
                e,
                i,
                r,
                this.placement
              )),
              (this._layerOrderChanged = !1)),
            this.pauseablePlacement.isDone()
              ? this.placement.setStale()
              : (this.pauseablePlacement.continuePlacement(
                  this._order,
                  this._layers,
                  o
                ),
                this.pauseablePlacement.isDone() &&
                  ((this.placement = this.pauseablePlacement.commit(l())),
                  (s = !0)),
                a && this.pauseablePlacement.placement.setStale()),
            s || a)
          )
            for (const l of this._order) {
              const t = this._layers[l];
              'symbol' === t.type &&
                this.placement.updateLayerOpacities(t, o[t.source]);
            }
          return (
            !this.pauseablePlacement.isDone() ||
            this.placement.hasTransitions(l())
          );
        }
        _releaseSymbolFadeTiles() {
          for (const t in this.tileManagers)
            this.tileManagers[t].releaseSymbolFadeTiles();
        }
        getImages(t, i) {
          return e._(this, void 0, void 0, function* () {
            const t = yield this.imageManager.getImages(i.icons);
            this._updateTilesForChangedImages();
            const e = this.tileManagers[i.source];
            return e && e.setDependencies(i.tileID.key, i.type, i.icons), t;
          });
        }
        getGlyphs(t, i) {
          return e._(this, void 0, void 0, function* () {
            const t = yield this.glyphManager.getGlyphs(i.stacks),
              e = this.tileManagers[i.source];
            return e && e.setDependencies(i.tileID.key, i.type, ['']), t;
          });
        }
        getGlyphsUrl() {
          return this.stylesheet.glyphs || null;
        }
        setGlyphs(t, i = {}) {
          this._checkLoaded(),
            (t && this._validate(e.B.glyphs, 'glyphs', t, null, i)) ||
              ((this._glyphsDidChange = !0),
              (this.stylesheet.glyphs = t),
              (this.glyphManager.entries = {}),
              this.glyphManager.setURL(t));
        }
        getDashes(t, i) {
          return e._(this, void 0, void 0, function* () {
            const t = {};
            for (const [e, r] of Object.entries(i.dashes))
              t[e] = this.lineAtlas.getDash(r.dasharray, r.round);
            return t;
          });
        }
        addSprite(t, i, r = {}, n) {
          this._checkLoaded();
          const a = [{ id: t, url: i }],
            s = [...y(this.stylesheet.sprite), ...a];
          this._validate(e.B.sprite, 'sprite', s, null, r) ||
            ((this.stylesheet.sprite = s), this._loadSprite(a, !0, n));
        }
        removeSprite(t) {
          this._checkLoaded();
          const i = y(this.stylesheet.sprite);
          if (i.find((e) => e.id === t)) {
            if (this._spritesImagesIds[t])
              for (const e of this._spritesImagesIds[t])
                this.imageManager.removeImage(e), (this._changedImages[e] = !0);
            i.splice(
              i.findIndex((e) => e.id === t),
              1
            ),
              (this.stylesheet.sprite = i.length > 0 ? i : void 0),
              delete this._spritesImagesIds[t],
              (this._availableImages = this.imageManager.listImages()),
              (this._changed = !0),
              this.dispatcher.broadcast('SI', this._availableImages),
              this.fire(new e.l('data', { dataType: 'style' }));
          } else this.fire(new e.k(new Error(`Sprite "${t}" doesn't exists on this map.`)));
        }
        getSprite() {
          return y(this.stylesheet.sprite);
        }
        setSprite(t, i = {}, r) {
          this._checkLoaded(),
            (t && this._validate(e.B.sprite, 'sprite', t, null, i)) ||
              ((this.stylesheet.sprite = t),
              t
                ? this._loadSprite(t, !0, r)
                : (this._unloadSprite(), r && r(null)));
        }
      }
      var Li = e.aN([
        { name: 'a_pos', type: 'Int16', components: 2 },
        { name: 'a_texture_pos', type: 'Int16', components: 2 },
      ]);
      class Ai {
        constructor() {
          (this.boundProgram = null),
            (this.boundLayoutVertexBuffer = null),
            (this.boundPaintVertexBuffers = []),
            (this.boundIndexBuffer = null),
            (this.boundVertexOffset = null),
            (this.boundDynamicVertexBuffer = null),
            (this.vao = null);
        }
        bind(t, e, i, r, n, a, s, o, l) {
          this.context = t;
          let c = this.boundPaintVertexBuffers.length !== r.length;
          for (let h = 0; !c && h < r.length; h++)
            this.boundPaintVertexBuffers[h] !== r[h] && (c = !0);
          !this.vao ||
          this.boundProgram !== e ||
          this.boundLayoutVertexBuffer !== i ||
          c ||
          this.boundIndexBuffer !== n ||
          this.boundVertexOffset !== a ||
          this.boundDynamicVertexBuffer !== s ||
          this.boundDynamicVertexBuffer2 !== o ||
          this.boundDynamicVertexBuffer3 !== l
            ? this.freshBind(e, i, r, n, a, s, o, l)
            : (t.bindVertexArray.set(this.vao),
              s && s.bind(),
              n && n.dynamicDraw && n.bind(),
              o && o.bind(),
              l && l.bind());
        }
        freshBind(t, e, i, r, n, a, s, o) {
          const l = t.numAttributes,
            c = this.context,
            h = c.gl;
          this.vao && this.destroy(),
            (this.vao = c.createVertexArray()),
            c.bindVertexArray.set(this.vao),
            (this.boundProgram = t),
            (this.boundLayoutVertexBuffer = e),
            (this.boundPaintVertexBuffers = i),
            (this.boundIndexBuffer = r),
            (this.boundVertexOffset = n),
            (this.boundDynamicVertexBuffer = a),
            (this.boundDynamicVertexBuffer2 = s),
            (this.boundDynamicVertexBuffer3 = o),
            e.enableAttributes(h, t);
          for (const u of i) u.enableAttributes(h, t);
          a && a.enableAttributes(h, t),
            s && s.enableAttributes(h, t),
            o && o.enableAttributes(h, t),
            e.bind(),
            e.setVertexAttribPointers(h, t, n);
          for (const u of i) u.bind(), u.setVertexAttribPointers(h, t, n);
          a && (a.bind(), a.setVertexAttribPointers(h, t, n)),
            r && r.bind(),
            s && (s.bind(), s.setVertexAttribPointers(h, t, n)),
            o && (o.bind(), o.setVertexAttribPointers(h, t, n)),
            (c.currentNumAttributes = l);
        }
        destroy() {
          this.vao &&
            (this.context.deleteVertexArray(this.vao), (this.vao = null));
        }
      }
      const Ei = (t, i, r, n, a) => ({
          u_texture: 0,
          u_ele_delta: t,
          u_fog_matrix: i,
          u_fog_color: r ? r.properties.get('fog-color') : e.bi.white,
          u_fog_ground_blend: r ? r.properties.get('fog-ground-blend') : 1,
          u_fog_ground_blend_opacity: a
            ? 0
            : r
            ? r.calculateFogBlendOpacity(n)
            : 0,
          u_horizon_color: r ? r.properties.get('horizon-color') : e.bi.white,
          u_horizon_fog_blend: r ? r.properties.get('horizon-fog-blend') : 1,
          u_is_globe_mode: a ? 1 : 0,
        }),
        Ri = {
          mainMatrix: 'u_projection_matrix',
          tileMercatorCoords: 'u_projection_tile_mercator_coords',
          clippingPlane: 'u_projection_clipping_plane',
          projectionTransition: 'u_projection_transition',
          fallbackMatrix: 'u_projection_fallback_matrix',
        };
      function zi(t) {
        const e = [];
        for (let i = 0; i < t.length; i++) {
          if (null === t[i]) continue;
          const r = t[i].split(' ');
          e.push(r.pop());
        }
        return e;
      }
      class ki {
        constructor(t, i, r, n, a, s, o, l, c = []) {
          const h = t.gl;
          this.program = h.createProgram();
          const u = zi(i.staticAttributes),
            d = r ? r.getBinderAttributes() : [],
            p = u.concat(d),
            f = Se.prelude.staticUniforms ? zi(Se.prelude.staticUniforms) : [],
            m = o.staticUniforms ? zi(o.staticUniforms) : [],
            g = i.staticUniforms ? zi(i.staticUniforms) : [],
            _ = r ? r.getBinderUniforms() : [],
            y = f.concat(m).concat(g).concat(_),
            v = [];
          for (const e of y) v.indexOf(e) < 0 && v.push(e);
          const x = r ? r.defines() : [];
          Qe(h) && x.unshift('#version 300 es'),
            a && x.push('#define OVERDRAW_INSPECTOR;'),
            s && x.push('#define TERRAIN3D;'),
            l && x.push(l),
            c && x.push(...c);
          let b = x
              .concat(
                Se.prelude.fragmentSource,
                o.fragmentSource,
                i.fragmentSource
              )
              .join('\n'),
            w = x
              .concat(Se.prelude.vertexSource, o.vertexSource, i.vertexSource)
              .join('\n');
          Qe(h) ||
            ((b = (function (t) {
              return t
                .replace(/\bin\s/g, 'varying ')
                .replace('out highp vec4 fragColor;', '')
                .replace(/fragColor/g, 'gl_FragColor')
                .replace(/texture\(/g, 'texture2D(');
            })(b)),
            (w = (function (t) {
              return t
                .replace(/\bin\s/g, 'attribute ')
                .replace(/\bout\s/g, 'varying ')
                .replace(/texture\(/g, 'texture2D(');
            })(w)));
          const T = h.createShader(h.FRAGMENT_SHADER);
          if (h.isContextLost()) return void (this.failedToCreate = !0);
          if (
            (h.shaderSource(T, b),
            h.compileShader(T),
            !h.getShaderParameter(T, h.COMPILE_STATUS))
          )
            throw new Error(
              `Could not compile fragment shader: ${h.getShaderInfoLog(T)}`
            );
          h.attachShader(this.program, T);
          const P = h.createShader(h.VERTEX_SHADER);
          if (h.isContextLost()) return void (this.failedToCreate = !0);
          if (
            (h.shaderSource(P, w),
            h.compileShader(P),
            !h.getShaderParameter(P, h.COMPILE_STATUS))
          )
            throw new Error(
              `Could not compile vertex shader: ${h.getShaderInfoLog(P)}`
            );
          h.attachShader(this.program, P), (this.attributes = {});
          const C = {};
          this.numAttributes = p.length;
          for (let e = 0; e < this.numAttributes; e++)
            p[e] &&
              (h.bindAttribLocation(this.program, e, p[e]),
              (this.attributes[p[e]] = e));
          if (
            (h.linkProgram(this.program),
            !h.getProgramParameter(this.program, h.LINK_STATUS))
          )
            throw new Error(
              `Program failed to link: ${h.getProgramInfoLog(this.program)}`
            );
          h.deleteShader(P), h.deleteShader(T);
          for (let e = 0; e < v.length; e++) {
            const t = v[e];
            if (t && !C[t]) {
              const e = h.getUniformLocation(this.program, t);
              e && (C[t] = e);
            }
          }
          (this.fixedUniforms = n(t, C)),
            (this.terrainUniforms = ((t, i) => ({
              u_depth: new e.bT(t, i.u_depth),
              u_terrain: new e.bT(t, i.u_terrain),
              u_terrain_dim: new e.bj(t, i.u_terrain_dim),
              u_terrain_matrix: new e.bV(t, i.u_terrain_matrix),
              u_terrain_unpack: new e.bW(t, i.u_terrain_unpack),
              u_terrain_exaggeration: new e.bj(t, i.u_terrain_exaggeration),
            }))(t, C)),
            (this.projectionUniforms = ((t, i) => ({
              u_projection_matrix: new e.bV(t, i.u_projection_matrix),
              u_projection_tile_mercator_coords: new e.bW(
                t,
                i.u_projection_tile_mercator_coords
              ),
              u_projection_clipping_plane: new e.bW(
                t,
                i.u_projection_clipping_plane
              ),
              u_projection_transition: new e.bj(t, i.u_projection_transition),
              u_projection_fallback_matrix: new e.bV(
                t,
                i.u_projection_fallback_matrix
              ),
            }))(t, C)),
            (this.binderUniforms = r ? r.getUniforms(t, C) : []);
        }
        draw(t, e, i, r, n, a, s, o, l, c, h, u, d, p, f, m, g, _, y) {
          const v = t.gl;
          if (this.failedToCreate) return;
          if (
            (t.program.set(this.program),
            t.setDepthMode(i),
            t.setStencilMode(r),
            t.setColorMode(n),
            t.setCullFace(a),
            o)
          ) {
            t.activeTexture.set(v.TEXTURE2),
              v.bindTexture(v.TEXTURE_2D, o.depthTexture),
              t.activeTexture.set(v.TEXTURE3),
              v.bindTexture(v.TEXTURE_2D, o.texture);
            for (const t in this.terrainUniforms)
              this.terrainUniforms[t].set(o[t]);
          }
          if (l) for (const b in l) this.projectionUniforms[Ri[b]].set(l[b]);
          if (s)
            for (const b in this.fixedUniforms) this.fixedUniforms[b].set(s[b]);
          m && m.setUniforms(t, this.binderUniforms, p, { zoom: f });
          let x = 0;
          switch (e) {
            case v.LINES:
              x = 2;
              break;
            case v.TRIANGLES:
              x = 3;
              break;
            case v.LINE_STRIP:
              x = 1;
          }
          for (const b of d.get()) {
            const i = b.vaos || (b.vaos = {});
            (i[c] || (i[c] = new Ai())).bind(
              t,
              this,
              h,
              m ? m.getPaintVertexBuffers() : [],
              u,
              b.vertexOffset,
              g,
              _,
              y
            ),
              v.drawElements(
                e,
                b.primitiveLength * x,
                v.UNSIGNED_SHORT,
                b.primitiveOffset * x * 2
              );
          }
        }
      }
      function Oi(t, i, r) {
        const n = 1 / e.aG(r, 1, i.transform.tileZoom),
          a = Math.pow(2, r.tileID.overscaledZ),
          s = (r.tileSize * Math.pow(2, i.transform.tileZoom)) / a,
          o = s * (r.tileID.canonical.x + r.tileID.wrap * a),
          l = s * r.tileID.canonical.y;
        return {
          u_image: 0,
          u_texsize: r.imageAtlasTexture.size,
          u_scale: [n, t.fromScale, t.toScale],
          u_fade: t.t,
          u_pixel_coord_upper: [o >> 16, l >> 16],
          u_pixel_coord_lower: [65535 & o, 65535 & l],
        };
      }
      const Fi = (t, i, r, n) => {
          const a = t.style.light,
            s = a.properties.get('position'),
            o = [s.x, s.y, s.z],
            l = e.bZ();
          'viewport' === a.properties.get('anchor') &&
            e.b_(l, t.transform.bearingInRadians),
            e.b$(o, o, l);
          const c = t.transform.transformLightDirection(o),
            h = a.properties.get('color');
          return {
            u_lightpos: o,
            u_lightpos_globe: c,
            u_lightintensity: a.properties.get('intensity'),
            u_lightcolor: [h.r, h.g, h.b],
            u_vertical_gradient: +i,
            u_opacity: r,
            u_fill_translate: n,
          };
        },
        Bi = (t, i, r, n, a, s, o) =>
          e.e(Fi(t, i, r, n), Oi(s, t, o), {
            u_height_factor: -Math.pow(2, a.overscaledZ) / o.tileSize / 8,
          }),
        Ni = (t, i, r, n) => e.e(Oi(i, t, r), { u_fill_translate: n }),
        Vi = (t, e) => ({ u_world: t, u_fill_translate: e }),
        ji = (t, i, r, n, a) => e.e(Ni(t, i, r, a), { u_world: n }),
        Ui = (t, i, r, n, a) => {
          const s = t.transform;
          let o,
            l,
            c = 0;
          if ('map' === r.paint.get('circle-pitch-alignment')) {
            const t = e.aG(i, 1, s.zoom);
            (o = !0),
              (l = [t, t]),
              (c =
                (t / (e.a3 * Math.pow(2, i.tileID.overscaledZ))) *
                2 *
                Math.PI *
                a);
          } else (o = !1), (l = s.pixelsToGLUnits);
          return {
            u_camera_to_center_distance: s.cameraToCenterDistance,
            u_scale_with_map: +('map' === r.paint.get('circle-pitch-scale')),
            u_pitch_with_map: +o,
            u_device_pixel_ratio: t.pixelRatio,
            u_extrude_scale: l,
            u_globe_extrude_scale: c,
            u_translate: n,
          };
        },
        Gi = (t) => ({ u_pixel_extrude_scale: [1 / t.width, 1 / t.height] }),
        Zi = (t) => ({ u_viewport_size: [t.width, t.height] }),
        $i = (t, e = 1) => ({ u_color: t, u_overlay: 0, u_overlay_scale: e }),
        qi = (t, i, r, n) => {
          const a =
            (e.aG(t, 1, i) / (e.a3 * Math.pow(2, t.tileID.overscaledZ))) *
            2 *
            Math.PI *
            n;
          return {
            u_extrude_scale: e.aG(t, 1, i),
            u_intensity: r,
            u_globe_extrude_scale: a,
          };
        },
        Hi = (t, i, r, n) => {
          const a = e.M();
          e.c0(a, 0, t.width, t.height, 0, 0, 1);
          const s = t.context.gl;
          return {
            u_matrix: a,
            u_world: [s.drawingBufferWidth, s.drawingBufferHeight],
            u_image: r,
            u_color_ramp: n,
            u_opacity: i.paint.get('heatmap-opacity'),
          };
        },
        Wi = (t, e, i) => {
          const r = i.paint.get('hillshade-accent-color');
          let n;
          switch (i.paint.get('hillshade-method')) {
            case 'basic':
              n = 4;
              break;
            case 'combined':
              n = 1;
              break;
            case 'igor':
              n = 2;
              break;
            case 'multidirectional':
              n = 3;
              break;
            default:
              n = 0;
          }
          const a = i.getIlluminationProperties();
          for (let s = 0; s < a.directionRadians.length; s++)
            'viewport' === i.paint.get('hillshade-illumination-anchor') &&
              (a.directionRadians[s] += t.transform.bearingInRadians);
          return {
            u_image: 0,
            u_latrange: Yi(0, e.tileID),
            u_exaggeration: i.paint.get('hillshade-exaggeration'),
            u_altitudes: a.altitudeRadians,
            u_azimuths: a.directionRadians,
            u_accent: r,
            u_method: n,
            u_highlights: a.highlightColor,
            u_shadows: a.shadowColor,
          };
        },
        Xi = (t, i) => {
          const r = i.stride,
            n = e.M();
          return (
            e.c0(n, 0, e.a3, -e.a3, 0, 0, 1),
            e.N(n, n, [0, -e.a3, 0]),
            {
              u_matrix: n,
              u_image: 1,
              u_dimension: [r, r],
              u_zoom: t.overscaledZ,
              u_unpack: i.getUnpackVector(),
            }
          );
        };
      function Yi(t, i) {
        const r = Math.pow(2, i.canonical.z),
          n = i.canonical.y;
        return [
          new e.a5(0, n / r).toLngLat().lat,
          new e.a5(0, (n + 1) / r).toLngLat().lat,
        ];
      }
      const Ki = (t, e, i = 0) => ({
          u_image: 0,
          u_unpack: e.getUnpackVector(),
          u_dimension: [e.stride, e.stride],
          u_elevation_stops: 1,
          u_color_stops: 4,
          u_color_ramp_size: i,
          u_opacity: t.paint.get('color-relief-opacity'),
        }),
        Ji = (t, i, r, n) => {
          const a = t.transform;
          return {
            u_translation: nr(t, i, r),
            u_ratio: n / e.aG(i, 1, a.zoom),
            u_device_pixel_ratio: t.pixelRatio,
            u_units_to_pixels: [
              1 / a.pixelsToGLUnits[0],
              1 / a.pixelsToGLUnits[1],
            ],
          };
        },
        Qi = (t, i, r, n, a) =>
          e.e(Ji(t, i, r, n), { u_image: 0, u_image_height: a }),
        tr = (t, i, r, n, a) => {
          const s = t.transform,
            o = rr(i, s);
          return {
            u_translation: nr(t, i, r),
            u_texsize: i.imageAtlasTexture.size,
            u_ratio: n / e.aG(i, 1, s.zoom),
            u_device_pixel_ratio: t.pixelRatio,
            u_image: 0,
            u_scale: [o, a.fromScale, a.toScale],
            u_fade: a.t,
            u_units_to_pixels: [
              1 / s.pixelsToGLUnits[0],
              1 / s.pixelsToGLUnits[1],
            ],
          };
        },
        er = (t, i, r, n, a) => {
          const s = rr(i, t.transform);
          return e.e(Ji(t, i, r, n), {
            u_tileratio: s,
            u_crossfade_from: a.fromScale,
            u_crossfade_to: a.toScale,
            u_image: 0,
            u_mix: a.t,
            u_lineatlas_width: t.lineAtlas.width,
            u_lineatlas_height: t.lineAtlas.height,
          });
        },
        ir = (t, i, r, n, a, s) => {
          const o = rr(i, t.transform);
          return e.e(Ji(t, i, r, n), {
            u_image: 0,
            u_image_height: s,
            u_tileratio: o,
            u_crossfade_from: a.fromScale,
            u_crossfade_to: a.toScale,
            u_image_dash: 1,
            u_mix: a.t,
            u_lineatlas_width: t.lineAtlas.width,
            u_lineatlas_height: t.lineAtlas.height,
          });
        };
      function rr(t, i) {
        return 1 / e.aG(t, 1, i.tileZoom);
      }
      function nr(t, i, r) {
        return e.aH(
          t.transform,
          i,
          r.paint.get('line-translate'),
          r.paint.get('line-translate-anchor')
        );
      }
      const ar = (t, e, i, r, n) => {
        return {
          u_tl_parent: t,
          u_scale_parent: e,
          u_buffer_scale: 1,
          u_fade_t: i.mix,
          u_opacity: i.opacity * r.paint.get('raster-opacity'),
          u_image0: 0,
          u_image1: 1,
          u_brightness_low: r.paint.get('raster-brightness-min'),
          u_brightness_high: r.paint.get('raster-brightness-max'),
          u_saturation_factor:
            ((s = r.paint.get('raster-saturation')),
            s > 0 ? 1 - 1 / (1.001 - s) : -s),
          u_contrast_factor:
            ((a = r.paint.get('raster-contrast')), a > 0 ? 1 / (1 - a) : 1 + a),
          u_spin_weights: sr(r.paint.get('raster-hue-rotate')),
          u_coords_top: [n[0].x, n[0].y, n[1].x, n[1].y],
          u_coords_bottom: [n[3].x, n[3].y, n[2].x, n[2].y],
        };
        var a, s;
      };
      function sr(t) {
        t *= Math.PI / 180;
        const e = Math.sin(t),
          i = Math.cos(t);
        return [
          (2 * i + 1) / 3,
          (-Math.sqrt(3) * e - i + 1) / 3,
          (Math.sqrt(3) * e - i + 1) / 3,
        ];
      }
      const or = (t, e, i, r, n, a, s, o, l, c, h, u, d) => {
          const p = s.transform;
          return {
            u_is_size_zoom_constant: +('constant' === t || 'source' === t),
            u_is_size_feature_constant: +('constant' === t || 'camera' === t),
            u_size_t: e ? e.uSizeT : 0,
            u_size: e ? e.uSize : 0,
            u_camera_to_center_distance: p.cameraToCenterDistance,
            u_pitch: (p.pitch / 360) * 2 * Math.PI,
            u_rotate_symbol: +i,
            u_aspect_ratio: p.width / p.height,
            u_fade_change: s.options.fadeDuration ? s.symbolFadeChange : 1,
            u_label_plane_matrix: o,
            u_coord_matrix: l,
            u_is_text: +h,
            u_pitch_with_map: +r,
            u_is_along_line: n,
            u_is_variable_anchor: a,
            u_texsize: u,
            u_texture: 0,
            u_translation: c,
            u_pitched_scale: d,
          };
        },
        lr = (t, i, r, n, a, s, o, l, c, h, u, d, p, f) => {
          const m = o.transform;
          return e.e(or(t, i, r, n, a, s, o, l, c, h, u, d, f), {
            u_gamma_scale: n
              ? Math.cos((m.pitch * Math.PI) / 180) * m.cameraToCenterDistance
              : 1,
            u_device_pixel_ratio: o.pixelRatio,
            u_is_halo: 1,
          });
        },
        cr = (t, i, r, n, a, s, o, l, c, h, u, d, p) =>
          e.e(lr(t, i, r, n, a, s, o, l, c, h, !0, u, 0, p), {
            u_texsize_icon: d,
            u_texture_icon: 1,
          }),
        hr = (t, e) => ({ u_opacity: t, u_color: e }),
        ur = (t, i, r, n, a) =>
          e.e(
            (function (t, i, r, n) {
              const a = r.imageManager.getPattern(t.from.toString()),
                s = r.imageManager.getPattern(t.to.toString()),
                { width: o, height: l } = r.imageManager.getPixelSize(),
                c = Math.pow(2, n.tileID.overscaledZ),
                h = (n.tileSize * Math.pow(2, r.transform.tileZoom)) / c,
                u = h * (n.tileID.canonical.x + n.tileID.wrap * c),
                d = h * n.tileID.canonical.y;
              return {
                u_image: 0,
                u_pattern_tl_a: a.tl,
                u_pattern_br_a: a.br,
                u_pattern_tl_b: s.tl,
                u_pattern_br_b: s.br,
                u_texsize: [o, l],
                u_mix: i.t,
                u_pattern_size_a: a.displaySize,
                u_pattern_size_b: s.displaySize,
                u_scale_a: i.fromScale,
                u_scale_b: i.toScale,
                u_tile_units_to_pixels: 1 / e.aG(n, 1, r.transform.tileZoom),
                u_pixel_coord_upper: [u >> 16, d >> 16],
                u_pixel_coord_lower: [65535 & u, 65535 & d],
              };
            })(r, a, i, n),
            { u_opacity: t }
          ),
        dr = (t, e) => {},
        pr = {
          fillExtrusion: (t, i) => ({
            u_lightpos: new e.bX(t, i.u_lightpos),
            u_lightpos_globe: new e.bX(t, i.u_lightpos_globe),
            u_lightintensity: new e.bj(t, i.u_lightintensity),
            u_lightcolor: new e.bX(t, i.u_lightcolor),
            u_vertical_gradient: new e.bj(t, i.u_vertical_gradient),
            u_opacity: new e.bj(t, i.u_opacity),
            u_fill_translate: new e.bY(t, i.u_fill_translate),
          }),
          fillExtrusionPattern: (t, i) => ({
            u_lightpos: new e.bX(t, i.u_lightpos),
            u_lightpos_globe: new e.bX(t, i.u_lightpos_globe),
            u_lightintensity: new e.bj(t, i.u_lightintensity),
            u_lightcolor: new e.bX(t, i.u_lightcolor),
            u_vertical_gradient: new e.bj(t, i.u_vertical_gradient),
            u_height_factor: new e.bj(t, i.u_height_factor),
            u_opacity: new e.bj(t, i.u_opacity),
            u_fill_translate: new e.bY(t, i.u_fill_translate),
            u_image: new e.bT(t, i.u_image),
            u_texsize: new e.bY(t, i.u_texsize),
            u_pixel_coord_upper: new e.bY(t, i.u_pixel_coord_upper),
            u_pixel_coord_lower: new e.bY(t, i.u_pixel_coord_lower),
            u_scale: new e.bX(t, i.u_scale),
            u_fade: new e.bj(t, i.u_fade),
          }),
          fill: (t, i) => ({
            u_fill_translate: new e.bY(t, i.u_fill_translate),
          }),
          fillPattern: (t, i) => ({
            u_image: new e.bT(t, i.u_image),
            u_texsize: new e.bY(t, i.u_texsize),
            u_pixel_coord_upper: new e.bY(t, i.u_pixel_coord_upper),
            u_pixel_coord_lower: new e.bY(t, i.u_pixel_coord_lower),
            u_scale: new e.bX(t, i.u_scale),
            u_fade: new e.bj(t, i.u_fade),
            u_fill_translate: new e.bY(t, i.u_fill_translate),
          }),
          fillOutline: (t, i) => ({
            u_world: new e.bY(t, i.u_world),
            u_fill_translate: new e.bY(t, i.u_fill_translate),
          }),
          fillOutlinePattern: (t, i) => ({
            u_world: new e.bY(t, i.u_world),
            u_image: new e.bT(t, i.u_image),
            u_texsize: new e.bY(t, i.u_texsize),
            u_pixel_coord_upper: new e.bY(t, i.u_pixel_coord_upper),
            u_pixel_coord_lower: new e.bY(t, i.u_pixel_coord_lower),
            u_scale: new e.bX(t, i.u_scale),
            u_fade: new e.bj(t, i.u_fade),
            u_fill_translate: new e.bY(t, i.u_fill_translate),
          }),
          circle: (t, i) => ({
            u_camera_to_center_distance: new e.bj(
              t,
              i.u_camera_to_center_distance
            ),
            u_scale_with_map: new e.bT(t, i.u_scale_with_map),
            u_pitch_with_map: new e.bT(t, i.u_pitch_with_map),
            u_extrude_scale: new e.bY(t, i.u_extrude_scale),
            u_device_pixel_ratio: new e.bj(t, i.u_device_pixel_ratio),
            u_globe_extrude_scale: new e.bj(t, i.u_globe_extrude_scale),
            u_translate: new e.bY(t, i.u_translate),
          }),
          collisionBox: (t, i) => ({
            u_pixel_extrude_scale: new e.bY(t, i.u_pixel_extrude_scale),
          }),
          collisionCircle: (t, i) => ({
            u_viewport_size: new e.bY(t, i.u_viewport_size),
          }),
          debug: (t, i) => ({
            u_color: new e.bU(t, i.u_color),
            u_overlay: new e.bT(t, i.u_overlay),
            u_overlay_scale: new e.bj(t, i.u_overlay_scale),
          }),
          depth: dr,
          clippingMask: dr,
          heatmap: (t, i) => ({
            u_extrude_scale: new e.bj(t, i.u_extrude_scale),
            u_intensity: new e.bj(t, i.u_intensity),
            u_globe_extrude_scale: new e.bj(t, i.u_globe_extrude_scale),
          }),
          heatmapTexture: (t, i) => ({
            u_matrix: new e.bV(t, i.u_matrix),
            u_world: new e.bY(t, i.u_world),
            u_image: new e.bT(t, i.u_image),
            u_color_ramp: new e.bT(t, i.u_color_ramp),
            u_opacity: new e.bj(t, i.u_opacity),
          }),
          hillshade: (t, i) => ({
            u_image: new e.bT(t, i.u_image),
            u_latrange: new e.bY(t, i.u_latrange),
            u_exaggeration: new e.bj(t, i.u_exaggeration),
            u_altitudes: new e.c2(t, i.u_altitudes),
            u_azimuths: new e.c2(t, i.u_azimuths),
            u_accent: new e.bU(t, i.u_accent),
            u_method: new e.bT(t, i.u_method),
            u_shadows: new e.c1(t, i.u_shadows),
            u_highlights: new e.c1(t, i.u_highlights),
          }),
          hillshadePrepare: (t, i) => ({
            u_matrix: new e.bV(t, i.u_matrix),
            u_image: new e.bT(t, i.u_image),
            u_dimension: new e.bY(t, i.u_dimension),
            u_zoom: new e.bj(t, i.u_zoom),
            u_unpack: new e.bW(t, i.u_unpack),
          }),
          colorRelief: (t, i) => ({
            u_image: new e.bT(t, i.u_image),
            u_unpack: new e.bW(t, i.u_unpack),
            u_dimension: new e.bY(t, i.u_dimension),
            u_elevation_stops: new e.bT(t, i.u_elevation_stops),
            u_color_stops: new e.bT(t, i.u_color_stops),
            u_color_ramp_size: new e.bT(t, i.u_color_ramp_size),
            u_opacity: new e.bj(t, i.u_opacity),
          }),
          line: (t, i) => ({
            u_translation: new e.bY(t, i.u_translation),
            u_ratio: new e.bj(t, i.u_ratio),
            u_device_pixel_ratio: new e.bj(t, i.u_device_pixel_ratio),
            u_units_to_pixels: new e.bY(t, i.u_units_to_pixels),
          }),
          lineGradient: (t, i) => ({
            u_translation: new e.bY(t, i.u_translation),
            u_ratio: new e.bj(t, i.u_ratio),
            u_device_pixel_ratio: new e.bj(t, i.u_device_pixel_ratio),
            u_units_to_pixels: new e.bY(t, i.u_units_to_pixels),
            u_image: new e.bT(t, i.u_image),
            u_image_height: new e.bj(t, i.u_image_height),
          }),
          linePattern: (t, i) => ({
            u_translation: new e.bY(t, i.u_translation),
            u_texsize: new e.bY(t, i.u_texsize),
            u_ratio: new e.bj(t, i.u_ratio),
            u_device_pixel_ratio: new e.bj(t, i.u_device_pixel_ratio),
            u_image: new e.bT(t, i.u_image),
            u_units_to_pixels: new e.bY(t, i.u_units_to_pixels),
            u_scale: new e.bX(t, i.u_scale),
            u_fade: new e.bj(t, i.u_fade),
          }),
          lineSDF: (t, i) => ({
            u_translation: new e.bY(t, i.u_translation),
            u_ratio: new e.bj(t, i.u_ratio),
            u_device_pixel_ratio: new e.bj(t, i.u_device_pixel_ratio),
            u_units_to_pixels: new e.bY(t, i.u_units_to_pixels),
            u_image: new e.bT(t, i.u_image),
            u_mix: new e.bj(t, i.u_mix),
            u_tileratio: new e.bj(t, i.u_tileratio),
            u_crossfade_from: new e.bj(t, i.u_crossfade_from),
            u_crossfade_to: new e.bj(t, i.u_crossfade_to),
            u_lineatlas_width: new e.bj(t, i.u_lineatlas_width),
            u_lineatlas_height: new e.bj(t, i.u_lineatlas_height),
          }),
          lineGradientSDF: (t, i) => ({
            u_translation: new e.bY(t, i.u_translation),
            u_ratio: new e.bj(t, i.u_ratio),
            u_device_pixel_ratio: new e.bj(t, i.u_device_pixel_ratio),
            u_units_to_pixels: new e.bY(t, i.u_units_to_pixels),
            u_image: new e.bT(t, i.u_image),
            u_image_height: new e.bj(t, i.u_image_height),
            u_tileratio: new e.bj(t, i.u_tileratio),
            u_crossfade_from: new e.bj(t, i.u_crossfade_from),
            u_crossfade_to: new e.bj(t, i.u_crossfade_to),
            u_image_dash: new e.bT(t, i.u_image_dash),
            u_mix: new e.bj(t, i.u_mix),
            u_lineatlas_width: new e.bj(t, i.u_lineatlas_width),
            u_lineatlas_height: new e.bj(t, i.u_lineatlas_height),
          }),
          raster: (t, i) => ({
            u_tl_parent: new e.bY(t, i.u_tl_parent),
            u_scale_parent: new e.bj(t, i.u_scale_parent),
            u_buffer_scale: new e.bj(t, i.u_buffer_scale),
            u_fade_t: new e.bj(t, i.u_fade_t),
            u_opacity: new e.bj(t, i.u_opacity),
            u_image0: new e.bT(t, i.u_image0),
            u_image1: new e.bT(t, i.u_image1),
            u_brightness_low: new e.bj(t, i.u_brightness_low),
            u_brightness_high: new e.bj(t, i.u_brightness_high),
            u_saturation_factor: new e.bj(t, i.u_saturation_factor),
            u_contrast_factor: new e.bj(t, i.u_contrast_factor),
            u_spin_weights: new e.bX(t, i.u_spin_weights),
            u_coords_top: new e.bW(t, i.u_coords_top),
            u_coords_bottom: new e.bW(t, i.u_coords_bottom),
          }),
          symbolIcon: (t, i) => ({
            u_is_size_zoom_constant: new e.bT(t, i.u_is_size_zoom_constant),
            u_is_size_feature_constant: new e.bT(
              t,
              i.u_is_size_feature_constant
            ),
            u_size_t: new e.bj(t, i.u_size_t),
            u_size: new e.bj(t, i.u_size),
            u_camera_to_center_distance: new e.bj(
              t,
              i.u_camera_to_center_distance
            ),
            u_pitch: new e.bj(t, i.u_pitch),
            u_rotate_symbol: new e.bT(t, i.u_rotate_symbol),
            u_aspect_ratio: new e.bj(t, i.u_aspect_ratio),
            u_fade_change: new e.bj(t, i.u_fade_change),
            u_label_plane_matrix: new e.bV(t, i.u_label_plane_matrix),
            u_coord_matrix: new e.bV(t, i.u_coord_matrix),
            u_is_text: new e.bT(t, i.u_is_text),
            u_pitch_with_map: new e.bT(t, i.u_pitch_with_map),
            u_is_along_line: new e.bT(t, i.u_is_along_line),
            u_is_variable_anchor: new e.bT(t, i.u_is_variable_anchor),
            u_texsize: new e.bY(t, i.u_texsize),
            u_texture: new e.bT(t, i.u_texture),
            u_translation: new e.bY(t, i.u_translation),
            u_pitched_scale: new e.bj(t, i.u_pitched_scale),
          }),
          symbolSDF: (t, i) => ({
            u_is_size_zoom_constant: new e.bT(t, i.u_is_size_zoom_constant),
            u_is_size_feature_constant: new e.bT(
              t,
              i.u_is_size_feature_constant
            ),
            u_size_t: new e.bj(t, i.u_size_t),
            u_size: new e.bj(t, i.u_size),
            u_camera_to_center_distance: new e.bj(
              t,
              i.u_camera_to_center_distance
            ),
            u_pitch: new e.bj(t, i.u_pitch),
            u_rotate_symbol: new e.bT(t, i.u_rotate_symbol),
            u_aspect_ratio: new e.bj(t, i.u_aspect_ratio),
            u_fade_change: new e.bj(t, i.u_fade_change),
            u_label_plane_matrix: new e.bV(t, i.u_label_plane_matrix),
            u_coord_matrix: new e.bV(t, i.u_coord_matrix),
            u_is_text: new e.bT(t, i.u_is_text),
            u_pitch_with_map: new e.bT(t, i.u_pitch_with_map),
            u_is_along_line: new e.bT(t, i.u_is_along_line),
            u_is_variable_anchor: new e.bT(t, i.u_is_variable_anchor),
            u_texsize: new e.bY(t, i.u_texsize),
            u_texture: new e.bT(t, i.u_texture),
            u_gamma_scale: new e.bj(t, i.u_gamma_scale),
            u_device_pixel_ratio: new e.bj(t, i.u_device_pixel_ratio),
            u_is_halo: new e.bT(t, i.u_is_halo),
            u_translation: new e.bY(t, i.u_translation),
            u_pitched_scale: new e.bj(t, i.u_pitched_scale),
          }),
          symbolTextAndIcon: (t, i) => ({
            u_is_size_zoom_constant: new e.bT(t, i.u_is_size_zoom_constant),
            u_is_size_feature_constant: new e.bT(
              t,
              i.u_is_size_feature_constant
            ),
            u_size_t: new e.bj(t, i.u_size_t),
            u_size: new e.bj(t, i.u_size),
            u_camera_to_center_distance: new e.bj(
              t,
              i.u_camera_to_center_distance
            ),
            u_pitch: new e.bj(t, i.u_pitch),
            u_rotate_symbol: new e.bT(t, i.u_rotate_symbol),
            u_aspect_ratio: new e.bj(t, i.u_aspect_ratio),
            u_fade_change: new e.bj(t, i.u_fade_change),
            u_label_plane_matrix: new e.bV(t, i.u_label_plane_matrix),
            u_coord_matrix: new e.bV(t, i.u_coord_matrix),
            u_is_text: new e.bT(t, i.u_is_text),
            u_pitch_with_map: new e.bT(t, i.u_pitch_with_map),
            u_is_along_line: new e.bT(t, i.u_is_along_line),
            u_is_variable_anchor: new e.bT(t, i.u_is_variable_anchor),
            u_texsize: new e.bY(t, i.u_texsize),
            u_texsize_icon: new e.bY(t, i.u_texsize_icon),
            u_texture: new e.bT(t, i.u_texture),
            u_texture_icon: new e.bT(t, i.u_texture_icon),
            u_gamma_scale: new e.bj(t, i.u_gamma_scale),
            u_device_pixel_ratio: new e.bj(t, i.u_device_pixel_ratio),
            u_is_halo: new e.bT(t, i.u_is_halo),
            u_translation: new e.bY(t, i.u_translation),
            u_pitched_scale: new e.bj(t, i.u_pitched_scale),
          }),
          background: (t, i) => ({
            u_opacity: new e.bj(t, i.u_opacity),
            u_color: new e.bU(t, i.u_color),
          }),
          backgroundPattern: (t, i) => ({
            u_opacity: new e.bj(t, i.u_opacity),
            u_image: new e.bT(t, i.u_image),
            u_pattern_tl_a: new e.bY(t, i.u_pattern_tl_a),
            u_pattern_br_a: new e.bY(t, i.u_pattern_br_a),
            u_pattern_tl_b: new e.bY(t, i.u_pattern_tl_b),
            u_pattern_br_b: new e.bY(t, i.u_pattern_br_b),
            u_texsize: new e.bY(t, i.u_texsize),
            u_mix: new e.bj(t, i.u_mix),
            u_pattern_size_a: new e.bY(t, i.u_pattern_size_a),
            u_pattern_size_b: new e.bY(t, i.u_pattern_size_b),
            u_scale_a: new e.bj(t, i.u_scale_a),
            u_scale_b: new e.bj(t, i.u_scale_b),
            u_pixel_coord_upper: new e.bY(t, i.u_pixel_coord_upper),
            u_pixel_coord_lower: new e.bY(t, i.u_pixel_coord_lower),
            u_tile_units_to_pixels: new e.bj(t, i.u_tile_units_to_pixels),
          }),
          terrain: (t, i) => ({
            u_texture: new e.bT(t, i.u_texture),
            u_ele_delta: new e.bj(t, i.u_ele_delta),
            u_fog_matrix: new e.bV(t, i.u_fog_matrix),
            u_fog_color: new e.bU(t, i.u_fog_color),
            u_fog_ground_blend: new e.bj(t, i.u_fog_ground_blend),
            u_fog_ground_blend_opacity: new e.bj(
              t,
              i.u_fog_ground_blend_opacity
            ),
            u_horizon_color: new e.bU(t, i.u_horizon_color),
            u_horizon_fog_blend: new e.bj(t, i.u_horizon_fog_blend),
            u_is_globe_mode: new e.bj(t, i.u_is_globe_mode),
          }),
          terrainDepth: (t, i) => ({ u_ele_delta: new e.bj(t, i.u_ele_delta) }),
          terrainCoords: (t, i) => ({
            u_texture: new e.bT(t, i.u_texture),
            u_terrain_coords_id: new e.bj(t, i.u_terrain_coords_id),
            u_ele_delta: new e.bj(t, i.u_ele_delta),
          }),
          projectionErrorMeasurement: (t, i) => ({
            u_input: new e.bj(t, i.u_input),
            u_output_expected: new e.bj(t, i.u_output_expected),
          }),
          atmosphere: (t, i) => ({
            u_sun_pos: new e.bX(t, i.u_sun_pos),
            u_atmosphere_blend: new e.bj(t, i.u_atmosphere_blend),
            u_globe_position: new e.bX(t, i.u_globe_position),
            u_globe_radius: new e.bj(t, i.u_globe_radius),
            u_inv_proj_matrix: new e.bV(t, i.u_inv_proj_matrix),
          }),
          sky: (t, i) => ({
            u_sky_color: new e.bU(t, i.u_sky_color),
            u_horizon_color: new e.bU(t, i.u_horizon_color),
            u_horizon: new e.bY(t, i.u_horizon),
            u_horizon_normal: new e.bY(t, i.u_horizon_normal),
            u_sky_horizon_blend: new e.bj(t, i.u_sky_horizon_blend),
            u_sky_blend: new e.bj(t, i.u_sky_blend),
          }),
        };
      class fr {
        constructor(t, e, i) {
          this.context = t;
          const r = t.gl;
          (this.buffer = r.createBuffer()),
            (this.dynamicDraw = Boolean(i)),
            this.context.unbindVAO(),
            t.bindElementBuffer.set(this.buffer),
            r.bufferData(
              r.ELEMENT_ARRAY_BUFFER,
              e.arrayBuffer,
              this.dynamicDraw ? r.DYNAMIC_DRAW : r.STATIC_DRAW
            ),
            this.dynamicDraw || delete e.arrayBuffer;
        }
        bind() {
          this.context.bindElementBuffer.set(this.buffer);
        }
        updateData(t) {
          const e = this.context.gl;
          if (!this.dynamicDraw)
            throw new Error(
              'Attempted to update data while not in dynamic mode.'
            );
          this.context.unbindVAO(),
            this.bind(),
            e.bufferSubData(e.ELEMENT_ARRAY_BUFFER, 0, t.arrayBuffer);
        }
        destroy() {
          this.buffer &&
            (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
        }
      }
      const mr = {
        Int8: 'BYTE',
        Uint8: 'UNSIGNED_BYTE',
        Int16: 'SHORT',
        Uint16: 'UNSIGNED_SHORT',
        Int32: 'INT',
        Uint32: 'UNSIGNED_INT',
        Float32: 'FLOAT',
      };
      class gr {
        constructor(t, e, i, r) {
          (this.length = e.length),
            (this.attributes = i),
            (this.itemSize = e.bytesPerElement),
            (this.dynamicDraw = r),
            (this.context = t);
          const n = t.gl;
          (this.buffer = n.createBuffer()),
            t.bindVertexBuffer.set(this.buffer),
            n.bufferData(
              n.ARRAY_BUFFER,
              e.arrayBuffer,
              this.dynamicDraw ? n.DYNAMIC_DRAW : n.STATIC_DRAW
            ),
            this.dynamicDraw || delete e.arrayBuffer;
        }
        bind() {
          this.context.bindVertexBuffer.set(this.buffer);
        }
        updateData(t) {
          if (t.length !== this.length)
            throw new Error(
              `Length of new data is ${t.length}, which doesn't match current length of ${this.length}`
            );
          const e = this.context.gl;
          this.bind(), e.bufferSubData(e.ARRAY_BUFFER, 0, t.arrayBuffer);
        }
        enableAttributes(t, e) {
          for (let i = 0; i < this.attributes.length; i++) {
            const r = e.attributes[this.attributes[i].name];
            void 0 !== r && t.enableVertexAttribArray(r);
          }
        }
        setVertexAttribPointers(t, e, i) {
          for (let r = 0; r < this.attributes.length; r++) {
            const n = this.attributes[r],
              a = e.attributes[n.name];
            void 0 !== a &&
              t.vertexAttribPointer(
                a,
                n.components,
                t[mr[n.type]],
                !1,
                this.itemSize,
                n.offset + this.itemSize * (i || 0)
              );
          }
        }
        destroy() {
          this.buffer &&
            (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
        }
      }
      class _r {
        constructor(t) {
          (this.gl = t.gl),
            (this.default = this.getDefault()),
            (this.current = this.default),
            (this.dirty = !1);
        }
        get() {
          return this.current;
        }
        set(t) {}
        getDefault() {
          return this.default;
        }
        setDefault() {
          this.set(this.default);
        }
      }
      class yr extends _r {
        getDefault() {
          return e.bi.transparent;
        }
        set(t) {
          const e = this.current;
          (t.r !== e.r ||
            t.g !== e.g ||
            t.b !== e.b ||
            t.a !== e.a ||
            this.dirty) &&
            (this.gl.clearColor(t.r, t.g, t.b, t.a),
            (this.current = t),
            (this.dirty = !1));
        }
      }
      class vr extends _r {
        getDefault() {
          return 1;
        }
        set(t) {
          (t !== this.current || this.dirty) &&
            (this.gl.clearDepth(t), (this.current = t), (this.dirty = !1));
        }
      }
      class xr extends _r {
        getDefault() {
          return 0;
        }
        set(t) {
          (t !== this.current || this.dirty) &&
            (this.gl.clearStencil(t), (this.current = t), (this.dirty = !1));
        }
      }
      class br extends _r {
        getDefault() {
          return [!0, !0, !0, !0];
        }
        set(t) {
          const e = this.current;
          (t[0] !== e[0] ||
            t[1] !== e[1] ||
            t[2] !== e[2] ||
            t[3] !== e[3] ||
            this.dirty) &&
            (this.gl.colorMask(t[0], t[1], t[2], t[3]),
            (this.current = t),
            (this.dirty = !1));
        }
      }
      class wr extends _r {
        getDefault() {
          return !0;
        }
        set(t) {
          (t !== this.current || this.dirty) &&
            (this.gl.depthMask(t), (this.current = t), (this.dirty = !1));
        }
      }
      class Tr extends _r {
        getDefault() {
          return 255;
        }
        set(t) {
          (t !== this.current || this.dirty) &&
            (this.gl.stencilMask(t), (this.current = t), (this.dirty = !1));
        }
      }
      class Pr extends _r {
        getDefault() {
          return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
        }
        set(t) {
          const e = this.current;
          (t.func !== e.func ||
            t.ref !== e.ref ||
            t.mask !== e.mask ||
            this.dirty) &&
            (this.gl.stencilFunc(t.func, t.ref, t.mask),
            (this.current = t),
            (this.dirty = !1));
        }
      }
      class Cr extends _r {
        getDefault() {
          const t = this.gl;
          return [t.KEEP, t.KEEP, t.KEEP];
        }
        set(t) {
          const e = this.current;
          (t[0] !== e[0] || t[1] !== e[1] || t[2] !== e[2] || this.dirty) &&
            (this.gl.stencilOp(t[0], t[1], t[2]),
            (this.current = t),
            (this.dirty = !1));
        }
      }
      class Ir extends _r {
        getDefault() {
          return !1;
        }
        set(t) {
          if (t === this.current && !this.dirty) return;
          const e = this.gl;
          t ? e.enable(e.STENCIL_TEST) : e.disable(e.STENCIL_TEST),
            (this.current = t),
            (this.dirty = !1);
        }
      }
      class Sr extends _r {
        getDefault() {
          return [0, 1];
        }
        set(t) {
          const e = this.current;
          (t[0] !== e[0] || t[1] !== e[1] || this.dirty) &&
            (this.gl.depthRange(t[0], t[1]),
            (this.current = t),
            (this.dirty = !1));
        }
      }
      class Mr extends _r {
        getDefault() {
          return !1;
        }
        set(t) {
          if (t === this.current && !this.dirty) return;
          const e = this.gl;
          t ? e.enable(e.DEPTH_TEST) : e.disable(e.DEPTH_TEST),
            (this.current = t),
            (this.dirty = !1);
        }
      }
      class Dr extends _r {
        getDefault() {
          return this.gl.LESS;
        }
        set(t) {
          (t !== this.current || this.dirty) &&
            (this.gl.depthFunc(t), (this.current = t), (this.dirty = !1));
        }
      }
      class Lr extends _r {
        getDefault() {
          return !1;
        }
        set(t) {
          if (t === this.current && !this.dirty) return;
          const e = this.gl;
          t ? e.enable(e.BLEND) : e.disable(e.BLEND),
            (this.current = t),
            (this.dirty = !1);
        }
      }
      class Ar extends _r {
        getDefault() {
          const t = this.gl;
          return [t.ONE, t.ZERO];
        }
        set(t) {
          const e = this.current;
          (t[0] !== e[0] || t[1] !== e[1] || this.dirty) &&
            (this.gl.blendFunc(t[0], t[1]),
            (this.current = t),
            (this.dirty = !1));
        }
      }
      class Er extends _r {
        getDefault() {
          return e.bi.transparent;
        }
        set(t) {
          const e = this.current;
          (t.r !== e.r ||
            t.g !== e.g ||
            t.b !== e.b ||
            t.a !== e.a ||
            this.dirty) &&
            (this.gl.blendColor(t.r, t.g, t.b, t.a),
            (this.current = t),
            (this.dirty = !1));
        }
      }
      class Rr extends _r {
        getDefault() {
          return this.gl.FUNC_ADD;
        }
        set(t) {
          (t !== this.current || this.dirty) &&
            (this.gl.blendEquation(t), (this.current = t), (this.dirty = !1));
        }
      }
      class zr extends _r {
        getDefault() {
          return !1;
        }
        set(t) {
          if (t === this.current && !this.dirty) return;
          const e = this.gl;
          t ? e.enable(e.CULL_FACE) : e.disable(e.CULL_FACE),
            (this.current = t),
            (this.dirty = !1);
        }
      }
      class kr extends _r {
        getDefault() {
          return this.gl.BACK;
        }
        set(t) {
          (t !== this.current || this.dirty) &&
            (this.gl.cullFace(t), (this.current = t), (this.dirty = !1));
        }
      }
      class Or extends _r {
        getDefault() {
          return this.gl.CCW;
        }
        set(t) {
          (t !== this.current || this.dirty) &&
            (this.gl.frontFace(t), (this.current = t), (this.dirty = !1));
        }
      }
      class Fr extends _r {
        getDefault() {
          return null;
        }
        set(t) {
          (t !== this.current || this.dirty) &&
            (this.gl.useProgram(t), (this.current = t), (this.dirty = !1));
        }
      }
      class Br extends _r {
        getDefault() {
          return this.gl.TEXTURE0;
        }
        set(t) {
          (t !== this.current || this.dirty) &&
            (this.gl.activeTexture(t), (this.current = t), (this.dirty = !1));
        }
      }
      class Nr extends _r {
        getDefault() {
          const t = this.gl;
          return [0, 0, t.drawingBufferWidth, t.drawingBufferHeight];
        }
        set(t) {
          const e = this.current;
          (t[0] !== e[0] ||
            t[1] !== e[1] ||
            t[2] !== e[2] ||
            t[3] !== e[3] ||
            this.dirty) &&
            (this.gl.viewport(t[0], t[1], t[2], t[3]),
            (this.current = t),
            (this.dirty = !1));
        }
      }
      class Vr extends _r {
        getDefault() {
          return null;
        }
        set(t) {
          if (t === this.current && !this.dirty) return;
          const e = this.gl;
          e.bindFramebuffer(e.FRAMEBUFFER, t),
            (this.current = t),
            (this.dirty = !1);
        }
      }
      class jr extends _r {
        getDefault() {
          return null;
        }
        set(t) {
          if (t === this.current && !this.dirty) return;
          const e = this.gl;
          e.bindRenderbuffer(e.RENDERBUFFER, t),
            (this.current = t),
            (this.dirty = !1);
        }
      }
      class Ur extends _r {
        getDefault() {
          return null;
        }
        set(t) {
          if (t === this.current && !this.dirty) return;
          const e = this.gl;
          e.bindTexture(e.TEXTURE_2D, t), (this.current = t), (this.dirty = !1);
        }
      }
      class Gr extends _r {
        getDefault() {
          return null;
        }
        set(t) {
          if (t === this.current && !this.dirty) return;
          const e = this.gl;
          e.bindBuffer(e.ARRAY_BUFFER, t),
            (this.current = t),
            (this.dirty = !1);
        }
      }
      class Zr extends _r {
        getDefault() {
          return null;
        }
        set(t) {
          const e = this.gl;
          e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, t),
            (this.current = t),
            (this.dirty = !1);
        }
      }
      class $r extends _r {
        getDefault() {
          return null;
        }
        set(t) {
          var e;
          if (t === this.current && !this.dirty) return;
          const i = this.gl;
          Qe(i)
            ? i.bindVertexArray(t)
            : null === (e = i.getExtension('OES_vertex_array_object')) ||
              void 0 === e ||
              e.bindVertexArrayOES(t),
            (this.current = t),
            (this.dirty = !1);
        }
      }
      class qr extends _r {
        getDefault() {
          return 4;
        }
        set(t) {
          if (t === this.current && !this.dirty) return;
          const e = this.gl;
          e.pixelStorei(e.UNPACK_ALIGNMENT, t),
            (this.current = t),
            (this.dirty = !1);
        }
      }
      class Hr extends _r {
        getDefault() {
          return !1;
        }
        set(t) {
          if (t === this.current && !this.dirty) return;
          const e = this.gl;
          e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t),
            (this.current = t),
            (this.dirty = !1);
        }
      }
      class Wr extends _r {
        getDefault() {
          return !1;
        }
        set(t) {
          if (t === this.current && !this.dirty) return;
          const e = this.gl;
          e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, t),
            (this.current = t),
            (this.dirty = !1);
        }
      }
      class Xr extends _r {
        constructor(t, e) {
          super(t), (this.context = t), (this.parent = e);
        }
        getDefault() {
          return null;
        }
      }
      class Yr extends Xr {
        setDirty() {
          this.dirty = !0;
        }
        set(t) {
          if (t === this.current && !this.dirty) return;
          this.context.bindFramebuffer.set(this.parent);
          const e = this.gl;
          e.framebufferTexture2D(
            e.FRAMEBUFFER,
            e.COLOR_ATTACHMENT0,
            e.TEXTURE_2D,
            t,
            0
          ),
            (this.current = t),
            (this.dirty = !1);
        }
      }
      class Kr extends Xr {
        set(t) {
          if (t === this.current && !this.dirty) return;
          this.context.bindFramebuffer.set(this.parent);
          const e = this.gl;
          e.framebufferRenderbuffer(
            e.FRAMEBUFFER,
            e.DEPTH_ATTACHMENT,
            e.RENDERBUFFER,
            t
          ),
            (this.current = t),
            (this.dirty = !1);
        }
      }
      class Jr extends Xr {
        set(t) {
          if (t === this.current && !this.dirty) return;
          this.context.bindFramebuffer.set(this.parent);
          const e = this.gl;
          e.framebufferRenderbuffer(
            e.FRAMEBUFFER,
            e.DEPTH_STENCIL_ATTACHMENT,
            e.RENDERBUFFER,
            t
          ),
            (this.current = t),
            (this.dirty = !1);
        }
      }
      const Qr = 'Framebuffer is not complete';
      class tn {
        constructor(t, e, i, r, n) {
          (this.context = t), (this.width = e), (this.height = i);
          const a = t.gl,
            s = (this.framebuffer = a.createFramebuffer());
          if (((this.colorAttachment = new Yr(t, s)), r))
            this.depthAttachment = n ? new Jr(t, s) : new Kr(t, s);
          else if (n) throw new Error('Stencil cannot be set without depth');
          if (
            a.checkFramebufferStatus(a.FRAMEBUFFER) !== a.FRAMEBUFFER_COMPLETE
          )
            throw new Error(Qr);
        }
        destroy() {
          const t = this.context.gl,
            e = this.colorAttachment.get();
          if ((e && t.deleteTexture(e), this.depthAttachment)) {
            const e = this.depthAttachment.get();
            e && t.deleteRenderbuffer(e);
          }
          t.deleteFramebuffer(this.framebuffer);
        }
      }
      class en {
        constructor(t) {
          var e, i;
          if (
            ((this.gl = t),
            (this.clearColor = new yr(this)),
            (this.clearDepth = new vr(this)),
            (this.clearStencil = new xr(this)),
            (this.colorMask = new br(this)),
            (this.depthMask = new wr(this)),
            (this.stencilMask = new Tr(this)),
            (this.stencilFunc = new Pr(this)),
            (this.stencilOp = new Cr(this)),
            (this.stencilTest = new Ir(this)),
            (this.depthRange = new Sr(this)),
            (this.depthTest = new Mr(this)),
            (this.depthFunc = new Dr(this)),
            (this.blend = new Lr(this)),
            (this.blendFunc = new Ar(this)),
            (this.blendColor = new Er(this)),
            (this.blendEquation = new Rr(this)),
            (this.cullFace = new zr(this)),
            (this.cullFaceSide = new kr(this)),
            (this.frontFace = new Or(this)),
            (this.program = new Fr(this)),
            (this.activeTexture = new Br(this)),
            (this.viewport = new Nr(this)),
            (this.bindFramebuffer = new Vr(this)),
            (this.bindRenderbuffer = new jr(this)),
            (this.bindTexture = new Ur(this)),
            (this.bindVertexBuffer = new Gr(this)),
            (this.bindElementBuffer = new Zr(this)),
            (this.bindVertexArray = new $r(this)),
            (this.pixelStoreUnpack = new qr(this)),
            (this.pixelStoreUnpackPremultiplyAlpha = new Hr(this)),
            (this.pixelStoreUnpackFlipY = new Wr(this)),
            (this.extTextureFilterAnisotropic =
              t.getExtension('EXT_texture_filter_anisotropic') ||
              t.getExtension('MOZ_EXT_texture_filter_anisotropic') ||
              t.getExtension('WEBKIT_EXT_texture_filter_anisotropic')),
            this.extTextureFilterAnisotropic &&
              (this.extTextureFilterAnisotropicMax = t.getParameter(
                this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT
              )),
            (this.maxTextureSize = t.getParameter(t.MAX_TEXTURE_SIZE)),
            Qe(t))
          ) {
            this.HALF_FLOAT = t.HALF_FLOAT;
            const r = t.getExtension('EXT_color_buffer_half_float');
            (this.RGBA16F =
              null !== (e = t.RGBA16F) && void 0 !== e
                ? e
                : null == r
                ? void 0
                : r.RGBA16F_EXT),
              (this.RGB16F =
                null !== (i = t.RGB16F) && void 0 !== i
                  ? i
                  : null == r
                  ? void 0
                  : r.RGB16F_EXT),
              t.getExtension('EXT_color_buffer_float');
          } else {
            t.getExtension('EXT_color_buffer_half_float'),
              t.getExtension('OES_texture_half_float_linear');
            const e = t.getExtension('OES_texture_half_float');
            this.HALF_FLOAT = null == e ? void 0 : e.HALF_FLOAT_OES;
          }
        }
        setDefault() {
          this.unbindVAO(),
            this.clearColor.setDefault(),
            this.clearDepth.setDefault(),
            this.clearStencil.setDefault(),
            this.colorMask.setDefault(),
            this.depthMask.setDefault(),
            this.stencilMask.setDefault(),
            this.stencilFunc.setDefault(),
            this.stencilOp.setDefault(),
            this.stencilTest.setDefault(),
            this.depthRange.setDefault(),
            this.depthTest.setDefault(),
            this.depthFunc.setDefault(),
            this.blend.setDefault(),
            this.blendFunc.setDefault(),
            this.blendColor.setDefault(),
            this.blendEquation.setDefault(),
            this.cullFace.setDefault(),
            this.cullFaceSide.setDefault(),
            this.frontFace.setDefault(),
            this.program.setDefault(),
            this.activeTexture.setDefault(),
            this.bindFramebuffer.setDefault(),
            this.pixelStoreUnpack.setDefault(),
            this.pixelStoreUnpackPremultiplyAlpha.setDefault(),
            this.pixelStoreUnpackFlipY.setDefault();
        }
        setDirty() {
          (this.clearColor.dirty = !0),
            (this.clearDepth.dirty = !0),
            (this.clearStencil.dirty = !0),
            (this.colorMask.dirty = !0),
            (this.depthMask.dirty = !0),
            (this.stencilMask.dirty = !0),
            (this.stencilFunc.dirty = !0),
            (this.stencilOp.dirty = !0),
            (this.stencilTest.dirty = !0),
            (this.depthRange.dirty = !0),
            (this.depthTest.dirty = !0),
            (this.depthFunc.dirty = !0),
            (this.blend.dirty = !0),
            (this.blendFunc.dirty = !0),
            (this.blendColor.dirty = !0),
            (this.blendEquation.dirty = !0),
            (this.cullFace.dirty = !0),
            (this.cullFaceSide.dirty = !0),
            (this.frontFace.dirty = !0),
            (this.program.dirty = !0),
            (this.activeTexture.dirty = !0),
            (this.viewport.dirty = !0),
            (this.bindFramebuffer.dirty = !0),
            (this.bindRenderbuffer.dirty = !0),
            (this.bindTexture.dirty = !0),
            (this.bindVertexBuffer.dirty = !0),
            (this.bindElementBuffer.dirty = !0),
            (this.bindVertexArray.dirty = !0),
            (this.pixelStoreUnpack.dirty = !0),
            (this.pixelStoreUnpackPremultiplyAlpha.dirty = !0),
            (this.pixelStoreUnpackFlipY.dirty = !0);
        }
        createIndexBuffer(t, e) {
          return new fr(this, t, e);
        }
        createVertexBuffer(t, e, i) {
          return new gr(this, t, e, i);
        }
        createRenderbuffer(t, e, i) {
          const r = this.gl,
            n = r.createRenderbuffer();
          return (
            this.bindRenderbuffer.set(n),
            r.renderbufferStorage(r.RENDERBUFFER, t, e, i),
            this.bindRenderbuffer.set(null),
            n
          );
        }
        createFramebuffer(t, e, i, r) {
          return new tn(this, t, e, i, r);
        }
        clear({ color: t, depth: e, stencil: i }) {
          const r = this.gl;
          let n = 0;
          t &&
            ((n |= r.COLOR_BUFFER_BIT),
            this.clearColor.set(t),
            this.colorMask.set([!0, !0, !0, !0])),
            void 0 !== e &&
              ((n |= r.DEPTH_BUFFER_BIT),
              this.depthRange.set([0, 1]),
              this.clearDepth.set(e),
              this.depthMask.set(!0)),
            void 0 !== i &&
              ((n |= r.STENCIL_BUFFER_BIT),
              this.clearStencil.set(i),
              this.stencilMask.set(255)),
            r.clear(n);
        }
        setCullFace(t) {
          !1 === t.enable
            ? this.cullFace.set(!1)
            : (this.cullFace.set(!0),
              this.cullFaceSide.set(t.mode),
              this.frontFace.set(t.frontFace));
        }
        setDepthMode(t) {
          t.func !== this.gl.ALWAYS || t.mask
            ? (this.depthTest.set(!0),
              this.depthFunc.set(t.func),
              this.depthMask.set(t.mask),
              this.depthRange.set(t.range))
            : this.depthTest.set(!1);
        }
        setStencilMode(t) {
          t.test.func !== this.gl.ALWAYS || t.mask
            ? (this.stencilTest.set(!0),
              this.stencilMask.set(t.mask),
              this.stencilOp.set([t.fail, t.depthFail, t.pass]),
              this.stencilFunc.set({
                func: t.test.func,
                ref: t.ref,
                mask: t.test.mask,
              }))
            : this.stencilTest.set(!1);
        }
        setColorMode(t) {
          e.bK(t.blendFunction, qe.Replace)
            ? this.blend.set(!1)
            : (this.blend.set(!0),
              this.blendFunc.set(t.blendFunction),
              this.blendColor.set(t.blendColor)),
            this.colorMask.set(t.mask);
        }
        createVertexArray() {
          var t;
          return Qe(this.gl)
            ? this.gl.createVertexArray()
            : null === (t = this.gl.getExtension('OES_vertex_array_object')) ||
              void 0 === t
            ? void 0
            : t.createVertexArrayOES();
        }
        deleteVertexArray(t) {
          var e;
          return Qe(this.gl)
            ? this.gl.deleteVertexArray(t)
            : null === (e = this.gl.getExtension('OES_vertex_array_object')) ||
              void 0 === e
            ? void 0
            : e.deleteVertexArrayOES(t);
        }
        unbindVAO() {
          this.bindVertexArray.set(null);
        }
      }
      let rn;
      function nn(t, i, r, n, a) {
        const s = t.context,
          o = t.transform,
          l = s.gl,
          c = t.useProgram('collisionBox'),
          h = [];
        let u = 0,
          d = 0;
        for (let e = 0; e < n.length; e++) {
          const p = n[e],
            f = i.getTile(p).getBucket(r);
          if (!f) continue;
          const m = a ? f.textCollisionBox : f.iconCollisionBox,
            g = f.collisionCircleArray;
          g.length > 0 &&
            (h.push({ circleArray: g, circleOffset: d, coord: p }),
            (u += g.length / 4),
            (d = u)),
            m &&
              c.draw(
                s,
                l.LINES,
                Xe.disabled,
                Ke.disabled,
                t.colorModeForRenderPass(),
                We.disabled,
                Gi(t.transform),
                t.style.map.terrain && t.style.map.terrain.getTerrainData(p),
                o.getProjectionData({
                  overscaledTileID: p,
                  applyGlobeMatrix: !0,
                  applyTerrainMatrix: !0,
                }),
                r.id,
                m.layoutVertexBuffer,
                m.indexBuffer,
                m.segments,
                null,
                t.transform.zoom,
                null,
                null,
                m.collisionVertexBuffer
              );
        }
        if (!a || !h.length) return;
        const p = t.useProgram('collisionCircle'),
          f = new e.c3();
        f.resize(4 * u), f._trim();
        let m = 0;
        for (const e of h)
          for (let t = 0; t < e.circleArray.length / 4; t++) {
            const i = 4 * t,
              r = e.circleArray[i + 0],
              n = e.circleArray[i + 1],
              a = e.circleArray[i + 2],
              s = e.circleArray[i + 3];
            f.emplace(m++, r, n, a, s, 0),
              f.emplace(m++, r, n, a, s, 1),
              f.emplace(m++, r, n, a, s, 2),
              f.emplace(m++, r, n, a, s, 3);
          }
        (!rn || rn.length < 2 * u) &&
          (rn = (function (t) {
            const i = 2 * t,
              r = new e.c5();
            r.resize(i), r._trim();
            for (let e = 0; e < i; e++) {
              const t = 6 * e;
              (r.uint16[t + 0] = 4 * e + 0),
                (r.uint16[t + 1] = 4 * e + 1),
                (r.uint16[t + 2] = 4 * e + 2),
                (r.uint16[t + 3] = 4 * e + 2),
                (r.uint16[t + 4] = 4 * e + 3),
                (r.uint16[t + 5] = 4 * e + 0);
            }
            return r;
          })(u));
        const g = s.createIndexBuffer(rn, !0),
          _ = s.createVertexBuffer(f, e.c4.members, !0);
        for (const y of h) {
          const i = Zi(t.transform);
          p.draw(
            s,
            l.TRIANGLES,
            Xe.disabled,
            Ke.disabled,
            t.colorModeForRenderPass(),
            We.disabled,
            i,
            t.style.map.terrain && t.style.map.terrain.getTerrainData(y.coord),
            null,
            r.id,
            _,
            g,
            e.aQ.simpleSegment(
              0,
              2 * y.circleOffset,
              y.circleArray.length,
              y.circleArray.length / 2
            ),
            null,
            t.transform.zoom,
            null,
            null,
            null
          );
        }
        _.destroy(), g.destroy();
      }
      const an = e.am(new Float32Array(16));
      function sn(t, i, r, n, a, s) {
        const { horizontalAlign: o, verticalAlign: l } = e.aL(t);
        return new e.P(
          ((-(o - 0.5) * i) / a + n[0]) * s,
          ((-(l - 0.5) * r) / a + n[1]) * s
        );
      }
      function on(t, i, r, n, a, s) {
        const o = i.tileAnchorPoint.add(
          new e.P(i.translation[0], i.translation[1])
        );
        if (i.pitchWithMap) {
          let t = n.mult(s);
          r || (t = t.rotate(-a));
          const e = o.add(t);
          return Ot(e.x, e.y, i.pitchedLabelPlaneMatrix, i.getElevation).point;
        }
        if (r) {
          const e = $t(
              i.tileAnchorPoint.x + 1,
              i.tileAnchorPoint.y,
              i
            ).point.sub(t),
            r = Math.atan(e.y / e.x) + (e.x < 0 ? Math.PI : 0);
          return t.add(n.rotate(r));
        }
        return t.add(n);
      }
      function ln(t, i, r, n, a, s, o, l, c, h, u, d) {
        const p = t.text.placedSymbolArray,
          f = t.text.dynamicLayoutVertexArray,
          m = t.icon.dynamicLayoutVertexArray,
          g = {};
        f.clear();
        for (let _ = 0; _ < p.length; _++) {
          const m = p.get(_),
            y =
              m.hidden ||
              !m.crossTileID ||
              (t.allowVerticalPlacement && !m.placedOrientation)
                ? null
                : n[m.crossTileID];
          if (y) {
            const n = new e.P(m.anchorX, m.anchorY),
              p = {
                getElevation: d,
                width: a.width,
                height: a.height,
                pitchedLabelPlaneMatrix: s,
                pitchWithMap: r,
                transform: a,
                tileAnchorPoint: n,
                translation: h,
                unwrappedTileID: u,
              },
              _ = r ? Ht(n.x, n.y, p) : $t(n.x, n.y, p),
              v = Ft(a.cameraToCenterDistance, _.signedDistanceFromCamera);
            let x = (e.at(t.textSizeData, l, m) * v) / e.aF;
            r && (x *= t.tilePixelRatio / o);
            const {
                width: b,
                height: w,
                anchor: T,
                textOffset: P,
                textBoxScale: C,
              } = y,
              I = sn(T, b, w, P, C, x),
              S = a.getPitchedTextCorrection(n.x + h[0], n.y + h[1], u),
              M = on(_.point, p, i, I, -a.bearingInRadians, S),
              D =
                t.allowVerticalPlacement &&
                m.placedOrientation === e.as.vertical
                  ? Math.PI / 2
                  : 0;
            for (let t = 0; t < m.numGlyphs; t++) e.az(f, M, D);
            c &&
              m.associatedIconIndex >= 0 &&
              (g[m.associatedIconIndex] = { shiftedAnchor: M, angle: D });
          } else Jt(m.numGlyphs, f);
        }
        if (c) {
          m.clear();
          const i = t.icon.placedSymbolArray;
          for (let t = 0; t < i.length; t++) {
            const r = i.get(t);
            if (r.hidden) Jt(r.numGlyphs, m);
            else {
              const i = g[t];
              if (i)
                for (let t = 0; t < r.numGlyphs; t++)
                  e.az(m, i.shiftedAnchor, i.angle);
              else Jt(r.numGlyphs, m);
            }
          }
          t.icon.dynamicLayoutVertexBuffer.updateData(m);
        }
        t.text.dynamicLayoutVertexBuffer.updateData(f);
      }
      function cn(t, e, i) {
        return i.iconsInText && e
          ? 'symbolTextAndIcon'
          : t
          ? 'symbolSDF'
          : 'symbolIcon';
      }
      function hn(t, i, r, n, a, s, o, l, c, h, u, d, p) {
        const f = t.context,
          m = f.gl,
          g = t.transform,
          _ = 'map' === l,
          y = 'map' === c,
          v = 'viewport' !== l && 'point' !== r.layout.get('symbol-placement'),
          x = _ && !y && !v,
          b = !r.layout.get('symbol-sort-key').isConstant();
        let w = !1;
        const T = t.getDepthModeForSublayer(0, Xe.ReadOnly),
          P =
            r._unevaluatedLayout.hasValue('text-variable-anchor') ||
            r._unevaluatedLayout.hasValue('text-variable-anchor-offset'),
          C = [],
          I = g.getCircleRadiusCorrection();
        for (const S of n) {
          const n = i.getTile(S),
            l = n.getBucket(r);
          if (!l) continue;
          const c = a ? l.text : l.icon;
          if (!c || !c.segments.get().length || !c.hasVisibleVertices) continue;
          const u = c.programConfigurations.get(r.id),
            d = a || l.sdfIcons,
            f = a ? l.textSizeData : l.iconSizeData,
            T = y || 0 !== g.pitch,
            M = t.useProgram(cn(d, a, l), u),
            D = e.ar(f, g.zoom),
            L = t.style.map.terrain && t.style.map.terrain.getTerrainData(S);
          let A,
            E,
            R,
            z,
            k = [0, 0],
            O = null;
          if (a)
            (E = n.glyphAtlasTexture),
              (R = m.LINEAR),
              (A = n.glyphAtlasTexture.size),
              l.iconsInText &&
                ((k = n.imageAtlasTexture.size),
                (O = n.imageAtlasTexture),
                (z =
                  T ||
                  t.options.rotating ||
                  t.options.zooming ||
                  'composite' === f.kind ||
                  'camera' === f.kind
                    ? m.LINEAR
                    : m.NEAREST));
          else {
            const e =
              1 !== r.layout.get('icon-size').constantOr(0) ||
              l.iconsNeedLinear;
            (E = n.imageAtlasTexture),
              (R =
                d || t.options.rotating || t.options.zooming || e || T
                  ? m.LINEAR
                  : m.NEAREST),
              (A = n.imageAtlasTexture.size);
          }
          const F = e.aG(n, 1, t.transform.zoom),
            B = Rt(_, t.transform, F),
            N = e.M();
          e.au(N, B);
          const V = zt(y, _, t.transform, F),
            j = e.aH(g, n, s, o),
            U = g.getProjectionData({
              overscaledTileID: S,
              applyGlobeMatrix: !p,
              applyTerrainMatrix: !0,
            }),
            G = P && l.hasTextData(),
            Z =
              'none' !== r.layout.get('icon-text-fit') && G && l.hasIconData();
          if (v) {
            const e = t.style.map.terrain
                ? (e, i) => t.style.map.terrain.getElevation(S, e, i)
                : null,
              i = 'map' === r.layout.get('text-rotation-alignment');
            Nt(
              l,
              t,
              a,
              B,
              N,
              y,
              h,
              i,
              S.toUnwrapped(),
              g.width,
              g.height,
              j,
              e
            );
          }
          const $ = (a && P) || Z,
            q = v || $ ? an : y ? B : t.transform.clipSpaceToPixelsMatrix,
            H =
              d &&
              0 !==
                r.paint
                  .get(a ? 'text-halo-width' : 'icon-halo-width')
                  .constantOr(1);
          let W;
          W = d
            ? l.iconsInText
              ? cr(f.kind, D, x, y, v, $, t, q, V, j, A, k, I)
              : lr(f.kind, D, x, y, v, $, t, q, V, j, a, A, 0, I)
            : or(f.kind, D, x, y, v, $, t, q, V, j, a, A, I);
          const X = {
            program: M,
            buffers: c,
            uniformValues: W,
            projectionData: U,
            atlasTexture: E,
            atlasTextureIcon: O,
            atlasInterpolation: R,
            atlasInterpolationIcon: z,
            isSDF: d,
            hasHalo: H,
          };
          if (b && l.canOverlap) {
            w = !0;
            const t = c.segments.get();
            for (const i of t)
              C.push({
                segments: new e.aQ([i]),
                sortKey: i.sortKey,
                state: X,
                terrainData: L,
              });
          } else
            C.push({
              segments: c.segments,
              sortKey: 0,
              state: X,
              terrainData: L,
            });
        }
        w && C.sort((t, e) => t.sortKey - e.sortKey);
        for (const e of C) {
          const i = e.state;
          if (
            (f.activeTexture.set(m.TEXTURE0),
            i.atlasTexture.bind(i.atlasInterpolation, m.CLAMP_TO_EDGE),
            i.atlasTextureIcon &&
              (f.activeTexture.set(m.TEXTURE1),
              i.atlasTextureIcon &&
                i.atlasTextureIcon.bind(
                  i.atlasInterpolationIcon,
                  m.CLAMP_TO_EDGE
                )),
            i.isSDF)
          ) {
            const n = i.uniformValues;
            i.hasHalo &&
              ((n.u_is_halo = 1),
              un(
                i.buffers,
                e.segments,
                r,
                t,
                i.program,
                T,
                u,
                d,
                n,
                i.projectionData,
                e.terrainData
              )),
              (n.u_is_halo = 0);
          }
          un(
            i.buffers,
            e.segments,
            r,
            t,
            i.program,
            T,
            u,
            d,
            i.uniformValues,
            i.projectionData,
            e.terrainData
          );
        }
      }
      function un(t, e, i, r, n, a, s, o, l, c, h) {
        const u = r.context;
        n.draw(
          u,
          u.gl.TRIANGLES,
          a,
          s,
          o,
          We.backCCW,
          l,
          h,
          c,
          i.id,
          t.layoutVertexBuffer,
          t.indexBuffer,
          e,
          i.paint,
          r.transform.zoom,
          t.programConfigurations.get(i.id),
          t.dynamicLayoutVertexBuffer,
          t.opacityVertexBuffer
        );
      }
      function dn(t, i, r, n, a) {
        const s = t.context,
          o = s.gl,
          l = Ke.disabled,
          c = new qe([o.ONE, o.ONE], e.bi.transparent, [!0, !0, !0, !0]),
          h = i.getBucket(r);
        if (!h) return;
        const u = n.key;
        let d = r.heatmapFbos.get(u);
        d || ((d = fn(s, i.tileSize, i.tileSize)), r.heatmapFbos.set(u, d)),
          s.bindFramebuffer.set(d.framebuffer),
          s.viewport.set([0, 0, i.tileSize, i.tileSize]),
          s.clear({ color: e.bi.transparent });
        const p = h.programConfigurations.get(r.id),
          f = t.useProgram('heatmap', p, !a),
          m = t.transform.getProjectionData({
            overscaledTileID: i.tileID,
            applyGlobeMatrix: !0,
            applyTerrainMatrix: !0,
          }),
          g = t.style.map.terrain.getTerrainData(n);
        f.draw(
          s,
          o.TRIANGLES,
          Xe.disabled,
          l,
          c,
          We.disabled,
          qi(i, t.transform.zoom, r.paint.get('heatmap-intensity'), 1),
          g,
          m,
          r.id,
          h.layoutVertexBuffer,
          h.indexBuffer,
          h.segments,
          r.paint,
          t.transform.zoom,
          p
        );
      }
      function pn(t, e, i, r, n) {
        const a = t.context,
          s = a.gl,
          o = t.transform;
        a.setColorMode(t.colorModeForRenderPass());
        const l = mn(a, e),
          c = i.key,
          h = e.heatmapFbos.get(c);
        if (!h) return;
        a.activeTexture.set(s.TEXTURE0),
          s.bindTexture(s.TEXTURE_2D, h.colorAttachment.get()),
          a.activeTexture.set(s.TEXTURE1),
          l.bind(s.LINEAR, s.CLAMP_TO_EDGE);
        const u = o.getProjectionData({
          overscaledTileID: i,
          applyTerrainMatrix: n,
          applyGlobeMatrix: !r,
        });
        t
          .useProgram('heatmapTexture')
          .draw(
            a,
            s.TRIANGLES,
            Xe.disabled,
            Ke.disabled,
            t.colorModeForRenderPass(),
            We.disabled,
            Hi(t, e, 0, 1),
            null,
            u,
            e.id,
            t.rasterBoundsBuffer,
            t.quadTriangleIndexBuffer,
            t.rasterBoundsSegments,
            e.paint,
            o.zoom
          ),
          h.destroy(),
          e.heatmapFbos.delete(c);
      }
      function fn(t, e, i) {
        var r, n;
        const a = t.gl,
          s = a.createTexture();
        a.bindTexture(a.TEXTURE_2D, s),
          a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_S, a.CLAMP_TO_EDGE),
          a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_T, a.CLAMP_TO_EDGE),
          a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, a.LINEAR),
          a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MAG_FILTER, a.LINEAR);
        const o =
            null !== (r = t.HALF_FLOAT) && void 0 !== r ? r : a.UNSIGNED_BYTE,
          l = null !== (n = t.RGBA16F) && void 0 !== n ? n : a.RGBA;
        a.texImage2D(a.TEXTURE_2D, 0, l, e, i, 0, a.RGBA, o, null);
        const c = t.createFramebuffer(e, i, !1, !1);
        return c.colorAttachment.set(s), c;
      }
      function mn(t, i) {
        return (
          i.colorRampTexture ||
            (i.colorRampTexture = new e.T(t, i.colorRamp, t.gl.RGBA)),
          i.colorRampTexture
        );
      }
      function gn(t, i, r, n, a, s, o, l) {
        let c = 256;
        if (a.stepInterpolant) {
          const n = i.getSource().maxzoom,
            a =
              o.canonical.z === n
                ? Math.ceil(1 << (t.transform.maxZoom - o.canonical.z))
                : 1;
          c = e.ai(
            e.c7((s.maxLineLength / e.a3) * 1024 * a),
            256,
            r.maxTextureSize
          );
        }
        return (
          (l.gradient = e.c8({
            expression: a.gradientExpression(),
            evaluationKey: 'lineProgress',
            resolution: c,
            image: l.gradient || void 0,
            clips: s.lineClipsArray,
          })),
          l.texture
            ? l.texture.update(l.gradient)
            : (l.texture = new e.T(r, l.gradient, n.RGBA)),
          (l.version = a.gradientVersion),
          l.texture
        );
      }
      function _n(t, e, i, r, n) {
        t.activeTexture.set(e.TEXTURE0),
          i.imageAtlasTexture.bind(e.LINEAR, e.CLAMP_TO_EDGE),
          r.updatePaintBuffers(n);
      }
      function yn(t, e, i, r, n, a) {
        (n || t.lineAtlas.dirty) &&
          (e.activeTexture.set(i.TEXTURE0), t.lineAtlas.bind(e)),
          r.updatePaintBuffers(a);
      }
      function vn(t, e, i, r, n, a, s) {
        const o = a.gradients[n.id];
        let l = o.texture;
        n.gradientVersion !== o.version && (l = gn(t, e, i, r, n, a, s, o)),
          i.activeTexture.set(r.TEXTURE0),
          l.bind(n.stepInterpolant ? r.NEAREST : r.LINEAR, r.CLAMP_TO_EDGE);
      }
      function xn(t, e, i, r, n, a, s, o, l) {
        const c = a.gradients[n.id];
        let h = c.texture;
        n.gradientVersion !== c.version && (h = gn(t, e, i, r, n, a, s, c)),
          i.activeTexture.set(r.TEXTURE0),
          h.bind(n.stepInterpolant ? r.NEAREST : r.LINEAR, r.CLAMP_TO_EDGE),
          i.activeTexture.set(r.TEXTURE1),
          t.lineAtlas.bind(i),
          o.updatePaintBuffers(l);
      }
      function bn(t, e, i, r, n) {
        if (!i || !r || !r.imageAtlas) return;
        const a = r.imageAtlas.patternPositions;
        let s = a[i.to.toString()],
          o = a[i.from.toString()];
        if ((!s && o && (s = o), !o && s && (o = s), !s || !o)) {
          const t = n.getPaintProperty(e);
          (s = a[t]), (o = a[t]);
        }
        s && o && t.setConstantPatternPositions(s, o);
      }
      function wn(t, i, r, n, a, s, o, l) {
        const c = t.context.gl,
          h = 'fill-pattern',
          u = r.paint.get(h),
          d = u && u.constantOr(1),
          p = r.getCrossfadeParameters();
        let f, m, g, _, y;
        const v = t.transform,
          x = r.paint.get('fill-translate'),
          b = r.paint.get('fill-translate-anchor');
        o
          ? ((m =
              d && !r.getPaintProperty('fill-outline-color')
                ? 'fillOutlinePattern'
                : 'fillOutline'),
            (f = c.LINES))
          : ((m = d ? 'fillPattern' : 'fill'), (f = c.TRIANGLES));
        const w = u.constantOr(null);
        for (const T of n) {
          const n = i.getTile(T);
          if (d && !n.patternsLoaded()) continue;
          const u = n.getBucket(r);
          if (!u) continue;
          const P = u.programConfigurations.get(r.id),
            C = t.useProgram(m, P),
            I = t.style.map.terrain && t.style.map.terrain.getTerrainData(T);
          d &&
            (t.context.activeTexture.set(c.TEXTURE0),
            n.imageAtlasTexture.bind(c.LINEAR, c.CLAMP_TO_EDGE),
            P.updatePaintBuffers(p)),
            bn(P, h, w, n, r);
          const S = v.getProjectionData({
              overscaledTileID: T,
              applyGlobeMatrix: !l,
              applyTerrainMatrix: !0,
            }),
            M = e.aH(v, n, x, b);
          if (o) {
            (_ = u.indexBuffer2), (y = u.segments2);
            const e = [c.drawingBufferWidth, c.drawingBufferHeight];
            g = 'fillOutlinePattern' === m && d ? ji(t, p, n, e, M) : Vi(e, M);
          } else
            (_ = u.indexBuffer),
              (y = u.segments),
              (g = d ? Ni(t, p, n, M) : { u_fill_translate: M });
          const D = t.stencilModeForClipping(T);
          C.draw(
            t.context,
            f,
            a,
            D,
            s,
            We.backCCW,
            g,
            I,
            S,
            r.id,
            u.layoutVertexBuffer,
            _,
            y,
            r.paint,
            t.transform.zoom,
            P
          );
        }
      }
      function Tn(t, i, r, n, a, s, o, l) {
        const c = t.context,
          h = c.gl,
          u = 'fill-extrusion-pattern',
          d = r.paint.get(u),
          p = d.constantOr(1),
          f = r.getCrossfadeParameters(),
          m = r.paint.get('fill-extrusion-opacity'),
          g = d.constantOr(null),
          _ = t.transform;
        for (const y of n) {
          const n = i.getTile(y),
            d = n.getBucket(r);
          if (!d) continue;
          const v =
              t.style.map.terrain && t.style.map.terrain.getTerrainData(y),
            x = d.programConfigurations.get(r.id),
            b = t.useProgram(p ? 'fillExtrusionPattern' : 'fillExtrusion', x);
          p &&
            (t.context.activeTexture.set(h.TEXTURE0),
            n.imageAtlasTexture.bind(h.LINEAR, h.CLAMP_TO_EDGE),
            x.updatePaintBuffers(f));
          const w = _.getProjectionData({
            overscaledTileID: y,
            applyGlobeMatrix: !l,
            applyTerrainMatrix: !0,
          });
          bn(x, u, g, n, r);
          const T = e.aH(
              _,
              n,
              r.paint.get('fill-extrusion-translate'),
              r.paint.get('fill-extrusion-translate-anchor')
            ),
            P = r.paint.get('fill-extrusion-vertical-gradient'),
            C = p ? Bi(t, P, m, T, y, f, n) : Fi(t, P, m, T);
          b.draw(
            c,
            c.gl.TRIANGLES,
            a,
            s,
            o,
            We.backCCW,
            C,
            v,
            w,
            r.id,
            d.layoutVertexBuffer,
            d.indexBuffer,
            d.segments,
            r.paint,
            t.transform.zoom,
            x,
            t.style.map.terrain && d.centroidVertexBuffer
          );
        }
      }
      function Pn(t, e, i, r, n, a, s, o, l) {
        var c;
        const h = t.style.projection,
          u = t.context,
          d = t.transform,
          p = u.gl,
          f = [
            `#define NUM_ILLUMINATION_SOURCES ${
              i.paint.get('hillshade-highlight-color').values.length
            }`,
          ],
          m = t.useProgram('hillshade', null, !1, f),
          g = !t.options.moving;
        for (const _ of r) {
          const r = e.getTile(_),
            f = r.fbo;
          if (!f) continue;
          const y = h.getMeshFromTileID(u, _.canonical, o, !0, 'raster'),
            v =
              null === (c = t.style.map.terrain) || void 0 === c
                ? void 0
                : c.getTerrainData(_);
          u.activeTexture.set(p.TEXTURE0),
            p.bindTexture(p.TEXTURE_2D, f.colorAttachment.get());
          const x = d.getProjectionData({
            overscaledTileID: _,
            aligned: g,
            applyGlobeMatrix: !l,
            applyTerrainMatrix: !0,
          });
          m.draw(
            u,
            p.TRIANGLES,
            a,
            n[_.overscaledZ],
            s,
            We.backCCW,
            Wi(t, r, i),
            v,
            x,
            i.id,
            y.vertexBuffer,
            y.indexBuffer,
            y.segments
          );
        }
      }
      function Cn(t, i, r, n, a, s, o, l, c) {
        var h;
        const u = t.style.projection,
          d = t.context,
          p = t.transform,
          f = d.gl,
          m = t.useProgram('colorRelief'),
          g = !t.options.moving;
        let _ = !0,
          y = 0;
        for (const v of n) {
          const n = i.getTile(v),
            x = n.dem;
          if (_) {
            const t = f.getParameter(f.MAX_TEXTURE_SIZE),
              { elevationTexture: e, colorTexture: i } = r.getColorRampTextures(
                d,
                t,
                x.getUnpackVector()
              );
            d.activeTexture.set(f.TEXTURE1),
              e.bind(f.NEAREST, f.CLAMP_TO_EDGE),
              d.activeTexture.set(f.TEXTURE4),
              i.bind(f.LINEAR, f.CLAMP_TO_EDGE),
              (_ = !1),
              (y = e.size[0]);
          }
          if (!x || !x.data) continue;
          const b = x.stride,
            w = x.getPixels();
          if (
            (d.activeTexture.set(f.TEXTURE0),
            d.pixelStoreUnpackPremultiplyAlpha.set(!1),
            (n.demTexture = n.demTexture || t.getTileTexture(b)),
            n.demTexture)
          ) {
            const t = n.demTexture;
            t.update(w, { premultiply: !1 }), t.bind(f.LINEAR, f.CLAMP_TO_EDGE);
          } else
            (n.demTexture = new e.T(d, w, f.RGBA, { premultiply: !1 })),
              n.demTexture.bind(f.LINEAR, f.CLAMP_TO_EDGE);
          const T = u.getMeshFromTileID(d, v.canonical, l, !0, 'raster'),
            P =
              null === (h = t.style.map.terrain) || void 0 === h
                ? void 0
                : h.getTerrainData(v),
            C = p.getProjectionData({
              overscaledTileID: v,
              aligned: g,
              applyGlobeMatrix: !c,
              applyTerrainMatrix: !0,
            });
          m.draw(
            d,
            f.TRIANGLES,
            s,
            a[v.overscaledZ],
            o,
            We.backCCW,
            Ki(r, n.dem, y),
            P,
            C,
            r.id,
            T.vertexBuffer,
            T.indexBuffer,
            T.segments
          );
        }
      }
      const In = [
        new e.P(0, 0),
        new e.P(e.a3, 0),
        new e.P(e.a3, e.a3),
        new e.P(0, e.a3),
      ];
      function Sn(t, e, i, r, n, a, s, o, l = !1, c = !1) {
        const h = r[r.length - 1].overscaledZ,
          u = t.context,
          d = u.gl,
          p = t.useProgram('raster'),
          f = t.transform,
          m = t.style.projection,
          g = t.colorModeForRenderPass(),
          _ = !t.options.moving,
          y = i.paint.get('raster-opacity'),
          v = i.paint.get('raster-resampling'),
          x = i.paint.get('raster-fade-duration'),
          b = !!t.style.map.terrain;
        for (const w of r) {
          const r = t.getDepthModeForSublayer(
              w.overscaledZ - h,
              1 === y ? Xe.ReadWrite : Xe.ReadOnly,
              d.LESS
            ),
            T = e.getTile(w),
            P = 'nearest' === v ? d.NEAREST : d.LINEAR;
          u.activeTexture.set(d.TEXTURE0),
            T.texture.bind(P, d.CLAMP_TO_EDGE, d.LINEAR_MIPMAP_NEAREST),
            u.activeTexture.set(d.TEXTURE1);
          const {
            parentTile: C,
            parentScaleBy: I,
            parentTopLeft: S,
            fadeValues: M,
          } = Mn(T, e, x, b);
          (T.fadeOpacity = M.tileOpacity),
            C
              ? ((C.fadeOpacity = M.parentTileOpacity),
                C.texture.bind(P, d.CLAMP_TO_EDGE, d.LINEAR_MIPMAP_NEAREST))
              : T.texture.bind(P, d.CLAMP_TO_EDGE, d.LINEAR_MIPMAP_NEAREST),
            T.texture.useMipmap &&
              u.extTextureFilterAnisotropic &&
              t.transform.pitch > 20 &&
              d.texParameterf(
                d.TEXTURE_2D,
                u.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT,
                u.extTextureFilterAnisotropicMax
              );
          const D =
              t.style.map.terrain && t.style.map.terrain.getTerrainData(w),
            L = f.getProjectionData({
              overscaledTileID: w,
              aligned: _,
              applyGlobeMatrix: !c,
              applyTerrainMatrix: !0,
            }),
            A = ar(S, I, M.fadeMix, i, o),
            E = m.getMeshFromTileID(u, w.canonical, a, s, 'raster');
          p.draw(
            u,
            d.TRIANGLES,
            r,
            n ? n[w.overscaledZ] : Ke.disabled,
            g,
            l ? We.frontCCW : We.backCCW,
            A,
            D,
            L,
            i.id,
            E.vertexBuffer,
            E.indexBuffer,
            E.segments
          );
        }
      }
      function Mn(t, i, r, n) {
        const a = {
          parentTile: null,
          parentScaleBy: 1,
          parentTopLeft: [0, 0],
          fadeValues: {
            tileOpacity: 1,
            parentTileOpacity: 1,
            fadeMix: { opacity: 1, mix: 0 },
          },
        };
        if (0 === r || n) return a;
        if (t.fadingParentID) {
          const n = i.getLoadedTile(t.fadingParentID);
          if (!n) return a;
          const s = Math.pow(2, n.tileID.overscaledZ - t.tileID.overscaledZ),
            o = [
              (t.tileID.canonical.x * s) % 1,
              (t.tileID.canonical.y * s) % 1,
            ],
            c = (function (t, i, r) {
              const n = l(),
                a = (n - i.timeAdded) / r,
                s = t.fadingDirection === ht.Incoming,
                o = e.ai((n - t.timeAdded) / r, 0, 1),
                c = e.ai(1 - a, 0, 1),
                h = s ? o : c;
              return {
                tileOpacity: h,
                parentTileOpacity: s ? c : o,
                fadeMix: { opacity: 1, mix: 1 - h },
              };
            })(t, n, r);
          return {
            parentTile: n,
            parentScaleBy: s,
            parentTopLeft: o,
            fadeValues: c,
          };
        }
        if (t.selfFading) {
          const i = (function (t, i) {
            const r = (l() - t.timeAdded) / i,
              n = e.ai(r, 0, 1);
            return { tileOpacity: n, fadeMix: { opacity: n, mix: 0 } };
          })(t, r);
          return {
            parentTile: null,
            parentScaleBy: 1,
            parentTopLeft: [0, 0],
            fadeValues: i,
          };
        }
        return a;
      }
      const Dn = new e.bi(1, 0, 0, 1),
        Ln = new e.bi(0, 1, 0, 1),
        An = new e.bi(0, 0, 1, 1),
        En = new e.bi(1, 0, 1, 1),
        Rn = new e.bi(0, 1, 1, 1);
      function zn(t, e, i, r) {
        On(t, 0, e + i / 2, t.transform.width, i, r);
      }
      function kn(t, e, i, r) {
        On(t, e - i / 2, 0, i, t.transform.height, r);
      }
      function On(t, e, i, r, n, a) {
        const s = t.context,
          o = s.gl;
        o.enable(o.SCISSOR_TEST),
          o.scissor(
            e * t.pixelRatio,
            i * t.pixelRatio,
            r * t.pixelRatio,
            n * t.pixelRatio
          ),
          s.clear({ color: a }),
          o.disable(o.SCISSOR_TEST);
      }
      function Fn(t, i, r) {
        const n = t.context,
          a = n.gl,
          s = t.useProgram('debug'),
          o = Xe.disabled,
          l = Ke.disabled,
          c = t.colorModeForRenderPass(),
          h = '$debug',
          u = t.style.map.terrain && t.style.map.terrain.getTerrainData(r);
        n.activeTexture.set(a.TEXTURE0);
        const d = i.getTileByID(r.key).latestRawTileData,
          p = Math.floor(((d && d.byteLength) || 0) / 1024),
          f = i.getTile(r).tileSize,
          m =
            (512 / Math.min(f, 512)) * (r.overscaledZ / t.transform.zoom) * 0.5;
        let g = r.canonical.toString();
        r.overscaledZ !== r.canonical.z && (g += ` => ${r.overscaledZ}`),
          (function (t, e) {
            t.initDebugOverlayCanvas();
            const i = t.debugOverlayCanvas,
              r = t.context.gl,
              n = t.debugOverlayCanvas.getContext('2d');
            n.clearRect(0, 0, i.width, i.height),
              (n.shadowColor = 'white'),
              (n.shadowBlur = 2),
              (n.lineWidth = 1.5),
              (n.strokeStyle = 'white'),
              (n.textBaseline = 'top'),
              (n.font = 'bold 36px Open Sans, sans-serif'),
              n.fillText(e, 5, 5),
              n.strokeText(e, 5, 5),
              t.debugOverlayTexture.update(i),
              t.debugOverlayTexture.bind(r.LINEAR, r.CLAMP_TO_EDGE);
          })(t, `${g} ${p}kB`);
        const _ = t.transform.getProjectionData({
          overscaledTileID: r,
          applyGlobeMatrix: !0,
          applyTerrainMatrix: !0,
        });
        s.draw(
          n,
          a.TRIANGLES,
          o,
          l,
          qe.alphaBlended,
          We.disabled,
          $i(e.bi.transparent, m),
          null,
          _,
          h,
          t.debugBuffer,
          t.quadTriangleIndexBuffer,
          t.debugSegments
        ),
          s.draw(
            n,
            a.LINE_STRIP,
            o,
            l,
            c,
            We.disabled,
            $i(e.bi.red),
            u,
            _,
            h,
            t.debugBuffer,
            t.tileBorderIndexBuffer,
            t.debugSegments
          );
      }
      function Bn(t, e, i, r) {
        const { isRenderingGlobe: n } = r,
          a = t.context,
          s = a.gl,
          o = t.transform,
          l = t.colorModeForRenderPass(),
          c = t.getDepthModeFor3D(),
          h = t.useProgram('terrain');
        a.bindFramebuffer.set(null), a.viewport.set([0, 0, t.width, t.height]);
        for (const u of i) {
          const i = e.getTerrainMesh(u.tileID),
            r = t.renderToTexture.getTexture(u),
            d = e.getTerrainData(u.tileID);
          a.activeTexture.set(s.TEXTURE0),
            s.bindTexture(s.TEXTURE_2D, r.texture);
          const p = e.getMeshFrameDelta(o.zoom),
            f = o.calculateFogMatrix(u.tileID.toUnwrapped()),
            m = Ei(p, f, t.style.sky, o.pitch, n),
            g = o.getProjectionData({
              overscaledTileID: u.tileID,
              applyTerrainMatrix: !1,
              applyGlobeMatrix: !0,
            });
          h.draw(
            a,
            s.TRIANGLES,
            c,
            Ke.disabled,
            l,
            We.backCCW,
            m,
            d,
            g,
            'terrain',
            i.vertexBuffer,
            i.indexBuffer,
            i.segments
          );
        }
      }
      function Nn(t, i) {
        if (!i.mesh) {
          const r = new e.aP();
          r.emplaceBack(-1, -1),
            r.emplaceBack(1, -1),
            r.emplaceBack(1, 1),
            r.emplaceBack(-1, 1);
          const n = new e.aR();
          n.emplaceBack(0, 1, 2),
            n.emplaceBack(0, 2, 3),
            (i.mesh = new De(
              t.createVertexBuffer(r, Le.members),
              t.createIndexBuffer(n),
              e.aQ.simpleSegment(0, 0, r.length, n.length)
            ));
        }
        return i.mesh;
      }
      class Vn {
        constructor(t, i) {
          (this.context = new en(t)),
            (this.transform = i),
            (this._tileTextures = {}),
            (this.terrainFacilitator = {
              dirty: !0,
              matrix: e.am(new Float64Array(16)),
              renderTime: 0,
            }),
            this.setup(),
            (this.numSublayers = St.maxUnderzooming + St.maxOverzooming + 1),
            (this.depthEpsilon = 1 / Math.pow(2, 16)),
            (this.crossTileSymbolIndex = new Ce());
        }
        resize(t, e, i) {
          if (
            ((this.width = Math.floor(t * i)),
            (this.height = Math.floor(e * i)),
            (this.pixelRatio = i),
            this.context.viewport.set([0, 0, this.width, this.height]),
            this.style)
          )
            for (const r of this.style._order) this.style._layers[r].resize();
        }
        setup() {
          const t = this.context,
            i = new e.aP();
          i.emplaceBack(0, 0),
            i.emplaceBack(e.a3, 0),
            i.emplaceBack(0, e.a3),
            i.emplaceBack(e.a3, e.a3),
            (this.tileExtentBuffer = t.createVertexBuffer(i, Le.members)),
            (this.tileExtentSegments = e.aQ.simpleSegment(0, 0, 4, 2));
          const r = new e.aP();
          r.emplaceBack(0, 0),
            r.emplaceBack(e.a3, 0),
            r.emplaceBack(0, e.a3),
            r.emplaceBack(e.a3, e.a3),
            (this.debugBuffer = t.createVertexBuffer(r, Le.members)),
            (this.debugSegments = e.aQ.simpleSegment(0, 0, 4, 5));
          const n = new e.ca();
          n.emplaceBack(0, 0, 0, 0),
            n.emplaceBack(e.a3, 0, e.a3, 0),
            n.emplaceBack(0, e.a3, 0, e.a3),
            n.emplaceBack(e.a3, e.a3, e.a3, e.a3),
            (this.rasterBoundsBuffer = t.createVertexBuffer(n, Li.members)),
            (this.rasterBoundsSegments = e.aQ.simpleSegment(0, 0, 4, 2));
          const a = new e.aP();
          a.emplaceBack(0, 0),
            a.emplaceBack(e.a3, 0),
            a.emplaceBack(0, e.a3),
            a.emplaceBack(e.a3, e.a3),
            (this.rasterBoundsBufferPosOnly = t.createVertexBuffer(
              a,
              Le.members
            )),
            (this.rasterBoundsSegmentsPosOnly = e.aQ.simpleSegment(0, 0, 4, 5));
          const s = new e.aP();
          s.emplaceBack(0, 0),
            s.emplaceBack(1, 0),
            s.emplaceBack(0, 1),
            s.emplaceBack(1, 1),
            (this.viewportBuffer = t.createVertexBuffer(s, Le.members)),
            (this.viewportSegments = e.aQ.simpleSegment(0, 0, 4, 2));
          const o = new e.cb();
          o.emplaceBack(0),
            o.emplaceBack(1),
            o.emplaceBack(3),
            o.emplaceBack(2),
            o.emplaceBack(0),
            (this.tileBorderIndexBuffer = t.createIndexBuffer(o));
          const l = new e.aR();
          l.emplaceBack(1, 0, 2),
            l.emplaceBack(1, 2, 3),
            (this.quadTriangleIndexBuffer = t.createIndexBuffer(l));
          const c = this.context.gl;
          (this.stencilClearMode = new Ke(
            { func: c.ALWAYS, mask: 0 },
            0,
            255,
            c.ZERO,
            c.ZERO,
            c.ZERO
          )),
            (this.tileExtentMesh = new De(
              this.tileExtentBuffer,
              this.quadTriangleIndexBuffer,
              this.tileExtentSegments
            ));
        }
        clearStencil() {
          const t = this.context,
            i = t.gl;
          (this.nextStencilID = 1), (this.currentStencilSource = void 0);
          const r = e.M();
          e.c0(r, 0, this.width, this.height, 0, 0, 1),
            e.O(r, r, [i.drawingBufferWidth, i.drawingBufferHeight, 0]);
          const n = {
            mainMatrix: r,
            tileMercatorCoords: [0, 0, 1, 1],
            clippingPlane: [0, 0, 0, 0],
            projectionTransition: 0,
            fallbackMatrix: r,
          };
          this.useProgram('clippingMask', null, !0).draw(
            t,
            i.TRIANGLES,
            Xe.disabled,
            this.stencilClearMode,
            qe.disabled,
            We.disabled,
            null,
            null,
            n,
            '$clipping',
            this.viewportBuffer,
            this.quadTriangleIndexBuffer,
            this.viewportSegments
          );
        }
        _renderTileClippingMasks(t, e, i) {
          if (
            this.currentStencilSource === t.source ||
            !t.isTileClipped() ||
            !e ||
            !e.length
          )
            return;
          (this.currentStencilSource = t.source),
            this.nextStencilID + e.length > 256 && this.clearStencil();
          const r = this.context;
          r.setColorMode(qe.disabled), r.setDepthMode(Xe.disabled);
          const n = {};
          for (const a of e) n[a.key] = this.nextStencilID++;
          this._renderTileMasks(n, e, i, !0),
            this._renderTileMasks(n, e, i, !1),
            (this._tileClippingMaskIDs = n);
        }
        _renderTileMasks(t, e, i, r) {
          const n = this.context,
            a = n.gl,
            s = this.style.projection,
            o = this.transform,
            l = this.useProgram('clippingMask');
          for (const c of e) {
            const e = t[c.key],
              h =
                this.style.map.terrain &&
                this.style.map.terrain.getTerrainData(c),
              u = s.getMeshFromTileID(
                this.context,
                c.canonical,
                r,
                !0,
                'stencil'
              ),
              d = o.getProjectionData({
                overscaledTileID: c,
                applyGlobeMatrix: !i,
                applyTerrainMatrix: !0,
              });
            l.draw(
              n,
              a.TRIANGLES,
              Xe.disabled,
              new Ke(
                { func: a.ALWAYS, mask: 0 },
                e,
                255,
                a.KEEP,
                a.KEEP,
                a.REPLACE
              ),
              qe.disabled,
              i ? We.disabled : We.backCCW,
              null,
              h,
              d,
              '$clipping',
              u.vertexBuffer,
              u.indexBuffer,
              u.segments
            );
          }
        }
        _renderTilesDepthBuffer() {
          const t = this.context,
            e = t.gl,
            i = this.style.projection,
            r = this.transform,
            n = this.useProgram('depth'),
            a = this.getDepthModeFor3D(),
            s = Ct(r, { tileSize: r.tileSize });
          for (const o of s) {
            const s =
                this.style.map.terrain &&
                this.style.map.terrain.getTerrainData(o),
              l = i.getMeshFromTileID(
                this.context,
                o.canonical,
                !0,
                !0,
                'raster'
              ),
              c = r.getProjectionData({
                overscaledTileID: o,
                applyGlobeMatrix: !0,
                applyTerrainMatrix: !0,
              });
            n.draw(
              t,
              e.TRIANGLES,
              a,
              Ke.disabled,
              qe.disabled,
              We.backCCW,
              null,
              s,
              c,
              '$clipping',
              l.vertexBuffer,
              l.indexBuffer,
              l.segments
            );
          }
        }
        stencilModeFor3D() {
          (this.currentStencilSource = void 0),
            this.nextStencilID + 1 > 256 && this.clearStencil();
          const t = this.nextStencilID++,
            e = this.context.gl;
          return new Ke(
            { func: e.NOTEQUAL, mask: 255 },
            t,
            255,
            e.KEEP,
            e.KEEP,
            e.REPLACE
          );
        }
        stencilModeForClipping(t) {
          const e = this.context.gl;
          return new Ke(
            { func: e.EQUAL, mask: 255 },
            this._tileClippingMaskIDs[t.key],
            0,
            e.KEEP,
            e.KEEP,
            e.REPLACE
          );
        }
        getStencilConfigForOverlapAndUpdateStencilID(t) {
          const e = this.context.gl,
            i = t.sort((t, e) => e.overscaledZ - t.overscaledZ),
            r = i[i.length - 1].overscaledZ,
            n = i[0].overscaledZ - r + 1;
          if (n > 1) {
            (this.currentStencilSource = void 0),
              this.nextStencilID + n > 256 && this.clearStencil();
            const t = {};
            for (let i = 0; i < n; i++)
              t[i + r] = new Ke(
                { func: e.GEQUAL, mask: 255 },
                i + this.nextStencilID,
                255,
                e.KEEP,
                e.KEEP,
                e.REPLACE
              );
            return (this.nextStencilID += n), [t, i];
          }
          return [{ [r]: Ke.disabled }, i];
        }
        stencilConfigForOverlapTwoPass(t) {
          const e = this.context.gl,
            i = t.sort((t, e) => e.overscaledZ - t.overscaledZ),
            r = i[i.length - 1].overscaledZ,
            n = i[0].overscaledZ - r + 1;
          if ((this.clearStencil(), n > 1)) {
            const t = {},
              a = {};
            for (let i = 0; i < n; i++)
              (t[i + r] = new Ke(
                { func: e.GREATER, mask: 255 },
                n + 1 + i,
                255,
                e.KEEP,
                e.KEEP,
                e.REPLACE
              )),
                (a[i + r] = new Ke(
                  { func: e.GREATER, mask: 255 },
                  1 + i,
                  255,
                  e.KEEP,
                  e.KEEP,
                  e.REPLACE
                ));
            return (this.nextStencilID = 2 * n + 1), [t, a, i];
          }
          return (
            (this.nextStencilID = 3),
            [
              {
                [r]: new Ke(
                  { func: e.GREATER, mask: 255 },
                  2,
                  255,
                  e.KEEP,
                  e.KEEP,
                  e.REPLACE
                ),
              },
              {
                [r]: new Ke(
                  { func: e.GREATER, mask: 255 },
                  1,
                  255,
                  e.KEEP,
                  e.KEEP,
                  e.REPLACE
                ),
              },
              i,
            ]
          );
        }
        colorModeForRenderPass() {
          const t = this.context.gl;
          if (this._showOverdrawInspector) {
            const i = 1 / 8;
            return new qe([t.CONSTANT_COLOR, t.ONE], new e.bi(i, i, i, 0), [
              !0,
              !0,
              !0,
              !0,
            ]);
          }
          return 'opaque' === this.renderPass ? qe.unblended : qe.alphaBlended;
        }
        getDepthModeForSublayer(t, e, i) {
          if (!this.opaquePassEnabledForLayer()) return Xe.disabled;
          const r =
            1 -
            ((1 + this.currentLayer) * this.numSublayers + t) *
              this.depthEpsilon;
          return new Xe(i || this.context.gl.LEQUAL, e, [r, r]);
        }
        getDepthModeFor3D() {
          return new Xe(
            this.context.gl.LEQUAL,
            Xe.ReadWrite,
            this.depthRangeFor3D
          );
        }
        opaquePassEnabledForLayer() {
          return this.currentLayer < this.opaquePassCutoff;
        }
        render(t, i) {
          var r, n;
          (this.style = t),
            (this.options = i),
            (this.lineAtlas = t.lineAtlas),
            (this.imageManager = t.imageManager),
            (this.glyphManager = t.glyphManager),
            (this.symbolFadeChange = t.placement.symbolFadeChange(l())),
            this.imageManager.beginFrame();
          const a = this.style._order,
            s = this.style.tileManagers,
            o = {},
            c = {},
            h = {},
            u = {
              isRenderingToTexture: !1,
              isRenderingGlobe:
                (null === (r = t.projection) || void 0 === r
                  ? void 0
                  : r.transitionState) > 0,
            };
          for (const e in s) {
            const t = s[e];
            t.used && t.prepare(this.context),
              (o[e] = t.getVisibleCoordinates(!1)),
              (c[e] = o[e].slice().reverse()),
              (h[e] = t.getVisibleCoordinates(!0).reverse());
          }
          this.opaquePassCutoff = 1 / 0;
          for (let e = 0; e < a.length; e++)
            if (this.style._layers[a[e]].is3D()) {
              this.opaquePassCutoff = e;
              break;
            }
          this.maybeDrawDepthAndCoords(!1),
            this.renderToTexture &&
              (this.renderToTexture.prepareForRender(
                this.style,
                this.transform.zoom
              ),
              (this.opaquePassCutoff = 0)),
            (this.renderPass = 'offscreen');
          for (const e of a) {
            const t = this.style._layers[e];
            if (!t.hasOffscreenPass() || t.isHidden(this.transform.zoom))
              continue;
            const i = c[t.source];
            ('custom' === t.type || i.length) &&
              this.renderLayer(this, s[t.source], t, i, u);
          }
          if (
            (null === (n = this.style.projection) ||
              void 0 === n ||
              n.updateGPUdependent({
                context: this.context,
                useProgram: (t) => this.useProgram(t),
              }),
            this.context.viewport.set([0, 0, this.width, this.height]),
            this.context.bindFramebuffer.set(null),
            this.context.clear({
              color: i.showOverdrawInspector ? e.bi.black : e.bi.transparent,
              depth: 1,
            }),
            this.clearStencil(),
            this.style.sky &&
              (function (t, e) {
                const i = t.context,
                  r = i.gl,
                  n = ((t, e, i) => {
                    const r = Math.cos(e.rollInRadians),
                      n = Math.sin(e.rollInRadians),
                      a = _t(e),
                      s = e.getProjectionData({
                        overscaledTileID: null,
                        applyGlobeMatrix: !0,
                        applyTerrainMatrix: !0,
                      }).projectionTransition;
                    return {
                      u_sky_color: t.properties.get('sky-color'),
                      u_horizon_color: t.properties.get('horizon-color'),
                      u_horizon: [
                        (e.width / 2 - a * n) * i,
                        (e.height / 2 + a * r) * i,
                      ],
                      u_horizon_normal: [-n, r],
                      u_sky_horizon_blend:
                        ((t.properties.get('sky-horizon-blend') * e.height) /
                          2) *
                        i,
                      u_sky_blend: s,
                    };
                  })(e, t.style.map.transform, t.pixelRatio),
                  a = new Xe(r.LEQUAL, Xe.ReadWrite, [0, 1]),
                  s = Ke.disabled,
                  o = t.colorModeForRenderPass(),
                  l = t.useProgram('sky'),
                  c = Nn(i, e);
                l.draw(
                  i,
                  r.TRIANGLES,
                  a,
                  s,
                  o,
                  We.disabled,
                  n,
                  null,
                  void 0,
                  'sky',
                  c.vertexBuffer,
                  c.indexBuffer,
                  c.segments
                );
              })(this, this.style.sky),
            (this._showOverdrawInspector = i.showOverdrawInspector),
            (this.depthRangeFor3D = [
              0,
              1 - (t._order.length + 2) * this.numSublayers * this.depthEpsilon,
            ]),
            !this.renderToTexture)
          )
            for (
              this.renderPass = 'opaque', this.currentLayer = a.length - 1;
              this.currentLayer >= 0;
              this.currentLayer--
            ) {
              const t = this.style._layers[a[this.currentLayer]],
                e = s[t.source],
                i = o[t.source];
              this._renderTileClippingMasks(t, i, !1),
                this.renderLayer(this, e, t, i, u);
            }
          this.renderPass = 'translucent';
          let d = !1;
          for (
            this.currentLayer = 0;
            this.currentLayer < a.length;
            this.currentLayer++
          ) {
            const t = this.style._layers[a[this.currentLayer]],
              e = s[t.source];
            if (this.renderToTexture && this.renderToTexture.renderLayer(t, u))
              continue;
            this.opaquePassEnabledForLayer() ||
              d ||
              ((d = !0),
              u.isRenderingGlobe &&
                !this.style.map.terrain &&
                this._renderTilesDepthBuffer());
            const i = ('symbol' === t.type ? h : c)[t.source];
            this._renderTileClippingMasks(
              t,
              o[t.source],
              !!this.renderToTexture
            ),
              this.renderLayer(this, e, t, i, u);
          }
          if (
            (u.isRenderingGlobe &&
              (function (t, i, r) {
                const n = t.context,
                  a = n.gl,
                  s = t.useProgram('atmosphere'),
                  o = new Xe(a.LEQUAL, Xe.ReadOnly, [0, 1]),
                  l = t.transform,
                  c = (function (t, i) {
                    const r = t.properties.get('position'),
                      n = [-r.x, -r.y, -r.z],
                      a = e.am(new Float64Array(16));
                    return (
                      'map' === t.properties.get('anchor') &&
                        (e.b9(a, a, i.rollInRadians),
                        e.ba(a, a, -i.pitchInRadians),
                        e.b9(a, a, i.bearingInRadians),
                        e.ba(a, a, (i.center.lat * Math.PI) / 180),
                        e.bC(a, a, (-i.center.lng * Math.PI) / 180)),
                      e.c9(n, n, a),
                      n
                    );
                  })(r, t.transform),
                  h = l.getProjectionData({
                    overscaledTileID: null,
                    applyGlobeMatrix: !0,
                    applyTerrainMatrix: !0,
                  }),
                  u =
                    i.properties.get('atmosphere-blend') *
                    h.projectionTransition;
                if (0 === u) return;
                const d = hi(l.worldSize, l.center.lat),
                  p = l.inverseProjectionMatrix,
                  f = new Float64Array(4);
                (f[3] = 1),
                  e.aA(f, f, l.modelViewProjectionMatrix),
                  (f[0] /= f[3]),
                  (f[1] /= f[3]),
                  (f[2] /= f[3]),
                  (f[3] = 1),
                  e.aA(f, f, p),
                  (f[0] /= f[3]),
                  (f[1] /= f[3]),
                  (f[2] /= f[3]),
                  (f[3] = 1);
                const m = ((t, e, i, r, n) => ({
                    u_sun_pos: t,
                    u_atmosphere_blend: e,
                    u_globe_position: i,
                    u_globe_radius: r,
                    u_inv_proj_matrix: n,
                  }))(c, u, [f[0], f[1], f[2]], d, p),
                  g = Nn(n, i);
                s.draw(
                  n,
                  a.TRIANGLES,
                  o,
                  Ke.disabled,
                  qe.alphaBlended,
                  We.disabled,
                  m,
                  null,
                  null,
                  'atmosphere',
                  g.vertexBuffer,
                  g.indexBuffer,
                  g.segments
                );
              })(this, this.style.sky, this.style.light),
            this.options.showTileBoundaries)
          ) {
            const t = (function (t, e) {
              let i = null;
              const r = Object.values(t._layers).flatMap((i) =>
                  i.source && !i.isHidden(e) ? [t.tileManagers[i.source]] : []
                ),
                n = r.filter((t) => 'vector' === t.getSource().type),
                a = r.filter((t) => 'vector' !== t.getSource().type),
                s = (t) => {
                  (!i || i.getSource().maxzoom < t.getSource().maxzoom) &&
                    (i = t);
                };
              return n.forEach((t) => s(t)), i || a.forEach((t) => s(t)), i;
            })(this.style, this.transform.zoom);
            t &&
              (function (t, e, i) {
                for (let r = 0; r < i.length; r++) Fn(t, e, i[r]);
              })(this, t, t.getVisibleCoordinates());
          }
          this.options.showPadding &&
            (function (t) {
              const e = t.transform.padding;
              zn(t, t.transform.height - (e.top || 0), 3, Dn),
                zn(t, e.bottom || 0, 3, Ln),
                kn(t, e.left || 0, 3, An),
                kn(t, t.transform.width - (e.right || 0), 3, En);
              const i = t.transform.centerPoint;
              !(function (t, e, i, r) {
                On(t, e - 1, i - 10, 2, 20, r), On(t, e - 10, i - 1, 20, 2, r);
              })(t, i.x, t.transform.height - i.y, Rn);
            })(this),
            this.context.setDefault();
        }
        maybeDrawDepthAndCoords(t) {
          if (!this.style || !this.style.map || !this.style.map.terrain) return;
          const i = this.terrainFacilitator.matrix,
            r = this.transform.modelViewProjectionMatrix;
          let n = this.terrainFacilitator.dirty;
          n || (n = t ? !e.cc(i, r) : !e.cd(i, r)),
            n ||
              (n = this.style.map.terrain.tileManager.anyTilesAfterTime(
                this.terrainFacilitator.renderTime
              )),
            n &&
              (e.ce(i, r),
              (this.terrainFacilitator.renderTime = Date.now()),
              (this.terrainFacilitator.dirty = !1),
              (function (t, i) {
                const r = t.context,
                  n = r.gl,
                  a = t.transform,
                  s = qe.unblended,
                  o = new Xe(n.LEQUAL, Xe.ReadWrite, [0, 1]),
                  l = i.tileManager.getRenderableTiles(),
                  c = t.useProgram('terrainDepth');
                r.bindFramebuffer.set(i.getFramebuffer('depth').framebuffer),
                  r.viewport.set([
                    0,
                    0,
                    t.width / devicePixelRatio,
                    t.height / devicePixelRatio,
                  ]),
                  r.clear({ color: e.bi.transparent, depth: 1 });
                for (const e of l) {
                  const t = i.getTerrainMesh(e.tileID),
                    l = i.getTerrainData(e.tileID),
                    h = a.getProjectionData({
                      overscaledTileID: e.tileID,
                      applyTerrainMatrix: !1,
                      applyGlobeMatrix: !0,
                    }),
                    u = { u_ele_delta: i.getMeshFrameDelta(a.zoom) };
                  c.draw(
                    r,
                    n.TRIANGLES,
                    o,
                    Ke.disabled,
                    s,
                    We.backCCW,
                    u,
                    l,
                    h,
                    'terrain',
                    t.vertexBuffer,
                    t.indexBuffer,
                    t.segments
                  );
                }
                r.bindFramebuffer.set(null),
                  r.viewport.set([0, 0, t.width, t.height]);
              })(this, this.style.map.terrain),
              (function (t, i) {
                const r = t.context,
                  n = r.gl,
                  a = t.transform,
                  s = qe.unblended,
                  o = new Xe(n.LEQUAL, Xe.ReadWrite, [0, 1]),
                  l = i.getCoordsTexture(),
                  c = i.tileManager.getRenderableTiles(),
                  h = t.useProgram('terrainCoords');
                r.bindFramebuffer.set(i.getFramebuffer('coords').framebuffer),
                  r.viewport.set([
                    0,
                    0,
                    t.width / devicePixelRatio,
                    t.height / devicePixelRatio,
                  ]),
                  r.clear({ color: e.bi.transparent, depth: 1 }),
                  (i.coordsIndex = []);
                for (const e of c) {
                  const t = i.getTerrainMesh(e.tileID),
                    c = i.getTerrainData(e.tileID);
                  r.activeTexture.set(n.TEXTURE0),
                    n.bindTexture(n.TEXTURE_2D, l.texture);
                  const u = {
                      u_terrain_coords_id: (255 - i.coordsIndex.length) / 255,
                      u_texture: 0,
                      u_ele_delta: i.getMeshFrameDelta(a.zoom),
                    },
                    d = a.getProjectionData({
                      overscaledTileID: e.tileID,
                      applyTerrainMatrix: !1,
                      applyGlobeMatrix: !0,
                    });
                  h.draw(
                    r,
                    n.TRIANGLES,
                    o,
                    Ke.disabled,
                    s,
                    We.backCCW,
                    u,
                    c,
                    d,
                    'terrain',
                    t.vertexBuffer,
                    t.indexBuffer,
                    t.segments
                  ),
                    i.coordsIndex.push(e.tileID.key);
                }
                r.bindFramebuffer.set(null),
                  r.viewport.set([0, 0, t.width, t.height]);
              })(this, this.style.map.terrain));
        }
        renderLayer(t, i, r, n, a) {
          r.isHidden(this.transform.zoom) ||
            (('background' === r.type ||
              'custom' === r.type ||
              (n || []).length) &&
              ((this.id = r.id),
              e.cf(r)
                ? (function (t, i, r, n, a, s) {
                    if ('translucent' !== t.renderPass) return;
                    const { isRenderingToTexture: o } = s,
                      l = Ke.disabled,
                      c = t.colorModeForRenderPass();
                    (r._unevaluatedLayout.hasValue('text-variable-anchor') ||
                      r._unevaluatedLayout.hasValue(
                        'text-variable-anchor-offset'
                      )) &&
                      (function (t, i, r, n, a, s, o, l, c) {
                        const h = i.transform,
                          u = i.style.map.terrain,
                          d = 'map' === a,
                          p = 'map' === s;
                        for (const f of t) {
                          const t = n.getTile(f),
                            a = t.getBucket(r);
                          if (!a || !a.text || !a.text.segments.get().length)
                            continue;
                          const s = e.ar(a.textSizeData, h.zoom),
                            m = e.aG(t, 1, i.transform.zoom),
                            g = Rt(d, i.transform, m),
                            _ =
                              'none' !== r.layout.get('icon-text-fit') &&
                              a.hasIconData();
                          if (s) {
                            const i = Math.pow(
                                2,
                                h.zoom - t.tileID.overscaledZ
                              ),
                              r = u ? (t, e) => u.getElevation(f, t, e) : null;
                            ln(
                              a,
                              d,
                              p,
                              c,
                              h,
                              g,
                              i,
                              s,
                              _,
                              e.aH(h, t, o, l),
                              f.toUnwrapped(),
                              r
                            );
                          }
                        }
                      })(
                        n,
                        t,
                        r,
                        i,
                        r.layout.get('text-rotation-alignment'),
                        r.layout.get('text-pitch-alignment'),
                        r.paint.get('text-translate'),
                        r.paint.get('text-translate-anchor'),
                        a
                      ),
                      0 !== r.paint.get('icon-opacity').constantOr(1) &&
                        hn(
                          t,
                          i,
                          r,
                          n,
                          !1,
                          r.paint.get('icon-translate'),
                          r.paint.get('icon-translate-anchor'),
                          r.layout.get('icon-rotation-alignment'),
                          r.layout.get('icon-pitch-alignment'),
                          r.layout.get('icon-keep-upright'),
                          l,
                          c,
                          o
                        ),
                      0 !== r.paint.get('text-opacity').constantOr(1) &&
                        hn(
                          t,
                          i,
                          r,
                          n,
                          !0,
                          r.paint.get('text-translate'),
                          r.paint.get('text-translate-anchor'),
                          r.layout.get('text-rotation-alignment'),
                          r.layout.get('text-pitch-alignment'),
                          r.layout.get('text-keep-upright'),
                          l,
                          c,
                          o
                        ),
                      i.map.showCollisionBoxes &&
                        (nn(t, i, r, n, !0), nn(t, i, r, n, !1));
                  })(t, i, r, n, this.style.placement.variableOffsets, a)
                : e.cg(r)
                ? (function (t, i, r, n, a) {
                    if ('translucent' !== t.renderPass) return;
                    const { isRenderingToTexture: s } = a,
                      o = r.paint.get('circle-opacity'),
                      l = r.paint.get('circle-stroke-width'),
                      c = r.paint.get('circle-stroke-opacity'),
                      h = !r.layout.get('circle-sort-key').isConstant();
                    if (
                      0 === o.constantOr(1) &&
                      (0 === l.constantOr(1) || 0 === c.constantOr(1))
                    )
                      return;
                    const u = t.context,
                      d = u.gl,
                      p = t.transform,
                      f = t.getDepthModeForSublayer(0, Xe.ReadOnly),
                      m = Ke.disabled,
                      g = t.colorModeForRenderPass(),
                      _ = [],
                      y = p.getCircleRadiusCorrection();
                    for (let v = 0; v < n.length; v++) {
                      const a = n[v],
                        o = i.getTile(a),
                        l = o.getBucket(r);
                      if (!l) continue;
                      const c = r.paint.get('circle-translate'),
                        u = r.paint.get('circle-translate-anchor'),
                        d = e.aH(p, o, c, u),
                        f = l.programConfigurations.get(r.id),
                        m = t.useProgram('circle', f),
                        g = l.layoutVertexBuffer,
                        x = l.indexBuffer,
                        b =
                          t.style.map.terrain &&
                          t.style.map.terrain.getTerrainData(a),
                        w = {
                          programConfiguration: f,
                          program: m,
                          layoutVertexBuffer: g,
                          indexBuffer: x,
                          uniformValues: Ui(t, o, r, d, y),
                          terrainData: b,
                          projectionData: p.getProjectionData({
                            overscaledTileID: a,
                            applyGlobeMatrix: !s,
                            applyTerrainMatrix: !0,
                          }),
                        };
                      if (h) {
                        const t = l.segments.get();
                        for (const i of t)
                          _.push({
                            segments: new e.aQ([i]),
                            sortKey: i.sortKey,
                            state: w,
                          });
                      } else
                        _.push({ segments: l.segments, sortKey: 0, state: w });
                    }
                    h && _.sort((t, e) => t.sortKey - e.sortKey);
                    for (const e of _) {
                      const {
                        programConfiguration: i,
                        program: n,
                        layoutVertexBuffer: a,
                        indexBuffer: s,
                        uniformValues: o,
                        terrainData: l,
                        projectionData: c,
                      } = e.state;
                      n.draw(
                        u,
                        d.TRIANGLES,
                        f,
                        m,
                        g,
                        We.backCCW,
                        o,
                        l,
                        c,
                        r.id,
                        a,
                        s,
                        e.segments,
                        r.paint,
                        t.transform.zoom,
                        i
                      );
                    }
                  })(t, i, r, n, a)
                : e.ch(r)
                ? (function (t, i, r, n, a) {
                    if (0 === r.paint.get('heatmap-opacity')) return;
                    const s = t.context,
                      { isRenderingToTexture: o, isRenderingGlobe: l } = a;
                    if (t.style.map.terrain) {
                      for (const e of n) {
                        const n = i.getTile(e);
                        i.hasRenderableParent(e) ||
                          ('offscreen' === t.renderPass
                            ? dn(t, n, r, e, l)
                            : 'translucent' === t.renderPass &&
                              pn(t, r, e, o, l));
                      }
                      s.viewport.set([0, 0, t.width, t.height]);
                    } else
                      'offscreen' === t.renderPass
                        ? (function (t, i, r, n) {
                            const a = t.context,
                              s = a.gl,
                              o = t.transform,
                              l = Ke.disabled,
                              c = new qe([s.ONE, s.ONE], e.bi.transparent, [
                                !0,
                                !0,
                                !0,
                                !0,
                              ]);
                            (function (t, i, r) {
                              const n = t.gl;
                              t.activeTexture.set(n.TEXTURE1),
                                t.viewport.set([
                                  0,
                                  0,
                                  i.width / 4,
                                  i.height / 4,
                                ]);
                              let a = r.heatmapFbos.get(e.c6);
                              a
                                ? (n.bindTexture(
                                    n.TEXTURE_2D,
                                    a.colorAttachment.get()
                                  ),
                                  t.bindFramebuffer.set(a.framebuffer))
                                : ((a = fn(t, i.width / 4, i.height / 4)),
                                  r.heatmapFbos.set(e.c6, a));
                            })(a, t, r),
                              a.clear({ color: e.bi.transparent });
                            for (let e = 0; e < n.length; e++) {
                              const h = n[e];
                              if (i.hasRenderableParent(h)) continue;
                              const u = i.getTile(h),
                                d = u.getBucket(r);
                              if (!d) continue;
                              const p = d.programConfigurations.get(r.id),
                                f = t.useProgram('heatmap', p),
                                m = o.getProjectionData({
                                  overscaledTileID: h,
                                  applyGlobeMatrix: !0,
                                  applyTerrainMatrix: !1,
                                }),
                                g = o.getCircleRadiusCorrection();
                              f.draw(
                                a,
                                s.TRIANGLES,
                                Xe.disabled,
                                l,
                                c,
                                We.backCCW,
                                qi(
                                  u,
                                  o.zoom,
                                  r.paint.get('heatmap-intensity'),
                                  g
                                ),
                                null,
                                m,
                                r.id,
                                d.layoutVertexBuffer,
                                d.indexBuffer,
                                d.segments,
                                r.paint,
                                o.zoom,
                                p
                              );
                            }
                            a.viewport.set([0, 0, t.width, t.height]);
                          })(t, i, r, n)
                        : 'translucent' === t.renderPass &&
                          (function (t, i) {
                            const r = t.context,
                              n = r.gl;
                            r.setColorMode(t.colorModeForRenderPass());
                            const a = i.heatmapFbos.get(e.c6);
                            a &&
                              (r.activeTexture.set(n.TEXTURE0),
                              n.bindTexture(
                                n.TEXTURE_2D,
                                a.colorAttachment.get()
                              ),
                              r.activeTexture.set(n.TEXTURE1),
                              mn(r, i).bind(n.LINEAR, n.CLAMP_TO_EDGE),
                              t
                                .useProgram('heatmapTexture')
                                .draw(
                                  r,
                                  n.TRIANGLES,
                                  Xe.disabled,
                                  Ke.disabled,
                                  t.colorModeForRenderPass(),
                                  We.disabled,
                                  Hi(t, i, 0, 1),
                                  null,
                                  null,
                                  i.id,
                                  t.viewportBuffer,
                                  t.quadTriangleIndexBuffer,
                                  t.viewportSegments,
                                  i.paint,
                                  t.transform.zoom
                                ));
                          })(t, r);
                  })(t, i, r, n, a)
                : e.ci(r)
                ? (function (t, e, i, r, n) {
                    if ('translucent' !== t.renderPass) return;
                    const { isRenderingToTexture: a } = n,
                      s = i.paint.get('line-opacity'),
                      o = i.paint.get('line-width');
                    if (0 === s.constantOr(1) || 0 === o.constantOr(1)) return;
                    const l = t.getDepthModeForSublayer(0, Xe.ReadOnly),
                      c = t.colorModeForRenderPass(),
                      h = i.paint.get('line-dasharray'),
                      u = h.constantOr(1),
                      d = i.paint.get('line-pattern'),
                      p = d.constantOr(1),
                      f = i.paint.get('line-gradient'),
                      m = i.getCrossfadeParameters();
                    let g;
                    g = p
                      ? 'linePattern'
                      : u && f
                      ? 'lineGradientSDF'
                      : u
                      ? 'lineSDF'
                      : f
                      ? 'lineGradient'
                      : 'line';
                    const _ = t.context,
                      y = _.gl,
                      v = t.transform;
                    let x = !0;
                    for (const b of r) {
                      const r = e.getTile(b);
                      if (p && !r.patternsLoaded()) continue;
                      const n = r.getBucket(i);
                      if (!n) continue;
                      const s = n.programConfigurations.get(i.id),
                        o = t.context.program.get(),
                        w = t.useProgram(g, s),
                        T = x || w.program !== o,
                        P =
                          t.style.map.terrain &&
                          t.style.map.terrain.getTerrainData(b),
                        C = d.constantOr(null),
                        I = h && h.constantOr(null);
                      if (C && r.imageAtlas) {
                        const t = r.imageAtlas,
                          e = t.patternPositions[C.to.toString()],
                          i = t.patternPositions[C.from.toString()];
                        e && i && s.setConstantPatternPositions(e, i);
                      } else if (I) {
                        const e = 'round' === i.layout.get('line-cap'),
                          r = t.lineAtlas.getDash(I.to, e),
                          n = t.lineAtlas.getDash(I.from, e);
                        s.setConstantDashPositions(r, n);
                      }
                      const S = v.getProjectionData({
                          overscaledTileID: b,
                          applyGlobeMatrix: !a,
                          applyTerrainMatrix: !0,
                        }),
                        M = v.getPixelScale();
                      let D;
                      p
                        ? ((D = tr(t, r, i, M, m)), _n(_, y, r, s, m))
                        : u && f
                        ? ((D = ir(t, r, i, M, m, n.lineClipsArray.length)),
                          xn(t, e, _, y, i, n, b, s, m))
                        : u
                        ? ((D = er(t, r, i, M, m)), yn(t, _, y, s, T, m))
                        : f
                        ? ((D = Qi(t, r, i, M, n.lineClipsArray.length)),
                          vn(t, e, _, y, i, n, b))
                        : (D = Ji(t, r, i, M));
                      const L = t.stencilModeForClipping(b);
                      w.draw(
                        _,
                        y.TRIANGLES,
                        l,
                        L,
                        c,
                        We.disabled,
                        D,
                        P,
                        S,
                        i.id,
                        n.layoutVertexBuffer,
                        n.indexBuffer,
                        n.segments,
                        i.paint,
                        t.transform.zoom,
                        s,
                        n.layoutVertexBuffer2
                      ),
                        (x = !1);
                    }
                  })(t, i, r, n, a)
                : e.cj(r)
                ? (function (t, i, r, n, a) {
                    const s = r.paint.get('fill-color'),
                      o = r.paint.get('fill-opacity');
                    if (0 === o.constantOr(1)) return;
                    const { isRenderingToTexture: l } = a,
                      c = t.colorModeForRenderPass(),
                      h = r.paint.get('fill-pattern'),
                      u =
                        t.opaquePassEnabledForLayer() &&
                        !h.constantOr(1) &&
                        1 === s.constantOr(e.bi.transparent).a &&
                        1 === o.constantOr(0)
                          ? 'opaque'
                          : 'translucent';
                    if (t.renderPass === u) {
                      const e = t.getDepthModeForSublayer(
                        1,
                        'opaque' === t.renderPass ? Xe.ReadWrite : Xe.ReadOnly
                      );
                      wn(t, i, r, n, e, c, !1, l);
                    }
                    if (
                      'translucent' === t.renderPass &&
                      r.paint.get('fill-antialias')
                    ) {
                      const e = t.getDepthModeForSublayer(
                        r.getPaintProperty('fill-outline-color') ? 2 : 0,
                        Xe.ReadOnly
                      );
                      wn(t, i, r, n, e, c, !0, l);
                    }
                  })(t, i, r, n, a)
                : e.ck(r)
                ? (function (t, e, i, r, n) {
                    const a = i.paint.get('fill-extrusion-opacity');
                    if (0 === a) return;
                    const { isRenderingToTexture: s } = n;
                    if ('translucent' === t.renderPass) {
                      const n = new Xe(
                        t.context.gl.LEQUAL,
                        Xe.ReadWrite,
                        t.depthRangeFor3D
                      );
                      if (
                        1 !== a ||
                        i.paint.get('fill-extrusion-pattern').constantOr(1)
                      )
                        Tn(t, e, i, r, n, Ke.disabled, qe.disabled, s),
                          Tn(
                            t,
                            e,
                            i,
                            r,
                            n,
                            t.stencilModeFor3D(),
                            t.colorModeForRenderPass(),
                            s
                          );
                      else {
                        const a = t.colorModeForRenderPass();
                        Tn(t, e, i, r, n, Ke.disabled, a, s);
                      }
                    }
                  })(t, i, r, n, a)
                : e.cl(r)
                ? (function (t, i, r, n, a) {
                    if (
                      'offscreen' !== t.renderPass &&
                      'translucent' !== t.renderPass
                    )
                      return;
                    const { isRenderingToTexture: s } = a,
                      o = t.context,
                      l = t.style.projection.useSubdivision,
                      c = t.getDepthModeForSublayer(0, Xe.ReadOnly),
                      h = t.colorModeForRenderPass();
                    if ('offscreen' === t.renderPass)
                      !(function (t, i, r, n, a, s, o) {
                        const l = t.context,
                          c = l.gl;
                        for (const h of r) {
                          const r = i.getTile(h),
                            u = r.dem;
                          if (!u || !u.data) continue;
                          if (!r.needsHillshadePrepare) continue;
                          const d = u.dim,
                            p = u.stride,
                            f = u.getPixels();
                          if (
                            (l.activeTexture.set(c.TEXTURE1),
                            l.pixelStoreUnpackPremultiplyAlpha.set(!1),
                            (r.demTexture =
                              r.demTexture || t.getTileTexture(p)),
                            r.demTexture)
                          ) {
                            const t = r.demTexture;
                            t.update(f, { premultiply: !1 }),
                              t.bind(c.NEAREST, c.CLAMP_TO_EDGE);
                          } else
                            (r.demTexture = new e.T(l, f, c.RGBA, {
                              premultiply: !1,
                            })),
                              r.demTexture.bind(c.NEAREST, c.CLAMP_TO_EDGE);
                          l.activeTexture.set(c.TEXTURE0);
                          let m = r.fbo;
                          if (!m) {
                            const t = new e.T(
                              l,
                              { width: d, height: d, data: null },
                              c.RGBA
                            );
                            t.bind(c.LINEAR, c.CLAMP_TO_EDGE),
                              (m = r.fbo = l.createFramebuffer(d, d, !0, !1)),
                              m.colorAttachment.set(t.texture);
                          }
                          l.bindFramebuffer.set(m.framebuffer),
                            l.viewport.set([0, 0, d, d]),
                            t
                              .useProgram('hillshadePrepare')
                              .draw(
                                l,
                                c.TRIANGLES,
                                a,
                                s,
                                o,
                                We.disabled,
                                Xi(r.tileID, u),
                                null,
                                null,
                                n.id,
                                t.rasterBoundsBuffer,
                                t.quadTriangleIndexBuffer,
                                t.rasterBoundsSegments
                              ),
                            (r.needsHillshadePrepare = !1);
                        }
                      })(t, i, n, r, c, Ke.disabled, h),
                        o.viewport.set([0, 0, t.width, t.height]);
                    else if ('translucent' === t.renderPass)
                      if (l) {
                        const [e, a, o] = t.stencilConfigForOverlapTwoPass(n);
                        Pn(t, i, r, o, e, c, h, !1, s),
                          Pn(t, i, r, o, a, c, h, !0, s);
                      } else {
                        const [e, a] =
                          t.getStencilConfigForOverlapAndUpdateStencilID(n);
                        Pn(t, i, r, a, e, c, h, !1, s);
                      }
                  })(t, i, r, n, a)
                : e.cm(r)
                ? (function (t, e, i, r, n) {
                    if ('translucent' !== t.renderPass) return;
                    if (!r.length) return;
                    const { isRenderingToTexture: a } = n,
                      s = t.style.projection.useSubdivision,
                      o = t.getDepthModeForSublayer(0, Xe.ReadOnly),
                      l = t.colorModeForRenderPass();
                    if (s) {
                      const [n, s, c] = t.stencilConfigForOverlapTwoPass(r);
                      Cn(t, e, i, c, n, o, l, !1, a),
                        Cn(t, e, i, c, s, o, l, !0, a);
                    } else {
                      const [n, s] =
                        t.getStencilConfigForOverlapAndUpdateStencilID(r);
                      Cn(t, e, i, s, n, o, l, !1, a);
                    }
                  })(t, i, r, n, a)
                : e.bN(r)
                ? (function (t, e, i, r, n) {
                    if ('translucent' !== t.renderPass) return;
                    if (0 === i.paint.get('raster-opacity')) return;
                    if (!r.length) return;
                    const { isRenderingToTexture: a } = n,
                      s = e.getSource(),
                      o = t.style.projection.useSubdivision;
                    if (s instanceof tt)
                      Sn(
                        t,
                        e,
                        i,
                        r,
                        null,
                        !1,
                        !1,
                        s.tileCoords,
                        s.flippedWindingOrder,
                        a
                      );
                    else if (o) {
                      const [n, s, o] = t.stencilConfigForOverlapTwoPass(r);
                      Sn(t, e, i, o, n, !1, !0, In, !1, a),
                        Sn(t, e, i, o, s, !0, !0, In, !1, a);
                    } else {
                      const [n, s] =
                        t.getStencilConfigForOverlapAndUpdateStencilID(r);
                      Sn(t, e, i, s, n, !1, !0, In, !1, a);
                    }
                  })(t, i, r, n, a)
                : e.cn(r)
                ? (function (t, e, i, r, n) {
                    const a = i.paint.get('background-color'),
                      s = i.paint.get('background-opacity');
                    if (0 === s) return;
                    const { isRenderingToTexture: o } = n,
                      l = t.context,
                      c = l.gl,
                      h = t.style.projection,
                      u = t.transform,
                      d = u.tileSize,
                      p = i.paint.get('background-pattern');
                    if (t.isPatternMissing(p)) return;
                    const f =
                      !p &&
                      1 === a.a &&
                      1 === s &&
                      t.opaquePassEnabledForLayer()
                        ? 'opaque'
                        : 'translucent';
                    if (t.renderPass !== f) return;
                    const m = Ke.disabled,
                      g = t.getDepthModeForSublayer(
                        0,
                        'opaque' === f ? Xe.ReadWrite : Xe.ReadOnly
                      ),
                      _ = t.colorModeForRenderPass(),
                      y = t.useProgram(p ? 'backgroundPattern' : 'background'),
                      v =
                        r ||
                        Ct(u, { tileSize: d, terrain: t.style.map.terrain });
                    p &&
                      (l.activeTexture.set(c.TEXTURE0),
                      t.imageManager.bind(t.context));
                    const x = i.getCrossfadeParameters();
                    for (const b of v) {
                      const e = u.getProjectionData({
                          overscaledTileID: b,
                          applyGlobeMatrix: !o,
                          applyTerrainMatrix: !0,
                        }),
                        r = p
                          ? ur(s, t, p, { tileID: b, tileSize: d }, x)
                          : hr(s, a),
                        n =
                          t.style.map.terrain &&
                          t.style.map.terrain.getTerrainData(b),
                        f = h.getMeshFromTileID(
                          l,
                          b.canonical,
                          !1,
                          !0,
                          'raster'
                        );
                      y.draw(
                        l,
                        c.TRIANGLES,
                        g,
                        m,
                        _,
                        We.backCCW,
                        r,
                        n,
                        e,
                        i.id,
                        f.vertexBuffer,
                        f.indexBuffer,
                        f.segments
                      );
                    }
                  })(t, 0, r, n, a)
                : e.co(r) &&
                  (function (t, e, i, r) {
                    const { isRenderingGlobe: n } = r,
                      a = t.context,
                      s = i.implementation,
                      o = t.style.projection,
                      l = t.transform,
                      c = l.getProjectionDataForCustomLayer(n),
                      h = {
                        farZ: l.farZ,
                        nearZ: l.nearZ,
                        fov: (l.fov * Math.PI) / 180,
                        modelViewProjectionMatrix: l.modelViewProjectionMatrix,
                        projectionMatrix: l.projectionMatrix,
                        shaderData: {
                          variantName: o.shaderVariantName,
                          vertexShaderPrelude: `const float PI = 3.141592653589793;\nuniform mat4 u_projection_matrix;\n${o.shaderPreludeCode.vertexSource}`,
                          define: o.shaderDefine,
                        },
                        defaultProjectionData: c,
                      },
                      u = s.renderingMode ? s.renderingMode : '2d';
                    if ('offscreen' === t.renderPass) {
                      const e = s.prerender;
                      e &&
                        (t.setCustomLayerDefaults(),
                        a.setColorMode(t.colorModeForRenderPass()),
                        e.call(s, a.gl, h),
                        a.setDirty(),
                        t.setBaseState());
                    } else if ('translucent' === t.renderPass) {
                      t.setCustomLayerDefaults(),
                        a.setColorMode(t.colorModeForRenderPass()),
                        a.setStencilMode(Ke.disabled);
                      const e =
                        '3d' === u
                          ? t.getDepthModeFor3D()
                          : t.getDepthModeForSublayer(0, Xe.ReadOnly);
                      a.setDepthMode(e),
                        s.render(a.gl, h),
                        a.setDirty(),
                        t.setBaseState(),
                        a.bindFramebuffer.set(null);
                    }
                  })(t, 0, r, a)));
        }
        saveTileTexture(t) {
          const e = this._tileTextures[t.size[0]];
          e ? e.push(t) : (this._tileTextures[t.size[0]] = [t]);
        }
        getTileTexture(t) {
          const e = this._tileTextures[t];
          return e && e.length > 0 ? e.pop() : null;
        }
        isPatternMissing(t) {
          if (!t) return !1;
          if (!t.from || !t.to) return !0;
          const e = this.imageManager.getPattern(t.from.toString()),
            i = this.imageManager.getPattern(t.to.toString());
          return !e || !i;
        }
        useProgram(t, e, i = !1, r = []) {
          this.cache = this.cache || {};
          const n = !!this.style.map.terrain,
            a = this.style.projection,
            s = i ? Se.projectionMercator : a.shaderPreludeCode,
            o = i ? Ae : a.shaderDefine,
            l =
              t +
              (e ? e.cacheKey : '') +
              `/${i ? Ee : a.shaderVariantName}` +
              (this._showOverdrawInspector ? '/overdraw' : '') +
              (n ? '/terrain' : '') +
              (r ? `/${r.join('/')}` : '');
          return (
            this.cache[l] ||
              (this.cache[l] = new ki(
                this.context,
                Se[t],
                e,
                pr[t],
                this._showOverdrawInspector,
                n,
                s,
                o,
                r
              )),
            this.cache[l]
          );
        }
        setCustomLayerDefaults() {
          this.context.unbindVAO(),
            this.context.cullFace.setDefault(),
            this.context.activeTexture.setDefault(),
            this.context.pixelStoreUnpack.setDefault(),
            this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(),
            this.context.pixelStoreUnpackFlipY.setDefault();
        }
        setBaseState() {
          const t = this.context.gl;
          this.context.cullFace.set(!1),
            this.context.viewport.set([0, 0, this.width, this.height]),
            this.context.blendEquation.set(t.FUNC_ADD);
        }
        initDebugOverlayCanvas() {
          null == this.debugOverlayCanvas &&
            ((this.debugOverlayCanvas = document.createElement('canvas')),
            (this.debugOverlayCanvas.width = 512),
            (this.debugOverlayCanvas.height = 512),
            (this.debugOverlayTexture = new e.T(
              this.context,
              this.debugOverlayCanvas,
              this.context.gl.RGBA
            )));
        }
        destroy() {
          this.debugOverlayTexture && this.debugOverlayTexture.destroy();
        }
        overLimit() {
          const { drawingBufferWidth: t, drawingBufferHeight: e } =
            this.context.gl;
          return this.width !== t || this.height !== e;
        }
      }
      function jn(t, e) {
        let i,
          r = !1,
          n = null,
          a = null;
        const s = () => {
          (n = null), r && (t.apply(a, i), (n = setTimeout(s, e)), (r = !1));
        };
        return (...t) => ((r = !0), (a = this), (i = t), n || s(), n);
      }
      class Un {
        constructor(t) {
          (this._getCurrentHash = () => {
            const t = window.location.hash.replace('#', '');
            if (this._hashName) {
              let e;
              return (
                t
                  .split('&')
                  .map((t) => t.split('='))
                  .forEach((t) => {
                    t[0] === this._hashName && (e = t);
                  }),
                ((e && e[1]) || '').split('/')
              );
            }
            return t.split('/');
          }),
            (this._onHashChange = () => {
              const t = this._getCurrentHash();
              if (!this._isValidHash(t)) return !1;
              const e =
                this._map.dragRotate.isEnabled() &&
                this._map.touchZoomRotate.isEnabled()
                  ? +(t[3] || 0)
                  : this._map.getBearing();
              return (
                this._map.jumpTo({
                  center: [+t[2], +t[1]],
                  zoom: +t[0],
                  bearing: e,
                  pitch: +(t[4] || 0),
                }),
                !0
              );
            }),
            (this._updateHashUnthrottled = () => {
              const t = window.location.href.replace(
                /(#.*)?$/,
                this.getHashString()
              );
              window.history.replaceState(window.history.state, null, t);
            }),
            (this._removeHash = () => {
              const t = this._getCurrentHash();
              if (0 === t.length) return;
              const e = t.join('/');
              let i = e;
              i.split('&').length > 0 && (i = i.split('&')[0]),
                this._hashName && (i = `${this._hashName}=${e}`);
              let r = window.location.hash.replace(i, '');
              r.startsWith('#&')
                ? (r = r.slice(0, 1) + r.slice(2))
                : '#' === r && (r = '');
              let n = window.location.href.replace(/(#.+)?$/, r);
              (n = n.replace('&&', '&')),
                window.history.replaceState(window.history.state, null, n);
            }),
            (this._updateHash = jn(this._updateHashUnthrottled, 300)),
            (this._hashName = t && encodeURIComponent(t));
        }
        addTo(t) {
          return (
            (this._map = t),
            addEventListener('hashchange', this._onHashChange, !1),
            this._map.on('moveend', this._updateHash),
            this
          );
        }
        remove() {
          return (
            removeEventListener('hashchange', this._onHashChange, !1),
            this._map.off('moveend', this._updateHash),
            clearTimeout(this._updateHash()),
            this._removeHash(),
            delete this._map,
            this
          );
        }
        getHashString(t) {
          const e = this._map.getCenter(),
            i = Math.round(100 * this._map.getZoom()) / 100,
            r = Math.ceil(
              (i * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10
            ),
            n = Math.pow(10, r),
            a = Math.round(e.lng * n) / n,
            s = Math.round(e.lat * n) / n,
            o = this._map.getBearing(),
            l = this._map.getPitch();
          let c = '';
          if (
            ((c += t ? `/${a}/${s}/${i}` : `${i}/${s}/${a}`),
            (o || l) && (c += '/' + Math.round(10 * o) / 10),
            l && (c += `/${Math.round(l)}`),
            this._hashName)
          ) {
            const t = this._hashName;
            let e = !1;
            const i = window.location.hash
              .slice(1)
              .split('&')
              .map((i) => {
                const r = i.split('=')[0];
                return r === t ? ((e = !0), `${r}=${c}`) : i;
              })
              .filter((t) => t);
            return e || i.push(`${t}=${c}`), `#${i.join('&')}`;
          }
          return `#${c}`;
        }
        _isValidHash(t) {
          if (t.length < 3 || t.some(isNaN)) return !1;
          try {
            new e.U(+t[2], +t[1]);
          } catch (t) {
            return !1;
          }
          const i = +t[0],
            r = +(t[3] || 0),
            n = +(t[4] || 0);
          return (
            i >= this._map.getMinZoom() &&
            i <= this._map.getMaxZoom() &&
            r >= -180 &&
            r <= 180 &&
            n >= this._map.getMinPitch() &&
            n <= this._map.getMaxPitch()
          );
        }
      }
      const Gn = { linearity: 0.3, easing: e.cp(0, 0, 0.3, 1) },
        Zn = e.e({ deceleration: 2500, maxSpeed: 1400 }, Gn),
        $n = e.e({ deceleration: 20, maxSpeed: 1400 }, Gn),
        qn = e.e({ deceleration: 1e3, maxSpeed: 360 }, Gn),
        Hn = e.e({ deceleration: 1e3, maxSpeed: 90 }, Gn),
        Wn = e.e({ deceleration: 1e3, maxSpeed: 360 }, Gn);
      class Xn {
        constructor(t) {
          (this._map = t), this.clear();
        }
        clear() {
          this._inertiaBuffer = [];
        }
        record(t) {
          this._drainInertiaBuffer(),
            this._inertiaBuffer.push({ time: l(), settings: t });
        }
        _drainInertiaBuffer() {
          const t = this._inertiaBuffer,
            e = l();
          for (; t.length > 0 && e - t[0].time > 160; ) t.shift();
        }
        _onMoveEnd(t) {
          if ((this._drainInertiaBuffer(), this._inertiaBuffer.length < 2))
            return;
          const i = {
            zoom: 0,
            bearing: 0,
            pitch: 0,
            roll: 0,
            pan: new e.P(0, 0),
            pinchAround: void 0,
            around: void 0,
          };
          for (const { settings: e } of this._inertiaBuffer)
            (i.zoom += e.zoomDelta || 0),
              (i.bearing += e.bearingDelta || 0),
              (i.pitch += e.pitchDelta || 0),
              (i.roll += e.rollDelta || 0),
              e.panDelta && i.pan._add(e.panDelta),
              e.around && (i.around = e.around),
              e.pinchAround && (i.pinchAround = e.pinchAround);
          const r =
              this._inertiaBuffer[this._inertiaBuffer.length - 1].time -
              this._inertiaBuffer[0].time,
            n = {};
          if (i.pan.mag()) {
            const a = Kn(i.pan.mag(), r, e.e({}, Zn, t || {})),
              s = i.pan.mult(a.amount / i.pan.mag()),
              o = this._map.cameraHelper.handlePanInertia(
                s,
                this._map.transform
              );
            (n.center = o.easingCenter), (n.offset = o.easingOffset), Yn(n, a);
          }
          if (i.zoom) {
            const t = Kn(i.zoom, r, $n);
            (n.zoom = this._map.transform.zoom + t.amount), Yn(n, t);
          }
          if (i.bearing) {
            const t = Kn(i.bearing, r, qn);
            (n.bearing =
              this._map.transform.bearing + e.ai(t.amount, -179, 179)),
              Yn(n, t);
          }
          if (i.pitch) {
            const t = Kn(i.pitch, r, Hn);
            (n.pitch = this._map.transform.pitch + t.amount), Yn(n, t);
          }
          if (i.roll) {
            const t = Kn(i.roll, r, Wn);
            (n.roll = this._map.transform.roll + e.ai(t.amount, -179, 179)),
              Yn(n, t);
          }
          if (n.zoom || n.bearing) {
            const t = void 0 === i.pinchAround ? i.around : i.pinchAround;
            n.around = t ? this._map.unproject(t) : this._map.getCenter();
          }
          return this.clear(), e.e(n, { noMoveStart: !0 });
        }
      }
      function Yn(t, e) {
        (!t.duration || t.duration < e.duration) &&
          ((t.duration = e.duration), (t.easing = e.easing));
      }
      function Kn(t, i, r) {
        const { maxSpeed: n, linearity: a, deceleration: s } = r,
          o = e.ai((t * a) / (i / 1e3), -n, n),
          l = Math.abs(o) / (s * a);
        return { easing: r.easing, duration: 1e3 * l, amount: o * (l / 2) };
      }
      class Jn extends e.l {
        preventDefault() {
          this._defaultPrevented = !0;
        }
        get defaultPrevented() {
          return this._defaultPrevented;
        }
        constructor(t, i, r, n = {}) {
          r = r instanceof MouseEvent ? r : new MouseEvent(t, r);
          const a = c.mousePos(i.getCanvas(), r),
            s = i.unproject(a);
          super(t, e.e({ point: a, lngLat: s, originalEvent: r }, n)),
            (this._defaultPrevented = !1),
            (this.target = i);
        }
      }
      class Qn extends e.l {
        preventDefault() {
          this._defaultPrevented = !0;
        }
        get defaultPrevented() {
          return this._defaultPrevented;
        }
        constructor(t, i, r) {
          const n = 'touchend' === t ? r.changedTouches : r.touches,
            a = c.touchPos(i.getCanvasContainer(), n),
            s = a.map((t) => i.unproject(t)),
            o = a.reduce((t, e, i, r) => t.add(e.div(r.length)), new e.P(0, 0));
          super(t, {
            points: a,
            point: o,
            lngLats: s,
            lngLat: i.unproject(o),
            originalEvent: r,
          }),
            (this._defaultPrevented = !1);
        }
      }
      class ta extends e.l {
        preventDefault() {
          this._defaultPrevented = !0;
        }
        get defaultPrevented() {
          return this._defaultPrevented;
        }
        constructor(t, e, i) {
          super(t, { originalEvent: i }), (this._defaultPrevented = !1);
        }
      }
      class ea {
        constructor(t, e) {
          (this._map = t), (this._clickTolerance = e.clickTolerance);
        }
        reset() {
          delete this._mousedownPos;
        }
        wheel(t) {
          return this._firePreventable(new ta(t.type, this._map, t));
        }
        mousedown(t, e) {
          return (
            (this._mousedownPos = e),
            this._firePreventable(new Jn(t.type, this._map, t))
          );
        }
        mouseup(t) {
          this._map.fire(new Jn(t.type, this._map, t));
        }
        click(t, e) {
          (this._mousedownPos &&
            this._mousedownPos.dist(e) >= this._clickTolerance) ||
            this._map.fire(new Jn(t.type, this._map, t));
        }
        dblclick(t) {
          return this._firePreventable(new Jn(t.type, this._map, t));
        }
        mouseover(t) {
          this._map.fire(new Jn(t.type, this._map, t));
        }
        mouseout(t) {
          this._map.fire(new Jn(t.type, this._map, t));
        }
        touchstart(t) {
          return this._firePreventable(new Qn(t.type, this._map, t));
        }
        touchmove(t) {
          this._map.fire(new Qn(t.type, this._map, t));
        }
        touchend(t) {
          this._map.fire(new Qn(t.type, this._map, t));
        }
        touchcancel(t) {
          this._map.fire(new Qn(t.type, this._map, t));
        }
        _firePreventable(t) {
          if ((this._map.fire(t), t.defaultPrevented)) return {};
        }
        isEnabled() {
          return !0;
        }
        isActive() {
          return !1;
        }
        enable() {}
        disable() {}
      }
      class ia {
        constructor(t) {
          this._map = t;
        }
        reset() {
          (this._delayContextMenu = !1),
            (this._ignoreContextMenu = !0),
            delete this._contextMenuEvent;
        }
        mousemove(t) {
          this._map.fire(new Jn(t.type, this._map, t));
        }
        mousedown() {
          (this._delayContextMenu = !0), (this._ignoreContextMenu = !1);
        }
        mouseup() {
          (this._delayContextMenu = !1),
            this._contextMenuEvent &&
              (this._map.fire(
                new Jn('contextmenu', this._map, this._contextMenuEvent)
              ),
              delete this._contextMenuEvent);
        }
        contextmenu(t) {
          this._delayContextMenu
            ? (this._contextMenuEvent = t)
            : this._ignoreContextMenu ||
              this._map.fire(new Jn(t.type, this._map, t)),
            this._map.listens('contextmenu') && t.preventDefault();
        }
        isEnabled() {
          return !0;
        }
        isActive() {
          return !1;
        }
        enable() {}
        disable() {}
      }
      class ra {
        constructor(t) {
          this._map = t;
        }
        get transform() {
          return this._map._requestedCameraState || this._map.transform;
        }
        get center() {
          return {
            lng: this.transform.center.lng,
            lat: this.transform.center.lat,
          };
        }
        get zoom() {
          return this.transform.zoom;
        }
        get pitch() {
          return this.transform.pitch;
        }
        get bearing() {
          return this.transform.bearing;
        }
        unproject(t) {
          return this.transform.screenPointToLocation(
            e.P.convert(t),
            this._map.terrain
          );
        }
      }
      class na {
        constructor(t, e) {
          (this._map = t),
            (this._tr = new ra(t)),
            (this._el = t.getCanvasContainer()),
            (this._container = t.getContainer()),
            (this._clickTolerance = e.clickTolerance || 1);
        }
        isEnabled() {
          return !!this._enabled;
        }
        isActive() {
          return !!this._active;
        }
        enable() {
          this.isEnabled() || (this._enabled = !0);
        }
        disable() {
          this.isEnabled() && (this._enabled = !1);
        }
        mousedown(t, e) {
          this.isEnabled() &&
            t.shiftKey &&
            0 === t.button &&
            (c.disableDrag(),
            (this._startPos = this._lastPos = e),
            (this._active = !0));
        }
        mousemoveWindow(t, e) {
          if (!this._active) return;
          const i = e;
          if (
            this._lastPos.equals(i) ||
            (!this._box && i.dist(this._startPos) < this._clickTolerance)
          )
            return;
          const r = this._startPos;
          (this._lastPos = i),
            this._box ||
              ((this._box = c.create(
                'div',
                'maplibregl-boxzoom',
                this._container
              )),
              this._container.classList.add('maplibregl-crosshair'),
              this._fireEvent('boxzoomstart', t));
          const n = Math.min(r.x, i.x),
            a = Math.max(r.x, i.x),
            s = Math.min(r.y, i.y),
            o = Math.max(r.y, i.y);
          c.setTransform(this._box, `translate(${n}px,${s}px)`),
            (this._box.style.width = a - n + 'px'),
            (this._box.style.height = o - s + 'px');
        }
        mouseupWindow(t, i) {
          if (!this._active) return;
          if (0 !== t.button) return;
          const r = this._startPos,
            n = i;
          if ((this.reset(), c.suppressClick(), r.x !== n.x || r.y !== n.y))
            return (
              this._map.fire(new e.l('boxzoomend', { originalEvent: t })),
              {
                cameraAnimation: (t) =>
                  t.fitScreenCoordinates(r, n, this._tr.bearing, {
                    linear: !0,
                  }),
              }
            );
          this._fireEvent('boxzoomcancel', t);
        }
        keydown(t) {
          this._active &&
            27 === t.keyCode &&
            (this.reset(), this._fireEvent('boxzoomcancel', t));
        }
        reset() {
          (this._active = !1),
            this._container.classList.remove('maplibregl-crosshair'),
            this._box && (c.remove(this._box), (this._box = null)),
            c.enableDrag(),
            delete this._startPos,
            delete this._lastPos;
        }
        _fireEvent(t, i) {
          return this._map.fire(new e.l(t, { originalEvent: i }));
        }
      }
      function aa(t, e) {
        if (t.length !== e.length)
          throw new Error(
            `The number of touches and points are not equal - touches ${t.length}, points ${e.length}`
          );
        const i = {};
        for (let r = 0; r < t.length; r++) i[t[r].identifier] = e[r];
        return i;
      }
      class sa {
        constructor(t) {
          this.reset(), (this.numTouches = t.numTouches);
        }
        reset() {
          delete this.centroid,
            delete this.startTime,
            delete this.touches,
            (this.aborted = !1);
        }
        touchstart(t, i, r) {
          (this.centroid || r.length > this.numTouches) && (this.aborted = !0),
            this.aborted ||
              (void 0 === this.startTime && (this.startTime = t.timeStamp),
              r.length === this.numTouches &&
                ((this.centroid = (function (t) {
                  const i = new e.P(0, 0);
                  for (const e of t) i._add(e);
                  return i.div(t.length);
                })(i)),
                (this.touches = aa(r, i))));
        }
        touchmove(t, e, i) {
          if (this.aborted || !this.centroid) return;
          const r = aa(i, e);
          for (const n in this.touches) {
            const t = r[n];
            (!t || t.dist(this.touches[n]) > 30) && (this.aborted = !0);
          }
        }
        touchend(t, e, i) {
          if (
            ((!this.centroid || t.timeStamp - this.startTime > 500) &&
              (this.aborted = !0),
            0 === i.length)
          ) {
            const t = !this.aborted && this.centroid;
            if ((this.reset(), t)) return t;
          }
        }
      }
      class oa {
        constructor(t) {
          (this.singleTap = new sa(t)),
            (this.numTaps = t.numTaps),
            this.reset();
        }
        reset() {
          (this.lastTime = 1 / 0),
            delete this.lastTap,
            (this.count = 0),
            this.singleTap.reset();
        }
        touchstart(t, e, i) {
          this.singleTap.touchstart(t, e, i);
        }
        touchmove(t, e, i) {
          this.singleTap.touchmove(t, e, i);
        }
        touchend(t, e, i) {
          const r = this.singleTap.touchend(t, e, i);
          if (r) {
            const e = t.timeStamp - this.lastTime < 500,
              i = !this.lastTap || this.lastTap.dist(r) < 30;
            if (
              ((e && i) || this.reset(),
              this.count++,
              (this.lastTime = t.timeStamp),
              (this.lastTap = r),
              this.count === this.numTaps)
            )
              return this.reset(), r;
          }
        }
      }
      class la {
        constructor(t) {
          (this._tr = new ra(t)),
            (this._zoomIn = new oa({ numTouches: 1, numTaps: 2 })),
            (this._zoomOut = new oa({ numTouches: 2, numTaps: 1 })),
            this.reset();
        }
        reset() {
          (this._active = !1), this._zoomIn.reset(), this._zoomOut.reset();
        }
        touchstart(t, e, i) {
          this._zoomIn.touchstart(t, e, i), this._zoomOut.touchstart(t, e, i);
        }
        touchmove(t, e, i) {
          this._zoomIn.touchmove(t, e, i), this._zoomOut.touchmove(t, e, i);
        }
        touchend(t, e, i) {
          const r = this._zoomIn.touchend(t, e, i),
            n = this._zoomOut.touchend(t, e, i),
            a = this._tr;
          return r
            ? ((this._active = !0),
              t.preventDefault(),
              setTimeout(() => this.reset(), 0),
              {
                cameraAnimation: (e) =>
                  e.easeTo(
                    { duration: 300, zoom: a.zoom + 1, around: a.unproject(r) },
                    { originalEvent: t }
                  ),
              })
            : n
            ? ((this._active = !0),
              t.preventDefault(),
              setTimeout(() => this.reset(), 0),
              {
                cameraAnimation: (e) =>
                  e.easeTo(
                    { duration: 300, zoom: a.zoom - 1, around: a.unproject(n) },
                    { originalEvent: t }
                  ),
              })
            : void 0;
        }
        touchcancel() {
          this.reset();
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          (this._enabled = !1), this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class ca {
        constructor(t) {
          (this._enabled = !!t.enable),
            (this._moveStateManager = t.moveStateManager),
            (this._clickTolerance = t.clickTolerance || 1),
            (this._moveFunction = t.move),
            (this._activateOnStart = !!t.activateOnStart),
            t.assignEvents(this),
            this.reset();
        }
        reset(t) {
          (this._active = !1),
            (this._moved = !1),
            delete this._lastPoint,
            this._moveStateManager.endMove(t);
        }
        _move(...t) {
          const e = this._moveFunction(...t);
          if (
            e.bearingDelta ||
            e.pitchDelta ||
            e.rollDelta ||
            e.around ||
            e.panDelta
          )
            return (this._active = !0), e;
        }
        dragStart(t, e) {
          this.isEnabled() &&
            !this._lastPoint &&
            this._moveStateManager.isValidStartEvent(t) &&
            (this._moveStateManager.startMove(t),
            (this._lastPoint = Array.isArray(e) ? e[0] : e),
            this._activateOnStart && this._lastPoint && (this._active = !0));
        }
        dragMove(t, e) {
          if (!this.isEnabled()) return;
          const i = this._lastPoint;
          if (!i) return;
          if ((t.preventDefault(), !this._moveStateManager.isValidMoveEvent(t)))
            return void this.reset(t);
          const r = Array.isArray(e) ? e[0] : e;
          return !this._moved && r.dist(i) < this._clickTolerance
            ? void 0
            : ((this._moved = !0), (this._lastPoint = r), this._move(i, r));
        }
        dragEnd(t) {
          this.isEnabled() &&
            this._lastPoint &&
            this._moveStateManager.isValidEndEvent(t) &&
            (this._moved && c.suppressClick(), this.reset(t));
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          (this._enabled = !1), this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
        getClickTolerance() {
          return this._clickTolerance;
        }
      }
      const ha = { 0: 1, 2: 2 };
      class ua {
        constructor(t) {
          this._correctEvent = t.checkCorrectEvent;
        }
        startMove(t) {
          const e = c.mouseButton(t);
          this._eventButton = e;
        }
        endMove(t) {
          delete this._eventButton;
        }
        isValidStartEvent(t) {
          return this._correctEvent(t);
        }
        isValidMoveEvent(t) {
          return !(function (t, e) {
            const i = ha[e];
            return void 0 === t.buttons || (t.buttons & i) !== i;
          })(t, this._eventButton);
        }
        isValidEndEvent(t) {
          return c.mouseButton(t) === this._eventButton;
        }
      }
      class da {
        constructor() {
          this._firstTouch = void 0;
        }
        _isOneFingerTouch(t) {
          return 1 === t.targetTouches.length;
        }
        _isSameTouchEvent(t) {
          return t.targetTouches[0].identifier === this._firstTouch;
        }
        startMove(t) {
          this._firstTouch = t.targetTouches[0].identifier;
        }
        endMove(t) {
          delete this._firstTouch;
        }
        isValidStartEvent(t) {
          return this._isOneFingerTouch(t);
        }
        isValidMoveEvent(t) {
          return this._isOneFingerTouch(t) && this._isSameTouchEvent(t);
        }
        isValidEndEvent(t) {
          return this._isOneFingerTouch(t) && this._isSameTouchEvent(t);
        }
      }
      class pa {
        constructor(t = new ua({ checkCorrectEvent: () => !0 }), e = new da()) {
          (this.mouseMoveStateManager = t),
            (this.oneFingerTouchMoveStateManager = e);
        }
        _executeRelevantHandler(t, e, i) {
          return t instanceof MouseEvent
            ? e(t)
            : 'undefined' != typeof TouchEvent && t instanceof TouchEvent
            ? i(t)
            : void 0;
        }
        startMove(t) {
          this._executeRelevantHandler(
            t,
            (t) => this.mouseMoveStateManager.startMove(t),
            (t) => this.oneFingerTouchMoveStateManager.startMove(t)
          );
        }
        endMove(t) {
          this._executeRelevantHandler(
            t,
            (t) => this.mouseMoveStateManager.endMove(t),
            (t) => this.oneFingerTouchMoveStateManager.endMove(t)
          );
        }
        isValidStartEvent(t) {
          return this._executeRelevantHandler(
            t,
            (t) => this.mouseMoveStateManager.isValidStartEvent(t),
            (t) => this.oneFingerTouchMoveStateManager.isValidStartEvent(t)
          );
        }
        isValidMoveEvent(t) {
          return this._executeRelevantHandler(
            t,
            (t) => this.mouseMoveStateManager.isValidMoveEvent(t),
            (t) => this.oneFingerTouchMoveStateManager.isValidMoveEvent(t)
          );
        }
        isValidEndEvent(t) {
          return this._executeRelevantHandler(
            t,
            (t) => this.mouseMoveStateManager.isValidEndEvent(t),
            (t) => this.oneFingerTouchMoveStateManager.isValidEndEvent(t)
          );
        }
      }
      const fa = (t) => {
        (t.mousedown = t.dragStart),
          (t.mousemoveWindow = t.dragMove),
          (t.mouseup = t.dragEnd),
          (t.contextmenu = (t) => {
            t.preventDefault();
          });
      };
      class ma {
        constructor(t, e) {
          (this._clickTolerance = t.clickTolerance || 1),
            (this._map = e),
            this.reset();
        }
        reset() {
          (this._active = !1),
            (this._touches = {}),
            (this._sum = new e.P(0, 0));
        }
        _shouldBePrevented(t) {
          return t < (this._map.cooperativeGestures.isEnabled() ? 2 : 1);
        }
        touchstart(t, e, i) {
          return this._calculateTransform(t, e, i);
        }
        touchmove(t, e, i) {
          if (this._active) {
            if (!this._shouldBePrevented(i.length))
              return t.preventDefault(), this._calculateTransform(t, e, i);
            this._map.cooperativeGestures.notifyGestureBlocked('touch_pan', t);
          }
        }
        touchend(t, e, i) {
          this._calculateTransform(t, e, i),
            this._active && this._shouldBePrevented(i.length) && this.reset();
        }
        touchcancel() {
          this.reset();
        }
        _calculateTransform(t, i, r) {
          r.length > 0 && (this._active = !0);
          const n = aa(r, i),
            a = new e.P(0, 0),
            s = new e.P(0, 0);
          let o = 0;
          for (const e in n) {
            const t = n[e],
              i = this._touches[e];
            i && (a._add(t), s._add(t.sub(i)), o++, (n[e] = t));
          }
          if (((this._touches = n), this._shouldBePrevented(o) || !s.mag()))
            return;
          const l = s.div(o);
          return (
            this._sum._add(l),
            this._sum.mag() < this._clickTolerance
              ? void 0
              : { around: a.div(o), panDelta: l }
          );
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          (this._enabled = !1), this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class ga {
        constructor() {
          this.reset();
        }
        reset() {
          (this._active = !1), delete this._firstTwoTouches;
        }
        touchstart(t, e, i) {
          this._firstTwoTouches ||
            i.length < 2 ||
            ((this._firstTwoTouches = [i[0].identifier, i[1].identifier]),
            this._start([e[0], e[1]]));
        }
        touchmove(t, e, i) {
          if (!this._firstTwoTouches) return;
          t.preventDefault();
          const [r, n] = this._firstTwoTouches,
            a = _a(i, e, r),
            s = _a(i, e, n);
          if (!a || !s) return;
          const o = this._aroundCenter ? null : a.add(s).div(2);
          return this._move([a, s], o, t);
        }
        touchend(t, e, i) {
          if (!this._firstTwoTouches) return;
          const [r, n] = this._firstTwoTouches,
            a = _a(i, e, r),
            s = _a(i, e, n);
          (a && s) || (this._active && c.suppressClick(), this.reset());
        }
        touchcancel() {
          this.reset();
        }
        enable(t) {
          (this._enabled = !0),
            (this._aroundCenter = !!t && 'center' === t.around);
        }
        disable() {
          (this._enabled = !1), this.reset();
        }
        isEnabled() {
          return !!this._enabled;
        }
        isActive() {
          return !!this._active;
        }
      }
      function _a(t, e, i) {
        for (let r = 0; r < t.length; r++)
          if (t[r].identifier === i) return e[r];
      }
      function ya(t, e) {
        return Math.log(t / e) / Math.LN2;
      }
      class va extends ga {
        reset() {
          super.reset(), delete this._distance, delete this._startDistance;
        }
        _start(t) {
          this._startDistance = this._distance = t[0].dist(t[1]);
        }
        _move(t, e) {
          const i = this._distance;
          if (
            ((this._distance = t[0].dist(t[1])),
            this._active ||
              !(Math.abs(ya(this._distance, this._startDistance)) < 0.1))
          )
            return (
              (this._active = !0),
              { zoomDelta: ya(this._distance, i), pinchAround: e }
            );
        }
      }
      function xa(t, e) {
        return (180 * t.angleWith(e)) / Math.PI;
      }
      class ba extends ga {
        reset() {
          super.reset(),
            delete this._minDiameter,
            delete this._startVector,
            delete this._vector;
        }
        _start(t) {
          (this._startVector = this._vector = t[0].sub(t[1])),
            (this._minDiameter = t[0].dist(t[1]));
        }
        _move(t, e, i) {
          const r = this._vector;
          if (
            ((this._vector = t[0].sub(t[1])),
            this._active || !this._isBelowThreshold(this._vector))
          )
            return (
              (this._active = !0),
              { bearingDelta: xa(this._vector, r), pinchAround: e }
            );
        }
        _isBelowThreshold(t) {
          this._minDiameter = Math.min(this._minDiameter, t.mag());
          const e = (25 / (Math.PI * this._minDiameter)) * 360,
            i = xa(t, this._startVector);
          return Math.abs(i) < e;
        }
      }
      function wa(t) {
        return Math.abs(t.y) > Math.abs(t.x);
      }
      class Ta extends ga {
        constructor(t) {
          super(), (this._currentTouchCount = 0), (this._map = t);
        }
        reset() {
          super.reset(),
            (this._valid = void 0),
            delete this._firstMove,
            delete this._lastPoints;
        }
        touchstart(t, e, i) {
          super.touchstart(t, e, i), (this._currentTouchCount = i.length);
        }
        _start(t) {
          (this._lastPoints = t), wa(t[0].sub(t[1])) && (this._valid = !1);
        }
        _move(t, e, i) {
          if (
            this._map.cooperativeGestures.isEnabled() &&
            this._currentTouchCount < 3
          )
            return;
          const r = t[0].sub(this._lastPoints[0]),
            n = t[1].sub(this._lastPoints[1]);
          return (
            (this._valid = this.gestureBeginsVertically(r, n, i.timeStamp)),
            this._valid
              ? ((this._lastPoints = t),
                (this._active = !0),
                { pitchDelta: ((r.y + n.y) / 2) * -0.5 })
              : void 0
          );
        }
        gestureBeginsVertically(t, e, i) {
          if (void 0 !== this._valid) return this._valid;
          const r = t.mag() >= 2,
            n = e.mag() >= 2;
          if (!r && !n) return;
          if (!r || !n)
            return (
              void 0 === this._firstMove && (this._firstMove = i),
              i - this._firstMove < 100 && void 0
            );
          const a = t.y > 0 == e.y > 0;
          return wa(t) && wa(e) && a;
        }
      }
      const Pa = { panStep: 100, bearingStep: 15, pitchStep: 10 };
      class Ca {
        constructor(t) {
          this._tr = new ra(t);
          const e = Pa;
          (this._panStep = e.panStep),
            (this._bearingStep = e.bearingStep),
            (this._pitchStep = e.pitchStep),
            (this._rotationDisabled = !1);
        }
        reset() {
          this._active = !1;
        }
        keydown(t) {
          if (t.altKey || t.ctrlKey || t.metaKey) return;
          let e = 0,
            i = 0,
            r = 0,
            n = 0,
            a = 0;
          switch (t.keyCode) {
            case 61:
            case 107:
            case 171:
            case 187:
              e = 1;
              break;
            case 189:
            case 109:
            case 173:
              e = -1;
              break;
            case 37:
              t.shiftKey ? (i = -1) : (t.preventDefault(), (n = -1));
              break;
            case 39:
              t.shiftKey ? (i = 1) : (t.preventDefault(), (n = 1));
              break;
            case 38:
              t.shiftKey ? (r = 1) : (t.preventDefault(), (a = -1));
              break;
            case 40:
              t.shiftKey ? (r = -1) : (t.preventDefault(), (a = 1));
              break;
            default:
              return;
          }
          return (
            this._rotationDisabled && ((i = 0), (r = 0)),
            {
              cameraAnimation: (s) => {
                const o = this._tr;
                s.easeTo(
                  {
                    duration: 300,
                    easeId: 'keyboardHandler',
                    easing: Ia,
                    zoom: e
                      ? Math.round(o.zoom) + e * (t.shiftKey ? 2 : 1)
                      : o.zoom,
                    bearing: o.bearing + i * this._bearingStep,
                    pitch: o.pitch + r * this._pitchStep,
                    offset: [-n * this._panStep, -a * this._panStep],
                    center: o.center,
                  },
                  { originalEvent: t }
                );
              },
            }
          );
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          (this._enabled = !1), this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
        disableRotation() {
          this._rotationDisabled = !0;
        }
        enableRotation() {
          this._rotationDisabled = !1;
        }
      }
      function Ia(t) {
        return t * (2 - t);
      }
      const Sa = 4.000244140625,
        Ma = 1 / 450;
      class Da {
        constructor(t, e) {
          (this._onTimeout = (t) => {
            (this._type = 'wheel'),
              (this._delta -= this._lastValue),
              this._active || this._start(t);
          }),
            (this._map = t),
            (this._tr = new ra(t)),
            (this._triggerRenderFrame = e),
            (this._delta = 0),
            (this._defaultZoomRate = 0.01),
            (this._wheelZoomRate = Ma);
        }
        setZoomRate(t) {
          this._defaultZoomRate = t;
        }
        setWheelZoomRate(t) {
          this._wheelZoomRate = t;
        }
        isEnabled() {
          return !!this._enabled;
        }
        isActive() {
          return !!this._active || void 0 !== this._finishTimeout;
        }
        isZooming() {
          return !!this._zooming;
        }
        enable(t) {
          this.isEnabled() ||
            ((this._enabled = !0),
            (this._aroundCenter = !!t && 'center' === t.around));
        }
        disable() {
          this.isEnabled() && (this._enabled = !1);
        }
        _shouldBePrevented(t) {
          return (
            !!this._map.cooperativeGestures.isEnabled() &&
            !(t.ctrlKey || this._map.cooperativeGestures.isBypassed(t))
          );
        }
        wheel(t) {
          if (!this.isEnabled()) return;
          if (this._shouldBePrevented(t))
            return void this._map.cooperativeGestures.notifyGestureBlocked(
              'wheel_zoom',
              t
            );
          let e =
            t.deltaMode === WheelEvent.DOM_DELTA_LINE
              ? 40 * t.deltaY
              : t.deltaY;
          const i = l(),
            r = i - (this._lastWheelEventTime || 0);
          (this._lastWheelEventTime = i),
            0 !== e && e % Sa == 0
              ? (this._type = 'wheel')
              : 0 !== e && Math.abs(e) < 4
              ? (this._type = 'trackpad')
              : r > 400
              ? ((this._type = null),
                (this._lastValue = e),
                (this._timeout = setTimeout(this._onTimeout, 40, t)))
              : this._type ||
                ((this._type = Math.abs(r * e) < 200 ? 'trackpad' : 'wheel'),
                this._timeout &&
                  (clearTimeout(this._timeout),
                  (this._timeout = null),
                  (e += this._lastValue))),
            t.shiftKey && e && (e /= 4),
            this._type &&
              ((this._lastWheelEvent = t),
              (this._delta -= e),
              this._active || this._start(t)),
            t.preventDefault();
        }
        _start(t) {
          if (!this._delta) return;
          this._frameId && (this._frameId = null),
            (this._active = !0),
            this.isZooming() || (this._zooming = !0),
            this._finishTimeout &&
              (clearTimeout(this._finishTimeout), delete this._finishTimeout);
          const i = c.mousePos(this._map.getCanvas(), t),
            r = this._tr;
          (this._aroundPoint = this._aroundCenter
            ? r.transform.locationToScreenPoint(e.U.convert(r.center))
            : i),
            this._frameId || ((this._frameId = !0), this._triggerRenderFrame());
        }
        renderFrame() {
          if (!this._frameId) return;
          if (((this._frameId = null), !this.isActive())) return;
          const t = this._tr.transform;
          if ('number' == typeof this._lastExpectedZoom) {
            const e = t.zoom - this._lastExpectedZoom;
            'number' == typeof this._startZoom && (this._startZoom += e),
              'number' == typeof this._targetZoom && (this._targetZoom += e);
          }
          if (0 !== this._delta) {
            const i =
              'wheel' === this._type && Math.abs(this._delta) > Sa
                ? this._wheelZoomRate
                : this._defaultZoomRate;
            let r = 2 / (1 + Math.exp(-Math.abs(this._delta * i)));
            this._delta < 0 && 0 !== r && (r = 1 / r);
            const n =
              'number' != typeof this._targetZoom
                ? t.scale
                : e.al(this._targetZoom);
            (this._targetZoom = t.constrain(
              t.getCameraLngLat(),
              e.ao(n * r)
            ).zoom),
              'wheel' === this._type &&
                ((this._startZoom = t.zoom),
                (this._easing = this._smoothOutEasing(200))),
              (this._delta = 0);
          }
          const i =
              'number' != typeof this._targetZoom ? t.zoom : this._targetZoom,
            r = this._startZoom,
            n = this._easing;
          let a,
            s = !1;
          if ('wheel' === this._type && r && n) {
            const t = l() - this._lastWheelEventTime,
              o = Math.min((t + 5) / 200, 1),
              c = n(o);
            (a = e.F.number(r, i, c)),
              o < 1 ? this._frameId || (this._frameId = !0) : (s = !0);
          } else (a = i), (s = !0);
          return (
            (this._active = !0),
            s &&
              ((this._active = !1),
              (this._finishTimeout = setTimeout(() => {
                (this._zooming = !1),
                  this._triggerRenderFrame(),
                  delete this._targetZoom,
                  delete this._lastExpectedZoom,
                  delete this._finishTimeout;
              }, 200))),
            (this._lastExpectedZoom = a),
            {
              noInertia: !0,
              needsRenderFrame: !s,
              zoomDelta: a - t.zoom,
              around: this._aroundPoint,
              originalEvent: this._lastWheelEvent,
            }
          );
        }
        _smoothOutEasing(t) {
          let i = e.cr;
          if (this._prevEase) {
            const t = this._prevEase,
              r = (l() - t.start) / t.duration,
              n = t.easing(r + 0.01) - t.easing(r),
              a = (0.27 / Math.sqrt(n * n + 1e-4)) * 0.01,
              s = Math.sqrt(0.0729 - a * a);
            i = e.cp(a, s, 0.25, 1);
          }
          return (this._prevEase = { start: l(), duration: t, easing: i }), i;
        }
        reset() {
          (this._active = !1),
            (this._zooming = !1),
            delete this._targetZoom,
            delete this._lastExpectedZoom,
            this._finishTimeout &&
              (clearTimeout(this._finishTimeout), delete this._finishTimeout);
        }
      }
      class La {
        constructor(t, e) {
          (this._clickZoom = t), (this._tapZoom = e);
        }
        enable() {
          this._clickZoom.enable(), this._tapZoom.enable();
        }
        disable() {
          this._clickZoom.disable(), this._tapZoom.disable();
        }
        isEnabled() {
          return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
        }
        isActive() {
          return this._clickZoom.isActive() || this._tapZoom.isActive();
        }
      }
      class Aa {
        constructor(t) {
          (this._tr = new ra(t)), this.reset();
        }
        reset() {
          this._active = !1;
        }
        dblclick(t, e) {
          return (
            t.preventDefault(),
            {
              cameraAnimation: (i) => {
                i.easeTo(
                  {
                    duration: 300,
                    zoom: this._tr.zoom + (t.shiftKey ? -1 : 1),
                    around: this._tr.unproject(e),
                  },
                  { originalEvent: t }
                );
              },
            }
          );
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          (this._enabled = !1), this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class Ea {
        constructor() {
          (this._tap = new oa({ numTouches: 1, numTaps: 1 })), this.reset();
        }
        reset() {
          (this._active = !1),
            delete this._swipePoint,
            delete this._swipeTouch,
            delete this._tapTime,
            delete this._tapPoint,
            this._tap.reset();
        }
        touchstart(t, e, i) {
          if (!this._swipePoint)
            if (this._tapTime) {
              const r = e[0],
                n = t.timeStamp - this._tapTime < 500,
                a = this._tapPoint.dist(r) < 30;
              n && a
                ? i.length > 0 &&
                  ((this._swipePoint = r), (this._swipeTouch = i[0].identifier))
                : this.reset();
            } else this._tap.touchstart(t, e, i);
        }
        touchmove(t, e, i) {
          if (this._tapTime) {
            if (this._swipePoint) {
              if (i[0].identifier !== this._swipeTouch) return;
              const r = e[0],
                n = r.y - this._swipePoint.y;
              return (
                (this._swipePoint = r),
                t.preventDefault(),
                (this._active = !0),
                { zoomDelta: n / 128 }
              );
            }
          } else this._tap.touchmove(t, e, i);
        }
        touchend(t, e, i) {
          if (this._tapTime) this._swipePoint && 0 === i.length && this.reset();
          else {
            const r = this._tap.touchend(t, e, i);
            r && ((this._tapTime = t.timeStamp), (this._tapPoint = r));
          }
        }
        touchcancel() {
          this.reset();
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          (this._enabled = !1), this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class Ra {
        constructor(t, e, i) {
          (this._el = t), (this._mousePan = e), (this._touchPan = i);
        }
        enable(t) {
          (this._inertiaOptions = t || {}),
            this._mousePan.enable(),
            this._touchPan.enable(),
            this._el.classList.add('maplibregl-touch-drag-pan');
        }
        disable() {
          this._mousePan.disable(),
            this._touchPan.disable(),
            this._el.classList.remove('maplibregl-touch-drag-pan');
        }
        isEnabled() {
          return this._mousePan.isEnabled() && this._touchPan.isEnabled();
        }
        isActive() {
          return this._mousePan.isActive() || this._touchPan.isActive();
        }
      }
      class za {
        constructor(t, e, i, r) {
          (this._pitchWithRotate = t.pitchWithRotate),
            (this._rollEnabled = t.rollEnabled),
            (this._mouseRotate = e),
            (this._mousePitch = i),
            (this._mouseRoll = r);
        }
        enable() {
          this._mouseRotate.enable(),
            this._pitchWithRotate && this._mousePitch.enable(),
            this._rollEnabled && this._mouseRoll.enable();
        }
        disable() {
          this._mouseRotate.disable(),
            this._mousePitch.disable(),
            this._mouseRoll.disable();
        }
        isEnabled() {
          return (
            this._mouseRotate.isEnabled() &&
            (!this._pitchWithRotate || this._mousePitch.isEnabled()) &&
            (!this._rollEnabled || this._mouseRoll.isEnabled())
          );
        }
        isActive() {
          return (
            this._mouseRotate.isActive() ||
            this._mousePitch.isActive() ||
            this._mouseRoll.isActive()
          );
        }
      }
      class ka {
        constructor(t, e, i, r) {
          (this._el = t),
            (this._touchZoom = e),
            (this._touchRotate = i),
            (this._tapDragZoom = r),
            (this._rotationDisabled = !1),
            (this._enabled = !0);
        }
        enable(t) {
          this._touchZoom.enable(t),
            this._rotationDisabled || this._touchRotate.enable(t),
            this._tapDragZoom.enable(),
            this._el.classList.add('maplibregl-touch-zoom-rotate');
        }
        disable() {
          this._touchZoom.disable(),
            this._touchRotate.disable(),
            this._tapDragZoom.disable(),
            this._el.classList.remove('maplibregl-touch-zoom-rotate');
        }
        isEnabled() {
          return (
            this._touchZoom.isEnabled() &&
            (this._rotationDisabled || this._touchRotate.isEnabled()) &&
            this._tapDragZoom.isEnabled()
          );
        }
        isActive() {
          return (
            this._touchZoom.isActive() ||
            this._touchRotate.isActive() ||
            this._tapDragZoom.isActive()
          );
        }
        disableRotation() {
          (this._rotationDisabled = !0), this._touchRotate.disable();
        }
        enableRotation() {
          (this._rotationDisabled = !1),
            this._touchZoom.isEnabled() && this._touchRotate.enable();
        }
      }
      class Oa {
        constructor(t, e) {
          (this._bypassKey =
            -1 !== navigator.userAgent.indexOf('Mac') ? 'metaKey' : 'ctrlKey'),
            (this._map = t),
            (this._options = e),
            (this._enabled = !1);
        }
        isActive() {
          return !1;
        }
        reset() {}
        _setupUI() {
          if (this._container) return;
          const t = this._map.getCanvasContainer();
          t.classList.add('maplibregl-cooperative-gestures'),
            (this._container = c.create(
              'div',
              'maplibregl-cooperative-gesture-screen',
              t
            ));
          let e = this._map._getUIString(
            'CooperativeGesturesHandler.WindowsHelpText'
          );
          'metaKey' === this._bypassKey &&
            (e = this._map._getUIString(
              'CooperativeGesturesHandler.MacHelpText'
            ));
          const i = this._map._getUIString(
              'CooperativeGesturesHandler.MobileHelpText'
            ),
            r = document.createElement('div');
          (r.className = 'maplibregl-desktop-message'),
            (r.textContent = e),
            this._container.appendChild(r);
          const n = document.createElement('div');
          (n.className = 'maplibregl-mobile-message'),
            (n.textContent = i),
            this._container.appendChild(n),
            this._container.setAttribute('aria-hidden', 'true');
        }
        _destroyUI() {
          this._container &&
            (c.remove(this._container),
            this._map
              .getCanvasContainer()
              .classList.remove('maplibregl-cooperative-gestures')),
            delete this._container;
        }
        enable() {
          this._setupUI(), (this._enabled = !0);
        }
        disable() {
          (this._enabled = !1), this._destroyUI();
        }
        isEnabled() {
          return this._enabled;
        }
        isBypassed(t) {
          return t[this._bypassKey];
        }
        notifyGestureBlocked(t, i) {
          this._enabled &&
            (this._map.fire(
              new e.l('cooperativegestureprevented', {
                gestureType: t,
                originalEvent: i,
              })
            ),
            this._container.classList.add('maplibregl-show'),
            setTimeout(() => {
              this._container.classList.remove('maplibregl-show');
            }, 100));
        }
      }
      const Fa = (t) => t.zoom || t.drag || t.roll || t.pitch || t.rotate;
      class Ba extends e.l {}
      function Na(t) {
        return (
          (t.panDelta && t.panDelta.mag()) ||
          t.zoomDelta ||
          t.bearingDelta ||
          t.pitchDelta ||
          t.rollDelta
        );
      }
      class Va {
        constructor(t, i) {
          (this.handleWindowEvent = (t) => {
            this.handleEvent(t, `${t.type}Window`);
          }),
            (this.handleEvent = (t, i) => {
              if ('blur' === t.type) return void this.stop(!0);
              this._updatingCamera = !0;
              const r = 'renderFrame' === t.type ? void 0 : t,
                n = { needsRenderFrame: !1 },
                a = {},
                s = {};
              for (const { handlerName: h, handler: u, allowed: d } of this
                ._handlers) {
                if (!u.isEnabled()) continue;
                let o;
                if (this._blockedByActive(s, d, h)) u.reset();
                else if (u[i || t.type]) {
                  if (e.cs(t, i || t.type)) {
                    const e = c.mousePos(this._map.getCanvas(), t);
                    o = u[i || t.type](t, e);
                  } else if (e.ct(t, i || t.type)) {
                    const e = this._getMapTouches(t.touches),
                      r = c.touchPos(this._map.getCanvas(), e);
                    o = u[i || t.type](t, r, e);
                  } else e.cu(i || t.type) || (o = u[i || t.type](t));
                  this.mergeHandlerResult(n, a, o, h, r),
                    o && o.needsRenderFrame && this._triggerRenderFrame();
                }
                (o || u.isActive()) && (s[h] = u);
              }
              const o = {};
              for (const e in this._previousActiveHandlers) s[e] || (o[e] = r);
              (this._previousActiveHandlers = s),
                (Object.keys(o).length || Na(n)) &&
                  (this._changes.push([n, a, o]), this._triggerRenderFrame()),
                (Object.keys(s).length || Na(n)) && this._map._stop(!0),
                (this._updatingCamera = !1);
              const { cameraAnimation: l } = n;
              l &&
                (this._inertia.clear(),
                this._fireEvents({}, {}, !0),
                (this._changes = []),
                l(this._map));
            }),
            (this._map = t),
            (this._el = this._map.getCanvasContainer()),
            (this._handlers = []),
            (this._handlersById = {}),
            (this._changes = []),
            (this._inertia = new Xn(t)),
            (this._bearingSnap = i.bearingSnap),
            (this._previousActiveHandlers = {}),
            (this._eventsInProgress = {}),
            this._addDefaultHandlers(i);
          const r = this._el;
          this._listeners = [
            [r, 'touchstart', { passive: !0 }],
            [r, 'touchmove', { passive: !1 }],
            [r, 'touchend', void 0],
            [r, 'touchcancel', void 0],
            [r, 'mousedown', void 0],
            [r, 'mousemove', void 0],
            [r, 'mouseup', void 0],
            [document, 'mousemove', { capture: !0 }],
            [document, 'mouseup', void 0],
            [r, 'mouseover', void 0],
            [r, 'mouseout', void 0],
            [r, 'dblclick', void 0],
            [r, 'click', void 0],
            [r, 'keydown', { capture: !1 }],
            [r, 'keyup', void 0],
            [r, 'wheel', { passive: !1 }],
            [r, 'contextmenu', void 0],
            [window, 'blur', void 0],
          ];
          for (const [e, n, a] of this._listeners)
            c.addEventListener(
              e,
              n,
              e === document ? this.handleWindowEvent : this.handleEvent,
              a
            );
        }
        destroy() {
          for (const [t, e, i] of this._listeners)
            c.removeEventListener(
              t,
              e,
              t === document ? this.handleWindowEvent : this.handleEvent,
              i
            );
        }
        _addDefaultHandlers(t) {
          const i = this._map,
            r = i.getCanvasContainer();
          this._add('mapEvent', new ea(i, t));
          const n = (i.boxZoom = new na(i, t));
          this._add('boxZoom', n), t.interactive && t.boxZoom && n.enable();
          const a = (i.cooperativeGestures = new Oa(i, t.cooperativeGestures));
          this._add('cooperativeGestures', a),
            t.cooperativeGestures && a.enable();
          const s = new la(i),
            o = new Aa(i);
          (i.doubleClickZoom = new La(o, s)),
            this._add('tapZoom', s),
            this._add('clickZoom', o),
            t.interactive && t.doubleClickZoom && i.doubleClickZoom.enable();
          const l = new Ea();
          this._add('tapDragZoom', l);
          const h = (i.touchPitch = new Ta(i));
          this._add('touchPitch', h),
            t.interactive && t.touchPitch && i.touchPitch.enable(t.touchPitch);
          const u = () => i.project(i.getCenter()),
            d = (function (
              {
                enable: t,
                clickTolerance: i,
                aroundCenter: r = !0,
                minPixelCenterThreshold: n = 100,
                rotateDegreesPerPixelMoved: a = 0.8,
              },
              s
            ) {
              const o = new ua({
                checkCorrectEvent: (t) =>
                  (0 === c.mouseButton(t) && t.ctrlKey) ||
                  (2 === c.mouseButton(t) && !t.ctrlKey),
              });
              return new ca({
                clickTolerance: i,
                move: (t, i) => {
                  const o = s();
                  if (r && Math.abs(o.y - t.y) > n)
                    return { bearingDelta: e.cq(new e.P(t.x, i.y), i, o) };
                  let l = (i.x - t.x) * a;
                  return r && i.y < o.y && (l = -l), { bearingDelta: l };
                },
                moveStateManager: o,
                enable: t,
                assignEvents: fa,
              });
            })(t, u),
            p = (function ({
              enable: t,
              clickTolerance: e,
              pitchDegreesPerPixelMoved: i = -0.5,
            }) {
              const r = new ua({
                checkCorrectEvent: (t) =>
                  (0 === c.mouseButton(t) && t.ctrlKey) ||
                  2 === c.mouseButton(t),
              });
              return new ca({
                clickTolerance: e,
                move: (t, e) => ({ pitchDelta: (e.y - t.y) * i }),
                moveStateManager: r,
                enable: t,
                assignEvents: fa,
              });
            })(t),
            f = (function (
              {
                enable: t,
                clickTolerance: e,
                rollDegreesPerPixelMoved: i = 0.3,
              },
              r
            ) {
              const n = new ua({
                checkCorrectEvent: (t) => 2 === c.mouseButton(t) && t.ctrlKey,
              });
              return new ca({
                clickTolerance: e,
                move: (t, e) => {
                  const n = r();
                  let a = (e.x - t.x) * i;
                  return e.y < n.y && (a = -a), { rollDelta: a };
                },
                moveStateManager: n,
                enable: t,
                assignEvents: fa,
              });
            })(t, u);
          (i.dragRotate = new za(t, d, p, f)),
            this._add('mouseRotate', d, ['mousePitch']),
            this._add('mousePitch', p, ['mouseRotate', 'mouseRoll']),
            this._add('mouseRoll', f, ['mousePitch']),
            t.interactive && t.dragRotate && i.dragRotate.enable();
          const m = (function ({ enable: t, clickTolerance: e }) {
              const i = new ua({
                checkCorrectEvent: (t) => 0 === c.mouseButton(t) && !t.ctrlKey,
              });
              return new ca({
                clickTolerance: e,
                move: (t, e) => ({ around: e, panDelta: e.sub(t) }),
                activateOnStart: !0,
                moveStateManager: i,
                enable: t,
                assignEvents: fa,
              });
            })(t),
            g = new ma(t, i);
          (i.dragPan = new Ra(r, m, g)),
            this._add('mousePan', m),
            this._add('touchPan', g, ['touchZoom', 'touchRotate']),
            t.interactive && t.dragPan && i.dragPan.enable(t.dragPan);
          const _ = new ba(),
            y = new va();
          (i.touchZoomRotate = new ka(r, y, _, l)),
            this._add('touchRotate', _, ['touchPan', 'touchZoom']),
            this._add('touchZoom', y, ['touchPan', 'touchRotate']),
            t.interactive &&
              t.touchZoomRotate &&
              i.touchZoomRotate.enable(t.touchZoomRotate),
            this._add('blockableMapEvent', new ia(i));
          const v = (i.scrollZoom = new Da(i, () =>
            this._triggerRenderFrame()
          ));
          this._add('scrollZoom', v, ['mousePan']),
            t.interactive && t.scrollZoom && i.scrollZoom.enable(t.scrollZoom);
          const x = (i.keyboard = new Ca(i));
          this._add('keyboard', x),
            t.interactive && t.keyboard && i.keyboard.enable();
        }
        _add(t, e, i) {
          this._handlers.push({ handlerName: t, handler: e, allowed: i }),
            (this._handlersById[t] = e);
        }
        stop(t) {
          if (!this._updatingCamera) {
            for (const { handler: t } of this._handlers) t.reset();
            this._inertia.clear(),
              this._fireEvents({}, {}, t),
              (this._changes = []);
          }
        }
        isActive() {
          for (const { handler: t } of this._handlers)
            if (t.isActive()) return !0;
          return !1;
        }
        isZooming() {
          return (
            !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming()
          );
        }
        isRotating() {
          return !!this._eventsInProgress.rotate;
        }
        isMoving() {
          return Boolean(Fa(this._eventsInProgress)) || this.isZooming();
        }
        _blockedByActive(t, e, i) {
          for (const r in t) if (r !== i && (!e || e.indexOf(r) < 0)) return !0;
          return !1;
        }
        _getMapTouches(t) {
          const e = [];
          for (const i of t) this._el.contains(i.target) && e.push(i);
          return e;
        }
        mergeHandlerResult(t, i, r, n, a) {
          if (!r) return;
          e.e(t, r);
          const s = { handlerName: n, originalEvent: r.originalEvent || a };
          void 0 !== r.zoomDelta && (i.zoom = s),
            void 0 !== r.panDelta && (i.drag = s),
            void 0 !== r.rollDelta && (i.roll = s),
            void 0 !== r.pitchDelta && (i.pitch = s),
            void 0 !== r.bearingDelta && (i.rotate = s);
        }
        _applyChanges() {
          const t = {},
            i = {},
            r = {};
          for (const [n, a, s] of this._changes)
            n.panDelta &&
              (t.panDelta = (t.panDelta || new e.P(0, 0))._add(n.panDelta)),
              n.zoomDelta && (t.zoomDelta = (t.zoomDelta || 0) + n.zoomDelta),
              n.bearingDelta &&
                (t.bearingDelta = (t.bearingDelta || 0) + n.bearingDelta),
              n.pitchDelta &&
                (t.pitchDelta = (t.pitchDelta || 0) + n.pitchDelta),
              n.rollDelta && (t.rollDelta = (t.rollDelta || 0) + n.rollDelta),
              void 0 !== n.around && (t.around = n.around),
              void 0 !== n.pinchAround && (t.pinchAround = n.pinchAround),
              n.noInertia && (t.noInertia = n.noInertia),
              e.e(i, a),
              e.e(r, s);
          this._updateMapTransform(t, i, r), (this._changes = []);
        }
        _updateMapTransform(t, e, i) {
          const r = this._map,
            n = r._getTransformForUpdate(),
            a = r.terrain;
          if (!(Na(t) || (a && this._terrainMovement)))
            return this._fireEvents(e, i, !0);
          r._stop(!0);
          let {
            panDelta: s,
            zoomDelta: o,
            bearingDelta: l,
            pitchDelta: c,
            rollDelta: h,
            around: u,
            pinchAround: d,
          } = t;
          void 0 !== d && (u = d),
            (u = u || r.transform.centerPoint),
            a && !n.isPointOnMapSurface(u) && (u = n.centerPoint);
          const p = {
            panDelta: s,
            zoomDelta: o,
            rollDelta: h,
            pitchDelta: c,
            bearingDelta: l,
            around: u,
          };
          this._map.cameraHelper.useGlobeControls &&
            !n.isPointOnMapSurface(u) &&
            (u = n.centerPoint);
          const f =
            u.distSqr(n.centerPoint) < 0.01
              ? n.center
              : n.screenPointToLocation(s ? u.sub(s) : u);
          this._handleMapControls({
            terrain: a,
            tr: n,
            deltasForHelper: p,
            preZoomAroundLoc: f,
            combinedEventsInProgress: e,
            panDelta: s,
          }),
            r._applyUpdatedTransform(n),
            this._map._update(),
            t.noInertia || this._inertia.record(t),
            this._fireEvents(e, i, !0);
        }
        _handleMapControls({
          terrain: t,
          tr: e,
          deltasForHelper: i,
          preZoomAroundLoc: r,
          combinedEventsInProgress: n,
          panDelta: a,
        }) {
          const s = this._map.cameraHelper;
          if ((s.handleMapControlsRollPitchBearingZoom(i, e), t))
            return s.useGlobeControls
              ? (this._terrainMovement ||
                  (!n.drag && !n.zoom) ||
                  ((this._terrainMovement = !0),
                  (this._map._elevationFreeze = !0)),
                void s.handleMapControlsPan(i, e, r))
              : this._terrainMovement || (!n.drag && !n.zoom)
              ? void (n.drag && this._terrainMovement && a
                  ? e.setCenter(e.screenPointToLocation(e.centerPoint.sub(a)))
                  : s.handleMapControlsPan(i, e, r))
              : ((this._terrainMovement = !0),
                (this._map._elevationFreeze = !0),
                void s.handleMapControlsPan(i, e, r));
          s.handleMapControlsPan(i, e, r);
        }
        _fireEvents(t, i, r) {
          const n = Fa(this._eventsInProgress),
            a = Fa(t),
            o = {};
          for (const e in t) {
            const { originalEvent: i } = t[e];
            this._eventsInProgress[e] || (o[`${e}start`] = i),
              (this._eventsInProgress[e] = t[e]);
          }
          !n && a && this._fireEvent('movestart', a.originalEvent);
          for (const e in o) this._fireEvent(e, o[e]);
          a && this._fireEvent('move', a.originalEvent);
          for (const e in t) {
            const { originalEvent: i } = t[e];
            this._fireEvent(e, i);
          }
          const l = {};
          let c;
          for (const e in this._eventsInProgress) {
            const { handlerName: t, originalEvent: r } =
              this._eventsInProgress[e];
            this._handlersById[t].isActive() ||
              (delete this._eventsInProgress[e],
              (c = i[t] || r),
              (l[`${e}end`] = c));
          }
          for (const e in l) this._fireEvent(e, l[e]);
          const h = Fa(this._eventsInProgress),
            u = (n || a) && !h;
          if (u && this._terrainMovement) {
            (this._map._elevationFreeze = !1), (this._terrainMovement = !1);
            const t = this._map._getTransformForUpdate();
            this._map.getCenterClampedToGround() &&
              t.recalculateZoomAndCenter(this._map.terrain),
              this._map._applyUpdatedTransform(t);
          }
          if (r && u) {
            this._updatingCamera = !0;
            const t = this._inertia._onMoveEnd(
                this._map.dragPan._inertiaOptions
              ),
              i = (t) =>
                0 !== t && -this._bearingSnap < t && t < this._bearingSnap;
            !t || (!t.essential && s.prefersReducedMotion)
              ? (this._map.fire(new e.l('moveend', { originalEvent: c })),
                i(this._map.getBearing()) && this._map.resetNorth())
              : (i(t.bearing || this._map.getBearing()) && (t.bearing = 0),
                (t.freezeElevation = !0),
                this._map.easeTo(t, { originalEvent: c })),
              (this._updatingCamera = !1);
          }
        }
        _fireEvent(t, i) {
          this._map.fire(new e.l(t, i ? { originalEvent: i } : {}));
        }
        _requestFrame() {
          return (
            this._map.triggerRepaint(),
            this._map._renderTaskQueue.add((t) => {
              delete this._frameId,
                this.handleEvent(new Ba('renderFrame', { timeStamp: t })),
                this._applyChanges();
            })
          );
        }
        _triggerRenderFrame() {
          void 0 === this._frameId && (this._frameId = this._requestFrame());
        }
      }
      class ja extends e.E {
        constructor(t, e, i) {
          super(),
            (this._renderFrameCallback = () => {
              const t = Math.min(
                (l() - this._easeStart) / this._easeOptions.duration,
                1
              );
              this._onEaseFrame(this._easeOptions.easing(t)),
                t < 1 && this._easeFrameId
                  ? (this._easeFrameId = this._requestRenderFrame(
                      this._renderFrameCallback
                    ))
                  : this.stop();
            }),
            (this._moving = !1),
            (this._zooming = !1),
            (this.transform = t),
            (this._bearingSnap = i.bearingSnap),
            (this.cameraHelper = e),
            this.on('moveend', () => {
              delete this._requestedCameraState;
            });
        }
        migrateProjection(t, e) {
          t.apply(this.transform),
            (this.transform = t),
            (this.cameraHelper = e);
        }
        getCenter() {
          return new e.U(this.transform.center.lng, this.transform.center.lat);
        }
        setCenter(t, e) {
          return this.jumpTo({ center: t }, e);
        }
        getCenterElevation() {
          return this.transform.elevation;
        }
        setCenterElevation(t, e) {
          return this.jumpTo({ elevation: t }, e), this;
        }
        getCenterClampedToGround() {
          return this._centerClampedToGround;
        }
        setCenterClampedToGround(t) {
          this._centerClampedToGround = t;
        }
        panBy(t, i, r) {
          return (
            (t = e.P.convert(t).mult(-1)),
            this.panTo(this.transform.center, e.e({ offset: t }, i), r)
          );
        }
        panTo(t, i, r) {
          return this.easeTo(e.e({ center: t }, i), r);
        }
        getZoom() {
          return this.transform.zoom;
        }
        setZoom(t, e) {
          return this.jumpTo({ zoom: t }, e), this;
        }
        zoomTo(t, i, r) {
          return this.easeTo(e.e({ zoom: t }, i), r);
        }
        zoomIn(t, e) {
          return this.zoomTo(this.getZoom() + 1, t, e), this;
        }
        zoomOut(t, e) {
          return this.zoomTo(this.getZoom() - 1, t, e), this;
        }
        getVerticalFieldOfView() {
          return this.transform.fov;
        }
        setVerticalFieldOfView(t, i) {
          return (
            t != this.transform.fov &&
              (this.transform.setFov(t),
              this.fire(new e.l('movestart', i))
                .fire(new e.l('move', i))
                .fire(new e.l('moveend', i))),
            this
          );
        }
        getBearing() {
          return this.transform.bearing;
        }
        setBearing(t, e) {
          return this.jumpTo({ bearing: t }, e), this;
        }
        getPadding() {
          return this.transform.padding;
        }
        setPadding(t, e) {
          return this.jumpTo({ padding: t }, e), this;
        }
        rotateTo(t, i, r) {
          return this.easeTo(e.e({ bearing: t }, i), r);
        }
        resetNorth(t, i) {
          return this.rotateTo(0, e.e({ duration: 1e3 }, t), i), this;
        }
        resetNorthPitch(t, i) {
          return (
            this.easeTo(
              e.e({ bearing: 0, pitch: 0, roll: 0, duration: 1e3 }, t),
              i
            ),
            this
          );
        }
        snapToNorth(t, e) {
          return Math.abs(this.getBearing()) < this._bearingSnap
            ? this.resetNorth(t, e)
            : this;
        }
        getPitch() {
          return this.transform.pitch;
        }
        setPitch(t, e) {
          return this.jumpTo({ pitch: t }, e), this;
        }
        getRoll() {
          return this.transform.roll;
        }
        setRoll(t, e) {
          return this.jumpTo({ roll: t }, e), this;
        }
        cameraForBounds(t, e) {
          t = q.convert(t).adjustAntiMeridian();
          const i = (e && e.bearing) || 0;
          return this._cameraForBoxAndBearing(
            t.getNorthWest(),
            t.getSouthEast(),
            i,
            e
          );
        }
        _cameraForBoxAndBearing(t, i, r, n) {
          const a = { top: 0, bottom: 0, right: 0, left: 0 };
          if (
            'number' ==
            typeof (n = e.e(
              { padding: a, offset: [0, 0], maxZoom: this.transform.maxZoom },
              n
            )).padding
          ) {
            const t = n.padding;
            n.padding = { top: t, bottom: t, right: t, left: t };
          }
          const s = e.e(a, n.padding);
          n.padding = s;
          const o = this.transform,
            l = new q(t, i);
          return this.cameraHelper.cameraForBoxAndBearing(n, s, l, r, o);
        }
        fitBounds(t, e, i) {
          return this._fitInternal(this.cameraForBounds(t, e), e, i);
        }
        fitScreenCoordinates(t, i, r, n, a) {
          return this._fitInternal(
            this._cameraForBoxAndBearing(
              this.transform.screenPointToLocation(e.P.convert(t)),
              this.transform.screenPointToLocation(e.P.convert(i)),
              r,
              n
            ),
            n,
            a
          );
        }
        _fitInternal(t, i, r) {
          return t
            ? (delete (i = e.e(t, i)).padding,
              i.linear ? this.easeTo(i, r) : this.flyTo(i, r))
            : this;
        }
        jumpTo(t, i) {
          this.stop();
          const r = this._getTransformForUpdate();
          let n = !1,
            a = !1,
            s = !1;
          const o = r.zoom;
          this.cameraHelper.handleJumpToCenterZoom(r, t);
          const l = r.zoom !== o;
          return (
            'elevation' in t &&
              r.elevation !== +t.elevation &&
              r.setElevation(+t.elevation),
            'bearing' in t &&
              r.bearing !== +t.bearing &&
              ((n = !0), r.setBearing(+t.bearing)),
            'pitch' in t &&
              r.pitch !== +t.pitch &&
              ((a = !0), r.setPitch(+t.pitch)),
            'roll' in t && r.roll !== +t.roll && ((s = !0), r.setRoll(+t.roll)),
            null == t.padding ||
              r.isPaddingEqual(t.padding) ||
              r.setPadding(t.padding),
            this._applyUpdatedTransform(r),
            this.fire(new e.l('movestart', i)).fire(new e.l('move', i)),
            l &&
              this.fire(new e.l('zoomstart', i))
                .fire(new e.l('zoom', i))
                .fire(new e.l('zoomend', i)),
            n &&
              this.fire(new e.l('rotatestart', i))
                .fire(new e.l('rotate', i))
                .fire(new e.l('rotateend', i)),
            a &&
              this.fire(new e.l('pitchstart', i))
                .fire(new e.l('pitch', i))
                .fire(new e.l('pitchend', i)),
            s &&
              this.fire(new e.l('rollstart', i))
                .fire(new e.l('roll', i))
                .fire(new e.l('rollend', i)),
            this.fire(new e.l('moveend', i))
          );
        }
        calculateCameraOptionsFromTo(t, i, r, n = 0) {
          const a = e.a5.fromLngLat(t, i),
            s = e.a5.fromLngLat(r, n),
            o = s.x - a.x,
            l = s.y - a.y,
            c = s.z - a.z,
            h = Math.hypot(o, l, c);
          if (0 === h)
            throw new Error(
              "Can't calculate camera options with same From and To"
            );
          const u = Math.hypot(o, l),
            d = e.ao(
              this.transform.cameraToCenterDistance /
                h /
                this.transform.tileSize
            ),
            p = (180 * Math.atan2(o, -l)) / Math.PI;
          let f = (180 * Math.acos(u / h)) / Math.PI;
          return (
            (f = c < 0 ? 90 - f : 90 + f),
            {
              center: s.toLngLat(),
              elevation: n,
              zoom: d,
              pitch: f,
              bearing: p,
            }
          );
        }
        calculateCameraOptionsFromCameraLngLatAltRotation(t, e, i, r, n) {
          const a = this.transform.calculateCenterFromCameraLngLatAlt(
            t,
            e,
            i,
            r
          );
          return {
            center: a.center,
            elevation: a.elevation,
            zoom: a.zoom,
            bearing: i,
            pitch: r,
            roll: n,
          };
        }
        easeTo(t, i) {
          this._stop(!1, t.easeId),
            (!1 ===
              (t = e.e({ offset: [0, 0], duration: 500, easing: e.cr }, t))
                .animate ||
              (!t.essential && s.prefersReducedMotion)) &&
              (t.duration = 0);
          const r = this._getTransformForUpdate(),
            n = this.getBearing(),
            a = r.pitch,
            o = r.roll,
            l = 'bearing' in t ? this._normalizeBearing(t.bearing, n) : n,
            c = 'pitch' in t ? +t.pitch : a,
            h = 'roll' in t ? this._normalizeBearing(t.roll, o) : o,
            u = 'padding' in t ? t.padding : r.padding,
            d = e.P.convert(t.offset);
          let p, f;
          t.around &&
            ((p = e.U.convert(t.around)), (f = r.locationToScreenPoint(p)));
          const m = {
              moving: this._moving,
              zooming: this._zooming,
              rotating: this._rotating,
              pitching: this._pitching,
              rolling: this._rolling,
            },
            g = this.cameraHelper.handleEaseTo(r, {
              bearing: l,
              pitch: c,
              roll: h,
              padding: u,
              around: p,
              aroundPoint: f,
              offsetAsPoint: d,
              offset: t.offset,
              zoom: t.zoom,
              center: t.center,
            });
          return (
            (this._rotating = this._rotating || n !== l),
            (this._pitching = this._pitching || c !== a),
            (this._rolling = this._rolling || h !== o),
            (this._padding = !r.isPaddingEqual(u)),
            (this._zooming = this._zooming || g.isZooming),
            (this._easeId = t.easeId),
            this._prepareEase(i, t.noMoveStart, m),
            this.terrain && this._prepareElevation(g.elevationCenter),
            this._ease(
              (e) => {
                g.easeFunc(e),
                  this.terrain &&
                    !t.freezeElevation &&
                    this._updateElevation(e),
                  this._applyUpdatedTransform(r),
                  this._fireMoveEvents(i);
              },
              (e) => {
                this.terrain && t.freezeElevation && this._finalizeElevation(),
                  this._afterEase(i, e);
              },
              t
            ),
            this
          );
        }
        _prepareEase(t, i, r = {}) {
          (this._moving = !0),
            i || r.moving || this.fire(new e.l('movestart', t)),
            this._zooming && !r.zooming && this.fire(new e.l('zoomstart', t)),
            this._rotating &&
              !r.rotating &&
              this.fire(new e.l('rotatestart', t)),
            this._pitching &&
              !r.pitching &&
              this.fire(new e.l('pitchstart', t)),
            this._rolling && !r.rolling && this.fire(new e.l('rollstart', t));
        }
        _prepareElevation(t) {
          (this._elevationCenter = t),
            (this._elevationStart = this.transform.elevation),
            (this._elevationTarget = this.terrain.getElevationForLngLatZoom(
              t,
              this.transform.tileZoom
            )),
            (this._elevationFreeze = !0);
        }
        _updateElevation(t) {
          (void 0 !== this._elevationStart &&
            void 0 !== this._elevationCenter) ||
            this._prepareElevation(this.transform.center),
            this.transform.setMinElevationForCurrentTile(
              this.terrain.getMinTileElevationForLngLatZoom(
                this._elevationCenter,
                this.transform.tileZoom
              )
            );
          const i = this.terrain.getElevationForLngLatZoom(
            this._elevationCenter,
            this.transform.tileZoom
          );
          if (t < 1 && i !== this._elevationTarget) {
            const e = this._elevationTarget - this._elevationStart;
            (this._elevationStart +=
              t * (e - (i - (e * t + this._elevationStart)) / (1 - t))),
              (this._elevationTarget = i);
          }
          this.transform.setElevation(
            e.F.number(this._elevationStart, this._elevationTarget, t)
          );
        }
        _finalizeElevation() {
          (this._elevationFreeze = !1),
            this.getCenterClampedToGround() &&
              this.transform.recalculateZoomAndCenter(this.terrain);
        }
        _getTransformForUpdate() {
          return this.transformCameraUpdate || this.terrain
            ? (this._requestedCameraState ||
                (this._requestedCameraState = this.transform.clone()),
              this._requestedCameraState)
            : this.transform;
        }
        _elevateCameraIfInsideTerrain(t) {
          if (!this.terrain && t.elevation >= 0 && t.pitch <= 90) return {};
          const e = t.getCameraLngLat(),
            i = t.getCameraAltitude(),
            r = this.terrain
              ? this.terrain.getElevationForLngLatZoom(e, t.zoom)
              : 0;
          if (i < r) {
            const i = this.calculateCameraOptionsFromTo(
              e,
              r,
              t.center,
              t.elevation
            );
            return { pitch: i.pitch, zoom: i.zoom };
          }
          return {};
        }
        _applyUpdatedTransform(t) {
          const e = [];
          if (
            (e.push((t) => this._elevateCameraIfInsideTerrain(t)),
            this.transformCameraUpdate &&
              e.push((t) => this.transformCameraUpdate(t)),
            !e.length)
          )
            return;
          const i = t.clone();
          for (const r of e) {
            const t = i.clone(),
              {
                center: e,
                zoom: n,
                roll: a,
                pitch: s,
                bearing: o,
                elevation: l,
              } = r(t);
            e && t.setCenter(e),
              void 0 !== l && t.setElevation(l),
              void 0 !== n && t.setZoom(n),
              void 0 !== a && t.setRoll(a),
              void 0 !== s && t.setPitch(s),
              void 0 !== o && t.setBearing(o),
              i.apply(t);
          }
          this.transform.apply(i);
        }
        _fireMoveEvents(t) {
          this.fire(new e.l('move', t)),
            this._zooming && this.fire(new e.l('zoom', t)),
            this._rotating && this.fire(new e.l('rotate', t)),
            this._pitching && this.fire(new e.l('pitch', t)),
            this._rolling && this.fire(new e.l('roll', t));
        }
        _afterEase(t, i) {
          if (this._easeId && i && this._easeId === i) return;
          delete this._easeId;
          const r = this._zooming,
            n = this._rotating,
            a = this._pitching,
            s = this._rolling;
          (this._moving = !1),
            (this._zooming = !1),
            (this._rotating = !1),
            (this._pitching = !1),
            (this._rolling = !1),
            (this._padding = !1),
            r && this.fire(new e.l('zoomend', t)),
            n && this.fire(new e.l('rotateend', t)),
            a && this.fire(new e.l('pitchend', t)),
            s && this.fire(new e.l('rollend', t)),
            this.fire(new e.l('moveend', t));
        }
        flyTo(t, i) {
          if (!t.essential && s.prefersReducedMotion) {
            const r = e.S(t, [
              'center',
              'zoom',
              'bearing',
              'pitch',
              'roll',
              'elevation',
              'padding',
            ]);
            return this.jumpTo(r, i);
          }
          this.stop(),
            (t = e.e(
              { offset: [0, 0], speed: 1.2, curve: 1.42, easing: e.cr },
              t
            ));
          const r = this._getTransformForUpdate(),
            n = r.bearing,
            a = r.pitch,
            o = r.roll,
            l = r.padding,
            c = 'bearing' in t ? this._normalizeBearing(t.bearing, n) : n,
            h = 'pitch' in t ? +t.pitch : a,
            u = 'roll' in t ? this._normalizeBearing(t.roll, o) : o,
            d = 'padding' in t ? t.padding : r.padding,
            p = e.P.convert(t.offset);
          let f = r.centerPoint.add(p);
          const m = r.screenPointToLocation(f),
            g = this.cameraHelper.handleFlyTo(r, {
              bearing: c,
              pitch: h,
              roll: u,
              padding: d,
              locationAtOffset: m,
              offsetAsPoint: p,
              center: t.center,
              minZoom: t.minZoom,
              zoom: t.zoom,
            });
          let _ = t.curve;
          const y = Math.max(r.width, r.height),
            v = y / g.scaleOfZoom,
            x = g.pixelPathLength;
          'number' == typeof g.scaleOfMinZoom &&
            (_ = Math.sqrt((y / g.scaleOfMinZoom / x) * 2));
          const b = _ * _;
          function w(t) {
            const e =
              (v * v - y * y + (t ? -1 : 1) * b * b * x * x) /
              (2 * (t ? v : y) * b * x);
            return Math.log(Math.sqrt(e * e + 1) - e);
          }
          function T(t) {
            return (Math.exp(t) - Math.exp(-t)) / 2;
          }
          function P(t) {
            return (Math.exp(t) + Math.exp(-t)) / 2;
          }
          const C = w(!1);
          let I = function (t) {
              return P(C) / P(C + _ * t);
            },
            S = function (t) {
              return (
                (y * ((P(C) * (T((e = C + _ * t)) / P(e)) - T(C)) / b)) / x
              );
              var e;
            },
            M = (w(!0) - C) / _;
          if (Math.abs(x) < 2e-6 || !isFinite(M)) {
            if (Math.abs(y - v) < 1e-6) return this.easeTo(t, i);
            const e = v < y ? -1 : 1;
            (M = Math.abs(Math.log(v / y)) / _),
              (S = () => 0),
              (I = (t) => Math.exp(e * _ * t));
          }
          return (
            (t.duration =
              'duration' in t
                ? +t.duration
                : (1e3 * M) /
                  ('screenSpeed' in t ? +t.screenSpeed / _ : +t.speed)),
            t.maxDuration && t.duration > t.maxDuration && (t.duration = 0),
            (this._zooming = !0),
            (this._rotating = n !== c),
            (this._pitching = h !== a),
            (this._rolling = u !== o),
            (this._padding = !r.isPaddingEqual(d)),
            this._prepareEase(i, !1),
            this.terrain && this._prepareElevation(g.targetCenter),
            this._ease(
              (s) => {
                const m = s * M,
                  _ = 1 / I(m),
                  y = S(m);
                this._rotating && r.setBearing(e.F.number(n, c, s)),
                  this._pitching && r.setPitch(e.F.number(a, h, s)),
                  this._rolling && r.setRoll(e.F.number(o, u, s)),
                  this._padding &&
                    (r.interpolatePadding(l, d, s), (f = r.centerPoint.add(p))),
                  g.easeFunc(s, _, y, f),
                  this.terrain &&
                    !t.freezeElevation &&
                    this._updateElevation(s),
                  this._applyUpdatedTransform(r),
                  this._fireMoveEvents(i);
              },
              () => {
                this.terrain && t.freezeElevation && this._finalizeElevation(),
                  this._afterEase(i);
              },
              t
            ),
            this
          );
        }
        isEasing() {
          return !!this._easeFrameId;
        }
        stop() {
          return this._stop();
        }
        _stop(t, e) {
          var i;
          if (
            (this._easeFrameId &&
              (this._cancelRenderFrame(this._easeFrameId),
              delete this._easeFrameId,
              delete this._onEaseFrame),
            this._onEaseEnd)
          ) {
            const t = this._onEaseEnd;
            delete this._onEaseEnd, t.call(this, e);
          }
          return (
            t || null === (i = this.handlers) || void 0 === i || i.stop(!1),
            this
          );
        }
        _ease(t, e, i) {
          !1 === i.animate || 0 === i.duration
            ? (t(1), e())
            : ((this._easeStart = l()),
              (this._easeOptions = i),
              (this._onEaseFrame = t),
              (this._onEaseEnd = e),
              (this._easeFrameId = this._requestRenderFrame(
                this._renderFrameCallback
              )));
        }
        _normalizeBearing(t, i) {
          t = e.V(t, -180, 180);
          const r = Math.abs(t - i);
          return (
            Math.abs(t - 360 - i) < r && (t -= 360),
            Math.abs(t + 360 - i) < r && (t += 360),
            t
          );
        }
        queryTerrainElevation(t) {
          return this.terrain
            ? this.terrain.getElevationForLngLatZoom(
                e.U.convert(t),
                this.transform.tileZoom
              )
            : null;
        }
      }
      const Ua = {
        compact: !0,
        customAttribution:
          '<a href="https://maplibre.org/" target="_blank">MapLibre</a>',
      };
      class Ga {
        constructor(t = Ua) {
          (this._toggleAttribution = () => {
            this._container.classList.contains('maplibregl-compact') &&
              (this._container.classList.contains('maplibregl-compact-show')
                ? (this._container.setAttribute('open', ''),
                  this._container.classList.remove('maplibregl-compact-show'))
                : (this._container.classList.add('maplibregl-compact-show'),
                  this._container.removeAttribute('open')));
          }),
            (this._updateData = (t) => {
              !t ||
                ('metadata' !== t.sourceDataType &&
                  'visibility' !== t.sourceDataType &&
                  'style' !== t.dataType &&
                  'terrain' !== t.type) ||
                this._updateAttributions();
            }),
            (this._updateCompact = () => {
              this._map.getCanvasContainer().offsetWidth <= 640 || this._compact
                ? !1 === this._compact
                  ? this._container.setAttribute('open', '')
                  : this._container.classList.contains('maplibregl-compact') ||
                    this._container.classList.contains(
                      'maplibregl-attrib-empty'
                    ) ||
                    (this._container.setAttribute('open', ''),
                    this._container.classList.add(
                      'maplibregl-compact',
                      'maplibregl-compact-show'
                    ))
                : (this._container.setAttribute('open', ''),
                  this._container.classList.contains('maplibregl-compact') &&
                    this._container.classList.remove(
                      'maplibregl-compact',
                      'maplibregl-compact-show'
                    ));
            }),
            (this._updateCompactMinimize = () => {
              this._container.classList.contains('maplibregl-compact') &&
                this._container.classList.contains('maplibregl-compact-show') &&
                this._container.classList.remove('maplibregl-compact-show');
            }),
            (this.options = t);
        }
        getDefaultPosition() {
          return 'bottom-right';
        }
        onAdd(t) {
          return (
            (this._map = t),
            (this._compact = this.options.compact),
            (this._container = c.create(
              'details',
              'maplibregl-ctrl maplibregl-ctrl-attrib'
            )),
            (this._compactButton = c.create(
              'summary',
              'maplibregl-ctrl-attrib-button',
              this._container
            )),
            this._compactButton.addEventListener(
              'click',
              this._toggleAttribution
            ),
            this._setElementTitle(this._compactButton, 'ToggleAttribution'),
            (this._innerContainer = c.create(
              'div',
              'maplibregl-ctrl-attrib-inner',
              this._container
            )),
            this._updateAttributions(),
            this._updateCompact(),
            this._map.on('styledata', this._updateData),
            this._map.on('sourcedata', this._updateData),
            this._map.on('terrain', this._updateData),
            this._map.on('resize', this._updateCompact),
            this._map.on('drag', this._updateCompactMinimize),
            this._container
          );
        }
        onRemove() {
          c.remove(this._container),
            this._map.off('styledata', this._updateData),
            this._map.off('sourcedata', this._updateData),
            this._map.off('terrain', this._updateData),
            this._map.off('resize', this._updateCompact),
            this._map.off('drag', this._updateCompactMinimize),
            (this._map = void 0),
            (this._compact = void 0),
            (this._attribHTML = void 0);
        }
        _setElementTitle(t, e) {
          const i = this._map._getUIString(`AttributionControl.${e}`);
          (t.title = i), t.setAttribute('aria-label', i);
        }
        _updateAttributions() {
          if (!this._map.style) return;
          let t = [];
          if (
            (this.options.customAttribution &&
              (Array.isArray(this.options.customAttribution)
                ? (t = t.concat(
                    this.options.customAttribution.map((t) =>
                      'string' != typeof t ? '' : t
                    )
                  ))
                : 'string' == typeof this.options.customAttribution &&
                  t.push(this.options.customAttribution)),
            this._map.style.stylesheet)
          ) {
            const t = this._map.style.stylesheet;
            (this.styleOwner = t.owner), (this.styleId = t.id);
          }
          const e = this._map.style.tileManagers;
          for (const r in e) {
            const i = e[r];
            if (i.used || i.usedForTerrain) {
              const e = i.getSource();
              e.attribution &&
                t.indexOf(e.attribution) < 0 &&
                t.push(e.attribution);
            }
          }
          (t = t.filter((t) => String(t).trim())),
            t.sort((t, e) => t.length - e.length),
            (t = t.filter((e, i) => {
              for (let r = i + 1; r < t.length; r++)
                if (t[r].indexOf(e) >= 0) return !1;
              return !0;
            }));
          const i = t.join(' | ');
          i !== this._attribHTML &&
            ((this._attribHTML = i),
            t.length
              ? ((this._innerContainer.innerHTML = c.sanitize(i)),
                this._container.classList.remove('maplibregl-attrib-empty'))
              : this._container.classList.add('maplibregl-attrib-empty'),
            this._updateCompact(),
            (this._editLink = null));
        }
      }
      class Za {
        constructor(t = {}) {
          (this._updateCompact = () => {
            const t = this._container.children;
            if (t.length) {
              const e = t[0];
              this._map.getCanvasContainer().offsetWidth <= 640 || this._compact
                ? !1 !== this._compact && e.classList.add('maplibregl-compact')
                : e.classList.remove('maplibregl-compact');
            }
          }),
            (this.options = t);
        }
        getDefaultPosition() {
          return 'bottom-left';
        }
        onAdd(t) {
          (this._map = t),
            (this._compact = this.options && this.options.compact),
            (this._container = c.create('div', 'maplibregl-ctrl'));
          const e = c.create('a', 'maplibregl-ctrl-logo');
          return (
            (e.target = '_blank'),
            (e.rel = 'noopener nofollow'),
            (e.href = 'https://maplibre.org/'),
            e.setAttribute(
              'aria-label',
              this._map._getUIString('LogoControl.Title')
            ),
            e.setAttribute('rel', 'noopener nofollow'),
            this._container.appendChild(e),
            (this._container.style.display = 'block'),
            this._map.on('resize', this._updateCompact),
            this._updateCompact(),
            this._container
          );
        }
        onRemove() {
          c.remove(this._container),
            this._map.off('resize', this._updateCompact),
            (this._map = void 0),
            (this._compact = void 0);
        }
      }
      class $a {
        constructor() {
          (this._queue = []),
            (this._id = 0),
            (this._cleared = !1),
            (this._currentlyRunning = !1);
        }
        add(t) {
          const e = ++this._id;
          return this._queue.push({ callback: t, id: e, cancelled: !1 }), e;
        }
        remove(t) {
          const e = this._currentlyRunning,
            i = e ? this._queue.concat(e) : this._queue;
          for (const r of i) if (r.id === t) return void (r.cancelled = !0);
        }
        run(t = 0) {
          if (this._currentlyRunning)
            throw new Error('Attempting to run(), but is already running.');
          const e = (this._currentlyRunning = this._queue);
          this._queue = [];
          for (const i of e)
            if (!i.cancelled && (i.callback(t), this._cleared)) break;
          (this._cleared = !1), (this._currentlyRunning = !1);
        }
        clear() {
          this._currentlyRunning && (this._cleared = !0), (this._queue = []);
        }
      }
      var qa = e.aN([{ name: 'a_pos3d', type: 'Int16', components: 3 }]);
      class Ha extends e.E {
        constructor(t) {
          super(),
            (this._lastTilesetChange = l()),
            (this.tileManager = t),
            (this._tiles = {}),
            (this._renderableTilesKeys = []),
            (this._sourceTileCache = {}),
            (this.minzoom = 0),
            (this.maxzoom = 22),
            (this.deltaZoom = 1),
            (this.tileSize = t._source.tileSize * 2 ** this.deltaZoom),
            (t.usedForTerrain = !0),
            (t.tileSize = this.tileSize);
        }
        destruct() {
          (this.tileManager.usedForTerrain = !1),
            (this.tileManager.tileSize = null);
        }
        getSource() {
          return this.tileManager._source;
        }
        update(t, i) {
          this.tileManager.update(t, i), (this._renderableTilesKeys = []);
          const r = {};
          for (const n of Ct(t, {
            tileSize: this.tileSize,
            minzoom: this.minzoom,
            maxzoom: this.maxzoom,
            reparseOverscaled: !1,
            terrain: i,
            calculateTileZoom: this.tileManager._source.calculateTileZoom,
          }))
            (r[n.key] = !0),
              this._renderableTilesKeys.push(n.key),
              this._tiles[n.key] ||
                ((n.terrainRttPosMatrix32f = new Float64Array(16)),
                e.c0(n.terrainRttPosMatrix32f, 0, e.a3, e.a3, 0, 0, 1),
                (this._tiles[n.key] = new ut(n, this.tileSize)),
                (this._lastTilesetChange = l()));
          for (const e in this._tiles) r[e] || delete this._tiles[e];
        }
        freeRtt(t) {
          for (const e in this._tiles) {
            const i = this._tiles[e];
            (!t ||
              i.tileID.equals(t) ||
              i.tileID.isChildOf(t) ||
              t.isChildOf(i.tileID)) &&
              (i.rtt = []);
          }
        }
        getRenderableTiles() {
          return this._renderableTilesKeys.map((t) => this.getTileByID(t));
        }
        getTileByID(t) {
          return this._tiles[t];
        }
        getTerrainCoords(t, e) {
          return e
            ? this._getTerrainCoordsForTileRanges(t, e)
            : this._getTerrainCoordsForRegularTile(t);
        }
        _getTerrainCoordsForRegularTile(t) {
          const i = {};
          for (const r of this._renderableTilesKeys) {
            const n = this._tiles[r].tileID,
              a = t.clone(),
              s = e.bd();
            if (n.canonical.equals(t.canonical))
              e.c0(s, 0, e.a3, e.a3, 0, 0, 1);
            else if (n.canonical.isChildOf(t.canonical)) {
              const i = n.canonical.z - t.canonical.z,
                r = n.canonical.x - ((n.canonical.x >> i) << i),
                a = n.canonical.y - ((n.canonical.y >> i) << i),
                o = e.a3 >> i;
              e.c0(s, 0, o, o, 0, 0, 1), e.N(s, s, [-r * o, -a * o, 0]);
            } else {
              if (!t.canonical.isChildOf(n.canonical)) continue;
              {
                const i = t.canonical.z - n.canonical.z,
                  r = t.canonical.x - ((t.canonical.x >> i) << i),
                  a = t.canonical.y - ((t.canonical.y >> i) << i),
                  o = e.a3 >> i;
                e.c0(s, 0, e.a3, e.a3, 0, 0, 1),
                  e.N(s, s, [r * o, a * o, 0]),
                  e.O(s, s, [1 / 2 ** i, 1 / 2 ** i, 0]);
              }
            }
            (a.terrainRttPosMatrix32f = new Float32Array(s)), (i[r] = a);
          }
          return i;
        }
        _getTerrainCoordsForTileRanges(t, i) {
          const r = {};
          for (const n of this._renderableTilesKeys) {
            const a = this._tiles[n].tileID;
            if (!this._isWithinTileRanges(a, i)) continue;
            const s = t.clone(),
              o = e.bd();
            if (a.canonical.z === t.canonical.z) {
              const i = t.canonical.x - a.canonical.x,
                r = t.canonical.y - a.canonical.y;
              e.c0(o, 0, e.a3, e.a3, 0, 0, 1),
                e.N(o, o, [i * e.a3, r * e.a3, 0]);
            } else if (a.canonical.z > t.canonical.z) {
              const i = a.canonical.z - t.canonical.z,
                r = a.canonical.x - ((a.canonical.x >> i) << i),
                n = a.canonical.y - ((a.canonical.y >> i) << i),
                s = t.canonical.x - (a.canonical.x >> i),
                l = t.canonical.y - (a.canonical.y >> i),
                c = e.a3 >> i;
              e.c0(o, 0, c, c, 0, 0, 1),
                e.N(o, o, [-r * c + s * e.a3, -n * c + l * e.a3, 0]);
            } else {
              const i = t.canonical.z - a.canonical.z,
                r = t.canonical.x - ((t.canonical.x >> i) << i),
                n = t.canonical.y - ((t.canonical.y >> i) << i),
                s = (t.canonical.x >> i) - a.canonical.x,
                l = (t.canonical.y >> i) - a.canonical.y,
                c = e.a3 << i;
              e.c0(o, 0, c, c, 0, 0, 1),
                e.N(o, o, [r * e.a3 + s * c, n * e.a3 + l * c, 0]);
            }
            (s.terrainRttPosMatrix32f = new Float32Array(o)), (r[n] = s);
          }
          return r;
        }
        getSourceTile(t, e) {
          const i = this.tileManager._source;
          let r = t.overscaledZ - this.deltaZoom;
          if ((r > i.maxzoom && (r = i.maxzoom), r < i.minzoom)) return null;
          this._sourceTileCache[t.key] ||
            (this._sourceTileCache[t.key] = t.scaledTo(r).key);
          let n = this.tileManager.getTileByID(this._sourceTileCache[t.key]);
          if ((!n || !n.dem) && e)
            for (; r >= i.minzoom && (!n || !n.dem); )
              n = this.tileManager.getTileByID(t.scaledTo(r--).key);
          return n;
        }
        anyTilesAfterTime(t = Date.now()) {
          return this._lastTilesetChange >= t;
        }
        _isWithinTileRanges(t, e) {
          return (
            e[t.canonical.z] &&
            t.canonical.x >= e[t.canonical.z].minTileX &&
            t.canonical.x <= e[t.canonical.z].maxTileX &&
            t.canonical.y >= e[t.canonical.z].minTileY &&
            t.canonical.y <= e[t.canonical.z].maxTileY
          );
        }
      }
      class Wa {
        constructor(t, e, i) {
          (this._meshCache = {}),
            (this.painter = t),
            (this.tileManager = new Ha(e)),
            (this.options = i),
            (this.exaggeration =
              'number' == typeof i.exaggeration ? i.exaggeration : 1),
            (this.qualityFactor = 2),
            (this.meshSize = 128),
            (this._demMatrixCache = {}),
            (this.coordsIndex = []),
            (this._coordsTextureSize = 1024);
        }
        getDEMElevation(t, i, r, n = e.a3) {
          var a;
          if (!(i >= 0 && i < n && r >= 0 && r < n)) return 0;
          const s = this.getTerrainData(t),
            o = null === (a = s.tile) || void 0 === a ? void 0 : a.dem;
          if (!o) return 0;
          const l = e.cv(
              [],
              [(i / n) * e.a3, (r / n) * e.a3],
              s.u_terrain_matrix
            ),
            c = [l[0] * o.dim, l[1] * o.dim],
            h = Math.floor(c[0]),
            u = Math.floor(c[1]),
            d = c[0] - h,
            p = c[1] - u;
          return (
            o.get(h, u) * (1 - d) * (1 - p) +
            o.get(h + 1, u) * d * (1 - p) +
            o.get(h, u + 1) * (1 - d) * p +
            o.get(h + 1, u + 1) * d * p
          );
        }
        getElevationForLngLatZoom(t, i) {
          if (!e.cw(i, t.wrap())) return 0;
          const {
            tileID: r,
            mercatorX: n,
            mercatorY: a,
          } = this._getOverscaledTileIDFromLngLatZoom(t, i);
          return this.getElevation(r, n % e.a3, a % e.a3, e.a3);
        }
        getElevation(t, i, r, n = e.a3) {
          return this.getDEMElevation(t, i, r, n) * this.exaggeration;
        }
        getTerrainData(t) {
          if (!this._emptyDemTexture) {
            const t = this.painter.context,
              i = new e.R({ width: 1, height: 1 }, new Uint8Array(4));
            (this._emptyDepthTexture = new e.T(t, i, t.gl.RGBA, {
              premultiply: !1,
            })),
              (this._emptyDemUnpack = [0, 0, 0, 0]),
              (this._emptyDemTexture = new e.T(
                t,
                new e.R({ width: 1, height: 1 }),
                t.gl.RGBA,
                { premultiply: !1 }
              )),
              this._emptyDemTexture.bind(t.gl.NEAREST, t.gl.CLAMP_TO_EDGE),
              (this._emptyDemMatrix = e.am([]));
          }
          const i = this.tileManager.getSourceTile(t, !0);
          if (i && i.dem && (!i.demTexture || i.needsTerrainPrepare)) {
            const t = this.painter.context;
            (i.demTexture = this.painter.getTileTexture(i.dem.stride)),
              i.demTexture
                ? i.demTexture.update(i.dem.getPixels(), { premultiply: !1 })
                : (i.demTexture = new e.T(t, i.dem.getPixels(), t.gl.RGBA, {
                    premultiply: !1,
                  })),
              i.demTexture.bind(t.gl.NEAREST, t.gl.CLAMP_TO_EDGE),
              (i.needsTerrainPrepare = !1);
          }
          const r = i && i + i.tileID.key + t.key;
          if (r && !this._demMatrixCache[r]) {
            const r = this.tileManager.getSource().maxzoom;
            let n = t.canonical.z - i.tileID.canonical.z;
            t.overscaledZ > t.canonical.z &&
              (t.canonical.z >= r
                ? (n = t.canonical.z - r)
                : e.w(
                    'cannot calculate elevation if elevation maxzoom > source.maxzoom'
                  ));
            const a = t.canonical.x - ((t.canonical.x >> n) << n),
              s = t.canonical.y - ((t.canonical.y >> n) << n),
              o = e.cx(new Float64Array(16), [
                1 / (e.a3 << n),
                1 / (e.a3 << n),
                0,
              ]);
            e.N(o, o, [a * e.a3, s * e.a3, 0]),
              (this._demMatrixCache[t.key] = { matrix: o, coord: t });
          }
          return {
            u_depth: 2,
            u_terrain: 3,
            u_terrain_dim: (i && i.dem && i.dem.dim) || 1,
            u_terrain_matrix: r
              ? this._demMatrixCache[t.key].matrix
              : this._emptyDemMatrix,
            u_terrain_unpack:
              (i && i.dem && i.dem.getUnpackVector()) || this._emptyDemUnpack,
            u_terrain_exaggeration: this.exaggeration,
            texture: ((i && i.demTexture) || this._emptyDemTexture).texture,
            depthTexture: (this._fboDepthTexture || this._emptyDepthTexture)
              .texture,
            tile: i,
          };
        }
        getFramebuffer(t) {
          const i = this.painter,
            r = i.width / devicePixelRatio,
            n = i.height / devicePixelRatio;
          return (
            !this._fbo ||
              (this._fbo.width === r && this._fbo.height === n) ||
              (this._fbo.destroy(),
              this._fboCoordsTexture.destroy(),
              this._fboDepthTexture.destroy(),
              delete this._fbo,
              delete this._fboDepthTexture,
              delete this._fboCoordsTexture),
            this._fboCoordsTexture ||
              ((this._fboCoordsTexture = new e.T(
                i.context,
                { width: r, height: n, data: null },
                i.context.gl.RGBA,
                { premultiply: !1 }
              )),
              this._fboCoordsTexture.bind(
                i.context.gl.NEAREST,
                i.context.gl.CLAMP_TO_EDGE
              )),
            this._fboDepthTexture ||
              ((this._fboDepthTexture = new e.T(
                i.context,
                { width: r, height: n, data: null },
                i.context.gl.RGBA,
                { premultiply: !1 }
              )),
              this._fboDepthTexture.bind(
                i.context.gl.NEAREST,
                i.context.gl.CLAMP_TO_EDGE
              )),
            this._fbo ||
              ((this._fbo = i.context.createFramebuffer(r, n, !0, !1)),
              this._fbo.depthAttachment.set(
                i.context.createRenderbuffer(
                  i.context.gl.DEPTH_COMPONENT16,
                  r,
                  n
                )
              )),
            this._fbo.colorAttachment.set(
              'coords' === t
                ? this._fboCoordsTexture.texture
                : this._fboDepthTexture.texture
            ),
            this._fbo
          );
        }
        getCoordsTexture() {
          const t = this.painter.context;
          if (this._coordsTexture) return this._coordsTexture;
          const i = new Uint8Array(
            this._coordsTextureSize * this._coordsTextureSize * 4
          );
          for (let e = 0, a = 0; e < this._coordsTextureSize; e++)
            for (let t = 0; t < this._coordsTextureSize; t++, a += 4)
              (i[a + 0] = 255 & t),
                (i[a + 1] = 255 & e),
                (i[a + 2] = ((t >> 8) << 4) | (e >> 8)),
                (i[a + 3] = 0);
          const r = new e.R(
              {
                width: this._coordsTextureSize,
                height: this._coordsTextureSize,
              },
              new Uint8Array(i.buffer)
            ),
            n = new e.T(t, r, t.gl.RGBA, { premultiply: !1 });
          return (
            n.bind(t.gl.NEAREST, t.gl.CLAMP_TO_EDGE),
            (this._coordsTexture = n),
            n
          );
        }
        pointCoordinate(t) {
          this.painter.maybeDrawDepthAndCoords(!0);
          const i = new Uint8Array(4),
            r = this.painter.context,
            n = r.gl,
            a = Math.round((t.x * this.painter.pixelRatio) / devicePixelRatio),
            s = Math.round((t.y * this.painter.pixelRatio) / devicePixelRatio),
            o = Math.round(this.painter.height / devicePixelRatio);
          r.bindFramebuffer.set(this.getFramebuffer('coords').framebuffer),
            n.readPixels(a, o - s - 1, 1, 1, n.RGBA, n.UNSIGNED_BYTE, i),
            r.bindFramebuffer.set(null);
          const l = i[0] + ((i[2] >> 4) << 8),
            c = i[1] + ((15 & i[2]) << 8),
            h = this.coordsIndex[255 - i[3]],
            u = h && this.tileManager.getTileByID(h);
          if (!u) return null;
          const d = this._coordsTextureSize,
            p = (1 << u.tileID.canonical.z) * d;
          return new e.a5(
            (u.tileID.canonical.x * d + l) / p + u.tileID.wrap,
            (u.tileID.canonical.y * d + c) / p,
            this.getElevation(u.tileID, l, c, d)
          );
        }
        depthAtPoint(t) {
          const e = new Uint8Array(4),
            i = this.painter.context,
            r = i.gl;
          return (
            i.bindFramebuffer.set(this.getFramebuffer('depth').framebuffer),
            r.readPixels(
              t.x,
              this.painter.height / devicePixelRatio - t.y - 1,
              1,
              1,
              r.RGBA,
              r.UNSIGNED_BYTE,
              e
            ),
            i.bindFramebuffer.set(null),
            (e[0] / 16777216 + e[1] / 65536 + e[2] / 256 + e[3]) / 256
          );
        }
        getTerrainMesh(t) {
          var i;
          const r =
              (null === (i = this.painter.style.projection) || void 0 === i
                ? void 0
                : i.transitionState) > 0,
            n = r && 0 === t.canonical.y,
            a = r && t.canonical.y === (1 << t.canonical.z) - 1,
            s = `m_${n ? 'n' : ''}_${a ? 's' : ''}`;
          if (this._meshCache[s]) return this._meshCache[s];
          const o = this.painter.context,
            l = new e.cy(),
            c = new e.aR(),
            h = this.meshSize,
            u = e.a3 / h,
            d = h * h;
          for (let e = 0; e <= h; e++)
            for (let t = 0; t <= h; t++) l.emplaceBack(t * u, e * u, 0);
          for (let e = 0; e < d; e += h + 1)
            for (let t = 0; t < h; t++)
              c.emplaceBack(t + e, h + t + e + 1, h + t + e + 2),
                c.emplaceBack(t + e, h + t + e + 2, t + e + 1);
          const p = l.length,
            f = p + (h + 1),
            m = (h + 1) * h,
            g = n ? e.bk : 0,
            _ = n ? 0 : 1,
            y = a ? e.bl : e.a3,
            v = a ? 0 : 1;
          for (let e = 0; e <= h; e++) l.emplaceBack(e * u, g, _);
          for (let e = 0; e <= h; e++) l.emplaceBack(e * u, y, v);
          for (let e = 0; e < h; e++)
            c.emplaceBack(m + e, f + e, f + e + 1),
              c.emplaceBack(m + e, f + e + 1, m + e + 1),
              c.emplaceBack(0 + e, p + e + 1, p + e),
              c.emplaceBack(0 + e, 0 + e + 1, p + e + 1);
          const x = l.length,
            b = x + 2 * (h + 1);
          for (const T of [0, 1])
            for (let t = 0; t <= h; t++)
              for (const i of [0, 1]) l.emplaceBack(T * e.a3, t * u, i);
          for (let e = 0; e < 2 * h; e += 2)
            c.emplaceBack(x + e, x + e + 1, x + e + 3),
              c.emplaceBack(x + e, x + e + 3, x + e + 2),
              c.emplaceBack(b + e, b + e + 3, b + e + 1),
              c.emplaceBack(b + e, b + e + 2, b + e + 3);
          const w = new De(
            o.createVertexBuffer(l, qa.members),
            o.createIndexBuffer(c),
            e.aQ.simpleSegment(0, 0, l.length, c.length)
          );
          return (this._meshCache[s] = w), w;
        }
        getMeshFrameDelta(t) {
          return (2 * Math.PI * e.bx) / Math.pow(2, Math.max(t, 0)) / 5;
        }
        getMinTileElevationForLngLatZoom(t, e) {
          var i;
          const { tileID: r } = this._getOverscaledTileIDFromLngLatZoom(t, e);
          return null !== (i = this.getMinMaxElevation(r).minElevation) &&
            void 0 !== i
            ? i
            : 0;
        }
        getMinMaxElevation(t) {
          const e = this.getTerrainData(t).tile,
            i = { minElevation: null, maxElevation: null };
          return (
            e &&
              e.dem &&
              ((i.minElevation = e.dem.min * this.exaggeration),
              (i.maxElevation = e.dem.max * this.exaggeration)),
            i
          );
        }
        _getOverscaledTileIDFromLngLatZoom(t, i) {
          const r = e.a5.fromLngLat(t.wrap()),
            n = (1 << i) * e.a3,
            a = r.x * n,
            s = r.y * n,
            o = Math.floor(a / e.a3),
            l = Math.floor(s / e.a3);
          return {
            tileID: new e.a0(i, 0, i, o, l),
            mercatorX: a,
            mercatorY: s,
          };
        }
      }
      class Xa {
        constructor(t, e, i) {
          (this._context = t),
            (this._size = e),
            (this._tileSize = i),
            (this._objects = []),
            (this._recentlyUsed = []),
            (this._stamp = 0);
        }
        destruct() {
          for (const t of this._objects) t.texture.destroy(), t.fbo.destroy();
        }
        _createObject(t) {
          const i = this._context.createFramebuffer(
              this._tileSize,
              this._tileSize,
              !0,
              !0
            ),
            r = new e.T(
              this._context,
              { width: this._tileSize, height: this._tileSize, data: null },
              this._context.gl.RGBA
            );
          return (
            r.bind(this._context.gl.LINEAR, this._context.gl.CLAMP_TO_EDGE),
            this._context.extTextureFilterAnisotropic &&
              this._context.gl.texParameterf(
                this._context.gl.TEXTURE_2D,
                this._context.extTextureFilterAnisotropic
                  .TEXTURE_MAX_ANISOTROPY_EXT,
                this._context.extTextureFilterAnisotropicMax
              ),
            i.depthAttachment.set(
              this._context.createRenderbuffer(
                this._context.gl.DEPTH_STENCIL,
                this._tileSize,
                this._tileSize
              )
            ),
            i.colorAttachment.set(r.texture),
            { id: t, fbo: i, texture: r, stamp: -1, inUse: !1 }
          );
        }
        getObjectForId(t) {
          return this._objects[t];
        }
        useObject(t) {
          (t.inUse = !0),
            (this._recentlyUsed = this._recentlyUsed.filter((e) => t.id !== e)),
            this._recentlyUsed.push(t.id);
        }
        stampObject(t) {
          t.stamp = ++this._stamp;
        }
        getOrCreateFreeObject() {
          for (const e of this._recentlyUsed)
            if (!this._objects[e].inUse) return this._objects[e];
          if (this._objects.length >= this._size)
            throw new Error(
              'No free RenderPool available, call freeAllObjects() required!'
            );
          const t = this._createObject(this._objects.length);
          return this._objects.push(t), t;
        }
        freeObject(t) {
          t.inUse = !1;
        }
        freeAllObjects() {
          for (const t of this._objects) this.freeObject(t);
        }
        isFull() {
          return (
            !(this._objects.length < this._size) &&
            !1 === this._objects.some((t) => !t.inUse)
          );
        }
      }
      const Ya = {
        'background': !0,
        'fill': !0,
        'line': !0,
        'raster': !0,
        'hillshade': !0,
        'color-relief': !0,
      };
      class Ka {
        constructor(t, e) {
          (this.painter = t),
            (this.terrain = e),
            (this.pool = new Xa(
              t.context,
              30,
              e.tileManager.tileSize * e.qualityFactor
            ));
        }
        destruct() {
          this.pool.destruct();
        }
        getTexture(t) {
          return this.pool.getObjectForId(
            t.rtt[this._stacks.length - 1].id
          ).texture;
        }
        prepareForRender(t, e) {
          (this._stacks = []),
            (this._prevType = null),
            (this._rttTiles = []),
            (this._renderableTiles =
              this.terrain.tileManager.getRenderableTiles()),
            (this._renderableLayerIds = t._order.filter(
              (i) => !t._layers[i].isHidden(e)
            )),
            (this._coordsAscending = {});
          for (const i in t.tileManagers) {
            this._coordsAscending[i] = {};
            const e = t.tileManagers[i].getVisibleCoordinates(),
              r = t.tileManagers[i].getSource(),
              n = r instanceof tt ? r.terrainTileRanges : null;
            for (const t of e) {
              const e = this.terrain.tileManager.getTerrainCoords(t, n);
              for (const t in e)
                this._coordsAscending[i][t] ||
                  (this._coordsAscending[i][t] = []),
                  this._coordsAscending[i][t].push(e[t]);
            }
          }
          this._coordsAscendingStr = {};
          for (const i of t._order) {
            const e = t._layers[i],
              r = e.source;
            if (Ya[e.type] && !this._coordsAscendingStr[r]) {
              this._coordsAscendingStr[r] = {};
              for (const t in this._coordsAscending[r])
                this._coordsAscendingStr[r][t] = this._coordsAscending[r][t]
                  .map((t) => t.key)
                  .sort()
                  .join();
            }
          }
          for (const i of this._renderableTiles)
            for (const t in this._coordsAscendingStr) {
              const e = this._coordsAscendingStr[t][i.tileID.key];
              e && e !== i.rttCoords[t] && (i.rtt = []);
            }
        }
        renderLayer(t, i) {
          if (t.isHidden(this.painter.transform.zoom)) return !1;
          const r = Object.assign(Object.assign({}, i), {
              isRenderingToTexture: !0,
            }),
            n = t.type,
            a = this.painter,
            s =
              this._renderableLayerIds[this._renderableLayerIds.length - 1] ===
              t.id;
          if (
            Ya[n] &&
            ((this._prevType && Ya[this._prevType]) || this._stacks.push([]),
            (this._prevType = n),
            this._stacks[this._stacks.length - 1].push(t.id),
            !s)
          )
            return !0;
          if (Ya[this._prevType] || (Ya[n] && s)) {
            this._prevType = n;
            const t = this._stacks.length - 1,
              i = this._stacks[t] || [];
            for (const n of this._renderableTiles) {
              if (
                (this.pool.isFull() &&
                  (Bn(this.painter, this.terrain, this._rttTiles, r),
                  (this._rttTiles = []),
                  this.pool.freeAllObjects()),
                this._rttTiles.push(n),
                n.rtt[t])
              ) {
                const e = this.pool.getObjectForId(n.rtt[t].id);
                if (e.stamp === n.rtt[t].stamp) {
                  this.pool.useObject(e);
                  continue;
                }
              }
              const s = this.pool.getOrCreateFreeObject();
              this.pool.useObject(s),
                this.pool.stampObject(s),
                (n.rtt[t] = { id: s.id, stamp: s.stamp }),
                a.context.bindFramebuffer.set(s.fbo.framebuffer),
                a.context.clear({ color: e.bi.transparent, stencil: 0 }),
                (a.currentStencilSource = void 0);
              for (let t = 0; t < i.length; t++) {
                const e = a.style._layers[i[t]],
                  o = e.source
                    ? this._coordsAscending[e.source][n.tileID.key]
                    : [n.tileID];
                a.context.viewport.set([0, 0, s.fbo.width, s.fbo.height]),
                  a._renderTileClippingMasks(e, o, !0),
                  a.renderLayer(a, a.style.tileManagers[e.source], e, o, r),
                  e.source &&
                    (n.rttCoords[e.source] =
                      this._coordsAscendingStr[e.source][n.tileID.key]);
              }
            }
            return (
              Bn(this.painter, this.terrain, this._rttTiles, r),
              (this._rttTiles = []),
              this.pool.freeAllObjects(),
              Ya[n]
            );
          }
          return !1;
        }
      }
      const Ja = {
          'AttributionControl.ToggleAttribution': 'Toggle attribution',
          'AttributionControl.MapFeedback': 'Map feedback',
          'FullscreenControl.Enter': 'Enter fullscreen',
          'FullscreenControl.Exit': 'Exit fullscreen',
          'GeolocateControl.FindMyLocation': 'Find my location',
          'GeolocateControl.LocationNotAvailable': 'Location not available',
          'LogoControl.Title': 'MapLibre logo',
          'Map.Title': 'Map',
          'Marker.Title': 'Map marker',
          'NavigationControl.ResetBearing': 'Reset bearing to north',
          'NavigationControl.ZoomIn': 'Zoom in',
          'NavigationControl.ZoomOut': 'Zoom out',
          'Popup.Close': 'Close popup',
          'ScaleControl.Feet': 'ft',
          'ScaleControl.Meters': 'm',
          'ScaleControl.Kilometers': 'km',
          'ScaleControl.Miles': 'mi',
          'ScaleControl.NauticalMiles': 'nm',
          'GlobeControl.Enable': 'Enable globe',
          'GlobeControl.Disable': 'Disable globe',
          'TerrainControl.Enable': 'Enable terrain',
          'TerrainControl.Disable': 'Disable terrain',
          'CooperativeGesturesHandler.WindowsHelpText':
            'Use Ctrl + scroll to zoom the map',
          'CooperativeGesturesHandler.MacHelpText':
            'Use  + scroll to zoom the map',
          'CooperativeGesturesHandler.MobileHelpText':
            'Use two fingers to move the map',
        },
        Qa = i,
        ts = {
          hash: !1,
          interactive: !0,
          bearingSnap: 7,
          attributionControl: Ua,
          maplibreLogo: !1,
          refreshExpiredTiles: !0,
          canvasContextAttributes: {
            antialias: !1,
            preserveDrawingBuffer: !1,
            powerPreference: 'high-performance',
            failIfMajorPerformanceCaveat: !1,
            desynchronized: !1,
            contextType: void 0,
          },
          scrollZoom: !0,
          minZoom: -2,
          maxZoom: 22,
          minPitch: 0,
          maxPitch: 60,
          boxZoom: !0,
          dragRotate: !0,
          dragPan: !0,
          keyboard: !0,
          doubleClickZoom: !0,
          touchZoomRotate: !0,
          touchPitch: !0,
          cooperativeGestures: !1,
          trackResize: !0,
          center: [0, 0],
          elevation: 0,
          zoom: 0,
          bearing: 0,
          pitch: 0,
          roll: 0,
          renderWorldCopies: !0,
          maxTileCacheSize: null,
          maxTileCacheZoomLevels: e.a.MAX_TILE_CACHE_ZOOM_LEVELS,
          transformRequest: null,
          transformCameraUpdate: null,
          transformConstrain: null,
          fadeDuration: 300,
          crossSourceCollisions: !0,
          clickTolerance: 3,
          localIdeographFontFamily: 'sans-serif',
          pitchWithRotate: !0,
          rollEnabled: !1,
          validateStyle: !0,
          maxCanvasSize: [4096, 4096],
          cancelPendingTileRequestsWhileZooming: !0,
          centerClampedToGround: !0,
        },
        es = {
          showCompass: !0,
          showZoom: !0,
          visualizePitch: !1,
          visualizeRoll: !0,
        };
      class is {
        constructor(t, i, r = !1) {
          (this.mousedown = (t) => {
            this.startMove(t, c.mousePos(this.element, t)),
              c.addEventListener(window, 'mousemove', this.mousemove),
              c.addEventListener(window, 'mouseup', this.mouseup);
          }),
            (this.mousemove = (t) => {
              this.move(t, c.mousePos(this.element, t));
            }),
            (this.mouseup = (t) => {
              this._rotatePitchHandler.dragEnd(t), this.offTemp();
            }),
            (this.touchstart = (t) => {
              1 !== t.targetTouches.length
                ? this.reset()
                : ((this._startPos = this._lastPos =
                    c.touchPos(this.element, t.targetTouches)[0]),
                  this.startMove(t, this._startPos),
                  c.addEventListener(window, 'touchmove', this.touchmove, {
                    passive: !1,
                  }),
                  c.addEventListener(window, 'touchend', this.touchend));
            }),
            (this.touchmove = (t) => {
              1 !== t.targetTouches.length
                ? this.reset()
                : ((this._lastPos = c.touchPos(
                    this.element,
                    t.targetTouches
                  )[0]),
                  this.move(t, this._lastPos));
            }),
            (this.touchend = (t) => {
              0 === t.targetTouches.length &&
                this._startPos &&
                this._lastPos &&
                this._startPos.dist(this._lastPos) < this._clickTolerance &&
                this.element.click(),
                delete this._startPos,
                delete this._lastPos,
                this.offTemp();
            }),
            (this.reset = () => {
              this._rotatePitchHandler.reset(),
                delete this._startPos,
                delete this._lastPos,
                this.offTemp();
            }),
            (this._clickTolerance = 10),
            (this.element = i);
          const n = new pa();
          (this._rotatePitchHandler = new ca({
            clickTolerance: 3,
            move: (t, n) => {
              const a = i.getBoundingClientRect(),
                s = new e.P((a.bottom - a.top) / 2, (a.right - a.left) / 2);
              return {
                bearingDelta: e.cq(new e.P(t.x, n.y), n, s),
                pitchDelta: r ? -0.5 * (n.y - t.y) : void 0,
              };
            },
            moveStateManager: n,
            enable: !0,
            assignEvents: () => {},
          })),
            (this.map = t),
            c.addEventListener(i, 'mousedown', this.mousedown),
            c.addEventListener(i, 'touchstart', this.touchstart, {
              passive: !1,
            }),
            c.addEventListener(i, 'touchcancel', this.reset);
        }
        startMove(t, e) {
          this._rotatePitchHandler.dragStart(t, e), c.disableDrag();
        }
        move(t, e) {
          const i = this.map,
            { bearingDelta: r, pitchDelta: n } =
              this._rotatePitchHandler.dragMove(t, e) || {};
          r && i.setBearing(i.getBearing() + r),
            n && i.setPitch(i.getPitch() + n);
        }
        off() {
          const t = this.element;
          c.removeEventListener(t, 'mousedown', this.mousedown),
            c.removeEventListener(t, 'touchstart', this.touchstart, {
              passive: !1,
            }),
            c.removeEventListener(window, 'touchmove', this.touchmove, {
              passive: !1,
            }),
            c.removeEventListener(window, 'touchend', this.touchend),
            c.removeEventListener(t, 'touchcancel', this.reset),
            this.offTemp();
        }
        offTemp() {
          c.enableDrag(),
            c.removeEventListener(window, 'mousemove', this.mousemove),
            c.removeEventListener(window, 'mouseup', this.mouseup),
            c.removeEventListener(window, 'touchmove', this.touchmove, {
              passive: !1,
            }),
            c.removeEventListener(window, 'touchend', this.touchend);
        }
      }
      let rs;
      function ns(t, i, r, n = !1) {
        if (n || !r.getCoveringTilesDetailsProvider().allowWorldCopies())
          return null == t ? void 0 : t.wrap();
        const a = new e.U(t.lng, t.lat);
        if (((t = new e.U(t.lng, t.lat)), i)) {
          const n = new e.U(t.lng - 360, t.lat),
            a = new e.U(t.lng + 360, t.lat),
            s = r.locationToScreenPoint(t).distSqr(i);
          r.locationToScreenPoint(n).distSqr(i) < s
            ? (t = n)
            : r.locationToScreenPoint(a).distSqr(i) < s && (t = a);
        }
        for (; Math.abs(t.lng - r.center.lng) > 180; ) {
          const e = r.locationToScreenPoint(t);
          if (e.x >= 0 && e.y >= 0 && e.x <= r.width && e.y <= r.height) break;
          t.lng > r.center.lng ? (t.lng -= 360) : (t.lng += 360);
        }
        return t.lng !== a.lng &&
          r.isPointOnMapSurface(r.locationToScreenPoint(t))
          ? t
          : a;
      }
      const as = {
        'center': 'translate(-50%,-50%)',
        'top': 'translate(-50%,0)',
        'top-left': 'translate(0,0)',
        'top-right': 'translate(-100%,0)',
        'bottom': 'translate(-50%,-100%)',
        'bottom-left': 'translate(0,-100%)',
        'bottom-right': 'translate(-100%,-100%)',
        'left': 'translate(0,-50%)',
        'right': 'translate(-100%,-50%)',
      };
      function ss(t, e, i) {
        const r = t.classList;
        for (const n in as) r.remove(`maplibregl-${i}-anchor-${n}`);
        r.add(`maplibregl-${i}-anchor-${e}`);
      }
      class os extends e.E {
        constructor(t) {
          if (
            (super(),
            (this._onKeyPress = (t) => {
              const e = t.code,
                i = t.charCode || t.keyCode;
              ('Space' !== e && 'Enter' !== e && 32 !== i && 13 !== i) ||
                this.togglePopup();
            }),
            (this._onMapClick = (t) => {
              const e = t.originalEvent.target,
                i = this._element;
              this._popup && (e === i || i.contains(e)) && this.togglePopup();
            }),
            (this._update = (t) => {
              if (!this._map) return;
              const e = this._map.loaded() && !this._map.isMoving();
              ('terrain' === (null == t ? void 0 : t.type) ||
                ('render' === (null == t ? void 0 : t.type) && !e)) &&
                this._map.once('render', this._update),
                (this._lngLat = ns(
                  this._lngLat,
                  this._flatPos,
                  this._map.transform
                )),
                (this._flatPos = this._pos =
                  this._map.project(this._lngLat)._add(this._offset)),
                this._map.terrain &&
                  (this._flatPos = this._map.transform
                    .locationToScreenPoint(this._lngLat)
                    ._add(this._offset));
              let i = '';
              'viewport' === this._rotationAlignment ||
              'auto' === this._rotationAlignment
                ? (i = `rotateZ(${this._rotation}deg)`)
                : 'map' === this._rotationAlignment &&
                  (i = `rotateZ(${
                    this._rotation - this._map.getBearing()
                  }deg)`);
              let r = '';
              'viewport' === this._pitchAlignment ||
              'auto' === this._pitchAlignment
                ? (r = 'rotateX(0deg)')
                : 'map' === this._pitchAlignment &&
                  (r = `rotateX(${this._map.getPitch()}deg)`),
                this._subpixelPositioning ||
                  (t && 'moveend' !== t.type) ||
                  (this._pos = this._pos.round()),
                c.setTransform(
                  this._element,
                  `${as[this._anchor]} translate(${this._pos.x}px, ${
                    this._pos.y
                  }px) ${r} ${i}`
                ),
                s
                  .frameAsync(new AbortController())
                  .then(() => {
                    this._updateOpacity(t && 'moveend' === t.type);
                  })
                  .catch(() => {});
            }),
            (this._onMove = (t) => {
              if (!this._isDragging) {
                const e = this._clickTolerance || this._map._clickTolerance;
                this._isDragging = t.point.dist(this._pointerdownPos) >= e;
              }
              this._isDragging &&
                ((this._pos = t.point.sub(this._positionDelta)),
                (this._lngLat = this._map.unproject(this._pos)),
                this.setLngLat(this._lngLat),
                (this._element.style.pointerEvents = 'none'),
                'pending' === this._state &&
                  ((this._state = 'active'), this.fire(new e.l('dragstart'))),
                this.fire(new e.l('drag')));
            }),
            (this._onUp = () => {
              (this._element.style.pointerEvents = 'auto'),
                (this._positionDelta = null),
                (this._pointerdownPos = null),
                (this._isDragging = !1),
                this._map.off('mousemove', this._onMove),
                this._map.off('touchmove', this._onMove),
                'active' === this._state && this.fire(new e.l('dragend')),
                (this._state = 'inactive');
            }),
            (this._addDragHandler = (t) => {
              this._element.contains(t.originalEvent.target) &&
                (t.preventDefault(),
                (this._positionDelta = t.point
                  .sub(this._pos)
                  .add(this._offset)),
                (this._pointerdownPos = t.point),
                (this._state = 'pending'),
                this._map.on('mousemove', this._onMove),
                this._map.on('touchmove', this._onMove),
                this._map.once('mouseup', this._onUp),
                this._map.once('touchend', this._onUp));
            }),
            (this._anchor = (t && t.anchor) || 'center'),
            (this._color = (t && t.color) || '#3FB1CE'),
            (this._scale = (t && t.scale) || 1),
            (this._draggable = (t && t.draggable) || !1),
            (this._clickTolerance = (t && t.clickTolerance) || 0),
            (this._subpixelPositioning = (t && t.subpixelPositioning) || !1),
            (this._isDragging = !1),
            (this._state = 'inactive'),
            (this._rotation = (t && t.rotation) || 0),
            (this._rotationAlignment = (t && t.rotationAlignment) || 'auto'),
            (this._pitchAlignment =
              t && t.pitchAlignment && 'auto' !== t.pitchAlignment
                ? t.pitchAlignment
                : this._rotationAlignment),
            this.setOpacity(
              null == t ? void 0 : t.opacity,
              null == t ? void 0 : t.opacityWhenCovered
            ),
            t && t.element)
          )
            (this._element = t.element),
              (this._offset = e.P.convert((t && t.offset) || [0, 0]));
          else {
            (this._defaultMarker = !0), (this._element = c.create('div'));
            const i = c.createNS('http://www.w3.org/2000/svg', 'svg'),
              r = 41,
              n = 27;
            i.setAttributeNS(null, 'display', 'block'),
              i.setAttributeNS(null, 'height', `${r}px`),
              i.setAttributeNS(null, 'width', `${n}px`),
              i.setAttributeNS(null, 'viewBox', `0 0 ${n} ${r}`);
            const a = c.createNS('http://www.w3.org/2000/svg', 'g');
            a.setAttributeNS(null, 'stroke', 'none'),
              a.setAttributeNS(null, 'stroke-width', '1'),
              a.setAttributeNS(null, 'fill', 'none'),
              a.setAttributeNS(null, 'fill-rule', 'evenodd');
            const s = c.createNS('http://www.w3.org/2000/svg', 'g');
            s.setAttributeNS(null, 'fill-rule', 'nonzero');
            const o = c.createNS('http://www.w3.org/2000/svg', 'g');
            o.setAttributeNS(null, 'transform', 'translate(3.0, 29.0)'),
              o.setAttributeNS(null, 'fill', '#000000');
            const l = [
              { rx: '10.5', ry: '5.25002273' },
              { rx: '10.5', ry: '5.25002273' },
              { rx: '9.5', ry: '4.77275007' },
              { rx: '8.5', ry: '4.29549936' },
              { rx: '7.5', ry: '3.81822308' },
              { rx: '6.5', ry: '3.34094679' },
              { rx: '5.5', ry: '2.86367051' },
              { rx: '4.5', ry: '2.38636864' },
            ];
            for (const t of l) {
              const e = c.createNS('http://www.w3.org/2000/svg', 'ellipse');
              e.setAttributeNS(null, 'opacity', '0.04'),
                e.setAttributeNS(null, 'cx', '10.5'),
                e.setAttributeNS(null, 'cy', '5.80029008'),
                e.setAttributeNS(null, 'rx', t.rx),
                e.setAttributeNS(null, 'ry', t.ry),
                o.appendChild(e);
            }
            const h = c.createNS('http://www.w3.org/2000/svg', 'g');
            h.setAttributeNS(null, 'fill', this._color);
            const u = c.createNS('http://www.w3.org/2000/svg', 'path');
            u.setAttributeNS(
              null,
              'd',
              'M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z'
            ),
              h.appendChild(u);
            const d = c.createNS('http://www.w3.org/2000/svg', 'g');
            d.setAttributeNS(null, 'opacity', '0.25'),
              d.setAttributeNS(null, 'fill', '#000000');
            const p = c.createNS('http://www.w3.org/2000/svg', 'path');
            p.setAttributeNS(
              null,
              'd',
              'M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z'
            ),
              d.appendChild(p);
            const f = c.createNS('http://www.w3.org/2000/svg', 'g');
            f.setAttributeNS(null, 'transform', 'translate(6.0, 7.0)'),
              f.setAttributeNS(null, 'fill', '#FFFFFF');
            const m = c.createNS('http://www.w3.org/2000/svg', 'g');
            m.setAttributeNS(null, 'transform', 'translate(8.0, 8.0)');
            const g = c.createNS('http://www.w3.org/2000/svg', 'circle');
            g.setAttributeNS(null, 'fill', '#000000'),
              g.setAttributeNS(null, 'opacity', '0.25'),
              g.setAttributeNS(null, 'cx', '5.5'),
              g.setAttributeNS(null, 'cy', '5.5'),
              g.setAttributeNS(null, 'r', '5.4999962');
            const _ = c.createNS('http://www.w3.org/2000/svg', 'circle');
            _.setAttributeNS(null, 'fill', '#FFFFFF'),
              _.setAttributeNS(null, 'cx', '5.5'),
              _.setAttributeNS(null, 'cy', '5.5'),
              _.setAttributeNS(null, 'r', '5.4999962'),
              m.appendChild(g),
              m.appendChild(_),
              s.appendChild(o),
              s.appendChild(h),
              s.appendChild(d),
              s.appendChild(f),
              s.appendChild(m),
              i.appendChild(s),
              i.setAttributeNS(null, 'height', r * this._scale + 'px'),
              i.setAttributeNS(null, 'width', n * this._scale + 'px'),
              this._element.appendChild(i),
              (this._offset = e.P.convert((t && t.offset) || [0, -14]));
          }
          if (
            (this._element.classList.add('maplibregl-marker'),
            this._element.addEventListener('dragstart', (t) => {
              t.preventDefault();
            }),
            this._element.addEventListener('mousedown', (t) => {
              t.preventDefault();
            }),
            ss(this._element, this._anchor, 'marker'),
            t && t.className)
          )
            for (const e of t.className.split(' '))
              this._element.classList.add(e);
          this._popup = null;
        }
        addTo(t) {
          return (
            this.remove(),
            (this._map = t),
            this._element.hasAttribute('aria-label') ||
              this._element.setAttribute(
                'aria-label',
                t._getUIString('Marker.Title')
              ),
            this._element.hasAttribute('role') ||
              this._element.setAttribute('role', 'button'),
            t.getCanvasContainer().appendChild(this._element),
            t.on('move', this._update),
            t.on('moveend', this._update),
            t.on('terrain', this._update),
            t.on('projectiontransition', this._update),
            this.setDraggable(this._draggable),
            this._update(),
            this._map.on('click', this._onMapClick),
            this
          );
        }
        remove() {
          return (
            this._opacityTimeout &&
              (clearTimeout(this._opacityTimeout), delete this._opacityTimeout),
            this._map &&
              (this._map.off('click', this._onMapClick),
              this._map.off('move', this._update),
              this._map.off('moveend', this._update),
              this._map.off('terrain', this._update),
              this._map.off('projectiontransition', this._update),
              this._map.off('mousedown', this._addDragHandler),
              this._map.off('touchstart', this._addDragHandler),
              this._map.off('mouseup', this._onUp),
              this._map.off('touchend', this._onUp),
              this._map.off('mousemove', this._onMove),
              this._map.off('touchmove', this._onMove),
              delete this._map),
            c.remove(this._element),
            this._popup && this._popup.remove(),
            this
          );
        }
        getLngLat() {
          return this._lngLat;
        }
        setLngLat(t) {
          return (
            (this._lngLat = e.U.convert(t)),
            (this._pos = null),
            this._popup && this._popup.setLngLat(this._lngLat),
            this._update(),
            this
          );
        }
        getElement() {
          return this._element;
        }
        setPopup(t) {
          if (
            (this._popup &&
              (this._popup.remove(),
              (this._popup = null),
              this._element.removeEventListener('keypress', this._onKeyPress),
              this._originalTabIndex ||
                this._element.removeAttribute('tabindex')),
            t)
          ) {
            if (!('offset' in t.options)) {
              const e = 38.1,
                i = 13.5,
                r = Math.abs(i) / Math.SQRT2;
              t.options.offset = this._defaultMarker
                ? {
                    'top': [0, 0],
                    'top-left': [0, 0],
                    'top-right': [0, 0],
                    'bottom': [0, -e],
                    'bottom-left': [r, -1 * (e - i + r)],
                    'bottom-right': [-r, -1 * (e - i + r)],
                    'left': [i, -1 * (e - i)],
                    'right': [-i, -1 * (e - i)],
                  }
                : this._offset;
            }
            (this._popup = t),
              (this._originalTabIndex = this._element.getAttribute('tabindex')),
              this._originalTabIndex ||
                this._element.setAttribute('tabindex', '0'),
              this._element.addEventListener('keypress', this._onKeyPress);
          }
          return this;
        }
        setSubpixelPositioning(t) {
          return (this._subpixelPositioning = t), this;
        }
        getPopup() {
          return this._popup;
        }
        togglePopup() {
          const t = this._popup;
          return this._element.style.opacity === this._opacityWhenCovered
            ? this
            : t
            ? (t.isOpen()
                ? t.remove()
                : (t.setLngLat(this._lngLat), t.addTo(this._map)),
              this)
            : this;
        }
        _updateOpacity(t = !1) {
          var i, r;
          const n =
              null === (i = this._map) || void 0 === i ? void 0 : i.terrain,
            a = this._map.transform.isLocationOccluded(this._lngLat);
          if (!n || a) {
            const t = a ? this._opacityWhenCovered : this._opacity;
            return void (
              this._element.style.opacity !== t &&
              (this._element.style.opacity = t)
            );
          }
          if (t) this._opacityTimeout = null;
          else {
            if (this._opacityTimeout) return;
            this._opacityTimeout = setTimeout(() => {
              this._opacityTimeout = null;
            }, 100);
          }
          const s = this._map,
            o = s.terrain.depthAtPoint(this._pos),
            l = s.terrain.getElevationForLngLatZoom(
              this._lngLat,
              s.transform.tileZoom
            );
          if (s.transform.lngLatToCameraDepth(this._lngLat, l) - o < 0.006)
            return void (this._element.style.opacity = this._opacity);
          const c = -this._offset.y / s.transform.pixelsPerMeter,
            h = Math.sin((s.getPitch() * Math.PI) / 180) * c,
            u = s.terrain.depthAtPoint(
              new e.P(this._pos.x, this._pos.y - this._offset.y)
            ),
            d =
              s.transform.lngLatToCameraDepth(this._lngLat, l + h) - u > 0.006;
          (null === (r = this._popup) || void 0 === r ? void 0 : r.isOpen()) &&
            d &&
            this._popup.remove(),
            (this._element.style.opacity = d
              ? this._opacityWhenCovered
              : this._opacity);
        }
        getOffset() {
          return this._offset;
        }
        setOffset(t) {
          return (this._offset = e.P.convert(t)), this._update(), this;
        }
        addClassName(t) {
          this._element.classList.add(t);
        }
        removeClassName(t) {
          this._element.classList.remove(t);
        }
        toggleClassName(t) {
          return this._element.classList.toggle(t);
        }
        setDraggable(t) {
          return (
            (this._draggable = !!t),
            this._map &&
              (t
                ? (this._map.on('mousedown', this._addDragHandler),
                  this._map.on('touchstart', this._addDragHandler))
                : (this._map.off('mousedown', this._addDragHandler),
                  this._map.off('touchstart', this._addDragHandler))),
            this
          );
        }
        isDraggable() {
          return this._draggable;
        }
        setRotation(t) {
          return (this._rotation = t || 0), this._update(), this;
        }
        getRotation() {
          return this._rotation;
        }
        setRotationAlignment(t) {
          return (this._rotationAlignment = t || 'auto'), this._update(), this;
        }
        getRotationAlignment() {
          return this._rotationAlignment;
        }
        setPitchAlignment(t) {
          return (
            (this._pitchAlignment =
              t && 'auto' !== t ? t : this._rotationAlignment),
            this._update(),
            this
          );
        }
        getPitchAlignment() {
          return this._pitchAlignment;
        }
        setOpacity(t, e) {
          return (
            (void 0 === this._opacity || (void 0 === t && void 0 === e)) &&
              ((this._opacity = '1'), (this._opacityWhenCovered = '0.2')),
            void 0 !== t && (this._opacity = t),
            void 0 !== e && (this._opacityWhenCovered = e),
            this._map && this._updateOpacity(!0),
            this
          );
        }
      }
      const ls = {
        positionOptions: {
          enableHighAccuracy: !1,
          maximumAge: 0,
          timeout: 6e3,
        },
        fitBoundsOptions: { maxZoom: 15 },
        trackUserLocation: !1,
        showAccuracyCircle: !0,
        showUserLocation: !0,
      };
      let cs = 0,
        hs = !1;
      const us = { maxWidth: 100, unit: 'metric' };
      function ds(t, e, i) {
        const r = (i && i.maxWidth) || 100,
          n = t._container.clientHeight / 2,
          a = t._container.clientWidth / 2,
          s = t.unproject([a - r / 2, n]),
          o = t.unproject([a + r / 2, n]),
          l = Math.round(t.project(o).x - t.project(s).x),
          c = Math.min(r, l, t._container.clientWidth),
          h = s.distanceTo(o);
        if (i && 'imperial' === i.unit) {
          const i = 3.2808 * h;
          i > 5280
            ? ps(e, c, i / 5280, t._getUIString('ScaleControl.Miles'))
            : ps(e, c, i, t._getUIString('ScaleControl.Feet'));
        } else i && 'nautical' === i.unit ? ps(e, c, h / 1852, t._getUIString('ScaleControl.NauticalMiles')) : h >= 1e3 ? ps(e, c, h / 1e3, t._getUIString('ScaleControl.Kilometers')) : ps(e, c, h, t._getUIString('ScaleControl.Meters'));
      }
      function ps(t, e, i, r) {
        const n = (function (t) {
          const e = Math.pow(10, `${Math.floor(t)}`.length - 1);
          let i = t / e;
          return (
            (i =
              i >= 10
                ? 10
                : i >= 5
                ? 5
                : i >= 3
                ? 3
                : i >= 2
                ? 2
                : i >= 1
                ? 1
                : (function (t) {
                    const e = Math.pow(10, Math.ceil(-Math.log(t) / Math.LN10));
                    return Math.round(t * e) / e;
                  })(i)),
            e * i
          );
        })(i);
        (t.style.width = e * (n / i) + 'px'), (t.innerHTML = `${n}&nbsp;${r}`);
      }
      const fs = {
          closeButton: !0,
          closeOnClick: !0,
          focusAfterOpen: !0,
          className: '',
          maxWidth: '240px',
          subpixelPositioning: !1,
          locationOccludedOpacity: void 0,
        },
        ms = [
          'a[href]',
          "[tabindex]:not([tabindex='-1'])",
          "[contenteditable]:not([contenteditable='false'])",
          'button:not([disabled])',
          'input:not([disabled])',
          'select:not([disabled])',
          'textarea:not([disabled])',
        ].join(', ');
      function gs(t) {
        if (t) {
          if ('number' == typeof t) {
            const i = Math.round(Math.abs(t) / Math.SQRT2);
            return {
              'center': new e.P(0, 0),
              'top': new e.P(0, t),
              'top-left': new e.P(i, i),
              'top-right': new e.P(-i, i),
              'bottom': new e.P(0, -t),
              'bottom-left': new e.P(i, -i),
              'bottom-right': new e.P(-i, -i),
              'left': new e.P(t, 0),
              'right': new e.P(-t, 0),
            };
          }
          if (t instanceof e.P || Array.isArray(t)) {
            const i = e.P.convert(t);
            return {
              'center': i,
              'top': i,
              'top-left': i,
              'top-right': i,
              'bottom': i,
              'bottom-left': i,
              'bottom-right': i,
              'left': i,
              'right': i,
            };
          }
          return {
            'center': e.P.convert(t.center || [0, 0]),
            'top': e.P.convert(t.top || [0, 0]),
            'top-left': e.P.convert(t['top-left'] || [0, 0]),
            'top-right': e.P.convert(t['top-right'] || [0, 0]),
            'bottom': e.P.convert(t.bottom || [0, 0]),
            'bottom-left': e.P.convert(t['bottom-left'] || [0, 0]),
            'bottom-right': e.P.convert(t['bottom-right'] || [0, 0]),
            'left': e.P.convert(t.left || [0, 0]),
            'right': e.P.convert(t.right || [0, 0]),
          };
        }
        return gs(new e.P(0, 0));
      }
      const _s = i;
      (t.AJAXError = e.cC),
        (t.Event = e.l),
        (t.Evented = e.E),
        (t.LngLat = e.U),
        (t.MercatorCoordinate = e.a5),
        (t.Point = e.P),
        (t.addProtocol = e.cD),
        (t.config = e.a),
        (t.removeProtocol = e.cE),
        (t.AttributionControl = Ga),
        (t.BoxZoomHandler = na),
        (t.CanvasSource = it),
        (t.CooperativeGesturesHandler = Oa),
        (t.DoubleClickZoomHandler = La),
        (t.DragPanHandler = Ra),
        (t.DragRotateHandler = za),
        (t.EdgeInsets = ze),
        (t.FullscreenControl = class extends e.E {
          constructor(t = {}) {
            super(),
              (this._onFullscreenChange = () => {
                var t;
                let e =
                  window.document.fullscreenElement ||
                  window.document.mozFullScreenElement ||
                  window.document.webkitFullscreenElement ||
                  window.document.msFullscreenElement;
                for (
                  ;
                  null === (t = null == e ? void 0 : e.shadowRoot) ||
                  void 0 === t
                    ? void 0
                    : t.fullscreenElement;

                )
                  e = e.shadowRoot.fullscreenElement;
                (e === this._container) !== this._fullscreen &&
                  this._handleFullscreenChange();
              }),
              (this._onClickFullscreen = () => {
                this._isFullscreen()
                  ? this._exitFullscreen()
                  : this._requestFullscreen();
              }),
              (this._fullscreen = !1),
              t &&
                t.container &&
                (t.container instanceof HTMLElement
                  ? (this._container = t.container)
                  : e.w(
                      "Full screen control 'container' must be a DOM element."
                    )),
              'onfullscreenchange' in document
                ? (this._fullscreenchange = 'fullscreenchange')
                : 'onmozfullscreenchange' in document
                ? (this._fullscreenchange = 'mozfullscreenchange')
                : 'onwebkitfullscreenchange' in document
                ? (this._fullscreenchange = 'webkitfullscreenchange')
                : 'onmsfullscreenchange' in document &&
                  (this._fullscreenchange = 'MSFullscreenChange');
          }
          onAdd(t) {
            return (
              (this._map = t),
              this._container || (this._container = this._map.getContainer()),
              (this._controlContainer = c.create(
                'div',
                'maplibregl-ctrl maplibregl-ctrl-group'
              )),
              this._setupUI(),
              this._controlContainer
            );
          }
          onRemove() {
            c.remove(this._controlContainer),
              (this._map = null),
              window.document.removeEventListener(
                this._fullscreenchange,
                this._onFullscreenChange
              );
          }
          _setupUI() {
            const t = (this._fullscreenButton = c.create(
              'button',
              'maplibregl-ctrl-fullscreen',
              this._controlContainer
            ));
            c
              .create('span', 'maplibregl-ctrl-icon', t)
              .setAttribute('aria-hidden', 'true'),
              (t.type = 'button'),
              this._updateTitle(),
              this._fullscreenButton.addEventListener(
                'click',
                this._onClickFullscreen
              ),
              window.document.addEventListener(
                this._fullscreenchange,
                this._onFullscreenChange
              );
          }
          _updateTitle() {
            const t = this._getTitle();
            this._fullscreenButton.setAttribute('aria-label', t),
              (this._fullscreenButton.title = t);
          }
          _getTitle() {
            return this._map._getUIString(
              this._isFullscreen()
                ? 'FullscreenControl.Exit'
                : 'FullscreenControl.Enter'
            );
          }
          _isFullscreen() {
            return this._fullscreen;
          }
          _handleFullscreenChange() {
            (this._fullscreen = !this._fullscreen),
              this._fullscreenButton.classList.toggle('maplibregl-ctrl-shrink'),
              this._fullscreenButton.classList.toggle(
                'maplibregl-ctrl-fullscreen'
              ),
              this._updateTitle(),
              this._fullscreen
                ? (this.fire(new e.l('fullscreenstart')),
                  (this._prevCooperativeGesturesEnabled =
                    this._map.cooperativeGestures.isEnabled()),
                  this._map.cooperativeGestures.disable())
                : (this.fire(new e.l('fullscreenend')),
                  this._prevCooperativeGesturesEnabled &&
                    this._map.cooperativeGestures.enable());
          }
          _exitFullscreen() {
            window.document.exitFullscreen
              ? window.document.exitFullscreen()
              : window.document.mozCancelFullScreen
              ? window.document.mozCancelFullScreen()
              : window.document.msExitFullscreen
              ? window.document.msExitFullscreen()
              : window.document.webkitCancelFullScreen
              ? window.document.webkitCancelFullScreen()
              : this._togglePseudoFullScreen();
          }
          _requestFullscreen() {
            this._container.requestFullscreen
              ? this._container.requestFullscreen()
              : this._container.mozRequestFullScreen
              ? this._container.mozRequestFullScreen()
              : this._container.msRequestFullscreen
              ? this._container.msRequestFullscreen()
              : this._container.webkitRequestFullscreen
              ? this._container.webkitRequestFullscreen()
              : this._togglePseudoFullScreen();
          }
          _togglePseudoFullScreen() {
            this._container.classList.toggle('maplibregl-pseudo-fullscreen'),
              this._handleFullscreenChange(),
              this._map.resize();
          }
        }),
        (t.GeoJSONSource = Q),
        (t.GeolocateControl = class extends e.E {
          constructor(t) {
            super(),
              (this._onSuccess = (t) => {
                if (this._map) {
                  if (this._isOutOfMapMaxBounds(t))
                    return (
                      this._setErrorState(),
                      this.fire(new e.l('outofmaxbounds', t)),
                      this._updateMarker(),
                      void this._finish()
                    );
                  if (this.options.trackUserLocation)
                    switch (((this._lastKnownPosition = t), this._watchState)) {
                      case 'WAITING_ACTIVE':
                      case 'ACTIVE_LOCK':
                      case 'ACTIVE_ERROR':
                        (this._watchState = 'ACTIVE_LOCK'),
                          this._geolocateButton.classList.remove(
                            'maplibregl-ctrl-geolocate-waiting'
                          ),
                          this._geolocateButton.classList.remove(
                            'maplibregl-ctrl-geolocate-active-error'
                          ),
                          this._geolocateButton.classList.add(
                            'maplibregl-ctrl-geolocate-active'
                          );
                        break;
                      case 'BACKGROUND':
                      case 'BACKGROUND_ERROR':
                        (this._watchState = 'BACKGROUND'),
                          this._geolocateButton.classList.remove(
                            'maplibregl-ctrl-geolocate-waiting'
                          ),
                          this._geolocateButton.classList.remove(
                            'maplibregl-ctrl-geolocate-background-error'
                          ),
                          this._geolocateButton.classList.add(
                            'maplibregl-ctrl-geolocate-background'
                          );
                        break;
                      default:
                        throw new Error(
                          `Unexpected watchState ${this._watchState}`
                        );
                    }
                  this.options.showUserLocation &&
                    'OFF' !== this._watchState &&
                    this._updateMarker(t),
                    (this.options.trackUserLocation &&
                      'ACTIVE_LOCK' !== this._watchState) ||
                      this._updateCamera(t),
                    this.options.showUserLocation &&
                      this._dotElement.classList.remove(
                        'maplibregl-user-location-dot-stale'
                      ),
                    this.fire(new e.l('geolocate', t)),
                    this._finish();
                }
              }),
              (this._updateCamera = (t) => {
                const i = new e.U(t.coords.longitude, t.coords.latitude),
                  r = t.coords.accuracy,
                  n = this._map.getBearing(),
                  a = e.e({ bearing: n }, this.options.fitBoundsOptions),
                  s = q.fromLngLat(i, r);
                this._map.fitBounds(s, a, { geolocateSource: !0 });
              }),
              (this._updateMarker = (t) => {
                if (t) {
                  const i = new e.U(t.coords.longitude, t.coords.latitude);
                  this._accuracyCircleMarker.setLngLat(i).addTo(this._map),
                    this._userLocationDotMarker.setLngLat(i).addTo(this._map),
                    (this._accuracy = t.coords.accuracy),
                    this._updateCircleRadiusIfNeeded();
                } else
                  this._userLocationDotMarker.remove(),
                    this._accuracyCircleMarker.remove();
              }),
              (this._onUpdate = () => {
                this._updateCircleRadiusIfNeeded();
              }),
              (this._onError = (t) => {
                if (this._map) {
                  if (1 === t.code) {
                    (this._watchState = 'OFF'),
                      this._geolocateButton.classList.remove(
                        'maplibregl-ctrl-geolocate-waiting'
                      ),
                      this._geolocateButton.classList.remove(
                        'maplibregl-ctrl-geolocate-active'
                      ),
                      this._geolocateButton.classList.remove(
                        'maplibregl-ctrl-geolocate-active-error'
                      ),
                      this._geolocateButton.classList.remove(
                        'maplibregl-ctrl-geolocate-background'
                      ),
                      this._geolocateButton.classList.remove(
                        'maplibregl-ctrl-geolocate-background-error'
                      ),
                      (this._geolocateButton.disabled = !0);
                    const t = this._map._getUIString(
                      'GeolocateControl.LocationNotAvailable'
                    );
                    (this._geolocateButton.title = t),
                      this._geolocateButton.setAttribute('aria-label', t),
                      void 0 !== this._geolocationWatchID && this._clearWatch();
                  } else {
                    if (3 === t.code && hs) return;
                    this._setErrorState();
                  }
                  'OFF' !== this._watchState &&
                    this.options.showUserLocation &&
                    this._dotElement.classList.add(
                      'maplibregl-user-location-dot-stale'
                    ),
                    this.fire(new e.l('error', t)),
                    this._finish();
                }
              }),
              (this._finish = () => {
                this._timeoutId && clearTimeout(this._timeoutId),
                  (this._timeoutId = void 0);
              }),
              (this._setupUI = () => {
                this._map &&
                  (this._container.addEventListener('contextmenu', (t) =>
                    t.preventDefault()
                  ),
                  (this._geolocateButton = c.create(
                    'button',
                    'maplibregl-ctrl-geolocate',
                    this._container
                  )),
                  c
                    .create(
                      'span',
                      'maplibregl-ctrl-icon',
                      this._geolocateButton
                    )
                    .setAttribute('aria-hidden', 'true'),
                  (this._geolocateButton.type = 'button'),
                  (this._geolocateButton.disabled = !0));
              }),
              (this._finishSetupUI = (t) => {
                if (this._map) {
                  if (!1 === t) {
                    e.w(
                      'Geolocation support is not available so the GeolocateControl will be disabled.'
                    );
                    const t = this._map._getUIString(
                      'GeolocateControl.LocationNotAvailable'
                    );
                    (this._geolocateButton.disabled = !0),
                      (this._geolocateButton.title = t),
                      this._geolocateButton.setAttribute('aria-label', t);
                  } else {
                    const t = this._map._getUIString(
                      'GeolocateControl.FindMyLocation'
                    );
                    (this._geolocateButton.disabled = !1),
                      (this._geolocateButton.title = t),
                      this._geolocateButton.setAttribute('aria-label', t);
                  }
                  this.options.trackUserLocation &&
                    (this._geolocateButton.setAttribute(
                      'aria-pressed',
                      'false'
                    ),
                    (this._watchState = 'OFF')),
                    this.options.showUserLocation &&
                      ((this._dotElement = c.create(
                        'div',
                        'maplibregl-user-location-dot'
                      )),
                      (this._userLocationDotMarker = new os({
                        element: this._dotElement,
                      })),
                      (this._circleElement = c.create(
                        'div',
                        'maplibregl-user-location-accuracy-circle'
                      )),
                      (this._accuracyCircleMarker = new os({
                        element: this._circleElement,
                        pitchAlignment: 'map',
                      })),
                      this.options.trackUserLocation &&
                        (this._watchState = 'OFF'),
                      this._map.on('zoom', this._onUpdate),
                      this._map.on('move', this._onUpdate),
                      this._map.on('rotate', this._onUpdate),
                      this._map.on('pitch', this._onUpdate)),
                    this._geolocateButton.addEventListener('click', () =>
                      this.trigger()
                    ),
                    (this._setup = !0),
                    this.options.trackUserLocation &&
                      this._map.on('movestart', (t) => {
                        const i =
                          (null == t ? void 0 : t[0]) instanceof
                          ResizeObserverEntry;
                        t.geolocateSource ||
                          'ACTIVE_LOCK' !== this._watchState ||
                          i ||
                          this._map.isZooming() ||
                          ((this._watchState = 'BACKGROUND'),
                          this._geolocateButton.classList.add(
                            'maplibregl-ctrl-geolocate-background'
                          ),
                          this._geolocateButton.classList.remove(
                            'maplibregl-ctrl-geolocate-active'
                          ),
                          this.fire(new e.l('trackuserlocationend')),
                          this.fire(new e.l('userlocationlostfocus')));
                      });
                }
              }),
              (this.options = e.e({}, ls, t));
          }
          onAdd(t) {
            return (
              (this._map = t),
              (this._container = c.create(
                'div',
                'maplibregl-ctrl maplibregl-ctrl-group'
              )),
              this._setupUI(),
              (function () {
                return e._(this, arguments, void 0, function* (t = !1) {
                  if (void 0 !== rs && !t) return rs;
                  if (void 0 === window.navigator.permissions)
                    return (rs = !!window.navigator.geolocation), rs;
                  try {
                    const t = yield window.navigator.permissions.query({
                      name: 'geolocation',
                    });
                    rs = 'denied' !== t.state;
                  } catch (t) {
                    rs = !!window.navigator.geolocation;
                  }
                  return rs;
                });
              })().then((t) => this._finishSetupUI(t)),
              this._container
            );
          }
          onRemove() {
            void 0 !== this._geolocationWatchID &&
              (window.navigator.geolocation.clearWatch(
                this._geolocationWatchID
              ),
              (this._geolocationWatchID = void 0)),
              this.options.showUserLocation &&
                this._userLocationDotMarker &&
                this._userLocationDotMarker.remove(),
              this.options.showAccuracyCircle &&
                this._accuracyCircleMarker &&
                this._accuracyCircleMarker.remove(),
              c.remove(this._container),
              this._map.off('zoom', this._onUpdate),
              this._map.off('move', this._onUpdate),
              this._map.off('rotate', this._onUpdate),
              this._map.off('pitch', this._onUpdate),
              (this._map = void 0),
              (cs = 0),
              (hs = !1);
          }
          _isOutOfMapMaxBounds(t) {
            const e = this._map.getMaxBounds(),
              i = t.coords;
            return (
              e &&
              (i.longitude < e.getWest() ||
                i.longitude > e.getEast() ||
                i.latitude < e.getSouth() ||
                i.latitude > e.getNorth())
            );
          }
          _setErrorState() {
            switch (this._watchState) {
              case 'WAITING_ACTIVE':
                (this._watchState = 'ACTIVE_ERROR'),
                  this._geolocateButton.classList.remove(
                    'maplibregl-ctrl-geolocate-active'
                  ),
                  this._geolocateButton.classList.add(
                    'maplibregl-ctrl-geolocate-active-error'
                  );
                break;
              case 'ACTIVE_LOCK':
                (this._watchState = 'ACTIVE_ERROR'),
                  this._geolocateButton.classList.remove(
                    'maplibregl-ctrl-geolocate-active'
                  ),
                  this._geolocateButton.classList.add(
                    'maplibregl-ctrl-geolocate-active-error'
                  ),
                  this._geolocateButton.classList.add(
                    'maplibregl-ctrl-geolocate-waiting'
                  );
                break;
              case 'BACKGROUND':
                (this._watchState = 'BACKGROUND_ERROR'),
                  this._geolocateButton.classList.remove(
                    'maplibregl-ctrl-geolocate-background'
                  ),
                  this._geolocateButton.classList.add(
                    'maplibregl-ctrl-geolocate-background-error'
                  ),
                  this._geolocateButton.classList.add(
                    'maplibregl-ctrl-geolocate-waiting'
                  );
                break;
              case 'ACTIVE_ERROR':
              case 'BACKGROUND_ERROR':
              case 'OFF':
              case void 0:
                break;
              default:
                throw new Error(`Unexpected watchState ${this._watchState}`);
            }
          }
          _updateCircleRadiusIfNeeded() {
            const t = this._userLocationDotMarker.getLngLat();
            if (
              !(
                this.options.showUserLocation &&
                this.options.showAccuracyCircle &&
                this._accuracy &&
                t
              )
            )
              return;
            const e = this._map.project(t),
              i = this._map.unproject([e.x + 100, e.y]),
              r = t.distanceTo(i) / 100,
              n = (2 * this._accuracy) / r;
            (this._circleElement.style.width = `${n.toFixed(2)}px`),
              (this._circleElement.style.height = `${n.toFixed(2)}px`);
          }
          trigger() {
            if (!this._setup)
              return (
                e.w('Geolocate control triggered before added to a map'), !1
              );
            if (this.options.trackUserLocation) {
              switch (this._watchState) {
                case 'OFF':
                  (this._watchState = 'WAITING_ACTIVE'),
                    this.fire(new e.l('trackuserlocationstart'));
                  break;
                case 'WAITING_ACTIVE':
                case 'ACTIVE_LOCK':
                case 'ACTIVE_ERROR':
                case 'BACKGROUND_ERROR':
                  cs--,
                    (hs = !1),
                    (this._watchState = 'OFF'),
                    this._geolocateButton.classList.remove(
                      'maplibregl-ctrl-geolocate-waiting'
                    ),
                    this._geolocateButton.classList.remove(
                      'maplibregl-ctrl-geolocate-active'
                    ),
                    this._geolocateButton.classList.remove(
                      'maplibregl-ctrl-geolocate-active-error'
                    ),
                    this._geolocateButton.classList.remove(
                      'maplibregl-ctrl-geolocate-background'
                    ),
                    this._geolocateButton.classList.remove(
                      'maplibregl-ctrl-geolocate-background-error'
                    ),
                    this.fire(new e.l('trackuserlocationend'));
                  break;
                case 'BACKGROUND':
                  (this._watchState = 'ACTIVE_LOCK'),
                    this._geolocateButton.classList.remove(
                      'maplibregl-ctrl-geolocate-background'
                    ),
                    this._lastKnownPosition &&
                      this._updateCamera(this._lastKnownPosition),
                    this.fire(new e.l('trackuserlocationstart')),
                    this.fire(new e.l('userlocationfocus'));
                  break;
                default:
                  throw new Error(`Unexpected watchState ${this._watchState}`);
              }
              switch (this._watchState) {
                case 'WAITING_ACTIVE':
                  this._geolocateButton.classList.add(
                    'maplibregl-ctrl-geolocate-waiting'
                  ),
                    this._geolocateButton.classList.add(
                      'maplibregl-ctrl-geolocate-active'
                    );
                  break;
                case 'ACTIVE_LOCK':
                  this._geolocateButton.classList.add(
                    'maplibregl-ctrl-geolocate-active'
                  );
                  break;
                case 'OFF':
                  break;
                default:
                  throw new Error(`Unexpected watchState ${this._watchState}`);
              }
              if (
                'OFF' === this._watchState &&
                void 0 !== this._geolocationWatchID
              )
                this._clearWatch();
              else if (void 0 === this._geolocationWatchID) {
                let t;
                this._geolocateButton.classList.add(
                  'maplibregl-ctrl-geolocate-waiting'
                ),
                  this._geolocateButton.setAttribute('aria-pressed', 'true'),
                  cs++,
                  cs > 1
                    ? ((t = { maximumAge: 6e5, timeout: 0 }), (hs = !0))
                    : ((t = this.options.positionOptions), (hs = !1)),
                  (this._geolocationWatchID =
                    window.navigator.geolocation.watchPosition(
                      this._onSuccess,
                      this._onError,
                      t
                    ));
              }
            } else
              window.navigator.geolocation.getCurrentPosition(
                this._onSuccess,
                this._onError,
                this.options.positionOptions
              ),
                (this._timeoutId = setTimeout(this._finish, 1e4));
            return !0;
          }
          _clearWatch() {
            window.navigator.geolocation.clearWatch(this._geolocationWatchID),
              (this._geolocationWatchID = void 0),
              this._geolocateButton.classList.remove(
                'maplibregl-ctrl-geolocate-waiting'
              ),
              this._geolocateButton.setAttribute('aria-pressed', 'false'),
              this.options.showUserLocation && this._updateMarker(null);
          }
        }),
        (t.GlobeControl = class {
          constructor() {
            (this._toggleProjection = () => {
              var t;
              const e =
                null === (t = this._map.getProjection()) || void 0 === t
                  ? void 0
                  : t.type;
              this._map.setProjection(
                'mercator' !== e && e ? { type: 'mercator' } : { type: 'globe' }
              ),
                this._updateGlobeIcon();
            }),
              (this._updateGlobeIcon = () => {
                var t;
                this._globeButton.classList.remove('maplibregl-ctrl-globe'),
                  this._globeButton.classList.remove(
                    'maplibregl-ctrl-globe-enabled'
                  ),
                  'globe' ===
                  (null === (t = this._map.getProjection()) || void 0 === t
                    ? void 0
                    : t.type)
                    ? (this._globeButton.classList.add(
                        'maplibregl-ctrl-globe-enabled'
                      ),
                      (this._globeButton.title = this._map._getUIString(
                        'GlobeControl.Disable'
                      )))
                    : (this._globeButton.classList.add('maplibregl-ctrl-globe'),
                      (this._globeButton.title = this._map._getUIString(
                        'GlobeControl.Enable'
                      )));
              });
          }
          onAdd(t) {
            return (
              (this._map = t),
              (this._container = c.create(
                'div',
                'maplibregl-ctrl maplibregl-ctrl-group'
              )),
              (this._globeButton = c.create(
                'button',
                'maplibregl-ctrl-globe',
                this._container
              )),
              c
                .create('span', 'maplibregl-ctrl-icon', this._globeButton)
                .setAttribute('aria-hidden', 'true'),
              (this._globeButton.type = 'button'),
              this._globeButton.addEventListener(
                'click',
                this._toggleProjection
              ),
              this._updateGlobeIcon(),
              this._map.on('styledata', this._updateGlobeIcon),
              this._container
            );
          }
          onRemove() {
            c.remove(this._container),
              this._map.off('styledata', this._updateGlobeIcon),
              this._globeButton.removeEventListener(
                'click',
                this._toggleProjection
              ),
              (this._map = void 0);
          }
        }),
        (t.Hash = Un),
        (t.ImageSource = tt),
        (t.KeyboardHandler = Ca),
        (t.LngLatBounds = q),
        (t.LogoControl = Za),
        (t.Map = class extends ja {
          constructor(t) {
            var i, r;
            e.cz.mark(e.cA.create);
            const n = Object.assign(Object.assign(Object.assign({}, ts), t), {
              canvasContextAttributes: Object.assign(
                Object.assign({}, ts.canvasContextAttributes),
                t.canvasContextAttributes
              ),
            });
            if (null != n.minZoom && null != n.maxZoom && n.minZoom > n.maxZoom)
              throw new Error(
                'maxZoom must be greater than or equal to minZoom'
              );
            if (
              null != n.minPitch &&
              null != n.maxPitch &&
              n.minPitch > n.maxPitch
            )
              throw new Error(
                'maxPitch must be greater than or equal to minPitch'
              );
            if (null != n.minPitch && n.minPitch < 0)
              throw new Error('minPitch must be greater than or equal to 0');
            if (null != n.maxPitch && n.maxPitch > 180)
              throw new Error('maxPitch must be less than or equal to 180');
            const a = new je(),
              s = new $e();
            if (
              (void 0 !== n.minZoom && a.setMinZoom(n.minZoom),
              void 0 !== n.maxZoom && a.setMaxZoom(n.maxZoom),
              void 0 !== n.minPitch && a.setMinPitch(n.minPitch),
              void 0 !== n.maxPitch && a.setMaxPitch(n.maxPitch),
              void 0 !== n.renderWorldCopies &&
                a.setRenderWorldCopies(n.renderWorldCopies),
              null !== n.transformConstrain &&
                a.setConstrain(n.transformConstrain),
              super(a, s, { bearingSnap: n.bearingSnap }),
              (this._idleTriggered = !1),
              (this._crossFadingFactor = 1),
              (this._renderTaskQueue = new $a()),
              (this._controls = []),
              (this._mapId = e.ab()),
              (this._contextLost = (t) => {
                t.preventDefault(),
                  this._frameRequest &&
                    (this._frameRequest.abort(), (this._frameRequest = null)),
                  this.fire(new e.l('webglcontextlost', { originalEvent: t }));
              }),
              (this._contextRestored = (t) => {
                this._setupPainter(),
                  this.resize(),
                  this._update(),
                  this.fire(
                    new e.l('webglcontextrestored', { originalEvent: t })
                  );
              }),
              (this._onMapScroll = (t) => {
                if (t.target === this._container)
                  return (
                    (this._container.scrollTop = 0),
                    (this._container.scrollLeft = 0),
                    !1
                  );
              }),
              (this._onWindowOnline = () => {
                this._update();
              }),
              (this._interactive = n.interactive),
              (this._maxTileCacheSize = n.maxTileCacheSize),
              (this._maxTileCacheZoomLevels = n.maxTileCacheZoomLevels),
              (this._canvasContextAttributes = Object.assign(
                {},
                n.canvasContextAttributes
              )),
              (this._trackResize = !0 === n.trackResize),
              (this._bearingSnap = n.bearingSnap),
              (this._centerClampedToGround = n.centerClampedToGround),
              (this._refreshExpiredTiles = !0 === n.refreshExpiredTiles),
              (this._fadeDuration = n.fadeDuration),
              (this._crossSourceCollisions = !0 === n.crossSourceCollisions),
              (this._collectResourceTiming = !0 === n.collectResourceTiming),
              (this._locale = Object.assign(Object.assign({}, Ja), n.locale)),
              (this._clickTolerance = n.clickTolerance),
              (this._overridePixelRatio = n.pixelRatio),
              (this._maxCanvasSize = n.maxCanvasSize),
              (this.transformCameraUpdate = n.transformCameraUpdate),
              (this.transformConstrain = n.transformConstrain),
              (this.cancelPendingTileRequestsWhileZooming =
                !0 === n.cancelPendingTileRequestsWhileZooming),
              (this._imageQueueHandle = g.addThrottleControl(() =>
                this.isMoving()
              )),
              (this._requestManager = new _(n.transformRequest)),
              'string' == typeof n.container)
            ) {
              if (
                ((this._container = document.getElementById(n.container)),
                !this._container)
              )
                throw new Error(`Container '${n.container}' not found.`);
            } else {
              if (!(n.container instanceof HTMLElement))
                throw new Error(
                  "Invalid type: 'container' must be a String or HTMLElement."
                );
              this._container = n.container;
            }
            if (
              (n.maxBounds && this.setMaxBounds(n.maxBounds),
              this._setupContainer(),
              this._setupPainter(),
              this.on('move', () => this._update(!1)),
              this.on('moveend', () => this._update(!1)),
              this.on('zoom', () => this._update(!0)),
              this.on('terrain', () => {
                (this.painter.terrainFacilitator.dirty = !0), this._update(!0);
              }),
              this.once('idle', () => {
                this._idleTriggered = !0;
              }),
              'undefined' != typeof window)
            ) {
              addEventListener('online', this._onWindowOnline, !1);
              let t = !1;
              const e = jn((t) => {
                this._trackResize &&
                  !this._removed &&
                  (this.resize(t), this.redraw());
              }, 50);
              (this._resizeObserver = new ResizeObserver((i) => {
                t ? e(i) : (t = !0);
              })),
                this._resizeObserver.observe(this._container);
            }
            (this.handlers = new Va(this, n)),
              (this._hash =
                n.hash &&
                new Un(('string' == typeof n.hash && n.hash) || void 0).addTo(
                  this
                )),
              (this._hash && this._hash._onHashChange()) ||
                (this.jumpTo({
                  center: n.center,
                  elevation: n.elevation,
                  zoom: n.zoom,
                  bearing: n.bearing,
                  pitch: n.pitch,
                  roll: n.roll,
                }),
                n.bounds &&
                  (this.resize(),
                  this.fitBounds(
                    n.bounds,
                    e.e({}, n.fitBoundsOptions, { duration: 0 })
                  )));
            const o =
              'string' == typeof n.style ||
              !(
                'globe' ===
                (null ===
                  (r =
                    null === (i = n.style) || void 0 === i
                      ? void 0
                      : i.projection) || void 0 === r
                  ? void 0
                  : r.type)
              );
            this.resize(null, o),
              (this._localIdeographFontFamily = n.localIdeographFontFamily),
              (this._validateStyle = n.validateStyle),
              n.style &&
                this.setStyle(n.style, {
                  localIdeographFontFamily: n.localIdeographFontFamily,
                }),
              n.attributionControl &&
                this.addControl(
                  new Ga(
                    'boolean' == typeof n.attributionControl
                      ? void 0
                      : n.attributionControl
                  )
                ),
              n.maplibreLogo && this.addControl(new Za(), n.logoPosition),
              this.on('style.load', () => {
                if ((o || this._resizeTransform(), this.transform.unmodified)) {
                  const t = e.S(this.style.stylesheet, [
                    'center',
                    'zoom',
                    'bearing',
                    'pitch',
                    'roll',
                  ]);
                  this.jumpTo(t);
                }
              }),
              this.on('data', (t) => {
                this._update('style' === t.dataType),
                  this.fire(new e.l(`${t.dataType}data`, t));
              }),
              this.on('dataloading', (t) => {
                this.fire(new e.l(`${t.dataType}dataloading`, t));
              }),
              this.on('dataabort', (t) => {
                this.fire(new e.l('sourcedataabort', t));
              });
          }
          _getMapId() {
            return this._mapId;
          }
          setGlobalStateProperty(t, e) {
            return this.style.setGlobalStateProperty(t, e), this._update(!0);
          }
          getGlobalState() {
            return this.style.getGlobalState();
          }
          addControl(t, i) {
            if (
              (void 0 === i &&
                (i = t.getDefaultPosition
                  ? t.getDefaultPosition()
                  : 'top-right'),
              !t || !t.onAdd)
            )
              return this.fire(
                new e.k(
                  new Error(
                    'Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.'
                  )
                )
              );
            const r = t.onAdd(this);
            this._controls.push(t);
            const n = this._controlPositions[i];
            return (
              -1 !== i.indexOf('bottom')
                ? n.insertBefore(r, n.firstChild)
                : n.appendChild(r),
              this
            );
          }
          removeControl(t) {
            if (!t || !t.onRemove)
              return this.fire(
                new e.k(
                  new Error(
                    'Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.'
                  )
                )
              );
            const i = this._controls.indexOf(t);
            return (
              i > -1 && this._controls.splice(i, 1), t.onRemove(this), this
            );
          }
          hasControl(t) {
            return this._controls.indexOf(t) > -1;
          }
          coveringTiles(t) {
            return Ct(this.transform, t);
          }
          calculateCameraOptionsFromTo(t, e, i, r) {
            return (
              null == r &&
                this.terrain &&
                (r = this.terrain.getElevationForLngLatZoom(
                  i,
                  this.transform.tileZoom
                )),
              super.calculateCameraOptionsFromTo(t, e, i, r)
            );
          }
          resize(t, i = !0) {
            const [r, n] = this._containerDimensions(),
              a = this._getClampedPixelRatio(r, n);
            if (
              (this._resizeCanvas(r, n, a),
              this.painter.resize(r, n, a),
              this.painter.overLimit())
            ) {
              const t = this.painter.context.gl;
              this._maxCanvasSize = [
                t.drawingBufferWidth,
                t.drawingBufferHeight,
              ];
              const e = this._getClampedPixelRatio(r, n);
              this._resizeCanvas(r, n, e), this.painter.resize(r, n, e);
            }
            this._resizeTransform(i);
            const s = !this._moving;
            return (
              s &&
                (this.stop(),
                this.fire(new e.l('movestart', t)).fire(new e.l('move', t))),
              this.fire(new e.l('resize', t)),
              s && this.fire(new e.l('moveend', t)),
              this
            );
          }
          _resizeTransform(t = !0) {
            var e;
            const [i, r] = this._containerDimensions();
            this.transform.resize(i, r, t),
              null === (e = this._requestedCameraState) ||
                void 0 === e ||
                e.resize(i, r, t);
          }
          _getClampedPixelRatio(t, e) {
            const { 0: i, 1: r } = this._maxCanvasSize,
              n = this.getPixelRatio(),
              a = t * n,
              s = e * n;
            return Math.min(a > i ? i / a : 1, s > r ? r / s : 1) * n;
          }
          getPixelRatio() {
            var t;
            return null !== (t = this._overridePixelRatio) && void 0 !== t
              ? t
              : devicePixelRatio;
          }
          setPixelRatio(t) {
            (this._overridePixelRatio = t), this.resize();
          }
          getBounds() {
            return this.transform.getBounds();
          }
          getMaxBounds() {
            return this.transform.getMaxBounds();
          }
          setMaxBounds(t) {
            return this.transform.setMaxBounds(q.convert(t)), this._update();
          }
          setMinZoom(t) {
            if ((t = null == t ? -2 : t) >= -2 && t <= this.transform.maxZoom)
              return (
                this.transform.setMinZoom(t),
                this._update(),
                this.getZoom() < t && this.setZoom(t),
                this
              );
            throw new Error(
              'minZoom must be between -2 and the current maxZoom, inclusive'
            );
          }
          getMinZoom() {
            return this.transform.minZoom;
          }
          setMaxZoom(t) {
            if ((t = null == t ? 22 : t) >= this.transform.minZoom)
              return (
                this.transform.setMaxZoom(t),
                this._update(),
                this.getZoom() > t && this.setZoom(t),
                this
              );
            throw new Error('maxZoom must be greater than the current minZoom');
          }
          getMaxZoom() {
            return this.transform.maxZoom;
          }
          setMinPitch(t) {
            if ((t = null == t ? 0 : t) < 0)
              throw new Error('minPitch must be greater than or equal to 0');
            if (t >= 0 && t <= this.transform.maxPitch)
              return (
                this.transform.setMinPitch(t),
                this._update(),
                this.getPitch() < t && this.setPitch(t),
                this
              );
            throw new Error(
              'minPitch must be between 0 and the current maxPitch, inclusive'
            );
          }
          getMinPitch() {
            return this.transform.minPitch;
          }
          setMaxPitch(t) {
            if ((t = null == t ? 60 : t) > 180)
              throw new Error('maxPitch must be less than or equal to 180');
            if (t >= this.transform.minPitch)
              return (
                this.transform.setMaxPitch(t),
                this._update(),
                this.getPitch() > t && this.setPitch(t),
                this
              );
            throw new Error(
              'maxPitch must be greater than the current minPitch'
            );
          }
          getMaxPitch() {
            return this.transform.maxPitch;
          }
          getRenderWorldCopies() {
            return this.transform.renderWorldCopies;
          }
          setRenderWorldCopies(t) {
            return this.transform.setRenderWorldCopies(t), this._update();
          }
          setTransformConstrain(t) {
            return this.transform.setConstrain(t), this._update();
          }
          project(t) {
            return this.transform.locationToScreenPoint(
              e.U.convert(t),
              this.style && this.terrain
            );
          }
          unproject(t) {
            return this.transform.screenPointToLocation(
              e.P.convert(t),
              this.terrain
            );
          }
          isMoving() {
            var t;
            return (
              this._moving ||
              (null === (t = this.handlers) || void 0 === t
                ? void 0
                : t.isMoving())
            );
          }
          isZooming() {
            var t;
            return (
              this._zooming ||
              (null === (t = this.handlers) || void 0 === t
                ? void 0
                : t.isZooming())
            );
          }
          isRotating() {
            var t;
            return (
              this._rotating ||
              (null === (t = this.handlers) || void 0 === t
                ? void 0
                : t.isRotating())
            );
          }
          _createDelegatedListener(t, e, i) {
            if ('mouseenter' === t || 'mouseover' === t) {
              let r = !1;
              const n = (n) => {
                const a = e.filter((t) => this.getLayer(t)),
                  s =
                    0 !== a.length
                      ? this.queryRenderedFeatures(n.point, { layers: a })
                      : [];
                s.length
                  ? r ||
                    ((r = !0),
                    i.call(
                      this,
                      new Jn(t, this, n.originalEvent, { features: s })
                    ))
                  : (r = !1);
              };
              return {
                layers: e,
                listener: i,
                delegates: {
                  mousemove: n,
                  mouseout: () => {
                    r = !1;
                  },
                },
              };
            }
            if ('mouseleave' === t || 'mouseout' === t) {
              let r = !1;
              const n = (n) => {
                  const a = e.filter((t) => this.getLayer(t));
                  (0 !== a.length
                    ? this.queryRenderedFeatures(n.point, { layers: a })
                    : []
                  ).length
                    ? (r = !0)
                    : r &&
                      ((r = !1),
                      i.call(this, new Jn(t, this, n.originalEvent)));
                },
                a = (e) => {
                  r &&
                    ((r = !1), i.call(this, new Jn(t, this, e.originalEvent)));
                };
              return {
                layers: e,
                listener: i,
                delegates: { mousemove: n, mouseout: a },
              };
            }
            {
              const r = (t) => {
                const r = e.filter((t) => this.getLayer(t)),
                  n =
                    0 !== r.length
                      ? this.queryRenderedFeatures(t.point, { layers: r })
                      : [];
                n.length &&
                  ((t.features = n), i.call(this, t), delete t.features);
              };
              return { layers: e, listener: i, delegates: { [t]: r } };
            }
          }
          _saveDelegatedListener(t, e) {
            (this._delegatedListeners = this._delegatedListeners || {}),
              (this._delegatedListeners[t] = this._delegatedListeners[t] || []),
              this._delegatedListeners[t].push(e);
          }
          _removeDelegatedListener(t, e, i) {
            if (!this._delegatedListeners || !this._delegatedListeners[t])
              return;
            const r = this._delegatedListeners[t];
            for (let n = 0; n < r.length; n++) {
              const t = r[n];
              if (
                t.listener === i &&
                t.layers.length === e.length &&
                t.layers.every((t) => e.includes(t))
              ) {
                for (const e in t.delegates) this.off(e, t.delegates[e]);
                return void r.splice(n, 1);
              }
            }
          }
          on(t, e, i) {
            if (void 0 === i) return super.on(t, e);
            const r = 'string' == typeof e ? [e] : e,
              n = this._createDelegatedListener(t, r, i);
            this._saveDelegatedListener(t, n);
            for (const a in n.delegates) this.on(a, n.delegates[a]);
            return {
              unsubscribe: () => {
                this._removeDelegatedListener(t, r, i);
              },
            };
          }
          once(t, e, i) {
            if (void 0 === i) return super.once(t, e);
            const r = 'string' == typeof e ? [e] : e,
              n = this._createDelegatedListener(t, r, i);
            for (const a in n.delegates) {
              const e = n.delegates[a];
              n.delegates[a] = (...n) => {
                this._removeDelegatedListener(t, r, i), e(...n);
              };
            }
            this._saveDelegatedListener(t, n);
            for (const a in n.delegates) this.once(a, n.delegates[a]);
            return this;
          }
          off(t, e, i) {
            return void 0 === i
              ? super.off(t, e)
              : (this._removeDelegatedListener(
                  t,
                  'string' == typeof e ? [e] : e,
                  i
                ),
                this);
          }
          queryRenderedFeatures(t, i) {
            if (!this.style) return [];
            let r;
            const n = t instanceof e.P || Array.isArray(t),
              a = n
                ? t
                : [
                    [0, 0],
                    [this.transform.width, this.transform.height],
                  ];
            if (
              ((i = i || (n ? {} : t) || {}),
              a instanceof e.P || 'number' == typeof a[0])
            )
              r = [e.P.convert(a)];
            else {
              const t = e.P.convert(a[0]),
                i = e.P.convert(a[1]);
              r = [t, new e.P(i.x, t.y), i, new e.P(t.x, i.y), t];
            }
            return this.style.queryRenderedFeatures(r, i, this.transform);
          }
          querySourceFeatures(t, e) {
            return this.style.querySourceFeatures(t, e);
          }
          setStyle(t, i) {
            return !1 !==
              (i = e.e(
                {},
                {
                  localIdeographFontFamily: this._localIdeographFontFamily,
                  validate: this._validateStyle,
                },
                i
              )).diff &&
              i.localIdeographFontFamily === this._localIdeographFontFamily &&
              this.style &&
              t
              ? (this._diffStyle(t, i), this)
              : ((this._localIdeographFontFamily = i.localIdeographFontFamily),
                this._updateStyle(t, i));
          }
          setTransformRequest(t) {
            return this._requestManager.setTransformRequest(t), this;
          }
          _getUIString(t) {
            const e = this._locale[t];
            if (null == e) throw new Error(`Missing UI string '${t}'`);
            return e;
          }
          _updateStyle(t, e) {
            var i, r;
            if (e.transformStyle && this.style && !this.style._loaded)
              return void this.style.once('style.load', () =>
                this._updateStyle(t, e)
              );
            const n =
              this.style && e.transformStyle ? this.style.serialize() : void 0;
            return (
              this.style &&
                (this.style.setEventedParent(null), this.style._remove(!t)),
              t
                ? ((this.style = new Di(this, e || {})),
                  this.style.setEventedParent(this, { style: this.style }),
                  'string' == typeof t
                    ? this.style.loadURL(t, e, n)
                    : this.style.loadJSON(t, e, n),
                  this)
                : (null ===
                    (r =
                      null === (i = this.style) || void 0 === i
                        ? void 0
                        : i.projection) ||
                    void 0 === r ||
                    r.destroy(),
                  delete this.style,
                  this)
            );
          }
          _lazyInitEmptyStyle() {
            this.style ||
              ((this.style = new Di(this, {})),
              this.style.setEventedParent(this, { style: this.style }),
              this.style.loadEmpty());
          }
          _diffStyle(t, i) {
            if ('string' == typeof t) {
              const r = this._requestManager.transformRequest(t, 'Style');
              e.j(r, new AbortController())
                .then((t) => {
                  this._updateDiff(t.data, i);
                })
                .catch((t) => {
                  t && this.fire(new e.k(t));
                });
            } else 'object' == typeof t && this._updateDiff(t, i);
          }
          _updateDiff(t, i) {
            try {
              this.style.setState(t, i) && this._update(!0);
            } catch (r) {
              e.w(
                `Unable to perform style diff: ${
                  r.message || r.error || r
                }.  Rebuilding the style from scratch.`
              ),
                this._updateStyle(t, i);
            }
          }
          getStyle() {
            if (this.style) return this.style.serialize();
          }
          isStyleLoaded() {
            return this.style
              ? this.style.loaded()
              : e.w('There is no style added to the map.');
          }
          addSource(t, e) {
            return (
              this._lazyInitEmptyStyle(),
              this.style.addSource(t, e),
              this._update(!0)
            );
          }
          isSourceLoaded(t) {
            const i = this.style && this.style.tileManagers[t];
            if (void 0 !== i) return i.loaded();
            this.fire(
              new e.k(new Error(`There is no tile manager with ID '${t}'`))
            );
          }
          setTerrain(t) {
            if (
              (this.style._checkLoaded(),
              this._terrainDataCallback &&
                this.style.off('data', this._terrainDataCallback),
              t)
            ) {
              const i = this.style.tileManagers[t.source];
              if (!i)
                throw new Error(
                  `cannot load terrain, because there exists no source with ID: ${t.source}`
                );
              null === this.terrain && i.reload();
              for (const r in this.style._layers) {
                const i = this.style._layers[r];
                'hillshade' === i.type &&
                  i.source === t.source &&
                  e.w(
                    'You are using the same source for a hillshade layer and for 3D terrain. Please consider using two separate sources to improve rendering quality.'
                  ),
                  'color-relief' === i.type &&
                    i.source === t.source &&
                    e.w(
                      'You are using the same source for a color-relief layer and for 3D terrain. Please consider using two separate sources to improve rendering quality.'
                    );
              }
              (this.terrain = new Wa(this.painter, i, t)),
                (this.painter.renderToTexture = new Ka(
                  this.painter,
                  this.terrain
                )),
                this.transform.setMinElevationForCurrentTile(
                  this.terrain.getMinTileElevationForLngLatZoom(
                    this.transform.center,
                    this.transform.tileZoom
                  )
                ),
                this.transform.setElevation(
                  this.terrain.getElevationForLngLatZoom(
                    this.transform.center,
                    this.transform.tileZoom
                  )
                ),
                (this._terrainDataCallback = (e) => {
                  var i;
                  'style' === e.dataType
                    ? this.terrain.tileManager.freeRtt()
                    : 'source' === e.dataType &&
                      e.tile &&
                      (e.sourceId !== t.source ||
                        this._elevationFreeze ||
                        (this.transform.setMinElevationForCurrentTile(
                          this.terrain.getMinTileElevationForLngLatZoom(
                            this.transform.center,
                            this.transform.tileZoom
                          )
                        ),
                        this._centerClampedToGround &&
                          this.transform.setElevation(
                            this.terrain.getElevationForLngLatZoom(
                              this.transform.center,
                              this.transform.tileZoom
                            )
                          )),
                      'image' ===
                      (null === (i = e.source) || void 0 === i
                        ? void 0
                        : i.type)
                        ? this.terrain.tileManager.freeRtt()
                        : this.terrain.tileManager.freeRtt(e.tile.tileID));
                }),
                this.style.on('data', this._terrainDataCallback);
            } else
              this.terrain && this.terrain.tileManager.destruct(),
                (this.terrain = null),
                this.painter.renderToTexture &&
                  this.painter.renderToTexture.destruct(),
                (this.painter.renderToTexture = null),
                this.transform.setMinElevationForCurrentTile(0),
                this._centerClampedToGround && this.transform.setElevation(0);
            return this.fire(new e.l('terrain', { terrain: t })), this;
          }
          getTerrain() {
            var t, e;
            return null !==
              (e =
                null === (t = this.terrain) || void 0 === t
                  ? void 0
                  : t.options) && void 0 !== e
              ? e
              : null;
          }
          areTilesLoaded() {
            const t = this.style && this.style.tileManagers;
            for (const e in t) {
              const i = t[e]._tiles;
              for (const t in i) {
                const e = i[t];
                if ('loaded' !== e.state && 'errored' !== e.state) return !1;
              }
            }
            return !0;
          }
          removeSource(t) {
            return this.style.removeSource(t), this._update(!0);
          }
          getSource(t) {
            return this.style.getSource(t);
          }
          setSourceTileLodParams(t, e, i) {
            if (i) {
              const r = this.getSource(i);
              if (!r)
                throw new Error(
                  `There is no source with ID "${i}", cannot set LOD parameters`
                );
              r.calculateTileZoom = wt(Math.max(1, t), Math.max(1, e));
            } else
              for (const r in this.style.tileManagers)
                this.style.tileManagers[r].getSource().calculateTileZoom = wt(
                  Math.max(1, t),
                  Math.max(1, e)
                );
            return this._update(!0), this;
          }
          refreshTiles(t, i) {
            const r = this.style.tileManagers[t];
            if (!r)
              throw new Error(
                `There is no tile manager with ID "${t}", cannot refresh tile`
              );
            void 0 === i
              ? r.reload(!0)
              : r.refreshTiles(i.map((t) => new e.a8(t.z, t.x, t.y)));
          }
          addImage(t, i, r = {}) {
            const {
              pixelRatio: n = 1,
              sdf: a = !1,
              stretchX: o,
              stretchY: l,
              content: c,
              textFitWidth: h,
              textFitHeight: u,
            } = r;
            if (
              (this._lazyInitEmptyStyle(),
              !(i instanceof HTMLImageElement || e.b(i)))
            ) {
              if (void 0 === i.width || void 0 === i.height)
                return this.fire(
                  new e.k(
                    new Error(
                      'Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`'
                    )
                  )
                );
              {
                const { width: r, height: s, data: d } = i,
                  p = i;
                return (
                  this.style.addImage(t, {
                    data: new e.R({ width: r, height: s }, new Uint8Array(d)),
                    pixelRatio: n,
                    stretchX: o,
                    stretchY: l,
                    content: c,
                    textFitWidth: h,
                    textFitHeight: u,
                    sdf: a,
                    version: 0,
                    userImage: p,
                  }),
                  p.onAdd && p.onAdd(this, t),
                  this
                );
              }
            }
            {
              const { width: r, height: d, data: p } = s.getImageData(i);
              this.style.addImage(t, {
                data: new e.R({ width: r, height: d }, p),
                pixelRatio: n,
                stretchX: o,
                stretchY: l,
                content: c,
                textFitWidth: h,
                textFitHeight: u,
                sdf: a,
                version: 0,
              });
            }
          }
          updateImage(t, i) {
            const r = this.style.getImage(t);
            if (!r)
              return this.fire(
                new e.k(
                  new Error(
                    'The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.'
                  )
                )
              );
            const n =
                i instanceof HTMLImageElement || e.b(i) ? s.getImageData(i) : i,
              { width: a, height: o, data: l } = n;
            if (void 0 === a || void 0 === o)
              return this.fire(
                new e.k(
                  new Error(
                    'Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`'
                  )
                )
              );
            if (a !== r.data.width || o !== r.data.height)
              return this.fire(
                new e.k(
                  new Error(
                    'The width and height of the updated image must be that same as the previous version of the image'
                  )
                )
              );
            const c = !(i instanceof HTMLImageElement || e.b(i));
            return r.data.replace(l, c), this.style.updateImage(t, r), this;
          }
          getImage(t) {
            return this.style.getImage(t);
          }
          hasImage(t) {
            return t
              ? !!this.style.getImage(t)
              : (this.fire(new e.k(new Error('Missing required image id'))),
                !1);
          }
          removeImage(t) {
            this.style.removeImage(t);
          }
          loadImage(t) {
            return g.getImage(
              this._requestManager.transformRequest(t, 'Image'),
              new AbortController()
            );
          }
          listImages() {
            return this.style.listImages();
          }
          addLayer(t, e) {
            return (
              this._lazyInitEmptyStyle(),
              this.style.addLayer(t, e),
              this._update(!0)
            );
          }
          moveLayer(t, e) {
            return this.style.moveLayer(t, e), this._update(!0);
          }
          removeLayer(t) {
            return this.style.removeLayer(t), this._update(!0);
          }
          getLayer(t) {
            return this.style.getLayer(t);
          }
          getLayersOrder() {
            return this.style.getLayersOrder();
          }
          setLayerZoomRange(t, e, i) {
            return this.style.setLayerZoomRange(t, e, i), this._update(!0);
          }
          setFilter(t, e, i = {}) {
            return this.style.setFilter(t, e, i), this._update(!0);
          }
          getFilter(t) {
            return this.style.getFilter(t);
          }
          setPaintProperty(t, e, i, r = {}) {
            return this.style.setPaintProperty(t, e, i, r), this._update(!0);
          }
          getPaintProperty(t, e) {
            return this.style.getPaintProperty(t, e);
          }
          setLayoutProperty(t, e, i, r = {}) {
            return this.style.setLayoutProperty(t, e, i, r), this._update(!0);
          }
          getLayoutProperty(t, e) {
            return this.style.getLayoutProperty(t, e);
          }
          setGlyphs(t, e = {}) {
            return (
              this._lazyInitEmptyStyle(),
              this.style.setGlyphs(t, e),
              this._update(!0)
            );
          }
          getGlyphs() {
            return this.style.getGlyphsUrl();
          }
          addSprite(t, e, i = {}) {
            return (
              this._lazyInitEmptyStyle(),
              this.style.addSprite(t, e, i, (t) => {
                t || this._update(!0);
              }),
              this
            );
          }
          removeSprite(t) {
            return (
              this._lazyInitEmptyStyle(),
              this.style.removeSprite(t),
              this._update(!0)
            );
          }
          getSprite() {
            return this.style.getSprite();
          }
          setSprite(t, e = {}) {
            return (
              this._lazyInitEmptyStyle(),
              this.style.setSprite(t, e, (t) => {
                t || this._update(!0);
              }),
              this
            );
          }
          setLight(t, e = {}) {
            return (
              this._lazyInitEmptyStyle(),
              this.style.setLight(t, e),
              this._update(!0)
            );
          }
          getLight() {
            return this.style.getLight();
          }
          setSky(t, e = {}) {
            return (
              this._lazyInitEmptyStyle(),
              this.style.setSky(t, e),
              this._update(!0)
            );
          }
          getSky() {
            return this.style.getSky();
          }
          setFeatureState(t, e) {
            return this.style.setFeatureState(t, e), this._update();
          }
          removeFeatureState(t, e) {
            return this.style.removeFeatureState(t, e), this._update();
          }
          getFeatureState(t) {
            return this.style.getFeatureState(t);
          }
          getContainer() {
            return this._container;
          }
          getCanvasContainer() {
            return this._canvasContainer;
          }
          getCanvas() {
            return this._canvas;
          }
          _containerDimensions() {
            let t = 0,
              e = 0;
            return (
              this._container &&
                ((t = this._container.clientWidth || 400),
                (e = this._container.clientHeight || 300)),
              [t, e]
            );
          }
          _setupContainer() {
            const t = this._container;
            t.classList.add('maplibregl-map');
            const e = (this._canvasContainer = c.create(
              'div',
              'maplibregl-canvas-container',
              t
            ));
            this._interactive && e.classList.add('maplibregl-interactive'),
              (this._canvas = c.create('canvas', 'maplibregl-canvas', e)),
              this._canvas.addEventListener(
                'webglcontextlost',
                this._contextLost,
                !1
              ),
              this._canvas.addEventListener(
                'webglcontextrestored',
                this._contextRestored,
                !1
              ),
              this._canvas.setAttribute(
                'tabindex',
                this._interactive ? '0' : '-1'
              ),
              this._canvas.setAttribute(
                'aria-label',
                this._getUIString('Map.Title')
              ),
              this._canvas.setAttribute('role', 'region');
            const i = this._containerDimensions(),
              r = this._getClampedPixelRatio(i[0], i[1]);
            this._resizeCanvas(i[0], i[1], r);
            const n = (this._controlContainer = c.create(
                'div',
                'maplibregl-control-container',
                t
              )),
              a = (this._controlPositions = {});
            ['top-left', 'top-right', 'bottom-left', 'bottom-right'].forEach(
              (t) => {
                a[t] = c.create('div', `maplibregl-ctrl-${t} `, n);
              }
            ),
              this._container.addEventListener('scroll', this._onMapScroll, !1);
          }
          _resizeCanvas(t, e, i) {
            (this._canvas.width = Math.floor(i * t)),
              (this._canvas.height = Math.floor(i * e)),
              (this._canvas.style.width = `${t}px`),
              (this._canvas.style.height = `${e}px`);
          }
          _setupPainter() {
            const t = Object.assign(
              Object.assign({}, this._canvasContextAttributes),
              { alpha: !0, depth: !0, stencil: !0, premultipliedAlpha: !0 }
            );
            let e = null;
            this._canvas.addEventListener(
              'webglcontextcreationerror',
              (i) => {
                (e = { requestedAttributes: t }),
                  i && ((e.statusMessage = i.statusMessage), (e.type = i.type));
              },
              { once: !0 }
            );
            let i = null;
            if (
              ((i = this._canvasContextAttributes.contextType
                ? this._canvas.getContext(
                    this._canvasContextAttributes.contextType,
                    t
                  )
                : this._canvas.getContext('webgl2', t) ||
                  this._canvas.getContext('webgl', t)),
              !i)
            ) {
              const t = 'Failed to initialize WebGL';
              throw e
                ? ((e.message = t), new Error(JSON.stringify(e)))
                : new Error(t);
            }
            (this.painter = new Vn(i, this.transform)), h.testSupport(i);
          }
          migrateProjection(t, i) {
            super.migrateProjection(t, i),
              (this.painter.transform = t),
              this.fire(
                new e.l('projectiontransition', {
                  newProjection: this.style.projection.name,
                })
              );
          }
          loaded() {
            return (
              !this._styleDirty &&
              !this._sourcesDirty &&
              !!this.style &&
              this.style.loaded()
            );
          }
          _update(t) {
            return this.style && this.style._loaded
              ? ((this._styleDirty = this._styleDirty || t),
                (this._sourcesDirty = !0),
                this.triggerRepaint(),
                this)
              : this;
          }
          _requestRenderFrame(t) {
            return this._update(), this._renderTaskQueue.add(t);
          }
          _cancelRenderFrame(t) {
            this._renderTaskQueue.remove(t);
          }
          _render(t) {
            var i, r, n, a, s;
            const o = this._idleTriggered ? this._fadeDuration : 0,
              c =
                (null === (i = this.style.projection) || void 0 === i
                  ? void 0
                  : i.transitionState) > 0;
            if (
              (this.painter.context.setDirty(),
              this.painter.setBaseState(),
              this._renderTaskQueue.run(t),
              this._removed)
            )
              return;
            let h = !1;
            if (this.style && this._styleDirty) {
              this._styleDirty = !1;
              const t = this.transform.zoom,
                i = l();
              this.style.zoomHistory.update(t, i);
              const r = new e.G(t, {
                  now: i,
                  fadeDuration: o,
                  zoomHistory: this.style.zoomHistory,
                  transition: this.style.getTransition(),
                }),
                n = r.crossFadingFactor();
              (1 === n && n === this._crossFadingFactor) ||
                ((h = !0), (this._crossFadingFactor = n)),
                this.style.update(r);
            }
            const u =
              (null === (r = this.style.projection) || void 0 === r
                ? void 0
                : r.transitionState) >
                0 !==
              c;
            null === (n = this.style.projection) ||
              void 0 === n ||
              n.setErrorQueryLatitudeDegrees(this.transform.center.lat),
              this.transform.setTransitionState(
                null === (a = this.style.projection) || void 0 === a
                  ? void 0
                  : a.transitionState,
                null === (s = this.style.projection) || void 0 === s
                  ? void 0
                  : s.latitudeErrorCorrectionRadians
              ),
              this.style &&
                (this._sourcesDirty || u) &&
                ((this._sourcesDirty = !1),
                this.style._updateSources(this.transform)),
              this.terrain
                ? (this.terrain.tileManager.update(
                    this.transform,
                    this.terrain
                  ),
                  this.transform.setMinElevationForCurrentTile(
                    this.terrain.getMinTileElevationForLngLatZoom(
                      this.transform.center,
                      this.transform.tileZoom
                    )
                  ),
                  !this._elevationFreeze &&
                    this._centerClampedToGround &&
                    this.transform.setElevation(
                      this.terrain.getElevationForLngLatZoom(
                        this.transform.center,
                        this.transform.tileZoom
                      )
                    ))
                : (this.transform.setMinElevationForCurrentTile(0),
                  this._centerClampedToGround &&
                    this.transform.setElevation(0)),
              (this._placementDirty =
                this.style &&
                this.style._updatePlacement(
                  this.transform,
                  this.showCollisionBoxes,
                  o,
                  this._crossSourceCollisions,
                  u
                )),
              this.painter.render(this.style, {
                showTileBoundaries: this.showTileBoundaries,
                showOverdrawInspector: this._showOverdrawInspector,
                rotating: this.isRotating(),
                zooming: this.isZooming(),
                moving: this.isMoving(),
                fadeDuration: o,
                showPadding: this.showPadding,
              }),
              this.fire(new e.l('render')),
              this.loaded() &&
                !this._loaded &&
                ((this._loaded = !0),
                e.cz.mark(e.cA.load),
                this.fire(new e.l('load'))),
              this.style &&
                (this.style.hasTransitions() || h) &&
                (this._styleDirty = !0),
              this.style &&
                !this._placementDirty &&
                this.style._releaseSymbolFadeTiles();
            const d =
              this._sourcesDirty || this._styleDirty || this._placementDirty;
            return (
              d || this._repaint
                ? this.triggerRepaint()
                : !this.isMoving() &&
                  this.loaded() &&
                  this.fire(new e.l('idle')),
              !this._loaded ||
                this._fullyLoaded ||
                d ||
                ((this._fullyLoaded = !0), e.cz.mark(e.cA.fullLoad)),
              this
            );
          }
          redraw() {
            return (
              this.style &&
                (this._frameRequest &&
                  (this._frameRequest.abort(), (this._frameRequest = null)),
                this._render(0)),
              this
            );
          }
          remove() {
            var t;
            this._hash && this._hash.remove();
            for (const e of this._controls) e.onRemove(this);
            (this._controls = []),
              this._frameRequest &&
                (this._frameRequest.abort(), (this._frameRequest = null)),
              this._renderTaskQueue.clear(),
              this.painter.destroy(),
              this.handlers.destroy(),
              delete this.handlers,
              this.setStyle(null),
              'undefined' != typeof window &&
                removeEventListener('online', this._onWindowOnline, !1),
              g.removeThrottleControl(this._imageQueueHandle),
              null === (t = this._resizeObserver) ||
                void 0 === t ||
                t.disconnect();
            const i =
              this.painter.context.gl.getExtension('WEBGL_lose_context');
            (null == i ? void 0 : i.loseContext) && i.loseContext(),
              this._canvas.removeEventListener(
                'webglcontextrestored',
                this._contextRestored,
                !1
              ),
              this._canvas.removeEventListener(
                'webglcontextlost',
                this._contextLost,
                !1
              ),
              c.remove(this._canvasContainer),
              c.remove(this._controlContainer),
              this._container.removeEventListener(
                'scroll',
                this._onMapScroll,
                !1
              ),
              this._container.classList.remove('maplibregl-map'),
              e.cz.clearMetrics(),
              (this._removed = !0),
              this.fire(new e.l('remove'));
          }
          triggerRepaint() {
            this.style &&
              !this._frameRequest &&
              ((this._frameRequest = new AbortController()),
              s.frame(
                this._frameRequest,
                (t) => {
                  e.cz.frame(t), (this._frameRequest = null);
                  try {
                    this._render(t);
                  } catch (t) {
                    if (
                      !e.cB(t) &&
                      !(function (t) {
                        return t.message === Qr;
                      })(t)
                    )
                      throw t;
                  }
                },
                () => {}
              ));
          }
          get showTileBoundaries() {
            return !!this._showTileBoundaries;
          }
          set showTileBoundaries(t) {
            this._showTileBoundaries !== t &&
              ((this._showTileBoundaries = t), this._update());
          }
          get showPadding() {
            return !!this._showPadding;
          }
          set showPadding(t) {
            this._showPadding !== t &&
              ((this._showPadding = t), this._update());
          }
          get showCollisionBoxes() {
            return !!this._showCollisionBoxes;
          }
          set showCollisionBoxes(t) {
            this._showCollisionBoxes !== t &&
              ((this._showCollisionBoxes = t),
              t ? this.style._generateCollisionBoxes() : this._update());
          }
          get showOverdrawInspector() {
            return !!this._showOverdrawInspector;
          }
          set showOverdrawInspector(t) {
            this._showOverdrawInspector !== t &&
              ((this._showOverdrawInspector = t), this._update());
          }
          get repaint() {
            return !!this._repaint;
          }
          set repaint(t) {
            this._repaint !== t && ((this._repaint = t), this.triggerRepaint());
          }
          get vertices() {
            return !!this._vertices;
          }
          set vertices(t) {
            (this._vertices = t), this._update();
          }
          get version() {
            return Qa;
          }
          getCameraTargetElevation() {
            return this.transform.elevation;
          }
          getProjection() {
            return this.style.getProjection();
          }
          setProjection(t) {
            return (
              this._lazyInitEmptyStyle(),
              this.style.setProjection(t),
              this._update(!0)
            );
          }
        }),
        (t.MapMouseEvent = Jn),
        (t.MapTouchEvent = Qn),
        (t.MapWheelEvent = ta),
        (t.Marker = os),
        (t.NavigationControl = class {
          constructor(t) {
            (this._updateZoomButtons = () => {
              const t = this._map.getZoom(),
                e = t === this._map.getMaxZoom(),
                i = t === this._map.getMinZoom();
              (this._zoomInButton.disabled = e),
                (this._zoomOutButton.disabled = i),
                this._zoomInButton.setAttribute('aria-disabled', e.toString()),
                this._zoomOutButton.setAttribute('aria-disabled', i.toString());
            }),
              (this._rotateCompassArrow = () => {
                this._compassIcon.style.transform =
                  this.options.visualizePitch && this.options.visualizeRoll
                    ? `scale(${
                        1 /
                        Math.pow(
                          Math.cos(this._map.transform.pitchInRadians),
                          0.5
                        )
                      }) rotateZ(${-this._map.transform.roll}deg) rotateX(${
                        this._map.transform.pitch
                      }deg) rotateZ(${-this._map.transform.bearing}deg)`
                    : this.options.visualizePitch
                    ? `scale(${
                        1 /
                        Math.pow(
                          Math.cos(this._map.transform.pitchInRadians),
                          0.5
                        )
                      }) rotateX(${
                        this._map.transform.pitch
                      }deg) rotateZ(${-this._map.transform.bearing}deg)`
                    : this.options.visualizeRoll
                    ? `rotate(${
                        -this._map.transform.bearing - this._map.transform.roll
                      }deg)`
                    : `rotate(${-this._map.transform.bearing}deg)`;
              }),
              (this._setButtonTitle = (t, e) => {
                const i = this._map._getUIString(`NavigationControl.${e}`);
                (t.title = i), t.setAttribute('aria-label', i);
              }),
              (this.options = e.e({}, es, t)),
              (this._container = c.create(
                'div',
                'maplibregl-ctrl maplibregl-ctrl-group'
              )),
              this._container.addEventListener('contextmenu', (t) =>
                t.preventDefault()
              ),
              this.options.showZoom &&
                ((this._zoomInButton = this._createButton(
                  'maplibregl-ctrl-zoom-in',
                  (t) => this._map.zoomIn({}, { originalEvent: t })
                )),
                c
                  .create('span', 'maplibregl-ctrl-icon', this._zoomInButton)
                  .setAttribute('aria-hidden', 'true'),
                (this._zoomOutButton = this._createButton(
                  'maplibregl-ctrl-zoom-out',
                  (t) => this._map.zoomOut({}, { originalEvent: t })
                )),
                c
                  .create('span', 'maplibregl-ctrl-icon', this._zoomOutButton)
                  .setAttribute('aria-hidden', 'true')),
              this.options.showCompass &&
                ((this._compass = this._createButton(
                  'maplibregl-ctrl-compass',
                  (t) => {
                    this.options.visualizePitch
                      ? this._map.resetNorthPitch({}, { originalEvent: t })
                      : this._map.resetNorth({}, { originalEvent: t });
                  }
                )),
                (this._compassIcon = c.create(
                  'span',
                  'maplibregl-ctrl-icon',
                  this._compass
                )),
                this._compassIcon.setAttribute('aria-hidden', 'true'));
          }
          onAdd(t) {
            return (
              (this._map = t),
              this.options.showZoom &&
                (this._setButtonTitle(this._zoomInButton, 'ZoomIn'),
                this._setButtonTitle(this._zoomOutButton, 'ZoomOut'),
                this._map.on('zoom', this._updateZoomButtons),
                this._updateZoomButtons()),
              this.options.showCompass &&
                (this._setButtonTitle(this._compass, 'ResetBearing'),
                this.options.visualizePitch &&
                  this._map.on('pitch', this._rotateCompassArrow),
                this.options.visualizeRoll &&
                  this._map.on('roll', this._rotateCompassArrow),
                this._map.on('rotate', this._rotateCompassArrow),
                this._rotateCompassArrow(),
                (this._handler = new is(
                  this._map,
                  this._compass,
                  this.options.visualizePitch
                ))),
              this._container
            );
          }
          onRemove() {
            c.remove(this._container),
              this.options.showZoom &&
                this._map.off('zoom', this._updateZoomButtons),
              this.options.showCompass &&
                (this.options.visualizePitch &&
                  this._map.off('pitch', this._rotateCompassArrow),
                this.options.visualizeRoll &&
                  this._map.off('roll', this._rotateCompassArrow),
                this._map.off('rotate', this._rotateCompassArrow),
                this._handler.off(),
                delete this._handler),
              delete this._map;
          }
          _createButton(t, e) {
            const i = c.create('button', t, this._container);
            return (i.type = 'button'), i.addEventListener('click', e), i;
          }
        }),
        (t.Popup = class extends e.E {
          constructor(t) {
            super(),
              (this._updateOpacity = () => {
                void 0 !== this.options.locationOccludedOpacity &&
                  (this._container.style.opacity =
                    this._map.transform.isLocationOccluded(this.getLngLat())
                      ? `${this.options.locationOccludedOpacity}`
                      : '');
              }),
              (this.remove = () => (
                this._content && c.remove(this._content),
                this._container &&
                  (c.remove(this._container), delete this._container),
                this._map &&
                  (this._map.off('move', this._update),
                  this._map.off('move', this._onClose),
                  this._map.off('click', this._onClose),
                  this._map.off('remove', this.remove),
                  this._map.off('mousemove', this._onMouseMove),
                  this._map.off('mouseup', this._onMouseUp),
                  this._map.off('drag', this._onDrag),
                  this._map._canvasContainer.classList.remove(
                    'maplibregl-track-pointer'
                  ),
                  delete this._map,
                  this.fire(new e.l('close'))),
                this
              )),
              (this._onMouseUp = (t) => {
                this._update(t.point);
              }),
              (this._onMouseMove = (t) => {
                this._update(t.point);
              }),
              (this._onDrag = (t) => {
                this._update(t.point);
              }),
              (this._update = (t) => {
                if (
                  !this._map ||
                  (!this._lngLat && !this._trackPointer) ||
                  !this._content
                )
                  return;
                if (!this._container) {
                  if (
                    ((this._container = c.create(
                      'div',
                      'maplibregl-popup',
                      this._map.getContainer()
                    )),
                    (this._tip = c.create(
                      'div',
                      'maplibregl-popup-tip',
                      this._container
                    )),
                    this._container.appendChild(this._content),
                    this.options.className)
                  )
                    for (const t of this.options.className.split(' '))
                      this._container.classList.add(t);
                  this._closeButton &&
                    this._closeButton.setAttribute(
                      'aria-label',
                      this._map._getUIString('Popup.Close')
                    ),
                    this._trackPointer &&
                      this._container.classList.add(
                        'maplibregl-popup-track-pointer'
                      );
                }
                if (
                  (this.options.maxWidth &&
                    this._container.style.maxWidth !== this.options.maxWidth &&
                    (this._container.style.maxWidth = this.options.maxWidth),
                  (this._lngLat = ns(
                    this._lngLat,
                    this._flatPos,
                    this._map.transform,
                    this._trackPointer
                  )),
                  this._trackPointer && !t)
                )
                  return;
                const e =
                  (this._flatPos =
                  this._pos =
                    this._trackPointer && t
                      ? t
                      : this._map.project(this._lngLat));
                this._map.terrain &&
                  (this._flatPos =
                    this._trackPointer && t
                      ? t
                      : this._map.transform.locationToScreenPoint(
                          this._lngLat
                        ));
                let i = this.options.anchor;
                const r = gs(this.options.offset);
                if (!i) {
                  const t = this._container.offsetWidth,
                    n = this._container.offsetHeight;
                  let a;
                  (a =
                    e.y + r.bottom.y < n
                      ? ['top']
                      : e.y > this._map.transform.height - n
                      ? ['bottom']
                      : []),
                    e.x < t / 2
                      ? a.push('left')
                      : e.x > this._map.transform.width - t / 2 &&
                        a.push('right'),
                    (i = 0 === a.length ? 'bottom' : a.join('-'));
                }
                let n = e.add(r[i]);
                this.options.subpixelPositioning || (n = n.round()),
                  c.setTransform(
                    this._container,
                    `${as[i]} translate(${n.x}px,${n.y}px)`
                  ),
                  ss(this._container, i, 'popup'),
                  this._updateOpacity();
              }),
              (this._onClose = () => {
                this.remove();
              }),
              (this.options = e.e(Object.create(fs), t));
          }
          addTo(t) {
            return (
              this._map && this.remove(),
              (this._map = t),
              this.options.closeOnClick && this._map.on('click', this._onClose),
              this.options.closeOnMove && this._map.on('move', this._onClose),
              this._map.on('remove', this.remove),
              this._update(),
              this._focusFirstElement(),
              this._trackPointer
                ? (this._map.on('mousemove', this._onMouseMove),
                  this._map.on('mouseup', this._onMouseUp),
                  this._container &&
                    this._container.classList.add(
                      'maplibregl-popup-track-pointer'
                    ),
                  this._map._canvasContainer.classList.add(
                    'maplibregl-track-pointer'
                  ))
                : this._map.on('move', this._update),
              this.fire(new e.l('open')),
              this
            );
          }
          isOpen() {
            return !!this._map;
          }
          getLngLat() {
            return this._lngLat;
          }
          setLngLat(t) {
            return (
              (this._lngLat = e.U.convert(t)),
              (this._pos = null),
              (this._flatPos = null),
              (this._trackPointer = !1),
              this._update(),
              this._map &&
                (this._map.on('move', this._update),
                this._map.off('mousemove', this._onMouseMove),
                this._container &&
                  this._container.classList.remove(
                    'maplibregl-popup-track-pointer'
                  ),
                this._map._canvasContainer.classList.remove(
                  'maplibregl-track-pointer'
                )),
              this
            );
          }
          trackPointer() {
            return (
              (this._trackPointer = !0),
              (this._pos = null),
              (this._flatPos = null),
              this._update(),
              this._map &&
                (this._map.off('move', this._update),
                this._map.on('mousemove', this._onMouseMove),
                this._map.on('drag', this._onDrag),
                this._container &&
                  this._container.classList.add(
                    'maplibregl-popup-track-pointer'
                  ),
                this._map._canvasContainer.classList.add(
                  'maplibregl-track-pointer'
                )),
              this
            );
          }
          getElement() {
            return this._container;
          }
          setText(t) {
            return this.setDOMContent(document.createTextNode(t));
          }
          setHTML(t) {
            const e = document.createDocumentFragment(),
              i = document.createElement('body');
            let r;
            for (i.innerHTML = t; (r = i.firstChild), r; ) e.appendChild(r);
            return this.setDOMContent(e);
          }
          getMaxWidth() {
            var t;
            return null === (t = this._container) || void 0 === t
              ? void 0
              : t.style.maxWidth;
          }
          setMaxWidth(t) {
            return (this.options.maxWidth = t), this._update(), this;
          }
          setDOMContent(t) {
            if (this._content)
              for (; this._content.hasChildNodes(); )
                this._content.firstChild &&
                  this._content.removeChild(this._content.firstChild);
            else
              this._content = c.create(
                'div',
                'maplibregl-popup-content',
                this._container
              );
            return (
              this._content.appendChild(t),
              this._createCloseButton(),
              this._update(),
              this._focusFirstElement(),
              this
            );
          }
          addClassName(t) {
            return this._container && this._container.classList.add(t), this;
          }
          removeClassName(t) {
            return this._container && this._container.classList.remove(t), this;
          }
          setOffset(t) {
            return (this.options.offset = t), this._update(), this;
          }
          toggleClassName(t) {
            if (this._container) return this._container.classList.toggle(t);
          }
          setSubpixelPositioning(t) {
            this.options.subpixelPositioning = t;
          }
          _createCloseButton() {
            this.options.closeButton &&
              ((this._closeButton = c.create(
                'button',
                'maplibregl-popup-close-button',
                this._content
              )),
              (this._closeButton.type = 'button'),
              (this._closeButton.innerHTML = '&#215;'),
              this._closeButton.addEventListener('click', this._onClose));
          }
          _focusFirstElement() {
            if (!this.options.focusAfterOpen || !this._container) return;
            const t = this._container.querySelector(ms);
            t && t.focus();
          }
        }),
        (t.RasterDEMTileSource = Y),
        (t.RasterTileSource = X),
        (t.ScaleControl = class {
          constructor(t) {
            (this._onMove = () => {
              ds(this._map, this._container, this.options);
            }),
              (this.setUnit = (t) => {
                (this.options.unit = t),
                  ds(this._map, this._container, this.options);
              }),
              (this.options = Object.assign(Object.assign({}, us), t));
          }
          getDefaultPosition() {
            return 'bottom-left';
          }
          onAdd(t) {
            return (
              (this._map = t),
              (this._container = c.create(
                'div',
                'maplibregl-ctrl maplibregl-ctrl-scale',
                t.getContainer()
              )),
              this._map.on('move', this._onMove),
              this._onMove(),
              this._container
            );
          }
          onRemove() {
            c.remove(this._container),
              this._map.off('move', this._onMove),
              (this._map = void 0);
          }
        }),
        (t.ScrollZoomHandler = Da),
        (t.Style = Di),
        (t.TerrainControl = class {
          constructor(t) {
            (this._toggleTerrain = () => {
              this._map.getTerrain()
                ? this._map.setTerrain(null)
                : this._map.setTerrain(this.options),
                this._updateTerrainIcon();
            }),
              (this._updateTerrainIcon = () => {
                this._terrainButton.classList.remove('maplibregl-ctrl-terrain'),
                  this._terrainButton.classList.remove(
                    'maplibregl-ctrl-terrain-enabled'
                  ),
                  this._map.terrain
                    ? (this._terrainButton.classList.add(
                        'maplibregl-ctrl-terrain-enabled'
                      ),
                      (this._terrainButton.title = this._map._getUIString(
                        'TerrainControl.Disable'
                      )))
                    : (this._terrainButton.classList.add(
                        'maplibregl-ctrl-terrain'
                      ),
                      (this._terrainButton.title = this._map._getUIString(
                        'TerrainControl.Enable'
                      )));
              }),
              (this.options = t);
          }
          onAdd(t) {
            return (
              (this._map = t),
              (this._container = c.create(
                'div',
                'maplibregl-ctrl maplibregl-ctrl-group'
              )),
              (this._terrainButton = c.create(
                'button',
                'maplibregl-ctrl-terrain',
                this._container
              )),
              c
                .create('span', 'maplibregl-ctrl-icon', this._terrainButton)
                .setAttribute('aria-hidden', 'true'),
              (this._terrainButton.type = 'button'),
              this._terrainButton.addEventListener(
                'click',
                this._toggleTerrain
              ),
              this._updateTerrainIcon(),
              this._map.on('terrain', this._updateTerrainIcon),
              this._container
            );
          }
          onRemove() {
            c.remove(this._container),
              this._map.off('terrain', this._updateTerrainIcon),
              (this._map = void 0);
          }
        }),
        (t.TwoFingersTouchPitchHandler = Ta),
        (t.TwoFingersTouchRotateHandler = ba),
        (t.TwoFingersTouchZoomHandler = va),
        (t.TwoFingersTouchZoomRotateHandler = ka),
        (t.VectorTileSource = W),
        (t.VideoSource = et),
        (t.addSourceType = (t, i) =>
          e._(void 0, void 0, void 0, function* () {
            if (nt(t))
              throw new Error(`A source type called "${t}" already exists.`);
            ((t, e) => {
              rt[t] = e;
            })(t, i);
          })),
        (t.clearPrewarmedResources = function () {
          const t = O;
          t &&
            (t.isPreloaded() && 1 === t.numActive()
              ? (t.release(R), (O = null))
              : console.warn(
                  'Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()'
                ));
        }),
        (t.createTileMesh = ii),
        (t.getMaxParallelImageRequests = function () {
          return e.a.MAX_PARALLEL_IMAGE_REQUESTS;
        }),
        (t.getRTLTextPluginStatus = function () {
          return lt().getRTLTextPluginStatus();
        }),
        (t.getVersion = function () {
          return _s;
        }),
        (t.getWorkerCount = function () {
          return z.workerCount;
        }),
        (t.getWorkerUrl = function () {
          return e.a.WORKER_URL;
        }),
        (t.importScriptInWorkers = function (t) {
          return V().broadcast('IS', t);
        }),
        (t.isTimeFrozen = function () {
          return o.isFrozen();
        }),
        (t.now = l),
        (t.prewarm = function () {
          B().acquire(R);
        }),
        (t.restoreNow = function () {
          o.restoreNow();
        }),
        (t.setMaxParallelImageRequests = function (t) {
          e.a.MAX_PARALLEL_IMAGE_REQUESTS = t;
        }),
        (t.setNow = function (t) {
          o.setNow(t);
        }),
        (t.setRTLTextPlugin = function (t, e) {
          return lt().setRTLTextPlugin(t, e);
        }),
        (t.setWorkerCount = function (t) {
          z.workerCount = t;
        }),
        (t.setWorkerUrl = function (t) {
          e.a.WORKER_URL = t;
        });
    });
  var r = t;
  return r;
})();
var Li = Mi(Di.exports),
  Ai = [
    {
      Name: 'Rehab Associates COVID-19 and Chronic Illness Recovery and Reconditioning Program',
      Longitude: -87.0165065,
      Latitude: 32.4331197,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Rehab Associates COVID-19 and Chronic Illness Recovery and Reconditioning Program',
      Longitude: -86.4212221,
      Latitude: 32.4624258,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Results Physiotherapy Post-Covid Rehabilitation',
      Longitude: -88.2259814,
      Latitude: 30.642048,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Results Physiotherapy Post-Covid Rehabilitation',
      Longitude: -86.6821577,
      Latitude: 33.4206459,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Results Physiotherapy Post-Covid Rehabilitation',
      Longitude: -86.5675729,
      Latitude: 34.6971615,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Champion Sports Medicine COVID-19 and Chronic Illness Recovery and Reconditioning program',
      Longitude: -86.0102837,
      Latitude: 34.66684,
      status: 'Did not answer the survey',
    },
    {
      Name: 'MedHelp Highway 280',
      Longitude: null,
      Latitude: null,
      status: 'Did not answer the survey',
    },
    {
      Name: '',
      Longitude: null,
      Latitude: null,
      status: 'Did not answer the survey',
    },
    {
      Name: 'University of Alabama at Birmingham',
      Longitude: -86.8156402,
      Latitude: 33.4986669,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Select Physical Therapy COVID-19 and Chronic Illness Recovery and Reconditioning program',
      Longitude: -150.7500507,
      Latitude: 60.5355054,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Select Physical Therapy COVID-19 and Chronic Illness Recovery and Reconditioning program',
      Longitude: -149.863179,
      Latitude: 61.1272512,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Select Physical Therapy COVID-19 and Chronic Illness Recovery and Reconditioning program',
      Longitude: -149.1140578,
      Latitude: 61.5994141,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Select Physical Therapy COVID-19 and Chronic Illness Recovery and Reconditioning program',
      Longitude: -147.8032786,
      Latitude: 64.8345344,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Bartlett Hospital Pulmonary Rehabilitation Program',
      Longitude: -134.4649168,
      Latitude: 58.3290164,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Neuroversion',
      Longitude: null,
      Latitude: null,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Banner University Medical Center - Phoenix',
      Longitude: -112.0563092,
      Latitude: 33.4639148,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Mountain Valley Regional Rehabilitation Hospital',
      Longitude: -112.3293878,
      Latitude: 34.5962432,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Rehabilitation Hospital of Northern Arizona',
      Longitude: -111.6305178,
      Latitude: 35.2093058,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Banner University Medical Center - Tucson',
      Longitude: -110.944877,
      Latitude: 32.24104,
      status: 'Did not answer the survey',
    },
    {
      Name: 'University of Arizona',
      Longitude: -110.946647,
      Latitude: 32.2404198,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Medical Associates of Northwest Arkansas Post COVID-19 Recovery Program',
      Longitude: -94.1559353,
      Latitude: 36.1121248,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Atlantis Physical Therapy COVID-19 Rehabilitation Program',
      Longitude: -118.3474276,
      Latitude: 33.8359868,
      status: 'Yes, They offer care',
    },
    {
      Name: 'Center for Complex Diseases',
      Longitude: -122.0824643,
      Latitude: 37.3687946,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Childrens Hospital Los Angeles Long COVID Recovery Care',
      Longitude: -118.2901101,
      Latitude: 34.0979878,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Keck Medicine of USC COVID Recovery Clinic',
      Longitude: -118.2015033,
      Latitude: 34.061963,
      status: 'Yes, They offer care',
    },
    {
      Name: 'Loma Linda University Health COVID-19 Heart Clinic',
      Longitude: -117.2641774,
      Latitude: 34.0494519,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Mission Heritage Medical Group Post Covid Clinic',
      Longitude: -117.6672549,
      Latitude: 33.5625279,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Pomona Valley Hospital Medical Center Post-COVID-19 Recovery Program',
      Longitude: -117.750907,
      Latitude: 34.076612,
      status: 'Did not answer the survey',
    },
    {
      Name: 'PRN Physical Therapy / PACER Program',
      Longitude: -117.1353451,
      Latitude: 32.7731212,
      status: 'Did not answer the survey',
    },
    {
      Name: 'PRN Physical Therapy / PACER Program',
      Longitude: -116.997981,
      Latitude: 32.7858043,
      status: 'Did not answer the survey',
    },
    {
      Name: 'PRN Physical Therapy / PACER Program',
      Longitude: -115.5728264,
      Latitude: 32.7926387,
      status: 'Did not answer the survey',
    },
    {
      Name: 'PRN Physical Therapy / PACER Program',
      Longitude: -116.9207087,
      Latitude: 32.8122768,
      status: 'Did not answer the survey',
    },
    {
      Name: 'PRN Physical Therapy / PACER Program',
      Longitude: -117.2727778,
      Latitude: 33.1182692,
      status: 'Did not answer the survey',
    },
    {
      Name: 'RTHM Clinic: Long COVID Telehealth and Treatment',
      Longitude: -122.2042768,
      Latitude: 37.4831626,
      status: 'Yes, They offer care',
    },
    {
      Name: 'Scripps Health COVID Recovery Program',
      Longitude: -117.1601602,
      Latitude: 32.7503541,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Scripps Health COVID Recovery Program',
      Longitude: -117.2429852,
      Latitude: 32.898542,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Sharp Allison deRose Rehabilitation Center, Sharp Grossmont Hospital Burr Heart & Lung Clinic',
      Longitude: -117.1549487,
      Latitude: 32.7974103,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Providence St. Jude Medical Center Post-COVID Rehabilitation Program, Wellness Program',
      Longitude: -117.9272201,
      Latitude: 33.8943451,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Stanford Post-Acute COVID-19 Syndrome (PACS) Clinic',
      Longitude: -122.2059536,
      Latitude: 37.4661142,
      status: 'Did not answer the survey',
    },
    {
      Name: 'UCI Health COVID Recovery Service',
      Longitude: -117.8861304,
      Latitude: 33.6695455,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Cedars-Sinai COVID-19 Recovery Program',
      Longitude: -118.3824887,
      Latitude: 34.0759269,
      status: 'Did not answer the survey',
    },
    {
      Name: 'University of California Davis Health Post-COVID-19 Clinic',
      Longitude: -121.468381,
      Latitude: 38.5739696,
      status: 'Did not answer the survey',
    },
    {
      Name: 'University of California San Diego Health Post-COVID Care Clinic',
      Longitude: -117.1652264,
      Latitude: 32.7531371,
      status: 'Did not answer the survey',
    },
    {
      Name: 'University of California, Los Angeles (UCLA) Post-COVID Clinic',
      Longitude: -118.7037075,
      Latitude: 34.1427903,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Valley Comprehensive Outpatient Rehabilitation Facility (CORF)',
      Longitude: -118.5347377,
      Latitude: 34.1725247,
      status: 'Did not answer the survey',
    },
    {
      Name: 'San Mateo County Health Department',
      Longitude: -122.4668185,
      Latitude: 37.6667243,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Stanford Medicine Health Care Tri-Valley',
      Longitude: -121.8803417,
      Latitude: 37.6933946,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Stanford University',
      Longitude: -122.1435799,
      Latitude: 37.4203479,
      status: 'Did not answer the survey',
    },
    {
      Name: 'UCSF Medical Center at Parnassus',
      Longitude: -122.4571621,
      Latitude: 37.7639795,
      status: 'Did not answer the survey',
    },
    {
      Name: 'University of California, San Francisco (UCSF)',
      Longitude: -122.4047401,
      Latitude: 37.7557238,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Denver Health',
      Longitude: -104.9913193,
      Latitude: 39.7279895,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Family Health West Post-COVID Recovery Team',
      Longitude: -108.7373578,
      Latitude: 39.1635088,
      status: 'Did not answer the survey',
    },
    {
      Name: 'National Jewish Health Center for Post-COVID-19 Care and Recovery',
      Longitude: -104.9423077,
      Latitude: 39.7394694,
      status: 'Did not answer the survey',
    },
    {
      Name: 'National Jewish Health for Kids',
      Longitude: -104.9423077,
      Latitude: 39.7394694,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Northern Colorado Rehabilitation Hospital (NCRH)',
      Longitude: -104.9712862,
      Latitude: 40.4063177,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Rehab Without Walls NeuroSolutions Post COVID / PICS Program',
      Longitude: -105.0500336,
      Latitude: 39.850467,
      status: 'Did not answer the survey',
    },
    {
      Name: '',
      Longitude: null,
      Latitude: null,
      status: 'Did not answer the survey',
    },
    {
      Name: 'University of Colorado Anschutz Medical Campus',
      Longitude: -104.8376069,
      Latitude: 39.7456083,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Gaylord Specialty Healthcare Post-COVID Outpatient Center',
      Longitude: -72.8570866,
      Latitude: 41.4725507,
      status: 'Yes, They offer care',
    },
    {
      Name: 'Hartford Healthcare COVID Recovery Center',
      Longitude: -72.6690345,
      Latitude: 41.7663627,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Middlesex Health Post-COVID Rehabilitation',
      Longitude: -72.6472698,
      Latitude: 41.5543067,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Post COVID-19 Recovery Program at Yale Winchester Chest Clinic',
      Longitude: -72.9356023,
      Latitude: 41.3024546,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Stamford Health Center for Integrative Medicine & Wellness COVID-19 Recovery Program',
      Longitude: -73.5523739,
      Latitude: 41.0549536,
      status: 'Did not answer the survey',
    },
    {
      Name: 'UConn Health Long-COVID Recovery Center',
      Longitude: -72.7915589,
      Latitude: 41.731761,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Yale New Haven Childrens Post-COVID Comprehensive Care Program',
      Longitude: -72.936538,
      Latitude: 41.3043831,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Childrens National Hospital Pediatric Post-COVID Program',
      Longitude: -77.0145221,
      Latitude: 38.9273449,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Howard University Hospital',
      Longitude: -77.0211917,
      Latitude: 38.9176038,
      status: 'Did not answer the survey',
    },
    {
      Name: 'MedStar National Rehabilitation Hospital',
      Longitude: -77.012567,
      Latitude: 38.9302554,
      status: 'Did not answer the survey',
    },
    {
      Name: 'MedStar Good Samaritan',
      Longitude: -76.5871105,
      Latitude: 39.3579963,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Northwest Nurse Practitoners',
      Longitude: -77.0560416,
      Latitude: 38.9298333,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Select Physical Therapy COVID-19 and Chronic Illness Recovery and Reconditioning program',
      Longitude: -80.2507988,
      Latitude: 26.211436,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Select Physical Therapy COVID-19 and Chronic Illness Recovery and Reconditioning program',
      Longitude: -80.104143,
      Latitude: 26.3610177,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Select Physical Therapy COVID-19 and Chronic Illness Recovery and Reconditioning program',
      Longitude: -80.0828857,
      Latitude: 26.6503562,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Modern Migraine: Post-COVID headaches',
      Longitude: -80.148283,
      Latitude: 25.962947,
      status: 'Did not answer the survey',
    },
    {
      Name: 'UF Health COVID RESTORE Treatment Program',
      Longitude: -82.4332127,
      Latitude: 29.6919603,
      status: 'Did not answer the survey',
    },
    {
      Name: 'University of Miami Health System COVID-19 Heart Program',
      Longitude: -80.2158355,
      Latitude: 25.7887037,
      status: 'Did not answer the survey',
    },
    {
      Name: '',
      Longitude: null,
      Latitude: null,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Watson Clinic Post COVID-19 Clinic',
      Longitude: -81.9542487,
      Latitude: 28.0666764,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Atlanta VA Medical Center',
      Longitude: -84.3128002,
      Latitude: 33.801354,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Emory University at Grady Memorial Hospital',
      Longitude: -84.3811047,
      Latitude: 33.7520306,
      status: 'Did not answer the survey',
    },
    {
      Name: "Emory's Hope Clinic",
      Longitude: -84.2786147,
      Latitude: 33.7908289,
      status: 'Did not answer the survey',
    },
    {
      Name: 'AbsoluteCare Long COVID Clininc',
      Longitude: -84.3938727,
      Latitude: 33.8129425,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Select Physical Therapy COVID-19 and Chronic Illness Recovery and Reconditioning program',
      Longitude: -80.9371032,
      Latitude: 32.2955264,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Dignity Health COVID-19 and Chronic Illness Recovery and Reconditioning program',
      Longitude: -83.7031335,
      Latitude: 32.8714765,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Emory Rehabilitation Outpatient Center',
      Longitude: -84.1372061,
      Latitude: 33.4334075,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Emory Executive Park Post-COVID Clinic',
      Longitude: -84.3378757,
      Latitude: 33.827956,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Kaiser Permanente Georgia',
      Longitude: -84.1341964,
      Latitude: 33.9454613,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Piedmont Pulmonary COVID Recovery Clinic',
      Longitude: -84.3971566,
      Latitude: 33.8087429,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Augusta University Health Rehabilitation and Therapy',
      Longitude: -81.9897417,
      Latitude: 33.4699171,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Results Physiotherapy Post-Covid Rehabilitation',
      Longitude: -84.385621,
      Latitude: 33.7924324,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Results Physiotherapy Post-Covid Rehabilitation',
      Longitude: -84.0211036,
      Latitude: 33.9665093,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Results Physiotherapy Post-Covid Rehabilitation',
      Longitude: -84.4636325,
      Latitude: 34.0346592,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Morehouse School of Medicine Clinical Research Center',
      Longitude: -84.4122714,
      Latitude: 33.7428111,
      status: 'Did not answer the survey',
    },
    {
      Name: 'The Queens Health Systems Post COVID Recovery and Care Clinic',
      Longitude: -157.8538581,
      Latitude: 21.3084698,
      status: 'Did not answer the survey',
    },
    {
      Name: 'University of Hawaii',
      Longitude: -157.8634044,
      Latitude: 21.296545,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Northern Idaho Acute Care Hospital',
      Longitude: -116.9037942,
      Latitude: 47.7132381,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Rehabilitation Hospital of the Northwest',
      Longitude: -116.901982,
      Latitude: 47.7128247,
      status: 'Did not answer the survey',
    },
    {
      Name: "St. Luke's Clinic  COVID Recovery",
      Longitude: -116.187676,
      Latitude: 43.603159,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Illinois RECOVER Network (ILLInet)',
      Longitude: -87.6720543,
      Latitude: 41.866375,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Advocate Health Care Post-COVID Recovery Clinic',
      Longitude: -87.6503283,
      Latitude: 41.9385363,
      status: 'Did not answer the survey',
    },
    {
      Name: 'RUSH Physical Therapy COVID-19 and Chronic Illness Recovery and Reconditioning program',
      Longitude: -87.8119466,
      Latitude: 41.5720518,
      status: 'Did not answer the survey',
    },
    {
      Name: 'RUSH Physical Therapy COVID-19 and Chronic Illness Recovery and Reconditioning program',
      Longitude: -88.1297809,
      Latitude: 41.790647,
      status: 'Did not answer the survey',
    },
    {
      Name: 'RUSH Physical Therapy COVID-19 and Chronic Illness Recovery and Reconditioning program',
      Longitude: -88.3354358,
      Latitude: 42.0075544,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Edward-Elmhurst Health Post-COVID Neuro Care Clinic',
      Longitude: -88.1215883,
      Latitude: 41.590024,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Edward-Elmhurst Health Post-COVID Neuro Care Clinic',
      Longitude: -88.4468616,
      Latitude: 41.660822,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Edward-Elmhurst Health Post-COVID Neuro Care Clinic',
      Longitude: -88.1229612,
      Latitude: 41.698469,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Edward-Elmhurst Health Post-COVID Neuro Care Clinic',
      Longitude: -88.1675142,
      Latitude: 41.818378,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Edward-Elmhurst Health Post-COVID Neuro Care Clinic',
      Longitude: -87.9221041,
      Latitude: 41.8185659,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Edward-Elmhurst Health Post-COVID Neuro Care Clinic',
      Longitude: -87.9329553,
      Latitude: 41.8640666,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Edward-Elmhurst Health Post-COVID Neuro Care Clinic',
      Longitude: -87.9963226,
      Latitude: 41.9350077,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Humboldt Park Health Post-COVID-19 Clinic',
      Longitude: -87.6996714,
      Latitude: 41.9006786,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Neurology COVID Clinic at Loyola Medicine',
      Longitude: -87.8350335,
      Latitude: 41.8603604,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Northwestern Medicine Comprehensive COVID-19 Center',
      Longitude: -87.8975415,
      Latitude: 41.5042336,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Northwestern Medicine Comprehensive COVID-19 Center',
      Longitude: -87.6320553,
      Latitude: 41.8682329,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Northwestern Medicine Comprehensive COVID-19 Center',
      Longitude: -88.1188793,
      Latitude: 41.9449677,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Northwestern Medicine Comprehensive COVID-19 Center',
      Longitude: -88.7262393,
      Latitude: 41.9649467,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Northwestern Medicine Comprehensive COVID-19 Center',
      Longitude: -87.9545849,
      Latitude: 42.3830785,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Northwestern Memorial Hospital Neuro Covid-19 Clinic',
      Longitude: -87.6210231,
      Latitude: 41.8955029,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Shirley Ryan AbilityLab COVID Care Unit',
      Longitude: -87.6181751,
      Latitude: 41.8939453,
      status: 'Yes, They offer care',
    },
    {
      Name: 'SIU Medicine Post-COVID Recovery Clinic',
      Longitude: -89.6584353,
      Latitude: 39.8106943,
      status: 'Did not answer the survey',
    },
    {
      Name: 'University of Chicago Medicine Post COVID Recovery Clinic',
      Longitude: -87.6032666,
      Latitude: 41.7885181,
      status: 'Did not answer the survey',
    },
    {
      Name: 'University of Illinois Health Post-COVID Clinic',
      Longitude: -87.6705246,
      Latitude: 41.8694894,
      status: 'Yes, They offer care',
    },
    {
      Name: 'Select Physical Therapy COVID-19 and Chronic Illness Recovery and Reconditioning program',
      Longitude: -86.0461789,
      Latitude: 39.7827771,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Select Physical Therapy COVID-19 and Chronic Illness Recovery and Reconditioning program',
      Longitude: -86.8687817,
      Latitude: 40.0472537,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Select Physical Therapy COVID-19 and Chronic Illness Recovery and Reconditioning program',
      Longitude: -86.3214723,
      Latitude: 40.7589562,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Indiana University Health ICU Survivor Center',
      Longitude: -86.1631017,
      Latitude: 39.7907165,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Lafayette Regional Rehabilitation Hospital',
      Longitude: -86.8297213,
      Latitude: 40.4046537,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Parkview Physicians Group Post-COVID Clinic',
      Longitude: -85.1007065,
      Latitude: 41.1870233,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Rehabilitation Hospital of Northern Indiana',
      Longitude: -86.1802868,
      Latitude: 41.7033571,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Results Physiotherapy Post-Covid Rehabilitation',
      Longitude: -85.8406941,
      Latitude: 38.3073,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Results Physiotherapy Post-Covid Rehabilitation',
      Longitude: -85.7038713,
      Latitude: 38.3499594,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Select Physical Therapy COVID-19 and Chronic Illness Recovery and Reconditioning program',
      Longitude: -93.4498346,
      Latitude: 41.6393289,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Select Physical Therapy COVID-19 and Chronic Illness Recovery and Reconditioning program',
      Longitude: -92.5778926,
      Latitude: 41.9801484,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Select Physical Therapy COVID-19 and Chronic Illness Recovery and Reconditioning program',
      Longitude: -93.1647897,
      Latitude: 42.0162277,
      status: 'Did not answer the survey',
    },
    {
      Name: 'On With Life Outpatient Post-COVID Neurological Rehabilitation Program',
      Longitude: -93.6087214,
      Latitude: 41.6983258,
      status: 'Did not answer the survey',
    },
    {
      Name: 'On With Life Outpatient Post-COVID Neurological Rehabilitation Program',
      Longitude: -91.6114707,
      Latitude: 41.705715,
      status: 'Did not answer the survey',
    },
    {
      Name: 'University of Iowa Health Care Post COVID-19 Clinic',
      Longitude: -91.5484633,
      Latitude: 41.6605049,
      status: 'Did not answer the survey',
    },
    {
      Name: 'University of Kansas Medical Center',
      Longitude: -94.610902,
      Latitude: 39.0583401,
      status: 'Did not answer the survey',
    },
    {
      Name: 'KORT COVID-19 and Chronic Illness Recovery and Reconditioning program',
      Longitude: -84.2842904,
      Latitude: 37.7337773,
      status: 'Did not answer the survey',
    },
    {
      Name: 'KORT COVID-19 and Chronic Illness Recovery and Reconditioning program',
      Longitude: -84.5359799,
      Latitude: 37.9557052,
      status: 'Did not answer the survey',
    },
    {
      Name: 'KORT COVID-19 and Chronic Illness Recovery and Reconditioning program',
      Longitude: -84.2174433,
      Latitude: 37.9954567,
      status: 'Did not answer the survey',
    },
    {
      Name: 'KORT COVID-19 and Chronic Illness Recovery and Reconditioning program',
      Longitude: -84.4208402,
      Latitude: 38.01555,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Norton Healthcare COVID-19 Long-Term Care Clinic - Adult',
      Longitude: -85.7485737,
      Latitude: 38.2460654,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Norton Healthcare COVID-19 Long-Term Care Clinic - Pediatric',
      Longitude: -85.7464055,
      Latitude: 38.2485807,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Results Physiotherapy Post-Covid Rehabilitation',
      Longitude: -85.6812733,
      Latitude: 37.9784106,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Results Physiotherapy Post-Covid Rehabilitation',
      Longitude: -85.2404109,
      Latitude: 38.2132999,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Results Physiotherapy Post-Covid Rehabilitation',
      Longitude: -85.7207871,
      Latitude: 38.2389135,
      status: 'Did not answer the survey',
    },
    {
      Name: 'UK HealthCare Pulmonary Rehabilitation Clinic',
      Longitude: -84.5080859,
      Latitude: 38.0336375,
      status: 'Did not answer the survey',
    },
    {
      Name: 'University of Kentucky',
      Longitude: -84.507143,
      Latitude: 38.0326195,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Louisiana State University Health Sciences Center',
      Longitude: -90.0844726,
      Latitude: 29.9577007,
      status: 'Did not answer the survey',
    },
    {
      Name: "Children's Hospital New Orleans Post-COVID-19 Clinic",
      Longitude: -90.127417,
      Latitude: 29.917793,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Pennington Biomedical Research Center',
      Longitude: -91.1236814,
      Latitude: 30.4033142,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Tulane School of Medicine',
      Longitude: -90.0753337,
      Latitude: 29.9569578,
      status: 'Did not answer the survey',
    },
    {
      Name: 'University Medical Center (UMC) - New Orleans',
      Longitude: -90.0814661,
      Latitude: 29.960568,
      status: 'Never provided care',
    },
    {
      Name: 'MaineHealth',
      Longitude: -70.3454757,
      Latitude: 43.5888212,
      status: 'Did not answer the survey',
    },
    {
      Name: 'MVPT Physical Therapy Post-Acute COVID Care',
      Longitude: -69.9638875,
      Latitude: 43.9226199,
      status: 'Did not answer the survey',
    },
    {
      Name: 'MVPT Physical Therapy Post-Acute COVID Care',
      Longitude: -70.2249598,
      Latitude: 44.1092,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Mercy Medical Center',
      Longitude: -76.613246,
      Latitude: 39.292837,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Johns Hopkins Medicine Post Acute COVID Team (PACT)',
      Longitude: -76.8847971,
      Latitude: 39.2142172,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Kennedy Krieger Institute - Pediatric Post COVID-19 Rehabilitation Clinic',
      Longitude: -76.5940173,
      Latitude: 39.2987991,
      status: 'Did not answer the survey',
    },
    {
      Name: 'MedStar Health COVID Recovery Program',
      Longitude: -76.5871105,
      Latitude: 39.3579963,
      status: 'Did not answer the survey',
    },
    {
      Name: 'UM Rehabilitation and Orthopaedic Institute COVID Recovery Rehabilitation Unit',
      Longitude: -76.7079286,
      Latitude: 39.3138338,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Beth Israel Deaconess Medical Center',
      Longitude: -71.1062612,
      Latitude: 42.3390281,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Boston Medical Center',
      Longitude: -71.0695187,
      Latitude: 42.3360172,
      status: 'Did not answer the survey',
    },
    {
      Name: "Brigham and Women's Hospital",
      Longitude: -71.1045415,
      Latitude: 42.3349619,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Cambridge Health Alliance (CHA)',
      Longitude: -71.0819011,
      Latitude: 42.3930126,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Massachusetts General Hospital',
      Longitude: -71.068747,
      Latitude: 42.362919,
      status: 'Did not answer the survey',
    },
    {
      Name: "Boston Children's Hospital Post-COVID Clinic",
      Longitude: -71.1055611,
      Latitude: 42.3375584,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Tufts Medical Center',
      Longitude: -71.0634934,
      Latitude: 42.3495467,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Emerson Hospital COVID-19 Recovery Program',
      Longitude: -71.3761748,
      Latitude: 42.4524369,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Andover Medical Center Post-COVID Recovery Program',
      Longitude: -71.1852794,
      Latitude: 42.6480605,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Andover/North Andover YMCA Post-COVID Recovery Program',
      Longitude: -71.1324114,
      Latitude: 42.6727768,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Marston Medical Center Post-COVID Recovery Program',
      Longitude: -71.1456537,
      Latitude: 42.7065305,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Spaulding Rehabilitation Network COVID Rehab Program',
      Longitude: -71.0491268,
      Latitude: 42.3785976,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Bay State Physical Therapy Post-Acute COVID Care',
      Longitude: -71.1589429,
      Latitude: 41.6727988,
      status: 'Declined to answer',
    },
    {
      Name: 'Spaulding Rehabilitation Network COVID Rehab Program',
      Longitude: -70.886436,
      Latitude: 42.5180539,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Spaulding Rehabilitation Network COVID Rehab Program',
      Longitude: -70.6556036,
      Latitude: 42.6269909,
      status: 'Did not answer the survey',
    },
    {
      Name: 'NovaCare Rehabilitation COVID-19 and Chronic Illness Recovery and Reconditioning program',
      Longitude: -86.1171899,
      Latitude: 42.7654741,
      status: 'Did not answer the survey',
    },
    {
      Name: 'NovaCare Rehabilitation COVID-19 and Chronic Illness Recovery and Reconditioning program',
      Longitude: -85.581087,
      Latitude: 43.1745809,
      status: 'Did not answer the survey',
    },
    {
      Name: 'NovaCare Rehabilitation COVID-19 and Chronic Illness Recovery and Reconditioning program',
      Longitude: -84.7605662,
      Latitude: 43.5821942,
      status: 'Did not answer the survey',
    },
    {
      Name: "C.S. Mott Children's Hospital Pediatric Post-COVID Syndrome Clinic",
      Longitude: -83.7272882,
      Latitude: 42.2820339,
      status: 'Did not answer the survey',
    },
    {
      Name: 'University of Michigan Health Post-COVID-19 Clinic',
      Longitude: -83.7448914,
      Latitude: 42.244591,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Abbott Northwestern Center for Outpatient Care',
      Longitude: -93.3929925,
      Latitude: 44.86128,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Allina Health Cambridge Clinic',
      Longitude: -93.2301143,
      Latitude: 45.5664246,
      status: 'Did not answer the survey',
    },
    {
      Name: 'NovaCare Rehabilitation COVID-19 and Chronic Illness Recovery and Reconditioning program',
      Longitude: -93.2357711,
      Latitude: 45.1855237,
      status: 'Did not answer the survey',
    },
    {
      Name: 'NovaCare Rehabilitation COVID-19 and Chronic Illness Recovery and Reconditioning program',
      Longitude: -93.7779477,
      Latitude: 45.3000081,
      status: 'Did not answer the survey',
    },
    {
      Name: 'NovaCare Rehabilitation COVID-19 and Chronic Illness Recovery and Reconditioning program',
      Longitude: -94.2032646,
      Latitude: 45.5906753,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Essentia Health Post COVID-19 Rehabilitation Program',
      Longitude: -92.1586125,
      Latitude: 46.8055121,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Hennepin Healthcare Post-Acute COVID-19 Recovery Clinic',
      Longitude: -93.2632212,
      Latitude: 44.9711612,
      status: 'Did not answer the survey',
    },
    {
      Name: 'M Health Fairview Pediatric COVID-19 Clinic',
      Longitude: -93.0334909,
      Latitude: 45.0298972,
      status: 'Did not answer the survey',
    },
    {
      Name: 'M Health Fairview Post-COVID-19 Clinic',
      Longitude: -93.0334909,
      Latitude: 45.0298972,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Mayo Clinic Post COVID-19 Care Clinic',
      Longitude: -92.4667508,
      Latitude: 44.0226729,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Prairie Rehabilitation Post-COVID-19 Recovery',
      Longitude: -95.5972612,
      Latitude: 43.6338084,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Prairie Rehabilitation Post-COVID-19 Recovery',
      Longitude: -94.7206797,
      Latitude: 43.65984,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Prairie Rehabilitation Post-COVID-19 Recovery',
      Longitude: -95.1684196,
      Latitude: 43.6860142,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Prairie Rehabilitation Post-COVID-19 Recovery',
      Longitude: -95.5952489,
      Latitude: 43.8754259,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Select Physical Therapy COVID-19 and Chronic Illness Recovery and Reconditioning program',
      Longitude: -89.9891531,
      Latitude: 34.9765793,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Methodist Rehabilitation Center Recovery After COVID Clinic',
      Longitude: -90.1718128,
      Latitude: 32.3282613,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Results Physiotherapy Post-Covid Rehabilitation',
      Longitude: -90.029025,
      Latitude: 32.283175,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Results Physiotherapy Post-Covid Rehabilitation',
      Longitude: -90.1548384,
      Latitude: 32.3436925,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Results Physiotherapy Post-Covid Rehabilitation',
      Longitude: -90.1472341,
      Latitude: 32.4360655,
      status: 'Did not answer the survey',
    },
    {
      Name: 'University of Mississippi Medical Center',
      Longitude: -90.1742277,
      Latitude: 32.3292336,
      status: 'Did not answer the survey',
    },
    {
      Name: 'SSM Health Day Institute COVID-19 and Chronic Illness Recovery and Reconditioning program',
      Longitude: -91.1391977,
      Latitude: 38.8211845,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Select Physical Therapy COVID-19 and Chronic Illness Recovery and Reconditioning program',
      Longitude: -92.2895889,
      Latitude: 38.9534818,
      status: 'Did not answer the survey',
    },
    {
      Name: 'North Kansas City Hospital Long COVID Rehab',
      Longitude: -94.5506021,
      Latitude: 39.1508483,
      status: 'Did not answer the survey',
    },
    {
      Name: 'University Health Center for COVID Recovery',
      Longitude: -94.5738683,
      Latitude: 39.0850111,
      status: 'Did not answer the survey',
    },
    {
      Name: 'University of Missouri COVID Recovery Program',
      Longitude: -92.3253298,
      Latitude: 38.9358041,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Washington University Physicians Post COVID-19 Clinic',
      Longitude: -90.2629971,
      Latitude: 38.6382239,
      status: 'Yes, they offer care',
    },
    {
      Name: 'Advanced Care Hospital of Montana',
      Longitude: -108.6045377,
      Latitude: 45.7431546,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Benefis Health System Post-COVID-19 Recovery Program',
      Longitude: -111.2594192,
      Latitude: 47.4911874,
      status: 'Did not answer the survey',
    },
    {
      Name: 'University of Nebraska Medical Center',
      Longitude: -95.9796225,
      Latitude: 41.2552541,
      status: 'Did not answer the survey',
    },
    {
      Name: 'UMC COVID-19 Recovery Clinic',
      Longitude: -115.230583,
      Latitude: 36.2361959,
      status: 'No longer offers Long COVID Care',
    },
    {
      Name: 'Center for Physical Therapy and Exercise',
      Longitude: -71.5279759,
      Latitude: 42.7949531,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Center for Physical Therapy and Exercise',
      Longitude: -71.4321163,
      Latitude: 42.8008793,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Center for Physical Therapy and Exercise',
      Longitude: -71.4915257,
      Latitude: 42.8582959,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Center for Physical Therapy and Exercise',
      Longitude: -71.4735798,
      Latitude: 42.9828087,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Dartmouth-Hitchcock Post-Acute COVID Syndrome Clinic',
      Longitude: -72.2729588,
      Latitude: 43.6754932,
      status: 'Declined to answer',
    },
    {
      Name: 'Advantage Therapy Centers Post-COVID Rehabilitation Program',
      Longitude: -75.0647194,
      Latitude: 39.7327499,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Advantage Therapy Centers Post-COVID Rehabilitation Program',
      Longitude: -74.954218,
      Latitude: 39.8992633,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Advantage Therapy Centers Post-COVID Rehabilitation Program',
      Longitude: -74.8988628,
      Latitude: 39.9742256,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Atlantic COVID Recovery Center',
      Longitude: -74.3329486,
      Latitude: 40.7178683,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Atlantic COVID Recovery Center',
      Longitude: -74.4646983,
      Latitude: 40.8160384,
      status: 'Did not answer the survey',
    },
    {
      Name: 'AtlantiCare Post-COVID-19 Long-Haul Clinic',
      Longitude: -74.4342891,
      Latitude: 39.3583314,
      status: 'Did not answer the survey',
    },
    {
      Name: 'CarePoint Health Outpatient COVID Care Center',
      Longitude: -74.0498006,
      Latitude: 40.7342585,
      status: 'Did not answer the survey',
    },
    {
      Name: 'CentraState Post-COVID Syndrome Recovery Program',
      Longitude: -74.3111593,
      Latitude: 40.2376082,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Deborah Heart and Lung Center Post-COVID Recovery Program',
      Longitude: -74.5851859,
      Latitude: 39.9775118,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Franklin Cardiovascular Autonomic Dysfunction and POTS Center',
      Longitude: -75.001685,
      Latitude: 39.747832,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Hackensack Meridian Childrens Health Pediatric COVID-19 Recovery Center',
      Longitude: -74.0562204,
      Latitude: 40.88264,
      status: 'Did not answer the survey',
    },
    {
      Name: "Hackensack Meridian Health's COVID Recovery Center",
      Longitude: -74.3357441,
      Latitude: 40.560655,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Kessler Rehabilitation Center Recovery and Reconditioning Program',
      Longitude: -74.104634,
      Latitude: 40.8063285,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Modern Migraine: Post-COVID headaches',
      Longitude: -74.1995205,
      Latitude: 39.9521556,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Monmouth Medical Center Southern Campus Post-COVID Recovery Program',
      Longitude: -74.218758,
      Latitude: 40.0731927,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Cooperman Barnabas Medical Center Post-COVID Comprehensive Assessment Recovery and Evaluation Program',
      Longitude: -74.3037812,
      Latitude: 40.7629282,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Penn Medicine Post-COVID Assessment & Recovery Clinic',
      Longitude: -74.9722022,
      Latitude: 39.903495,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Saint Peters University Hospital Post-COVID-19 Clinic',
      Longitude: -74.4593195,
      Latitude: 40.5009888,
      status: 'Did not answer the survey',
    },
    {
      Name: 'University Hospital Comprehensive COVID-19 Recovery Program',
      Longitude: -74.191281,
      Latitude: 40.7411578,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Virtua Health: Care After COVID Telehealth',
      Longitude: -74.9277276,
      Latitude: 39.8844933,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Penn Medicine Post-COVID Assessment and Recovery Clinic',
      Longitude: -74.9722022,
      Latitude: 39.903495,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Spear COVID-19 Rehab Therapy',
      Longitude: -74.0303143,
      Latitude: 40.7378149,
      status: 'Yes, they offer care',
    },
    {
      Name: 'Lovelace Health System Post-COVID Recovery Services',
      Longitude: -106.6398836,
      Latitude: 35.0870971,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Rehabilitation Hospital of Southern New Mexico',
      Longitude: -106.7245696,
      Latitude: 32.3257016,
      status: 'Did not answer the survey',
    },
    {
      Name: 'University of New Mexico',
      Longitude: -106.62,
      Latitude: 35.09,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Mount Sinai Hospital Center for Advanced Medicine',
      Longitude: -73.9520137,
      Latitude: 40.7914837,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Mount Sinai Cohen Center for Recovery from Complex Chronic Illnesses (CoRE)',
      Longitude: null,
      Latitude: null,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Spear COVID-19 Rehab Therapy',
      Longitude: -73.9606898,
      Latitude: 40.7198521,
      status: 'Yes, they offer care',
    },
    {
      Name: 'Albany Medical College Post-COVID Care Clinic',
      Longitude: -73.7733226,
      Latitude: 42.6533898,
      status: 'Did not answer the survey',
    },
    {
      Name: 'BronxCare Health System Post-COVID Care Clinic',
      Longitude: -73.9097657,
      Latitude: 40.8432087,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Columbia Primary Care Post COVID Care Program',
      Longitude: -73.9409419,
      Latitude: 40.8408953,
      status: 'Did not answer the survey',
    },
    {
      Name: 'H&D Post-Acute COVID Recovery',
      Longitude: -73.9719425,
      Latitude: 40.7507932,
      status: 'No longer offers Long COVID Care',
    },
    {
      Name: 'Columbia University Irving Medical Center COVID-19 Rehabilitation Program',
      Longitude: -73.9423408,
      Latitude: 40.8413476,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Dynamic Sports Physical Therapy Post Acute COVID Syndrome Rehabilitation Program',
      Longitude: -73.9817291,
      Latitude: 40.7511024,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Ellenvile Regional Hospital COVID Rehab',
      Longitude: -74.3789828,
      Latitude: 41.7326119,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Jamaica Hospital Medical Center Post-COVID Care Center',
      Longitude: -73.7569326,
      Latitude: 40.7059459,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Maimonides Medical Center Post-COVID Care Centers for Adults',
      Longitude: -73.9992746,
      Latitude: 40.6400473,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Maimonides Doctors Brighton Beach Post-COVID Care Centers for Adults',
      Longitude: -73.9582541,
      Latitude: 40.5765322,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Maimonides Medical Center Post-COVID Care Centers for Children',
      Longitude: -73.9992746,
      Latitude: 40.6400473,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Modern Migraine: Post-COVID headaches',
      Longitude: -73.9891929,
      Latitude: 40.7464854,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Montefiore Department of Medicine CORE (COVID-19 Recovery) Clinic',
      Longitude: -73.878608,
      Latitude: 40.8799534,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Mount Sinai Center for Post-COVID Care',
      Longitude: -73.989765,
      Latitude: 40.7348008,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Mount Sinai Heart Post-COVID Evaluation and Monitoring Program',
      Longitude: -73.9858565,
      Latitude: 40.7698296,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Northwell Health COVID Ambulatory Resource Support (CARES)',
      Longitude: -74.0059728,
      Latitude: 40.7127753,
      status: 'Did not answer the survey',
    },
    {
      Name: 'NYC Health + Hospitals/Gotham Health, Broadway COVID-19 Center of Excellence',
      Longitude: -73.9396062,
      Latitude: 40.6997803,
      status: 'Did not answer the survey',
    },
    {
      Name: 'NYC Health + Hospitals/Gotham Health, Roosevelt COVID-19 Center of Excellence',
      Longitude: -73.8939245,
      Latitude: 40.7472224,
      status: 'Did not answer the survey',
    },
    {
      Name: 'NYC Health + Hospitals/Gotham Health, Tremont COVID-19 Center of Excellence',
      Longitude: -73.9005135,
      Latitude: 40.8477768,
      status: 'Did not answer the survey',
    },
    {
      Name: 'NYU Langone Huntington Medical Group COVID-19 Recovery Care',
      Longitude: -73.2849893,
      Latitude: 40.8438209,
      status: 'Did not answer the survey',
    },
    {
      Name: 'NYU Langone Huntington Medical Group COVID-19 Recovery Care',
      Longitude: -73.39988,
      Latitude: 40.8526173,
      status: 'Did not answer the survey',
    },
    {
      Name: 'NYU Langone Huntington Medical Group COVID-19 Recovery Care',
      Longitude: -73.3948611,
      Latitude: 40.8575296,
      status: 'Did not answer the survey',
    },
    {
      Name: 'NYU Langone Post-COVID Care Program',
      Longitude: -73.9740737,
      Latitude: 40.7493378,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Richmond University Medical Center Post COVID-19 Care Center',
      Longitude: -74.1048634,
      Latitude: 40.6370433,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Richmond University Medical Center Post COVID-19 Care Center',
      Longitude: -74.1048634,
      Latitude: 40.6370433,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Spear COVID-19 Rehab Therapy',
      Longitude: -73.7893286,
      Latitude: 41.1314519,
      status: 'Yes, they offer care',
    },
    {
      Name: 'Spear COVID-19 Rehab Therapy',
      Longitude: -73.932743,
      Latitude: 40.745291,
      status: 'Yes, they offer care',
    },
    {
      Name: 'Spear COVID-19 Rehab Therapy',
      Longitude: -73.979121,
      Latitude: 40.7655377,
      status: 'Yes, they offer care',
    },
    {
      Name: 'St. Charles Hospital Post-COVID Outpatient Rehabilitation Program',
      Longitude: -73.0612113,
      Latitude: 40.9450302,
      status: 'Did not answer the survey',
    },
    {
      Name: 'St. Johns Riverside Hospital Post-COVID Care Program',
      Longitude: -73.8817379,
      Latitude: 40.9727937,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Staten Island University Hospital Post-COVID Recovery Center',
      Longitude: -74.0860039,
      Latitude: 40.5848868,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Stony Brook Medicine Post-COVID Clinic',
      Longitude: -73.2916469,
      Latitude: 40.8226772,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Sunnyview Rehabilitation Hospital Long-Haul COVID Program',
      Longitude: -73.9152685,
      Latitude: 42.8207479,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Weill Cornell Medicine Post-ICU Recovery Clinic',
      Longitude: -73.9591725,
      Latitude: 40.7606262,
      status: 'Did not answer the survey',
    },
    {
      Name: 'WMCHealth Post-COVID-19 Recovery Program',
      Longitude: -73.8050457,
      Latitude: 41.0868701,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Select Physical Therapy COVID-19 and Chronic Illness Recovery and Reconditioning program',
      Longitude: -79.1891082,
      Latitude: 35.469214,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Select Physical Therapy COVID-19 and Chronic Illness Recovery and Reconditioning program',
      Longitude: -78.6227666,
      Latitude: 35.8295787,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Select Physical Therapy COVID-19 and Chronic Illness Recovery and Reconditioning program',
      Longitude: -79.0319632,
      Latitude: 35.9304001,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Mountain Area Health Education Center Post-Acute COVID-19 Care Clinic',
      Longitude: -82.5438111,
      Latitude: 35.5606707,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Results Physiotherapy Post-Covid Rehabilitation',
      Longitude: -78.8625999,
      Latitude: 35.7377272,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Results Physiotherapy Post-Covid Rehabilitation',
      Longitude: -78.6615477,
      Latitude: 35.7952735,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Results Physiotherapy Post-Covid Rehabilitation',
      Longitude: -78.9303269,
      Latitude: 35.9106799,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Results Physiotherapy Post-Covid Rehabilitation',
      Longitude: -78.5436807,
      Latitude: 35.9481617,
      status: 'Did not answer the survey',
    },
    {
      Name: 'UNC COVID Recovery Clinic',
      Longitude: -79.0116227,
      Latitude: 35.9461194,
      status: 'Did not answer the survey',
    },
    {
      Name: 'WakeMed Rehabilitation Center COVID-19 Recovery Program',
      Longitude: -78.5879491,
      Latitude: 35.7841541,
      status: 'Did not answer the survey',
    },
    {
      Name: 'CHI St. Alexius Health Post-Covid Care Clinic',
      Longitude: -100.7792275,
      Latitude: 46.8083466,
      status: 'Did not answer the survey',
    },
    {
      Name: 'MetroHealth Post-COVID Clinic',
      Longitude: -81.6987862,
      Latitude: 41.4607746,
      status: 'Did not answer the survey',
    },
    {
      Name: 'University Hospitals Cleveland Medical Center',
      Longitude: -81.6053844,
      Latitude: 41.5061512,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Cleveland Clinic reCOVer Clinic',
      Longitude: -81.6549616,
      Latitude: 41.398405,
      status: 'Did not answer the survey',
    },
    {
      Name: 'NovaCare Rehabilitation COVID-19 and Chronic Illness Recovery and Reconditioning program',
      Longitude: -82.9943422,
      Latitude: 40.145922,
      status: 'Did not answer the survey',
    },
    {
      Name: 'NovaCare Rehabilitation COVID-19 and Chronic Illness Recovery and Reconditioning program',
      Longitude: -82.8697165,
      Latitude: 40.2442079,
      status: 'Did not answer the survey',
    },
    {
      Name: 'NovaCare Rehabilitation COVID-19 and Chronic Illness Recovery and Reconditioning program',
      Longitude: -83.0891655,
      Latitude: 40.3068826,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Memorial Health System Post COVID Care Center',
      Longitude: -81.464382,
      Latitude: 39.4315733,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Rehabilitation Hospital of the Northwest Ohio',
      Longitude: -83.6196967,
      Latitude: 41.6143101,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Southwest General Brunswick Medical Center COVID-19 Recovery Program',
      Longitude: -81.8316772,
      Latitude: 41.2388951,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Southwest General Brunswick Medical Center COVID-19 Recovery Program',
      Longitude: -81.8163731,
      Latitude: 41.2403042,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Southwest General Brunswick Medical Center COVID-19 Recovery Program',
      Longitude: -81.8328908,
      Latitude: 41.2870678,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Southwest General Brunswick Medical Center COVID-19 Recovery Program',
      Longitude: -81.7231856,
      Latitude: 41.3144627,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Southwest General Brunswick Medical Center COVID-19 Recovery Program',
      Longitude: -81.8270472,
      Latitude: 41.3189093,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Southwest General Brunswick Medical Center COVID-19 Recovery Program',
      Longitude: -81.8328234,
      Latitude: 41.3693567,
      status: 'Did not answer the survey',
    },
    {
      Name: 'LifeWorks of Southwest General',
      Longitude: -81.8366067,
      Latitude: 41.3641131,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Summa Health Post-COVID Clinic',
      Longitude: -81.5021207,
      Latitude: 41.0810159,
      status: 'Did not answer the survey',
    },
    {
      Name: 'The Ohio State University Wexner Medical Center Post-COVID Recovery Program',
      Longitude: -83.0177846,
      Latitude: 39.9942265,
      status: 'Yes, they offer care',
    },
    {
      Name: 'TriHealths Physical Rehabilitation Outpatient Services',
      Longitude: -84.5200889,
      Latitude: 39.1396777,
      status: 'Did not answer the survey',
    },
    {
      Name: 'TriHealths Physical Rehabilitation Outpatient Services',
      Longitude: -84.3647427,
      Latitude: 39.2560179,
      status: 'Did not answer the survey',
    },
    {
      Name: 'UC Health Post-COVID-19 Clinic',
      Longitude: -84.5049993,
      Latitude: 39.1365424,
      status: 'Did not answer the survey',
    },
    {
      Name: 'University Hospitals COVID Recovery Clinic',
      Longitude: -81.4941209,
      Latitude: 41.4514363,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Select Physical Therapy COVID-19 and Chronic Illness Recovery and Reconditioning program',
      Longitude: -97.5471588,
      Latitude: 35.3459163,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Select Physical Therapy COVID-19 and Chronic Illness Recovery and Reconditioning program',
      Longitude: -97.5144869,
      Latitude: 35.4807592,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Select Physical Therapy COVID-19 and Chronic Illness Recovery and Reconditioning program',
      Longitude: -97.4179837,
      Latitude: 35.6533296,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Norman Regional Post COVID Recovery Program',
      Longitude: -97.4396573,
      Latitude: 35.2306241,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Hillcrest Post-COVID Recovery Care',
      Longitude: -95.9666962,
      Latitude: 36.14564,
      status: 'Did not answer the survey',
    },
    {
      Name: 'University of Oklahoma Health Sciences Center',
      Longitude: -97.5011214,
      Latitude: 35.4771665,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Oregon Health & Science University Long COVID Program',
      Longitude: -122.6853459,
      Latitude: 45.4983679,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Allegheny Health Network Post-COVID-19 Recovery Clinic',
      Longitude: -80.0638147,
      Latitude: 40.6356415,
      status: 'No longer offers Long COVID Care',
    },
    {
      Name: 'Main Line Health Post-COVID Recovery Program',
      Longitude: -75.5298536,
      Latitude: 40.0107908,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Penn Medicine Lancaster General Health Post-COVID-19 Recovery Program',
      Longitude: -76.3040232,
      Latitude: 40.047027,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Penn Medicine Post-COVID Assessment and Recovery Clinic',
      Longitude: -75.1726037,
      Latitude: 39.9448509,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Penn Medicine Post-COVID Assessment and Recovery Clinic',
      Longitude: -75.3543032,
      Latitude: 40.0392514,
      status: 'Did not answer the survey',
    },
    {
      Name: 'St. Lukes COVID Recovery Clinic',
      Longitude: -75.4547736,
      Latitude: 40.6335278,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Temple Health Lung Center Post-COVID Recovery Clinic',
      Longitude: -75.1507198,
      Latitude: 40.0054237,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Temple Health Lung Center Post-COVID Recovery Clinic',
      Longitude: -75.2120133,
      Latitude: 40.0793826,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Temple Health Lung Center Post-COVID Recovery Clinic',
      Longitude: -75.4499945,
      Latitude: 40.1313323,
      status: 'Did not answer the survey',
    },
    {
      Name: 'University of Pittsburgh Medical Center Post-COVID Recovery Clinic',
      Longitude: -79.9593255,
      Latitude: 40.4415314,
      status: 'Did not answer the survey',
    },
    {
      Name: 'WellSpan COVID Care',
      Longitude: -76.6807122,
      Latitude: 39.9337894,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Bay State Physical Therapy Post-Acute COVID Care',
      Longitude: -71.4570502,
      Latitude: 41.4950487,
      status: 'Declined to answer',
    },
    {
      Name: 'Bay State Physical Therapy Post-Acute COVID Care',
      Longitude: -71.4959791,
      Latitude: 41.6614248,
      status: 'Declined to answer',
    },
    {
      Name: 'Bay State Physical Therapy Post-Acute COVID Care',
      Longitude: -71.4110556,
      Latitude: 41.8090499,
      status: 'Declined to answer',
    },
    {
      Name: 'Spaulding Rehabilitation Network COVID Rehab Program',
      Longitude: -71.3754236,
      Latitude: 41.8706234,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Select Physical Therapy COVID-19 and Chronic Illness Recovery and Reconditioning program',
      Longitude: -80.0871464,
      Latitude: 33.0187228,
      status: 'Did not answer the survey',
    },
    {
      Name: 'NovaCare Rehabilitation COVID-19 and Chronic Illness Recovery and Reconditioning program',
      Longitude: -81.9615198,
      Latitude: 33.4973478,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Select Physical Therapy COVID-19 and Chronic Illness Recovery and Reconditioning program',
      Longitude: -81.0556362,
      Latitude: 33.9936699,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Select Physical Therapy COVID-19 and Chronic Illness Recovery and Reconditioning program',
      Longitude: -82.1826405,
      Latitude: 34.1725564,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Greenwood Regional Rehabilitation Hospital',
      Longitude: -82.1561501,
      Latitude: 34.167124,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Midlands Regional Rehabilitation Hospital',
      Longitude: -80.7504709,
      Latitude: 34.147019,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Results Physiotherapy Post-Covid Rehabilitation',
      Longitude: -79.8361958,
      Latitude: 32.7633445,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Results Physiotherapy Post-Covid Rehabilitation',
      Longitude: -80.0841787,
      Latitude: 32.8252197,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Results Physiotherapy Post-Covid Rehabilitation',
      Longitude: -80.1359332,
      Latitude: 33.0415992,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Spartanburg Rehabilitation Institute',
      Longitude: -81.9424849,
      Latitude: 34.9898414,
      status: 'Did not answer the survey',
    },
    {
      Name: 'American Indian Clinical Trials Research Network',
      Longitude: -103.2304152,
      Latitude: 44.063279,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Sanford Health',
      Longitude: -96.7581905,
      Latitude: 43.5871865,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Prairie Rehabilitation Post-COVID-19 Recovery',
      Longitude: -96.5736468,
      Latitude: 43.5961526,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Prairie Rehabilitation Post-COVID-19 Recovery',
      Longitude: -96.9458238,
      Latitude: 43.6316471,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Ascension Medical Group Saint Thomas Post Acute COVID Care Clinic',
      Longitude: -86.8013659,
      Latitude: 36.1549113,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Ballad Health Center for Post-COVID Care',
      Longitude: -82.5518921,
      Latitude: 36.5576411,
      status: 'Declined to answer',
    },
    {
      Name: 'Select Physical Therapy COVID-19 and Chronic Illness Recovery and Reconditioning program',
      Longitude: -86.4282999,
      Latitude: 35.8598346,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Select Physical Therapy COVID-19 and Chronic Illness Recovery and Reconditioning program',
      Longitude: -87.3602122,
      Latitude: 36.0385651,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Hixon Lung Center Post-COVID Clinic',
      Longitude: -85.2493647,
      Latitude: 35.1411318,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Results Physiotherapy Post-Covid Rehabilitation',
      Longitude: -84.8551778,
      Latitude: 35.1913628,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Results Physiotherapy Post-Covid Rehabilitation',
      Longitude: -89.8402288,
      Latitude: 35.211009,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Results Physiotherapy Post-Covid Rehabilitation',
      Longitude: -86.2320069,
      Latitude: 35.3863784,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Results Physiotherapy Post-Covid Rehabilitation',
      Longitude: -83.8470011,
      Latitude: 35.9074379,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Results Physiotherapy Post-Covid Rehabilitation',
      Longitude: -87.3767198,
      Latitude: 36.0804866,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Results Physiotherapy Post-Covid Rehabilitation',
      Longitude: -82.264167,
      Latitude: 36.592404,
      status: 'Did not answer the survey',
    },
    {
      Name: 'University of Tennessee Health Science Center & Regional One Health Post-COVID-19 Clinic',
      Longitude: -90.0319782,
      Latitude: 35.1408456,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Vanderbilt Health Post-Acute COVID Care',
      Longitude: -86.8015241,
      Latitude: 36.1424994,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Baylor Medicine Post COVID Care Clinic',
      Longitude: -95.4030358,
      Latitude: 29.7094571,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Breathing Center of Houston Post COVID-19 Rehab Program',
      Longitude: -95.468361,
      Latitude: 29.7143603,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Breathing Center of Houston Post COVID-19 Rehab Program',
      Longitude: -95.4521457,
      Latitude: 30.1968787,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Breathing Center of Houston Post COVID-19 Rehab Program',
      Longitude: -95.6231067,
      Latitude: 29.7676804,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Breathing Center of Houston Post COVID-19 Rehab Program',
      Longitude: -95.1355108,
      Latitude: 29.5260411,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Breathing Center of Houston Post COVID-19 Rehab Program',
      Longitude: -95.6168424,
      Latitude: 29.5921451,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Corpus Christi Rehabilitation Hospital',
      Longitude: -97.3779799,
      Latitude: 27.6884137,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Baylor Scott and White Institute for Rehabilitation, COVID-19 and Chronic Illness Recovery and Reconditioning program',
      Longitude: -97.7410337,
      Latitude: 30.7027537,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Baylor Scott and White Institute for Rehabilitation, COVID-19 and Chronic Illness Recovery and Reconditioning program',
      Longitude: -97.4180682,
      Latitude: 32.6541224,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Houston Methodist COVID-19 Recovery Clinic',
      Longitude: -95.3994361,
      Latitude: 29.7123106,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Laredo Rehabilitation Hospital',
      Longitude: -99.4736233,
      Latitude: 27.5336774,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Memorial Hermann Rehabilitation Network COVID-19 Rehabilitation Program',
      Longitude: -95.545502,
      Latitude: 29.7827767,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Mesquite Rehabilitation Institute & Mesquite Specialty Hospital',
      Longitude: -96.5979084,
      Latitude: 32.7785004,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Nexus Neurorecovery Center Post-COVID Program',
      Longitude: -95.5309307,
      Latitude: 30.3145805,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Results Physiotherapy Post-Covid Rehabilitation',
      Longitude: -97.7929129,
      Latitude: 30.1562153,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Results Physiotherapy Post-Covid Rehabilitation',
      Longitude: -97.7339894,
      Latitude: 30.3869303,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Results Physiotherapy Post-Covid Rehabilitation',
      Longitude: -97.6889396,
      Latitude: 30.6318185,
      status: 'Did not answer the survey',
    },
    {
      Name: 'South Texas Rehabilitation Hospital',
      Longitude: -97.5105955,
      Latitude: 25.9808047,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Texas NeuroRehab Center COVID-19 Continuum Care Program',
      Longitude: -97.8075223,
      Latitude: 30.1890278,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Trustpoint Rehabilitation Hospital of Lubbock',
      Longitude: -101.9032526,
      Latitude: 33.6170957,
      status: 'Did not answer the survey',
    },
    {
      Name: 'University Health Post-COVID Recovery Clinic',
      Longitude: -98.5770325,
      Latitude: 29.5102455,
      status: 'Did not answer the survey',
    },
    {
      Name: 'University of Texas Medical Branch Post-COVID Recovery Clinic',
      Longitude: -94.7788955,
      Latitude: 29.3114518,
      status: 'Did not answer the survey',
    },
    {
      Name: 'UT Health Austin Post-COVID-19 Program',
      Longitude: -97.7356043,
      Latitude: 30.2779255,
      status: 'Did not answer the survey',
    },
    {
      Name: 'UT Health East Texas COVID-19 Recovery Clinic',
      Longitude: -95.2128672,
      Latitude: 32.4273448,
      status: 'Did not answer the survey',
    },
    {
      Name: 'UT Southwestern Medical Center Department of Physical Medicine and Rehabilitation: COVID RECOVER',
      Longitude: -96.8391618,
      Latitude: 32.8120994,
      status: 'Did not answer the survey',
    },
    {
      Name: 'UT Southwestern Medical Center Department of Physical Medicine and Rehabilitation: COVID RECOVER',
      Longitude: -96.8372564,
      Latitude: 33.1800008,
      status: 'Did not answer the survey',
    },
    {
      Name: 'UTHealth COVID-19 Center of Excellence',
      Longitude: -95.3972171,
      Latitude: 29.7147886,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Weslaco Regional Rehabilitation Hospital',
      Longitude: -97.9769277,
      Latitude: 26.1510261,
      status: 'Did not answer the survey',
    },
    {
      Name: 'University of Texas Education and Research Center at Laredo',
      Longitude: -99.4751347,
      Latitude: 27.5332654,
      status: 'Did not answer the survey',
    },
    {
      Name: 'University of Texas Health Science Center at San Antonio',
      Longitude: -98.5755382,
      Latitude: 29.5058407,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Intermountain Medical Center',
      Longitude: -111.8937853,
      Latitude: 40.659798,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Bateman Horne Center Long COVID Care',
      Longitude: -111.8596235,
      Latitude: 40.7596058,
      status: 'Did not answer the survey',
    },
    {
      Name: "Intermountain Primary Children's Hospital",
      Longitude: -111.8386621,
      Latitude: 40.7710597,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Northern Utah Rehabilitation Hospital Pediatric Long COVID Navigation Clinic',
      Longitude: -111.9413501,
      Latitude: 41.1572444,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Utah Valley Specialty Hospital',
      Longitude: -111.6626722,
      Latitude: 40.3054778,
      status: 'Did not answer the survey',
    },
    {
      Name: 'University of Utah Health COVID-19 Long-hauler Clinic',
      Longitude: -111.8352813,
      Latitude: 40.7706718,
      status: 'Did not answer the survey',
    },
    {
      Name: 'UVM Health Network COVID Recovery Program',
      Longitude: -73.2084571,
      Latitude: 44.4520397,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Centra Health Post-COVID Recovery Care Program',
      Longitude: -79.1692269,
      Latitude: 37.4136928,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Inova Post COVID-19 Recovery and Rehabilitation Care Centers',
      Longitude: -77.0769752,
      Latitude: 38.7397466,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Inova Post COVID-19 Recovery and Rehabilitation Care Centers',
      Longitude: -77.1049733,
      Latitude: 38.8223445,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Inova Post COVID-19 Recovery and Rehabilitation Care Centers',
      Longitude: -77.2275698,
      Latitude: 38.8568747,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Inova Post COVID-19 Recovery and Rehabilitation Care Centers',
      Longitude: -77.3800608,
      Latitude: 38.8841221,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Inova Post COVID-19 Recovery and Rehabilitation Care Centers',
      Longitude: -77.4784839,
      Latitude: 39.0752456,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Kaplan Center for Integrative Medicine Long-COVID Recovery Program',
      Longitude: -77.1797369,
      Latitude: 38.9355532,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Sentara Norfolk General Hospital',
      Longitude: -76.3029446,
      Latitude: 36.8626371,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Sheltering Arms Post-Covid-19 Rehabilitation Program',
      Longitude: -77.5489959,
      Latitude: 37.4988059,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Sheltering Arms Post-Covid-19 Rehabilitation Program',
      Longitude: -77.3869003,
      Latitude: 37.6272753,
      status: 'Did not answer the survey',
    },
    {
      Name: 'VCU Health Long COVID-19 Clinic',
      Longitude: -77.5656274,
      Latitude: 37.5532357,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Providence Regional Medical Center Everett',
      Longitude: -122.2060665,
      Latitude: 47.9994545,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Providence Sacred Heart Medical Center',
      Longitude: -117.4127556,
      Latitude: 47.6489676,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Swedish Medical Center',
      Longitude: -122.3214655,
      Latitude: 47.6088962,
      status: 'Did not answer the survey',
    },
    {
      Name: 'University of Washington',
      Longitude: -122.3419756,
      Latitude: 47.6236533,
      status: 'Did not answer the survey',
    },
    {
      Name: 'UW Medicine Harborview Medical Center Post-COVID-19 Rehabilitation and Recovery Clinic',
      Longitude: -122.3235328,
      Latitude: 47.6047183,
      status: 'Did not answer the survey',
    },
    {
      Name: 'West Virginia University',
      Longitude: -79.9697147,
      Latitude: 39.6480359,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Wheeling Hospital Post-COVID Outpatient Rehabilitation Program',
      Longitude: -80.6850467,
      Latitude: 40.0588459,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Ascension Medical Group Post-Acute COVID Care',
      Longitude: -87.9110315,
      Latitude: 42.8985978,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Bellin Health Long COVID Care',
      Longitude: -88.0116943,
      Latitude: 44.5021822,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Essentia Health Post COVID-19 Rehabilitation Program',
      Longitude: -90.8887053,
      Latitude: 46.5682534,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Froedtert & Medical College of Wisconsin Post-COVID Multispecialty Clinic',
      Longitude: -88.0242958,
      Latitude: 43.0408461,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Prevea COVID-19 Recovery Clinic',
      Longitude: -87.7367,
      Latitude: 43.7198,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Prevea COVID-19 Recovery Clinic',
      Longitude: -88.1281012,
      Latitude: 44.8654981,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Elkhorn Valley Rehabilitation Hospital',
      Longitude: -106.2423774,
      Latitude: 42.8441018,
      status: 'Did not answer the survey',
    },
    {
      Name: 'Washington University in St. Louis',
      Longitude: -90.3084017,
      Latitude: 38.6472402,
      status: 'Yes, they offer care',
    },
    {
      Name: 'Emory University School of Medicine',
      Longitude: -84.3186263,
      Latitude: 33.7935352,
      status: 'Did not answer the survey',
    },
    {
      Name: 'University of Southern California',
      Longitude: null,
      Latitude: null,
      status: 'Did not answer the survey',
    },
    {
      Name: 'GW Center for Integrative Medicine',
      Longitude: -77.0518879,
      Latitude: 38.9010974,
      status: 'Yes, they offer care',
    },
    {
      Name: 'Albert Einstein College of Medicine',
      Longitude: -73.989308,
      Latitude: 40.741895,
      status: 'No, they never offered care',
    },
  ];
console.log('Hello bakers');
const Ei = new Li.Map({
  container: 'map',
  style: 'https://demotiles.maplibre.org/globe.json',
  center: [-98.5795, 39.8283],
  zoom: 4,
  interactive: !1,
});
Ei.on('load', () => {
  Ei.setProjection('equalEarth'),
    Ei.fitBounds(
      [
        [-125, 24.5],
        [-66.9, 49.4],
      ],
      { padding: 80, duration: 1e3 }
    ),
    Ei.resize(),
    console.log('init'),
    Oi(),
    ki
      .setup({
        container: '#scroll',
        graphic: '.scroll__graphic',
        text: '.scroll__text',
        step: '.scroll__text .step',
        offset: 0.5,
        debug: !1,
      })
      .onStepEnter(Bi),
    window.addEventListener('resize', Oi);
});
const Ri = (function (t) {
  return 'string' == typeof t
    ? new St([[document.querySelector(t)]], [document.documentElement])
    : new St([[t]], It);
})('#scroll');
Ri.select('.scroll__graphic').select('.chart');
const zi = Ri.select('.scroll__text').selectAll('.step'),
  ki = (function () {
    let c,
      h,
      u,
      d = {},
      p = (function () {
        const t = 'abcdefghijklmnopqrstuvwxyz',
          e = Date.now(),
          i = [];
        for (let r = 0; r < 6; r += 1) {
          const e = t[Math.floor(Math.random() * t.length)];
          i.push(e);
        }
        return `${i.join('')}${e}`;
      })(),
      f = [],
      m = 0,
      g = !1,
      _ = !1,
      y = !1,
      v = !1,
      x = [];
    function b() {
      (d = { stepEnter: () => {}, stepExit: () => {}, stepProgress: () => {} }),
        (x = []);
    }
    function w(t) {
      t && !g && E(), !t && g && M(), (g = t);
    }
    function T(t, e) {
      const r = i(t),
        n = f[r];
      void 0 !== e && (n.progress = e);
      const a = { element: t, index: r, progress: e, direction: o };
      'enter' === n.state && d.stepProgress(a);
    }
    function P([t]) {
      const e = i(t.target),
        r = f[e],
        n = t.target.offsetHeight;
      n !== r.height && ((r.height = n), S(r), L(r), D(r));
    }
    function C([t]) {
      l(h);
      const { isIntersecting: e, target: r } = t;
      e
        ? (function (t, e = !0) {
            const r = i(t),
              n = f[r],
              a = { element: t, index: r, direction: o };
            (n.direction = o),
              (n.state = 'enter'),
              x[r] || d.stepEnter(a),
              v && (x[r] = !0);
          })(r)
        : (function (t, e = !0) {
            const r = i(t),
              n = f[r];
            if (!n.state) return !1;
            const a = { element: t, index: r, direction: o };
            _ &&
              ('down' === o && n.progress < 1
                ? T(t, 1)
                : 'up' === o && n.progress > 0 && T(t, 0)),
              (n.direction = o),
              (n.state = 'exit'),
              d.stepExit(a);
          })(r);
    }
    function I([t]) {
      const e = i(t.target),
        r = f[e],
        { isIntersecting: n, intersectionRatio: a, target: s } = t;
      n && 'enter' === r.state && T(s, a);
    }
    function S({ observers: t }) {
      Object.keys(t).map((e) => {
        t[e].disconnect();
      });
    }
    function M() {
      f.forEach(S);
    }
    function D(t) {
      const e = new ResizeObserver(P);
      e.observe(t.node), (t.observers.resize = e);
    }
    function L(e) {
      const i = window.innerHeight,
        r = e.offset || c,
        n = 'pixels' === r.format ? 1 : i,
        a = r.value * n,
        s = e.height / 2 - a,
        o = e.height / 2 - (i - a),
        l = new IntersectionObserver(C, {
          rootMargin: `${s}px 0px ${o}px 0px`,
          threshold: 0.5,
          root: u,
        });
      l.observe(e.node),
        (e.observers.step = l),
        y && t({ id: p, step: e, marginTop: s, marginBottom: o });
    }
    function A(t) {
      const e = window.innerHeight,
        i = t.offset || c,
        r = 'pixels' === i.format ? 1 : e,
        n = i.value * r,
        a = `${-n + t.height}px 0px ${n - e}px 0px`,
        s = (function (t, e) {
          const i = Math.ceil(t / e),
            r = [],
            n = 1 / i;
          for (let a = 0; a < i + 1; a += 1) r.push(a * n);
          return r;
        })(t.height, m),
        o = new IntersectionObserver(I, { rootMargin: a, threshold: s });
      o.observe(t.node), (t.observers.progress = o);
    }
    function E() {
      M(), f.forEach(D), f.forEach(L), _ && f.forEach(A);
    }
    const R = {};
    return (
      (R.setup = ({
        step: t,
        parent: i,
        offset: o = 0.5,
        threshold: d = 4,
        progress: p = !1,
        once: g = !1,
        debug: x = !1,
        container: T,
        root: P = null,
      }) => (
        (function (t) {
          (a = 0), (s = 0), document.addEventListener('scroll', () => l(t));
        })(T),
        (f = (function (t, e = document) {
          return 'string' == typeof t
            ? Array.from(e.querySelectorAll(t))
            : t instanceof Element
            ? [t]
            : t instanceof NodeList
            ? Array.from(t)
            : t instanceof Array
            ? t
            : [];
        })(t, i).map((t, e) => ({
          index: e,
          direction: void 0,
          height: t.offsetHeight,
          node: t,
          observers: {},
          offset: r(t.dataset.offset),
          top: n(t),
          progress: 0,
          state: void 0,
        }))),
        f.length
          ? ((_ = p),
            (v = g),
            (y = x),
            (m = Math.max(1, +d)),
            (c = r(o)),
            (h = T),
            (u = P),
            b(),
            (function (t) {
              t.forEach((t) =>
                t.node.setAttribute('data-scrollama-index', t.index)
              );
            })(f),
            w(!0),
            R)
          : (e('no step elements'), R)
      )),
      (R.enable = () => (w(!0), R)),
      (R.disable = () => (w(!1), R)),
      (R.destroy = () => (w(!1), b(), R)),
      (R.resize = () => (E(), R)),
      (R.offset = (t) => (null == t ? c.value : ((c = r(t)), E(), R))),
      (R.onStepEnter = (t) => (
        'function' == typeof t
          ? (d.stepEnter = t)
          : e('onStepEnter requires a function'),
        R
      )),
      (R.onStepExit = (t) => (
        'function' == typeof t
          ? (d.stepExit = t)
          : e('onStepExit requires a function'),
        R
      )),
      (R.onStepProgress = (t) => (
        'function' == typeof t
          ? (d.stepProgress = t)
          : e('onStepProgress requires a function'),
        R
      )),
      R
    );
  })();
function Oi() {
  ki.resize();
}
let Fi = new Map();
function Bi(t) {
  console.log('handleStepEnter', t),
    zi.classed('is-active', function (e, i) {
      return i === t.index;
    });
  var e = t.index + 1;
  1 == e &&
    (console.log('DO THE STEP ONE STUFF...'),
    Fi.forEach((t) => {
      t.remove();
    }),
    Fi.clear(),
    Ai.forEach((t) => {
      if (t.Longitude && t.Latitude) {
        const e =
            'yes' === t.status ? 'green' : 'no' === t.status ? 'red' : 'blue',
          i = document.createElement('div');
        (i.style.backgroundColor = e),
          (i.style.width = '12px'),
          (i.style.height = '12px'),
          (i.style.borderRadius = '50%'),
          (i.style.border = '2px solid white');
        const r = new Li.Marker({ element: i })
          .setLngLat([t.Longitude, t.Latitude])
          .addTo(Ei);
        Fi.set(`${t.Longitude},${t.Latitude}`, r);
      }
    })),
    4 == e &&
      (console.log('DO THE STEP FOUR STUFF...'),
      Fi.forEach((t, e) => {
        console.log('key', e);
        const [i, r] = e.split(',').map(Number),
          n = Ai.find((t) => t.Longitude === i && t.Latitude === r);
        if ((console.log('markerData', n), n)) {
          t.getElement().style.backgroundColor =
            'Did not answer the survey' === n.status ? 'gray' : 'blue';
        }
      })),
    console.log('activeStep', e);
}
//# sourceMappingURL=app.c42978e3.js.map
